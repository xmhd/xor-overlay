Bounds Checking Patches for gcc-4.0.2
--------------------------------------

By Richard W.M. Jones <rjones@orchestream.com>

What is bounds checking?
------------------------

These patches give very fine-grained bounds checking, catching errors in
C programs like this one:

	int i;
	char array[10];

	for (i = 0; i <= 10; ++i)
	  array[i] = 0;

(Notice element array[10] is not part of the array). The patches are
compatible with almost all C constructs. For instance, the following
programs have been successfully compiled with bounds checking:

	Tcl 7.3 & 7.4
	Tk 3.6 & 4.0
	Ghostscript 262
	uEmacs 3.10
	xrn
	GNU Grep 2.0
	XBoing 1.8

What files do you need?
-----------------------

You can install GCC with bounds checking either by compiling from the source.

>> To compile from source, you need to retrieve:

	bounds-checking-gcc-4.0.2-x.y.patch.bz2

   *plus* the source for GCC (which you may already have).

	gcc-4.0.2.tar.bz2

   You will need around 500 Mbytes of free disk space.

How to compile GCC with bounds checking from source
----------------------------------------------------

Let's suppose, for the sake of example, that you've already placed a *fresh*
GCC source tree in `~/gcc-4.0.2'. Patch the tree as follows:

	cd ~/gcc-4.0.2
	bzip2 -cd bounds-checking-gcc-4.0.2-x.y.patch.bz2 | patch -p1 -s

Compile GCC as detailed in the file `INSTALL' that comes with GCC. Usually
you need to type something like:

	cd ~/build_4.0.2_dir
	~/gcc-4.0.2/configure --srcdir=~/gcc-4.0.2	# Possibly some --options here.
	make BOOT_CFLAGS="-O2" STAGE1_CFLAGS="-O2" CFLAGS="-O2" bootstrap

This also makes the bounds checking library (in the bounds/lib/ subdir.).
You'll need `makeinfo' (from the `texinfo' package) to make the info pages.

Compile programs with bounds checking
-------------------------------------

Once you've got the program compiled, use the `-fbounds-checking' flag
to add bounds checking to your programs. Eg.

	~/build_4.0.2_dir/gcc/xgcc -B~/build_4.0.2_dir/gcc/ -fbounds-checking -c file1.c -o file1.o
	~/build_4.0.2_dir/gcc/xgcc -B~/build_4.0.2_dir/gcc/ -fbounds-checking file1.o -o program

Notice that:
  (1) I've assumed you have compiled/installed GCC in `~/build_4.0.2_dir'.
  (2) You need to pass the `-B' option to tell GCC which directory you're
      using. Note that the directory needs a trailing `/'.

For Makefiles, you could add/change the following rules:

	GCC_HOME = $(HOME)/build_4.0.2_dir/gcc
	CC = $(GCC_HOME)/xgcc
	CFLAGS = -B$(GCC_HOME)/ -fbounds-checking -g -Wall ..etc..

Looking for information
-----------------------

The first place to look for information is the GCC info page. The relevant
files are:

	~/gcc-4.0.2/gcc/doc/gcc.info
	~/gcc-4.0.2/gcc/doc/gcc.info-*

You will need `emacs', `tkinfo' or similar, to read them. Go to `Bounds
Checking' node.

There is an old manual in PostScript form in the file:

	~/gcc-4.0.2/gcc/bounds/report/bcrep2.ps.gz

and the source for this (in M$-Word 6 format - yes, I know):

	~/gcc-4.0.2/gcc/bounds/report/bcrep2.doc.gz

Special cases for bounds checking
---------------------------------

Although bounds checking ought to be automatic, if you use one of the
following constructs, you may need to change your program:

    .   signal handlers
        threads
                Read the user manual. For signal handlers, you will need to
                move the signal handlers into unchecked code. There are
                hooks in the checking library for threads.
    .   Using `-2' as a pointer.
                You can't use `-2' as a special pointer representation (because
                I use it). To fix this, either change your code to use, say,
                -1, or change the definition of ILLEGAL in `bounds/lib/
                bounds-lib.h'.

Read the gcc.info file for more details.

Bug reports
-----------

There are a few known bugs: read about them in

	~/gcc-4.0.2/gcc/bounds/BUGS

Please send bug reports & fixes to

	rjones@orchestream.com or Haj.Ten.Brugge@net.HCC.nl

Frequently asked questions
--------------------------

These are questions I've answered more than a hundred times already ...

1.	No, it doesn't work with C++. But do you feel like giving up ~1-2
	months of your time to implement it for me? If so, write soon.

2.	When will the patches be integrated into GCC? I have no answer to
	this. One day soon, when I feel that the software has been widely
	tested and the bugs have been all but eliminated, I will apply to
	have this happen. However, the GCC maintainers may have other ideas,
	in which case the answer will be `never'.

Related documents
-----------------

http://www-dse.doc.ic.ac.uk/~rj3/bounds-checking.html
http://www-ala.doc.ic.ac.uk/~phjk/BoundsChecking.html
http://www.inter.NL.net/hcc/Haj.Ten.Brugge

Platforms
---------

See the file MACHINES in the distribution to see what machines GCC/BC has been
ported to. It ought to work on just about any machine that GCC supports.
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/ada/bounds.c gcc-4.0.2/gcc/ada/bounds.c
--- gcc-4.0.2.org/gcc/ada/bounds.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/ada/bounds.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,166 @@
+/* This file is a dummy, for when C++ gets bounds checking like C. In the
+   mean time, there are some empty function definitions here, since `calls.c'
+   references these (but never calls them). */
+
+#include "config.h"
+#include "system.h"
+#include <stdio.h>
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "tree.h"
+#include "varray.h"
+#include "ggc.h"
+
+static GTY (()) varray_type static_ptr_init_list;
+static GTY (()) varray_type deferred_global_decls;
+static GTY (()) tree bounds_memcpy;
+static GTY (()) tree bounds_mempcpy;
+static GTY (()) tree bounds_memset;
+static GTY (()) tree bounds_find_object;
+static GTY (()) tree bounds_maybe_find_object;
+static GTY (()) tree bounds_check_ptr_plus_int;
+static GTY (()) tree bounds_check_ptr_minus_int;
+static GTY (()) tree bounds_check_ptr_plus_int_obj;
+static GTY (()) tree bounds_check_ptr_minus_int_obj;
+static GTY (()) tree bounds_check_array_reference;
+static GTY (()) tree bounds_check_array_reference_obj;
+static GTY (()) tree bounds_check_component_reference;
+static GTY (()) tree bounds_check_component_reference_obj;
+static GTY (()) tree bounds_check_ptr_diff;
+static GTY (()) tree bounds_check_ptr_diff_obj;
+static GTY (()) tree bounds_check_reference;
+static GTY (()) tree bounds_check_reference_obj;
+static GTY (()) tree bounds_check_ptr_lt_ptr;
+static GTY (()) tree bounds_check_ptr_lt_ptr_obj;
+static GTY (()) tree bounds_check_ptr_le_ptr;
+static GTY (()) tree bounds_check_ptr_le_ptr_obj;
+static GTY (()) tree bounds_check_ptr_gt_ptr;
+static GTY (()) tree bounds_check_ptr_gt_ptr_obj;
+static GTY (()) tree bounds_check_ptr_ge_ptr;
+static GTY (()) tree bounds_check_ptr_ge_ptr_obj;
+static GTY (()) tree bounds_check_ptr_eq_ptr;
+static GTY (()) tree bounds_check_ptr_ne_ptr;
+static GTY (()) tree bounds_check_ptr_postinc;
+static GTY (()) tree bounds_check_ptr_preinc;
+static GTY (()) tree bounds_check_ptr_postdec;
+static GTY (()) tree bounds_check_ptr_predec;
+static GTY (()) tree bounds_check_ptr_postinc_obj;
+static GTY (()) tree bounds_check_ptr_preinc_obj;
+static GTY (()) tree bounds_check_ptr_postdec_obj;
+static GTY (()) tree bounds_check_ptr_predec_obj;
+static GTY (()) tree bounds_check_ptr_postinc_ref;
+static GTY (()) tree bounds_check_ptr_preinc_ref;
+static GTY (()) tree bounds_check_ptr_postdec_ref;
+static GTY (()) tree bounds_check_ptr_predec_ref;
+static GTY (()) tree bounds_check_ptr_postinc_ref_obj;
+static GTY (()) tree bounds_check_ptr_preinc_ref_obj;
+static GTY (()) tree bounds_check_ptr_postdec_ref_obj;
+static GTY (()) tree bounds_check_ptr_predec_ref_obj;
+static GTY (()) tree bounds_check_ptr_true;
+static GTY (()) tree bounds_check_ptr_false;
+static GTY (()) tree bounds_note_constructed_object;
+static GTY (()) tree bounds_note_constructed_private_table;
+static GTY (()) tree bounds_push_function;
+static GTY (()) tree bounds_pop_function;
+static GTY (()) tree bounds_add_param_object;
+static GTY (()) tree bounds_add_stack_object;
+static GTY (()) tree bounds_delete_stack_object;
+static GTY (()) tree bounds_initialize_library;
+static GTY (()) tree bounds_check_free;
+static GTY (()) tree bounds_check_malloc;
+static GTY (()) tree bounds_check_realloc;
+static GTY (()) tree bounds_check_memalign;
+static GTY (()) tree bounds_check_calloc;
+static GTY (()) tree bounds_check_valloc;
+static GTY (()) tree bounds_check_alloca;
+static GTY (()) tree bounds_check___alloca;
+static GTY (()) tree bounds_check___builtin_alloca;
+static GTY (()) tree bounds_check_mmap;
+static GTY (()) tree bounds_check_munmap;
+static GTY (()) tree bounds_check_memcpy;
+static GTY (()) tree bounds_check_mempcpy;
+static GTY (()) tree bounds_check_memmove;
+static GTY (()) tree bounds_check_bcopy;
+static GTY (()) tree bounds_check_memset;
+static GTY (()) tree bounds_check_bzero;
+static GTY (()) tree bounds_check_memcmp;
+static GTY (()) tree bounds_check_bcmp;
+static GTY (()) tree bounds_check_strcpy;
+static GTY (()) tree bounds_check_strncpy;
+static GTY (()) tree bounds_check_strlen;
+static GTY (()) tree bounds_check_strcmp;
+static GTY (()) tree bounds_check_strncmp;
+static GTY (()) tree bounds_check_strcat;
+static GTY (()) tree bounds_check_strncat;
+static GTY (()) tree bounds_check_strpbrk;
+static GTY (()) tree bounds_check_strrchr;
+static GTY (()) tree bounds_check_rindex;
+static GTY (()) tree bounds_check_strspn;
+static GTY (()) tree bounds_check_strcspn;
+static GTY (()) tree bounds_check_strstr;
+static GTY (()) tree bounds_check_strtok;
+static GTY (()) tree bounds_check_strtok_r;
+static GTY (()) tree bounds_check_strdup;
+static GTY (()) tree bounds_check_strchr;
+static GTY (()) tree bounds_check_index;
+static GTY (()) tree bounds_check_strcoll;
+static GTY (()) tree bounds_check_strxfrm;
+static GTY (()) tree bounds_check_strcasecmp;
+static GTY (()) tree bounds_check_strncasecmp;
+static GTY (()) tree bounds_check_memchr;
+static GTY (()) tree bounds_check_memccpy;
+static GTY (()) tree bounds_private_statics;
+
+#include "gt-c-bounds.h"
+
+void
+bounds_convert_funcname (tree * function ATTRIBUTE_UNUSED,
+			 tree * params ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+void
+bounds_mark_for_runtime_check (tree decl ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+void
+bounds_build_static_constructors (void)
+{
+  abort ();
+}
+
+void
+bounds_register_decl (tree decl ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+int
+bounds_is_deletable_fn_p (char *name ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+void
+bounds_note_call_for_deletion (rtx first_insn ATTRIBUTE_UNUSED,
+			       rtx last_insn ATTRIBUTE_UNUSED,
+			       char *fnname ATTRIBUTE_UNUSED,
+			       tree callexpr ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+tree
+bounds_build_truthvalue_conversion (tree arg ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+void
+bounds_delete_redundant_calls (void)
+{
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/ada/Make-lang.in gcc-4.0.2/gcc/ada/Make-lang.in
--- gcc-4.0.2.org/gcc/ada/Make-lang.in	2005-03-15 21:52:43.000000000 +0100
+++ gcc-4.0.2/gcc/ada/Make-lang.in	2005-09-29 17:50:02.000000000 +0200
@@ -105,7 +105,8 @@ ADA_TOOLS_FLAGS_TO_PASS=\
 # Object files for gnat1 from C sources.
 GNAT1_C_OBJS = ada/b_gnat1.o ada/adadecode.o ada/adaint.o ada/cstreams.o \
  ada/cio.o ada/targtyps.o ada/decl.o ada/misc.o ada/utils.o ada/utils2.o \
- ada/trans.o ada/cuintp.o ada/argv.o ada/raise.o ada/init.o ada/tracebak.o
+ ada/trans.o ada/cuintp.o ada/argv.o ada/raise.o ada/init.o ada/tracebak.o \
+ ada/bounds.o
 
 # Object files from Ada sources that are used by gnat1
 
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/bgcc gcc-4.0.2/gcc/bounds/bgcc
--- gcc-4.0.2.org/gcc/bounds/bgcc	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/bgcc	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,61 @@
+:
+# bgcc -- driver for bgcc
+
+R=`dirname $0`
+R=`(cd $R > /dev/null 2>&1 ; cd ../../objdir* ; pwd)`
+
+libs=
+compiler=xgcc
+
+if [ ! -d "$R" ]
+then
+	echo "$0: Root directory $R not found"
+	exit 1
+fi
+
+G=${R}/gcc
+L=${R}/libraries
+
+#G=${R}/gcc/stage1
+#L=${R}/gcc
+
+if [ ! -d "$G" ]
+then
+	echo "$0: gcc directory $G not found"
+	exit 1
+fi
+
+# Set the -I and -L options to the build area.
+# Prepend -I and -L options specified on the command line.
+# Skip over enough of the other options to have a chance at getting
+# all of the -I and -L options.
+
+args=
+while [ ! -z "$1" ]
+do
+	case "$1" in
+	-[DILo]) args="$args $1 $2" ; shift ;;
+	-[DILoOW]*|-ped*|-pipe|-[SEcgsv]) args="$args $1" ;;
+	*) break ;;
+	esac
+	shift
+done
+
+# -I${G}/include/
+# -I/usr/include/
+
+exec ${G}/$compiler -B${G}/ \
+	$args \
+	-I${R}/../libio/ \
+	-I${R}/../libstdc++/ \
+	-I${R}/../include/ \
+	-I/usr/include/g++/ \
+	-I/usr/lib/g++-include/ \
+	-L${L}/libio/ \
+	-L${L}/libstdc++/ \
+	-L${L}/libiberty/ \
+	-L${G}/ \
+	-L${L}/ \
+	-L/lib/ \
+	-L/usr/lib/ \
+	"$@" $libs
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/BUGS gcc-4.0.2/gcc/bounds/BUGS
--- gcc-4.0.2.org/gcc/bounds/BUGS	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/BUGS	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,48 @@
+GCC with Bounds Checking, By Richard W.M. Jones <rjones@orchestream.com>
+------------------------------------------------------------------------
+
+1. KNOWN BUGS
+-------------
+
+Description:
+	The following bug was pointed out by Eberhard Mattes
+	<mattes@azu.informatik.uni-stuttgart.d400.de>
+Example code:
+	#define FOO(c) ({ int temp = c; temp; })
+
+	static void foo (int x)
+	{
+	  goto lbl;
+	
+	lbl:
+	  if (FOO (x))
+	    ++x;
+	}
+Comment:
+	Without -fbounds-checking, no error.
+	With -fbounds-checking, we get:
+		foo.c: In function `foo':
+		foo.c:7: label `lbl' used before containing binding contour
+	Must be something to do with how I'm adding constructors to
+	variables in binding contours.
+
+
+2. MISSING FEATURES
+-------------------
+
+Description:
+	Function pointers aren't found & checked.
+Comment:
+	We can find all function pointers using the same mechanism as for
+	static variables. We make them into byte-sized objects with
+	alignment -1 so that you can't do pointer arithmetic on them.
+
+
+3. LIMITATIONS IN FUNCTIONALITY
+-------------------------------
+
+Description:
+	Bounds checking isn't compatible with setjmp, longjmp.
+Comment:
+	The mechanism used by push/pop function (see 'functions.c' in the
+	bc-library) doesn't like functions that don't return.
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/CONTRIBUTORS gcc-4.0.2/gcc/bounds/CONTRIBUTORS
--- gcc-4.0.2.org/gcc/bounds/CONTRIBUTORS	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/CONTRIBUTORS	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,135 @@
+	This is an informal, and unfortunately rather incomplete, list of
+	contributors to this project. The names are listed in alphabetical
+	order of surname. The codes are:
+	N	name
+	E	email address
+	W	web site
+	P	phone
+	F	fax
+	M	postal address
+	D	description of work done on the project
+
+N: Danny Backx
+E: u27113@kb.be
+P: +32(2)422.74.57
+F: +32(2)422.81.77
+M: Kredietbank, Havenlaan 2, 1210 Brussel, Belgium
+D: Patches for `-never-fatal'. Port to NetBSD.
+
+N: Eberhard Mattes
+E: mattes@azu.informatik.uni-stuttgart.de
+D: Worked towards compiling GCC itself with bounds checking! OS/2 port.
+D: Pointed out multiple bugs in lib/string.c, now fixed. -no-warn-unaligned
+D: flag.
+
+N: William Bader
+E: william@nscs.fast.net
+E: williambader@hotmail.com
+W: http://williambader.com
+P: 610-746-7700
+M: Software Consulting Services, 630 Selvaggio Dr, Ste 420, Nazareth PA 18064
+D: 18Nov97: Added '-warn-compare-objects' to remove a test in
+D:   check.c for comparisons of pointers to different objects.
+D:   I had a program that built a tree ordered by node addresses.
+D: 04Dec97: Added size information to messages in string.c.
+D: 29Mar00: Converted from gcc-2.95.2 to egcs-20000327
+D: 26Mar01: Backport to gcc-2.95.3
+D: 23Aug01: Added -print-heap-long
+
+N: Hildo Biersma
+E: Hildo@CONSUL.NL
+D: Suggested fix for `pointer < pointer' code. You can find it in `bounds/misc/
+D: inequality-patches'.
+
+N: Herman ten Brugge
+E: Haj.Ten.Brugge@net.HCC.nl
+D: Many many patches, including ... extra stats, string fns, better diagnostic
+D: msgs, external objs, unchecked objs, speed ups, numerous bug fixes - thanks!
+D: (14/8/95): Fix for array refs, more string fns, ...
+D: (17/8/95): Fix for `char *a[] = {"a", "b", "c"};' in a function.
+D: (18/8/95): Fix (untested) for `verbose' bug
+
+N: Matthias Drochner
+E: drochner@zelux6.zel.kfa-juelich.de
+D: Port to Ultrix 4.2A
+
+N: Don Lewis
+E: gdonl@gv.ssi1.com
+D: Suggested that `bigend_correction' in assign_stack_local and assign_
+D: outer_stack_local functions was causing the infamous stack padding bug.
+
+N: Greg Hudson
+E: ghudson@mit.edu
+D: Fixes for BSD 4.4
+
+N: Richard W.M. Jones
+E: rjones@orchestream.com
+
+N: Paul H.J. Kelly
+E: phjk@doc.ic.ac.uk
+M: Dept. of Computing, Imperial College, London, England.
+
+N: Marko Kohtala
+E: Marko.Kohtala@ntc.nokia.com
+D: List of bugs & fixes (that's what I like to see :-)
+
+N: Don Lewis
+E: gdonl@gv.ssi1.com
+D: Patches to track ILLEGAL pointers.
+
+N: Joerg Petersen
+E: petersen@pi1.physik.uni-stuttgart.de
+F: +(49)-(711) / 685-4954
+P: +(49)-(711) / 695-4886
+M: 1. Physikalisches Institut
+M: Universitaet Stuttgart
+M: D-70550 Stuttgart, Germany
+D: Port to AIX (still in progress).
+
+N: Bart Schuller
+E: schuller@acme.wi.leidenuniv.nl
+D: Minor bug fixes.
+
+N: Steve Simmons
+E: scs@aisinc.com
+D: Cross compiled 2.7.0 with bc for i960. Patch to `gcc.1' man page.
+
+N: Mark W. Snitily
+E: mark@sgcs.com
+D: Helped fix bug in `bounds_frig_decl_initial'. Patched `strtok' for correct
+D: behaviour. Suggested a fix to get `-fno-builtin' automatically. Other
+D: useful bug reports. Patched Makefile for cross-compiler from Sun4 to
+D: VxWorks-68k platform. Sorted out `bcopy'.
+
+N: Peter Stephenson
+E: P.Stephenson@swansea.ac.uk
+M: Dept. of Physics, University of Wales, Swansea, Singleton Park, Swansea,
+M: SA2 8PP, UK.
+T: +44 1792 205678 extn. 4461
+F: +44 1792 295324
+D: Patches for DEC Alpha with OSF/1 3.0
+
+N: Andrew Taylor
+E: andrewt@cse.unsw.edu.au
+D: Suggested new format for errors with `file:line'
+
+N: Swen Thuemmler
+E: swen@uni-paderborn.de
+D: Fixed bug in `c-typeck.c:start_init'.
+
+N: Walter Tuppa
+E: tuppa@iue.tuwien.ac.at
+M: Inst. for MicroElectronics, Technical University of Vienna
+M: Gusshausstrasse 27-29 / 1040 Vienna / Austria
+P: +43/1/58801-3680
+F: +43/1/5059224
+D: Solved problems with 64 bit pointers on DEC Alpha machines.
+
+N: Joachim Wiesel
+E: wiesel@ipf.bau-verm.uni-karlsruhe.de
+M: Building 20.40, Rm. 025
+M: Inst. fuer Photogrammetrie und Fernerkundung,
+M: Universitaet Karlsruhe Englestr. 7, D-76128 Karlsruhe, Germany
+P: +49 721 608 2316
+F: +49 721 694 568
+D: Fixed static objects in Solaris 2.4 x86
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/COPYING gcc-4.0.2/gcc/bounds/COPYING
--- gcc-4.0.2.org/gcc/bounds/COPYING	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/COPYING	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year  name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/CRED_README gcc-4.0.2/gcc/bounds/CRED_README
--- gcc-4.0.2.org/gcc/bounds/CRED_README	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/CRED_README	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,26 @@
+			README FOR CRED EXTENSION 
+The contributions of the CRED(C Range Error Extension) to the original 
+bounds checking patch by Richard Jones(RWJ) are 
+ 1. Solves incompatibility problems with programs which compute using 
+out-of-range addresses/pointers. CRED dynamically tracks out-of-range pointers,
+and allows their safe usage e.g for comparison. The relevant files listed
+below were modified in the gcc/bounds/lib  directory
+  init.c 
+  check.c 
+  object.h 
+  object.c 
+  bounds-lib.h 
+  error.c 
+  globals.c 
+
+2. Significantly improves runtime performance by providing option to 
+   restrict bounds checking to only strings data structures. This restriction
+   whilst making CRED unsound is sufficient for guarding against buffer 
+   overflows. This required modifications to some of the gcc parsing files. 
+
+
+3. Inserts runtime checks for initialization of static pointers. In RWJs 
+   checker, initialization of static pointers involving pointer arithmetic 
+   went unchecked since the value of such pointers had to be resolved at 
+   compile time. In CRED, we insert an extra instruction to carry out this 
+   check at runtime.
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/diffexclude.dat gcc-4.0.2/gcc/bounds/diffexclude.dat
--- gcc-4.0.2.org/gcc/bounds/diffexclude.dat	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/diffexclude.dat	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,18 @@
+c-parse.[chy]*
+objc-parse.[cy]*
+parse.[ch]
+parse-scan.c
+tradcif.c
+cexp.c
+tm.h
+*.info*
+*.rej
+*.orig
+*-
+*~
+junk*
+configure
+core
+a.out
+general-test
+*.o
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/example.html gcc-4.0.2/gcc/bounds/example.html
--- gcc-4.0.2.org/gcc/bounds/example.html	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/example.html	2005-09-29 17:50:42.000000000 +0200
@@ -0,0 +1,251 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
+<html>
+
+<head>
+<title>GCC Bounds Checking</title>
+</head>
+
+<body>
+
+<h2><a name=Example>GCC Bounds Checking Example</a></h2>
+
+<p><code><pre>
+$ cat example.c
+main() {
+char *malloc(); char *a = malloc(2);
+a[2] = 'x';
+}
+$ ./bgcc -fbounds-checking example.c
+$ ./a.out
+Bounds Checking GCC v gcc-4.0.2-3.2 Copyright (C) 1995 Richard W.M. Jones
+Bounds Checking comes with ABSOLUTELY NO WARRANTY. For details see file
+`COPYING' that should have come with the source to this program.
+Bounds Checking is free software, and you are welcome to redistribute it
+under certain conditions. See the file `COPYING' for details.
+For more information, set GCC_BOUNDS_OPTS to `-help'
+example.c:3:Bounds error: attempt to reference memory overrunning the end of an object.
+example.c:3:  Pointer value: 0x8062002, Size: 1
+example.c:3:  Object `malloc':
+example.c:3:    Address in memory:    0x8062000 .. 0x8062001
+example.c:3:    Size:                 2 bytes
+example.c:3:    Element size:         1 bytes
+example.c:3:    Number of elements:   2
+example.c:3:    Created at:           example.c, line 2
+example.c:3:    Storage class:        heap
+</pre></code>
+
+<h2><a name=Example2>A Longer GCC Bounds Checking Example</a></h2>
+
+<p>
+
+This example shows some additional features:
+<ul>
+<li>Modules compiled with and without bounds checking may be linked together without special preparation.
+  <ul>
+  <li>Checked pointers may be passed to modules compiled without bounds checking.
+  <li>Structures containing pointers may be passed between modules compiled with and without bounds checking.
+  </ul>
+<li>Modules compiled without bounds checking still check some pointer accesses.
+  <ul>
+  <li>Checked pointers (pointers created by <code>malloc</code> or by modules compiled with
+      bounds checking) are checked in calls to the <code>str*</code> and <code>mem*</code>
+      library functions and in calls to modules compiled with bounds checking.
+  <li>The checks are similar to a malloc debug library, except more powerful because they
+      also check local and static variables created in modules compiled with checking.
+  </ul>
+<li>The <code>GCC_BOUNDS_OPTS</code> environment variable passes options to the bounds checker.
+  <ul>
+  <li>The <code>-never-fatal</code> option continues after errors.
+  <li>The <code>-print-heap</code> option shows memory leaks.
+  </ul>
+</ul>
+
+<p><code><pre>
+$ cat example2.c
+void test(char *p) { p[1] = 'x'; }	/* access a pointer out of range */
+
+static char static_var[1];	/* example static variable */
+
+main() {
+char local_var[1];		/* example stack variable */
+char *heap_var, *malloc();
+struct { char *a; char *b; } s; /* example structure with pointers */
+heap_var = malloc(1);		/* example heap variable */
+test(local_var);		/* access a local variable out of range */
+test(static_var);		/* access a static variable out of range */
+test(heap_var);			/* access a heap variable out of range */
+s.a = local_var;
+s.b = static_var;
+unchecked(&amp;s);			/* pass to a routine in unchecked module */
+}
+$ cat example2u.c
+/* example unchecked module mixed with checked module */
+/*   No special preparation is required, even for */
+/*   structures containing pointers. */
+
+struct s_tag { char *a; char *b; };
+
+void unchecked(struct s_tag *s) {
+memset(s-&gt;a, 0, 2);		/* example of catching checked pointers in */
+memcpy(s-&gt;b, s-&gt;a, 2);		/* library functions even from unchecked code */
+}
+$ gcc -c example2u.c
+$ ./bgcc -fbounds-checking example2.c example2u.o
+$ GCC_BOUNDS_OPTS="-never-fatal -print-heap" ./a.out
+Bounds Checking GCC v gcc-4.0.2-3.2 Copyright (C) 1995 Richard W.M. Jones
+Bounds Checking comes with ABSOLUTELY NO WARRANTY. For details see file
+`COPYING' that should have come with the source to this program.
+Bounds Checking is free software, and you are welcome to redistribute it
+under certain conditions. See the file `COPYING' for details.
+For more information, set GCC_BOUNDS_OPTS to `-help'
+example2.c:1:Bounds error: attempt to reference memory overrunning the end of an object.
+example2.c:1:  Pointer value: 0xbfffe704, Size: 1
+example2.c:1:  Object `local_var':
+example2.c:1:    Address in memory:    0xbfffe703 .. 0xbfffe703
+example2.c:1:    Size:                 1 bytes
+example2.c:1:    Element size:         1 bytes
+example2.c:1:    Number of elements:   1
+example2.c:1:    Created at:           example2.c, line 6
+example2.c:1:    Storage class:        stack
+example2.c:1:Bounds error: attempt to reference memory overrunning the end of an object.
+example2.c:1:  Pointer value: 0x8058eed, Size: 1
+example2.c:1:  Object `static_var':
+example2.c:1:    Address in memory:    0x8058eec .. 0x8058eec
+example2.c:1:    Size:                 1 bytes
+example2.c:1:    Element size:         1 bytes
+example2.c:1:    Number of elements:   1
+example2.c:1:    Created at:           example2.c, line 3
+example2.c:1:    Storage class:        static
+example2.c:1:Bounds error: attempt to reference memory overrunning the end of an object.
+example2.c:1:  Pointer value: 0x8063001, Size: 1
+example2.c:1:  Object `malloc':
+example2.c:1:    Address in memory:    0x8063000 .. 0x8063000
+example2.c:1:    Size:                 1 bytes
+example2.c:1:    Element size:         1 bytes
+example2.c:1:    Number of elements:   1
+example2.c:1:    Created at:           example2.c, line 9
+example2.c:1:    Storage class:        heap
+&lt;unknown&gt;:0:Bounds error: memset with this destination pointer and size 2 would overrun the end of the object's allocated memory.
+&lt;unknown&gt;:0:  Pointer value: 0xbfffe703
+&lt;unknown&gt;:0:  Object `local_var':
+&lt;unknown&gt;:0:    Address in memory:    0xbfffe703 .. 0xbfffe703
+&lt;unknown&gt;:0:    Size:                 1 bytes
+&lt;unknown&gt;:0:    Element size:         1 bytes
+&lt;unknown&gt;:0:    Number of elements:   1
+&lt;unknown&gt;:0:    Created at:           example2.c, line 6
+&lt;unknown&gt;:0:    Storage class:        stack
+&lt;unknown&gt;:0:Bounds error: memcpy with this destination pointer and size 2 would overrun the end of the object's allocated memory.
+&lt;unknown&gt;:0:  Pointer value: 0x8058eec
+&lt;unknown&gt;:0:  Object `static_var':
+&lt;unknown&gt;:0:    Address in memory:    0x8058eec .. 0x8058eec
+&lt;unknown&gt;:0:    Size:                 1 bytes
+&lt;unknown&gt;:0:    Element size:         1 bytes
+&lt;unknown&gt;:0:    Number of elements:   1
+&lt;unknown&gt;:0:    Created at:           example2.c, line 3
+&lt;unknown&gt;:0:    Storage class:        static
+&lt;unknown&gt;:0:Bounds error: memcpy with this source pointer and size 2 would overrun the end of the object's allocated memory.
+&lt;unknown&gt;:0:  Pointer value: 0xbfffe703
+&lt;unknown&gt;:0:  Object `local_var':
+&lt;unknown&gt;:0:    Address in memory:    0xbfffe703 .. 0xbfffe703
+&lt;unknown&gt;:0:    Size:                 1 bytes
+&lt;unknown&gt;:0:    Element size:         1 bytes
+&lt;unknown&gt;:0:    Number of elements:   1
+&lt;unknown&gt;:0:    Created at:           example2.c, line 6
+&lt;unknown&gt;:0:    Storage class:        stack
+Bounds library call frequency statistics:
+  Calls to push, pop, param function:        1, 1, 0
+  Calls to add, delete stack:                2, 2
+  Calls to add, delete heap:                 1, 0
+  Calls to check pointer +/- integer:        3
+  Calls to check array references:           0
+  Calls to check pointer differences:        0
+  Calls to check object references:          3
+  Calls to check component references:       0
+  Calls to check truth, falsity of pointers: 0, 0
+  Calls to check &lt;, &gt;, &lt;=, &gt;= of pointers:   0
+  Calls to check ==, != of pointers:         0
+  Calls to check p++, ++p, p--, --p:         0, 0, 0, 0
+  References to unchecked static, stack:     0, 0
+Filename = example2.c, Line = 9, Function = malloc, Count = 1 Avg Size = 1, Total = 1
+</pre></code>
+<h1>GCC Bounds Checking Patches</h1>
+
+<h2>
+Bounds checking patches for
+<A HREF="http://www.inter.NL.net/hcc/Haj.Ten.Brugge">GCC releases</A>,
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking">GCC snapshots</A> plus
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/gcc-2.95.3-bgcc-2.95.3.pat.bz2">gcc-2.95.3</A>,
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/gcc-3.0-bgcc-3.0.pat.bz2">gcc-3.0</A>,
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/gcc-3.0.1-bgcc-3.0.1.pat.bz2">gcc-3.0.1</A>,
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/gcc-3.0.2-bgcc-3.0.2.pat.bz2">gcc-3.0.2</A>,
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/gcc-3.0.3-bgcc-3.0.3.pat.bz2">gcc-3.0.3</A>,
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/gcc-3.0.4-bgcc-3.0.4.pat.bz2">gcc-3.0.4</A>,
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/gcc-3.1-bgcc-3.1.pat.bz2">gcc-3.1</A>,
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/gcc-3.1.1-bgcc-3.1.1.pat.bz2">gcc-3.1.1</A>, and
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/gcc-3.2-bgcc-3.2.pat.bz2">gcc-3.2</A>.
+</h2>
+
+<p>
+To build a bounds checking gcc:
+<pre>
+<code>
+  cd /u/gnu				# go to a work area
+  tar xzf gcc-x.y.tar.gz		# unpack gcc
+  mv gcc-x.y bgcc-x.y			# rename the gcc directory
+  cd bgcc-x.y				# go to the bgcc directory
+  patch -p1 -T &lt; gcc-x.y-bgcc-x.y.pat	# apply the patches
+  touch gcc/c-parse.in			# force a rebuild of .y and .c
+  mkdir objdir				# make an object file area
+  cd objdir				# enter the area
+  /u/gnu/bgcc-x.y/configure		# initialize the build
+  make bootstrap			# do the build
+</code>
+</pre>
+You can run the bounds checking gcc from its build area using the script
+<code>/u/gnu/bgcc-x.y/gcc/bounds/bgcc</code><br>
+For more build information, see the README files in
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/">ftp://nscs.fast.net/pub/binaries/boundschecking/</A>
+or the files created by the patches in <code>/u/gnu/bgcc-x.y/gcc/bounds/</code>.
+
+<p>These patches add a <code>-fbounds-checking</code> flag that
+adds bounds checking tests to pointer and array accesses.
+Richard Jones developed the
+<A HREF="http://www-ala.doc.ic.ac.uk/~phjk/BoundsChecking.html">patches against gcc-2.7</A>
+in 1995.
+<A HREF="http://www.inter.NL.net/hcc/Haj.Ten.Brugge">Herman ten Brugge</A>
+is the current maintainer and has updated the patches for
+<A HREF="http://www.inter.NL.net/hcc/Haj.Ten.Brugge">gcc-4.0.2</A>.
+<a href="http://williambader.com">William Bader</a> has unofficial
+updates for selected GCC snapshots.
+
+<p>A copy of Richard Jones' manual is at
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/bounds-checking-reports.tar.bz2">
+ftp://nscs.fast.net/pub/binaries/boundschecking/bounds-checking-reports.tar.bz2
+</A>.
+
+<p>You may freely mix object modules compiled with and without bounds checking.
+The bounds checker also includes replacements for
+<code>mem*</code> and <code>str*</code> routines
+and can detect invalid calls against checked memory objects, even from modules
+compiled without bounds checking.
+
+<i><small>
+<p>These patches are unrelated to the fat pointer bounds checking patches by
+Greg McGary gkm@eng.ascend.com which change the size of pointers and require
+building modified versions of libc and most other libraries that your program
+calls.  Greg's patches will eventually be incorporated into GCC.
+If you can use Greg's fat pointer bounds checker, it has the advantage of
+better run-time performance and support for languages other than C.
+</small></i>
+
+<hr>
+<address>
+Return to <A HREF="http://gcc.gnu.org/extensions.html">GCC extensions</A>
+<br>
+<small>Last modified
+2002-08-26
+</small>
+</address>
+
+</body>
+</html>
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/example.sh gcc-4.0.2/gcc/bounds/example.sh
--- gcc-4.0.2.org/gcc/bounds/example.sh	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/example.sh	2005-09-29 17:50:45.000000000 +0200
@@ -0,0 +1,245 @@
+:
+# example.sh -- create example.html
+#	Parameters:
+#		$1 = compiler command line ["bgcc" is the default]
+#
+# 23Aug02 wb initial version
+
+example=example.html
+
+if [ -f "$example" ] ; then rm -f "${example}-" ; mv "$example" "${example}-" ; fi
+
+(
+
+# Locate bgcc
+
+bgcc="$1"
+if [ -z "$bgcc" ]
+then
+	if [ -x bgcc ]
+	then
+		bgcc=./bgcc
+	else
+		bgcc=bgcc
+	fi
+fi
+
+# Check to avoid zapping files
+
+for name in example.c example2.c example2u.c
+do
+	if [ -f "$name" ]
+	then
+		echo "$0: Error: $name exists, stopping" 1>&2
+		exit
+	fi
+done
+
+# Function to run a command
+
+run() {
+	echo "\$ $*"
+	sh -c "$*" 2>&1 | sed -e 's/&/\&amp;/g' -e 's/</\&lt;/g' -e 's/>/\&gt;/g'
+}
+
+# Create example C programs
+
+cat > example.c <<EOF
+main() {
+char *malloc(); char *a = malloc(2);
+a[2] = 'x';
+}
+EOF
+
+cat > example2.c <<EOF
+void test(char *p) { p[1] = 'x'; }	/* access a pointer out of range */
+
+static char static_var[1];	/* example static variable */
+
+main() {
+char local_var[1];		/* example stack variable */
+char *heap_var, *malloc();
+struct { char *a; char *b; } s; /* example structure with pointers */
+heap_var = malloc(1);		/* example heap variable */
+test(local_var);		/* access a local variable out of range */
+test(static_var);		/* access a static variable out of range */
+test(heap_var);			/* access a heap variable out of range */
+s.a = local_var;
+s.b = static_var;
+unchecked(&s);			/* pass to a routine in unchecked module */
+}
+EOF
+
+cat > example2u.c <<EOF
+/* example unchecked module mixed with checked module */
+/*   No special preparation is required, even for */
+/*   structures containing pointers. */
+
+struct s_tag { char *a; char *b; };
+
+void unchecked(struct s_tag *s) {
+memset(s->a, 0, 2);		/* example of catching checked pointers in */
+memcpy(s->b, s->a, 2);		/* library functions even from unchecked code */
+}
+EOF
+
+# Start the HTML
+
+cat <<EOF
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
+<html>
+
+<head>
+<title>GCC Bounds Checking</title>
+</head>
+
+<body>
+
+<h2><a name=Example>GCC Bounds Checking Example</a></h2>
+
+<p><code><pre>
+EOF
+
+run "cat example.c"
+
+run "$bgcc -fbounds-checking example.c"
+
+run "./a.out"
+
+cat <<EOF
+</pre></code>
+
+<h2><a name=Example2>A Longer GCC Bounds Checking Example</a></h2>
+
+<p>
+
+This example shows some additional features:
+<ul>
+<li>Modules compiled with and without bounds checking may be linked together without special preparation.
+  <ul>
+  <li>Checked pointers may be passed to modules compiled without bounds checking.
+  <li>Structures containing pointers may be passed between modules compiled with and without bounds checking.
+  </ul>
+<li>Modules compiled without bounds checking still check some pointer accesses.
+  <ul>
+  <li>Checked pointers (pointers created by <code>malloc</code> or by modules compiled with
+      bounds checking) are checked in calls to the <code>str*</code> and <code>mem*</code>
+      library functions and in calls to modules compiled with bounds checking.
+  <li>The checks are similar to a malloc debug library, except more powerful because they
+      also check local and static variables created in modules compiled with checking.
+  </ul>
+<li>The <code>GCC_BOUNDS_OPTS</code> environment variable passes options to the bounds checker.
+  <ul>
+  <li>The <code>-never-fatal</code> option continues after errors.
+  <li>The <code>-print-heap</code> option shows memory leaks.
+  </ul>
+</ul>
+
+<p><code><pre>
+EOF
+
+run "cat example2.c"
+
+run "cat example2u.c"
+
+run "gcc -c example2u.c"
+
+run "$bgcc -fbounds-checking example2.c example2u.o"
+
+run 'GCC_BOUNDS_OPTS="-never-fatal -print-heap" ./a.out'
+
+cat <<EOF
+</pre></code>
+<h1>GCC Bounds Checking Patches</h1>
+
+<h2>
+Bounds checking patches for
+<A HREF="http://www.inter.NL.net/hcc/Haj.Ten.Brugge">GCC releases</A>,
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking">GCC snapshots</A> plus
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/gcc-2.95.3-bgcc-2.95.3.pat.bz2">gcc-2.95.3</A>,
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/gcc-3.0-bgcc-3.0.pat.bz2">gcc-3.0</A>,
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/gcc-3.0.1-bgcc-3.0.1.pat.bz2">gcc-3.0.1</A>,
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/gcc-3.0.2-bgcc-3.0.2.pat.bz2">gcc-3.0.2</A>,
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/gcc-3.0.3-bgcc-3.0.3.pat.bz2">gcc-3.0.3</A>,
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/gcc-3.0.4-bgcc-3.0.4.pat.bz2">gcc-3.0.4</A>,
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/gcc-3.1-bgcc-3.1.pat.bz2">gcc-3.1</A>,
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/gcc-3.1.1-bgcc-3.1.1.pat.bz2">gcc-3.1.1</A>, and
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/gcc-3.2-bgcc-3.2.pat.bz2">gcc-3.2</A>.
+</h2>
+
+<p>
+To build a bounds checking gcc:
+<pre>
+<code>
+  cd /u/gnu				# go to a work area
+  tar xzf gcc-x.y.tar.gz		# unpack gcc
+  mv gcc-x.y bgcc-x.y			# rename the gcc directory
+  cd bgcc-x.y				# go to the bgcc directory
+  patch -p1 -T &lt; gcc-x.y-bgcc-x.y.pat	# apply the patches
+  touch gcc/c-parse.in			# force a rebuild of .y and .c
+  mkdir objdir				# make an object file area
+  cd objdir				# enter the area
+  /u/gnu/bgcc-x.y/configure		# initialize the build
+  make bootstrap			# do the build
+</code>
+</pre>
+You can run the bounds checking gcc from its build area using the script
+<code>/u/gnu/bgcc-x.y/gcc/bounds/bgcc</code><br>
+For more build information, see the README files in
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/">ftp://nscs.fast.net/pub/binaries/boundschecking/</A>
+or the files created by the patches in <code>/u/gnu/bgcc-x.y/gcc/bounds/</code>.
+
+<p>These patches add a <code>-fbounds-checking</code> flag that
+adds bounds checking tests to pointer and array accesses.
+Richard Jones developed the
+<A HREF="http://www-ala.doc.ic.ac.uk/~phjk/BoundsChecking.html">patches against gcc-2.7</A>
+in 1995.
+<A HREF="http://www.inter.NL.net/hcc/Haj.Ten.Brugge">Herman ten Brugge</A>
+is the current maintainer and has updated the patches for
+<A HREF="http://www.inter.NL.net/hcc/Haj.Ten.Brugge">gcc-4.0.2</A>.
+<a href="http://williambader.com">William Bader</a> has unofficial
+updates for selected GCC snapshots.
+
+<p>A copy of Richard Jones' manual is at
+<A HREF="ftp://nscs.fast.net/pub/binaries/boundschecking/bounds-checking-reports.tar.bz2">
+ftp://nscs.fast.net/pub/binaries/boundschecking/bounds-checking-reports.tar.bz2
+</A>.
+
+<p>You may freely mix object modules compiled with and without bounds checking.
+The bounds checker also includes replacements for
+<code>mem*</code> and <code>str*</code> routines
+and can detect invalid calls against checked memory objects, even from modules
+compiled without bounds checking.
+
+<i><small>
+<p>These patches are unrelated to the fat pointer bounds checking patches by
+Greg McGary gkm@eng.ascend.com which change the size of pointers and require
+building modified versions of libc and most other libraries that your program
+calls.  Greg's patches will eventually be incorporated into GCC.
+If you can use Greg's fat pointer bounds checker, it has the advantage of
+better run-time performance and support for languages other than C.
+</small></i>
+
+<hr>
+<address>
+Return to <A HREF="http://gcc.gnu.org/extensions.html">GCC extensions</A>
+<br>
+<small>Last modified
+EOF
+
+date -I
+
+cat <<EOF
+</small>
+</address>
+
+</body>
+</html>
+EOF
+
+) > "$example"
+
+rm example.c example2.c example2u.c
+rm -f core a.out example*.o
+
+ls -l "$example"
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/IAFA-PACKAGE gcc-4.0.2/gcc/bounds/IAFA-PACKAGE
--- gcc-4.0.2.org/gcc/bounds/IAFA-PACKAGE	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/IAFA-PACKAGE	2005-09-29 17:50:48.000000000 +0200
@@ -0,0 +1,32 @@
+Title:		Bounds checking GCC
+
+Version:	gcc-4.0.2
+
+Description:	This package adds full, fine-grained array bounds and pointer
+		checking to GCC (C only). The level of checking is similar to,
+		and in some respects exceeds, that of languages like Pascal and
+		Modula-2. Checks work on all objects (not just malloc'd
+		objects, as with similar packages), and many of the C library
+		functions have been rewritten with more thorough checks.
+		Calls to malloc, realloc, free, etc. are also checked.
+
+		The package is supplied as patches to GCC source. Binaries
+		are available at the home FTP site only (dse.doc.ic.ac.uk, in
+		/pub/misc/bcc) or by request to the author.
+
+		Please read the README file in the bounds subdirectory very
+		closely before attempting to compile this software.
+
+Author:		Richard W.M. Jones <rjones@orchestream.com>
+
+Maintained-by:	Richard W.M. Jones <rjones@orchestream.com>
+		Herman A.J. ten Brugge <Haj.Ten.Brugge@net.HCC.nl>
+
+Maintained-at:	sunsite.unc.edu, dse.doc.ic.ac.uk  (old)
+		http://www.inter.NL.net/hcc/Haj.Ten.Brugge (new)
+
+Platforms:	All GCC platforms supported.
+
+Copying-Policy:	Freely Redistributable
+
+Keywords:	GCC C bounds checking pointer array
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/alloca.c gcc-4.0.2/gcc/bounds/lib/alloca.c
--- gcc-4.0.2.org/gcc/bounds/lib/alloca.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/alloca.c	2005-09-29 17:59:26.000000000 +0200
@@ -0,0 +1,137 @@
+/* Bounds Checking for GCC.
+   Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   File:
+  	lib/alloca.c
+   Summary:
+  	Implementation of `alloca' function. If you compile (as recommended)
+  	with -fno-builtin, you will get this implementation of a checked
+  	alloca, with optional checks for stale pointers and so forth.
+   Other notes:
+  	
+   Author      	Date		Notes
+   RWMJ		31/3/95		Initial implementation.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "bounds-lib.h"
+
+#include "mutex.h"		/* for 'enter|leave_critical_section'  */
+
+#if defined(__BOUNDS_CHECKING_ON)
+#error "This file must not be compiled with bounds checking enabled."
+#endif
+
+#if defined(alloca)
+#undef alloca
+#endif
+
+#if defined(__alloca)
+#undef __alloca
+#endif
+
+extern void *__alloca (size_t size);
+extern void *alloca (size_t size);
+
+static __inline__ void *
+bounds_alloca (const char *filename, int line, size_t size)
+{
+  alloca_item *item;
+  sigset_t old_mask;
+
+  enter_critical_section (&old_mask);
+  item = __bounds_malloc (sizeof (alloca_item));
+  if (!item)
+    __bounds_internal_error ("out of space allocating alloca chain",
+			     __FILE__, __LINE__);
+
+  /* Get `functions.c' to add the current alloca item to the current function
+     context. When the current function exits, we will be called (in
+     __bounds_alloca_free) with a chain of these allocations.  */
+  __bounds_add_alloca_chain (item);
+
+  /* Try to allocate the space as a checked memory allocation. Note:
+     (1) alloca never fails,
+     (2) `free' will be called for this object, but according to the
+     current heap mode, it may not actually be freed, and
+     (3) we allocate from the heap, not the stack.  */
+  /* We do not support zero sized objects.  */
+  if (size == 0)
+    size = 1;
+  item->pointer = __bounds_malloc (size + 1);
+  item->filename = filename;
+  item->line = line;
+  if (!item->pointer)
+    __bounds_internal_error ("alloca failed (out of memory)", filename, line);
+  __bounds_add_heap_object (item->pointer, size, 1, "alloca", 0,
+			    filename, line);
+  leave_critical_section (&old_mask);
+
+  return item->pointer;
+}
+
+void *
+__alloca (size_t size)
+{
+  return bounds_alloca (NULL, 0, size);
+}
+
+void *
+alloca (size_t size)
+{
+  return bounds_alloca (NULL, 0, size);
+}
+
+void *
+__bounds_check_alloca (const char *filename, int line, size_t size)
+{
+  return bounds_alloca (filename, line, size);
+}
+
+void *
+__bounds_check___alloca (const char *filename, int line, size_t size)
+{
+  return bounds_alloca (filename, line, size);
+}
+
+void *
+__bounds_check___builtin_alloca (const char *filename, int line, size_t size)
+{
+  return bounds_alloca (filename, line, size);
+}
+
+/* Free up the alloca stack for the current function.  */
+
+void
+__bounds_alloca_free (alloca_item * alloca_stack)
+{
+  alloca_item *next;
+
+  while (alloca_stack)
+    {
+      next = alloca_stack->next;
+      __bounds_delete_heap_object (alloca_stack->pointer, -1,
+				   "invalid pointer used in `alloca'",
+				   alloca_stack->filename,
+				   alloca_stack->line, NULL);
+      __bounds_free (alloca_stack->pointer);
+      __bounds_free (alloca_stack);
+      alloca_stack = next;
+    }
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/alloca.h gcc-4.0.2/gcc/bounds/lib/alloca.h
--- gcc-4.0.2.org/gcc/bounds/lib/alloca.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/alloca.h	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,41 @@
+/* Bounds Checking for GCC.
+   Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.
+
+   This program is free software; you can redistribute it and/or modify	
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   File:
+  	lib/alloca.h
+   Summary:
+  	Header file for `alloca' library. If you compile (as recommended)
+  	with -fno-builtin, you will get this implementation of a checked
+  	alloca, with optional checks for stale pointers and so forth.
+   Other notes:
+
+   Author      	Date		Notes
+   RWMJ		31/3/95		Initial implementation.
+*/
+
+#ifndef _ALLOCA_H_
+#define _ALLOCA_H_
+
+typedef struct alloca_item
+{
+  struct alloca_item *next;	/* Linked list.  */
+  void *pointer;		/* Allocation address.  */
+  const char *filename;
+  int line;
+} alloca_item;
+
+#endif /* _ALLOCA_H_ */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/bounds.c gcc-4.0.2/gcc/bounds/lib/bounds.c
--- gcc-4.0.2.org/gcc/bounds/lib/bounds.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/bounds.c	2005-09-29 18:02:49.000000000 +0200
@@ -0,0 +1,318 @@
+/* Bounds Checking for GCC.
+   Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+ 
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   File:
+  	lib/malloc/bounds.c
+   Summary:
+  	Bounds checking interface to the GNU C malloc library. The GNU
+  	malloc has been modified to provide the unchecked functions
+  	like '__bounds_malloc' directly. We provide the checked versions
+  	(eg. 'malloc') here.
+   Other notes:
+  	
+   Author      	Date		Notes
+   RWMJ		1/6/95		Initial implementation.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#ifdef malloc
+#undef malloc
+#endif
+#ifdef free
+#undef free
+#endif
+#ifdef calloc
+#undef calloc
+#endif
+#ifdef cfree
+#undef cfree
+#endif
+#ifdef memalign
+#undef memalign
+#endif
+#ifdef realloc
+#undef realloc
+#endif
+#ifdef valloc
+#undef valloc
+#endif
+
+#include "bounds-lib.h"
+
+#include "mutex.h"		/* for 'enter|leave_critical_section'  */
+
+#if defined(__BOUNDS_CHECKING_ON)
+#error "This file must not be compiled with bounds checking enabled."
+#endif
+
+extern void *memalign (size_t alignment, size_t size);
+extern void *__libc_memalign (size_t alignment, size_t size);
+
+/* Free a memory area in reuse mode. We add the memory area to a
+   list of memory areas where it will reside until the area ages
+   sufficiently, and then it is actually reallocated.  */
+
+static __inline__ void
+free_reuse (void *pointer)
+{
+  static int initialized = 0, enter = 0, leave = 0, count = 0;
+  static void **arealist;
+
+  if (__bounds_age_limit == 0 || !__bounds_checking_on)
+    {
+      __bounds_free (pointer);
+      return;
+    }
+
+  if (!initialized)
+    {
+      initialized = 1;
+      arealist =
+	(void **) __bounds_malloc (sizeof (void *) * __bounds_age_limit);
+      if (arealist == NULL)
+	__bounds_internal_error ("out of memory allocating memory aging list",
+				 __FILE__, __LINE__);
+    }
+  if (count == __bounds_age_limit)
+    {
+      __bounds_free (arealist[leave]);
+      leave++;
+      if (leave >= __bounds_age_limit)
+	leave = 0;
+    }
+  else
+    count++;
+  arealist[enter] = pointer;
+  enter++;
+  if (enter >= __bounds_age_limit)
+    enter = 0;
+}
+
+/* Free a pointer in 'no-reuse-heap' mode, ie. don't free it at
+   all. Nevertheless, we ought to combine such memory areas and
+   see if we can hand them back to the operating system (with
+   'munmap').  */
+
+static __inline__ void
+free_no_reuse (void *pointer __attribute__ ((unused)))
+{
+  /* Not yet implemented. */
+}
+
+/* Wrapper functions for the major C library dynamic memory functions.
+   These call the GNU library with the side effect of adding or
+   deleting memory objects where necessary.  */
+
+void *
+__bounds_check_malloc (const char *filename, int line, size_t size)
+{
+  void *pointer;
+  sigset_t old_mask;
+
+  /* Although malloc (0) is a strange usage, we are required to support it.
+     We can return any pointer that cannot be dereferenced here, in
+     particular, some libraries return NULL. However, some software thinks
+     that means out of memory. We could also return ILLEGAL, but X11 has
+     a habit of passing that pointer back to free (). Instead we make
+     malloc (0) == malloc (1), and you'd better not dereference it, since
+     the objects library doesn't support zero-sized objects.  */
+  if (size == 0)
+    size = 1;
+  enter_critical_section (&old_mask);
+  pointer = __bounds_malloc (size + 1);
+  if (pointer != NULL)
+    __bounds_add_heap_object (pointer, size, 1, "malloc", 0, filename, line);
+  leave_critical_section (&old_mask);
+  return pointer;
+}
+
+#ifndef __vxworks
+void *
+malloc (size_t size)
+{
+  return __bounds_check_malloc (NULL, 0, size);
+}
+#endif
+
+void
+__bounds_check_free (const char *filename, int line, void *pointer)
+{
+  sigset_t old_mask;
+
+  if (pointer == NULL)
+    {
+      if (__bounds_warn_free_null)
+	__bounds_warning (NULL, 0, "free",
+			  "attempted to free a NULL pointer");
+      return;
+    }
+  if (pointer == ILLEGAL)
+    {
+      __bounds_error ("attempted to free an ILLEGAL pointer", filename, line,
+		      pointer, NULL);
+      return;
+    }
+  enter_critical_section (&old_mask);
+  if (__bounds_delete_heap_object (pointer, -1,
+				   "invalid pointer passed to `free'",
+				   filename, line, NULL) == 0)
+    {
+      if (__bounds_never_free_heap)
+	free_no_reuse (pointer);
+      else
+	free_reuse (pointer);
+    }
+  leave_critical_section (&old_mask);
+}
+
+void
+free (void *pointer)
+{
+  __bounds_check_free (NULL, 0, pointer);
+}
+
+void *
+__bounds_check_realloc (const char *filename, int line,
+			void *pointer, size_t new_size)
+{
+  void *new_pointer;
+  size_t org_size = 1;
+  sigset_t old_mask;
+
+  if (pointer == ILLEGAL)
+    {
+      /* This pointer is non-NULL, but doesn't point to a heap object, so
+         this is an error.  */
+      __bounds_error ("invalid pointer passed to `realloc'",
+		      filename, line, pointer, NULL);
+      return NULL;
+    }
+  enter_critical_section (&old_mask);
+  if (pointer != NULL
+      && __bounds_delete_heap_object (pointer, -1,
+				      "invalid pointer passed to `realloc'",
+				      filename, line, &org_size))
+    new_pointer = NULL;
+  else
+    {
+      if (new_size == 0)
+	new_size = 1;
+      new_pointer = __bounds_realloc (pointer, new_size + 1);
+      if (new_pointer != NULL)
+        __bounds_add_heap_object (new_pointer, new_size, 1, "realloc", 0,
+			          filename, line);
+      else if (pointer != NULL)
+        __bounds_add_heap_object (pointer, org_size, 1, "realloc", 0,
+			          filename, line);
+    }
+  leave_critical_section (&old_mask);
+  return new_pointer;
+}
+
+void *
+realloc (void *pointer, size_t new_size)
+{
+  return __bounds_check_realloc (NULL, 0, pointer, new_size);
+}
+
+void *
+__bounds_check_memalign (const char *filename, int line,
+			 size_t alignment, size_t size)
+{
+  void *pointer;
+  sigset_t old_mask;
+
+  if (size == 0)
+    size = 1;
+  enter_critical_section (&old_mask);
+  pointer = __bounds_memalign (alignment, size + 1);
+  if (pointer != NULL)
+    __bounds_add_heap_object (pointer, size, 1, "memalign", 0, filename,
+			      line);
+  leave_critical_section (&old_mask);
+  return pointer;
+}
+
+void *
+memalign (size_t alignment, size_t size)
+{
+  return __bounds_check_memalign (NULL, 0, alignment, size);
+}
+
+void *
+__libc_memalign (size_t alignment, size_t size)
+{
+  return __bounds_check_memalign (NULL, 0, alignment, size);
+}
+
+void *
+__bounds_check_calloc (const char *filename, int line,
+		       size_t size1, size_t size2)
+{
+  size_t size = size1 * size2;
+  void *pointer;
+  sigset_t old_mask;
+
+  if (size == 0)
+    size = 1;
+  enter_critical_section (&old_mask);
+  pointer = __bounds_calloc (size + 1, 1);
+  if (pointer != NULL)
+    __bounds_add_heap_object (pointer, size, 1, "calloc", 0, filename, line);
+  leave_critical_section (&old_mask);
+  return pointer;
+}
+
+void *
+calloc (size_t size1, size_t size2)
+{
+  return __bounds_check_calloc (NULL, 0, size1, size2);
+}
+
+#ifndef __vxworks
+void cfree (void *pointer);
+
+void
+cfree (void *pointer)
+{
+  free (pointer);
+}
+#endif
+
+void *
+__bounds_check_valloc (const char *filename, int line, size_t size)
+{
+  void *pointer;
+  sigset_t old_mask;
+
+  if (size == 0)
+    size = 1;
+  enter_critical_section (&old_mask);
+  pointer = __bounds_valloc (size + 1);
+  if (pointer != NULL)
+    __bounds_add_heap_object (pointer, size, 1, "valloc", 0, filename, line);
+  leave_critical_section (&old_mask);
+  return pointer;
+}
+
+void *
+valloc (size_t size)
+{
+  return __bounds_check_valloc (NULL, 0, size);
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/bounds-lib.h gcc-4.0.2/gcc/bounds/lib/bounds-lib.h
--- gcc-4.0.2.org/gcc/bounds/lib/bounds-lib.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/bounds-lib.h	2005-09-29 18:00:11.000000000 +0200
@@ -0,0 +1,592 @@
+/* Bounds Checking for GCC.
+   Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.	
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   File:
+  	lib/bounds-lib.h
+   Summary:
+  	Header file for the bounds checking library.
+   Other notes:
+  	
+   Author      	Date		Notes
+   RWMJ		4/12/94		Initial implementation.
+   RWMJ		24/1/94		Added inline `is_.._pointer' functions.
+*/
+
+#ifndef _BOUNDS_LIB_H_
+#define _BOUNDS_LIB_H_
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <sys/types.h>
+
+#include "objects.h"
+#include "alloca.h"
+#include "functions.h"
+#include "version.h"
+
+#ifdef __vxworks
+typedef unsigned size_t;
+#endif
+
+typedef int bool;		/* Return type of <, >, etc.  */
+
+/* These macros should be used to cast between pointers & unsigned integers.
+   Notice that on some machines, sizeof (int) != sizeof (pointer), so we
+   should take care of that here too.  */
+
+typedef unsigned long ptr_as_unsigned_t;
+
+#define PTR_TO_UNSIGNED(p) ((ptr_as_unsigned_t)(p))
+#define UNSIGNED_TO_PTR(u) ((void *)(u))
+
+/* Constants.  */
+
+#define ILLEGAL		((void *)-2)	/* Bad ptr. arithmetic returns this.  */
+#define COLLECT_STATS	1	/* Collect statistics on call freq.  */
+#define DEBUG_FEATURES	1	/* Various extra features.  */
+#define DEBUG_OBJECTS	0	/* Print object info. To print correct
+				   object info you also have to
+				   modfiy c-bounds.c to use
+				   __bounds_maybe_find_object instead
+				   of __bounds_find_object.  */
+
+/* Global variables defined by the compiler when bounds checking has been
+   enabled.  */
+
+extern int __bounds_array_index_check;	/* Check array indexes.  */
+extern int __bounds_never_free_heap;	/* Heap allocation mode.  */
+extern int __bounds_age_limit;	/* Age limit before freeing.  */
+extern int __bounds_debug_print_calls;	/* Print calls to bounds library.  */
+extern int __bounds_debug_print_heap;	/* Print heap.  */
+extern int __bounds_check_mmap_calls;	/* Check mmap calls.  */
+extern int __bounds_debug_no_checking;	/* Disable checking of pointers.  */
+extern int __bounds_checking_on;	/* Bounds checking is on (in ___main) */
+extern int __bounds_warn_unchecked_statics;	/* Warn if unchecked statics used */
+extern int __bounds_warn_unchecked_stack;	/* Warn if unchecked stack used.  */
+extern int __bounds_warn_free_null;	/* Warn if free (0) is called.  */
+extern int __bounds_warn_misc_strings;	/* Warn for miscellaneous string
+					 * nonsense from X11 and GNU libc.  */
+extern int __bounds_warn_illegal;	/* Warn if illegal pointers are made. */
+extern int __bounds_warn_unaligned;	/* Warn if pointers used unaligned.  */
+extern int __bounds_warn_overlap;	/* Warn if memcpy arguments overlap.  */
+extern int __bounds_warn_compare_objects;	/* Warn if comparing points to
+						 * different objects. */
+extern int __bounds_never_fatal;	/* Don't abort on error.  */
+extern int __bounds_oob_pointers;	/* track out-of-bounds pointers.  */
+extern int __bounds_print_oob_pointers;	/* Print calls to oob pointers.  */
+extern int __bounds_debug_print_function;	/* Print debug for oob pointers.  */
+
+#if COLLECT_STATS
+
+/* Global variables for collecting call frequency statistics.  */
+
+extern unsigned __bounds_stats_ptr_plus_int;
+extern unsigned __bounds_stats_array_reference;
+extern unsigned __bounds_stats_ptr_diff;
+extern unsigned __bounds_stats_reference;
+extern unsigned __bounds_stats_component_reference;
+extern unsigned __bounds_stats_ptr_le_ptr;
+extern unsigned __bounds_stats_ptr_lt_ptr;
+extern unsigned __bounds_stats_ptr_ge_ptr;
+extern unsigned __bounds_stats_ptr_gt_ptr;
+extern unsigned __bounds_stats_ptr_ne_ptr;
+extern unsigned __bounds_stats_ptr_eq_ptr;
+extern unsigned __bounds_stats_ptr_postinc;
+extern unsigned __bounds_stats_ptr_preinc;
+extern unsigned __bounds_stats_ptr_postdec;
+extern unsigned __bounds_stats_ptr_predec;
+extern unsigned __bounds_stats_ptr_true;
+extern unsigned __bounds_stats_ptr_false;
+extern unsigned __bounds_stats_push_function;
+extern unsigned __bounds_stats_pop_function;
+extern unsigned __bounds_stats_param_function;
+extern unsigned __bounds_stats_environment;
+extern unsigned __bounds_stats_add_stack;
+extern unsigned __bounds_stats_delete_stack;
+extern unsigned __bounds_stats_add_heap;
+extern unsigned __bounds_stats_delete_heap;
+extern unsigned __bounds_stats_unchecked_stack;
+extern unsigned __bounds_stats_unchecked_static;
+extern unsigned __bounds_stats_add_oob_table;
+extern unsigned __bounds_stats_find_oob_table;
+extern unsigned __bounds_stats_delete_oob_table;
+#if DEBUG_OBJECTS
+extern unsigned __bounds_stats_find_object;
+extern unsigned __bounds_stats_maybe_find_object;
+extern unsigned __bounds_stats_maybe_find_object_search;
+#endif
+
+#endif /* COLLECT_STATS */
+
+extern char *__bounds_error_filename;
+extern int __bounds_error_filename_append;
+
+/* `etext' is the first byte of the data segment. `edata' is the first byte of
+   the bss (uninitialized data). `end' is the first byte of the heap.  */
+
+extern char etext, edata, end;
+
+/* Format of the private table passed by GCC listing all unnamed static
+   objects in a source file.  */
+
+typedef struct
+{
+  void *ptr;			/* Pointer to object.  */
+  void *size;			/* Size (bytes) of object.  */
+  const char *name;		/* Name of the object (NULL=unnamed). */
+} private_table;
+
+/* Format of the table passed by grab-statics utility to the library, listing
+   various named statics in external libraries and object files.
+   N.B.: This table is shared with `tools/find-objects.c'.  */
+
+typedef struct
+{
+  void *address;		/* Object address.  */
+  size_t size;			/* Size (bytes).  */
+  size_t align;			/* Alignment.  */
+  const char *filename;		/* Filename where found.  */
+  int line;			/* Line where found.  */
+  const char *name;		/* Name of object.  */
+} external_statics_table;
+
+/* Prototypes of functions in this library.  */
+
+/* Initialize the library. This is called as the first constructor function.
+   See also init.c  */
+
+void __bounds_initialize_library (void);
+
+/* Allocate/deallocate memory dynamically, but without checking.
+   See also malloc.c  */
+
+void *__bounds_memalign (size_t, size_t);
+void *__bounds_malloc (size_t);
+void __bounds_free (void *);
+void *__bounds_realloc (void *, size_t);
+void *__bounds_calloc (size_t, size_t);
+void __bounds_cfree (void *);
+void *__bounds_valloc (size_t);
+
+/* Notify, check and delete heap objects. Used by new malloc/free.
+   See also objects.c  */
+
+void __bounds_add_heap_object (void *base, size_t count, size_t align,
+			       const char *name, int no_padding,
+			       const char *filename, int line);
+int __bounds_delete_heap_object (void *base, size_t size, const char *error,
+				 const char *filename, int line,
+				 size_t *org_size);
+
+/* Notify, check and delete stack objects. Used on entry/exit to functions.
+   See also objects.c  */
+
+void __bounds_add_stack_object (void *base, size_t count, size_t align,
+				const char *filename, int line,
+				const char *name, int nesting_nr);
+void __bounds_delete_stack_object (void *base, object * obj, int nesting_nr);
+
+/* Internal versions of the above, which work with/return object pointers.
+   See also objects.c  */
+
+object *__bounds_internal_add_stack_object (void *base, size_t count,
+					    size_t align,
+					    const char *filename, int line,
+					    const char *name, int no_padding,
+					    int nesting_nr);
+void __bounds_internal_delete_stack_object (object * obj, int nesting_nr);
+void __bounds_add_object (void *base, size_t size, size_t align,
+		          const char *filename, int line, const char *name,
+		          int no_padding);
+void __bounds_delete_object (object * obj);
+
+/* Find the object referred to by a pointer.
+   See also objects.c  */
+
+object *__bounds_find_object (void *pointer);
+object *__bounds_maybe_find_object (object * obj, void *pointer);
+
+/* Notify of a constructed static object in the text or data segment.
+   See also objects.c  */
+
+object *__bounds_note_constructed_object (void *pointer, int size,
+					  size_t align,
+					  const char *filename, int line,
+					  const char *name);
+void __bounds_note_constructed_private_table (private_table *,
+					      const char *filename, int line);
+
+/* This is the new form of `__bounds_note_constructed_private_table'.
+   Eventually all calls to the above will be replaced with this, which
+   makes more stringent checks.
+   See also exstatics.c  */
+
+void __bounds_add_static_objects_table (external_statics_table *);
+
+/* Notify the library of the arguments to main ().
+   See also objects.c  */
+
+void __bounds_note_main_args (int argc, char **argv);
+
+/* Push and pop in function contexts.
+   See also functions.c  */
+
+int __bounds_push_function (const char *name, int in_main,
+			    const char *filename, int line);
+void __bounds_pop_function (const char *name, int nesting_nr);
+
+/* Add a function parameter for the current function context.
+   See also functions.c  */
+
+void __bounds_add_param_object (void *ptr, size_t size, size_t align,
+				const char *filename, int line,
+				const char *name, int nesting_nr);
+
+void __bounds_add_function_object (object * obj, int nesting_nr);
+int __bounds_remove_function_object (object * obj, int nesting_nr);
+int __bounds_remove_lower_function_object (function_context *fc, object * obj);
+void __bounds_remove_function_context (object * obj, int nesting_nr);
+
+/* Check entry for alloca.  */
+
+void *__bounds_check_alloca (const char *filename, int line, size_t size);
+void *__bounds_check___alloca (const char *filename, int line, size_t size);
+void *__bounds_check___builtin_alloca (const char *filename, int line,
+				       size_t size);
+
+/* Add an alloca allocation to the current function context.
+   See also functions.c  */
+
+void __bounds_add_alloca_chain (alloca_item *);
+void __bounds_delete_alloca_chain (object *);
+
+/* Remove all the alloca allocations for this function context.
+   See also alloca.c  */
+
+void __bounds_alloca_free (alloca_item * alloca_stack);
+
+/* Check pointer arithmetic. These never return if they fail.
+   See also check.c  */
+
+void *__bounds_check_ptr_plus_int (object * obj, void *pointer,
+				   int offset, size_t size,
+				   const char *filename, int line);
+void *__bounds_check_ptr_plus_int_obj (void *pointer,
+				       int offset, size_t size,
+				       const char *filename, int line);
+void *__bounds_check_ptr_minus_int (object * obj, void *pointer,
+				    int offset, size_t size,
+				    const char *filename, int line);
+void *__bounds_check_ptr_minus_int_obj (void *pointer,
+					int offset, size_t size,
+					const char *filename, int line);
+int __bounds_check_ptr_diff (object * obj1, object * obj2,
+			     void *pointer1, void *pointer2, size_t size,
+			     const char *filename, int line);
+int __bounds_check_ptr_diff_obj (void *pointer1, void *pointer2, size_t size,
+			         const char *filename, int line);
+
+/* Check array reference. This is almost the same as ptr_plus_int.
+   See also check.c  */
+
+int __bounds_check_array_reference (object * obj, void *pointer,
+				    int offset, size_t size,
+				    size_t array_size, const char *filename,
+				    int line);
+
+int __bounds_check_array_reference_obj (void *pointer,
+					int offset, size_t size,
+					size_t array_size,
+					const char *filename, int line);
+
+/* Check component references ('->').
+   See also check.c  */
+
+void *__bounds_check_component_reference (object * obj, void *pointer,
+					  int offset, int size,
+					  const char *filename, int line);
+void *__bounds_check_component_reference_obj (void *pointer,
+					      int offset, int size,
+					      const char *filename, int line);
+
+/* Check pointer references. These never return if they fail.
+   See also check.c  */
+
+void *__bounds_check_reference (object * obj, void *pointer, size_t size,
+				const char *filename, int line);
+void *__bounds_check_reference_obj (void *pointer, size_t size,
+				    const char *filename, int line);
+
+/* Check pointer truthvalue or falsity. These never return if they fail.
+   See also check.c  */
+
+bool __bounds_check_ptr_true (void *pointer, const char *filename, int line);
+bool __bounds_check_ptr_true_obj (void *pointer,
+				  const char *filename, int line);
+bool __bounds_check_ptr_false (void *pointer, const char *filename, int line);
+bool __bounds_check_ptr_false_obj (void *pointer,
+				   const char *filename, int line);
+
+/* Check pointer equality and inequality operations. These never return if
+   they fail.
+   See also check.c  */
+
+bool __bounds_check_ptr_le_ptr (object * obj1, object * obj2,
+				void *pointer1, void *pointer2,
+				const char *filename, int line);
+bool __bounds_check_ptr_le_ptr_obj (void *pointer1, void *pointer2,
+				    const char *filename, int line);
+bool __bounds_check_ptr_lt_ptr (object * obj1, object * obj2,
+				void *pointer1, void *pointer2,
+				const char *filename, int line);
+bool __bounds_check_ptr_lt_ptr_obj (void *pointer1, void *pointer2,
+				    const char *filename, int line);
+bool __bounds_check_ptr_ge_ptr (object * obj1, object * obj2,
+				void *pointer1, void *pointer2,
+				const char *filename, int line);
+bool __bounds_check_ptr_ge_ptr_obj (void *pointer1, void *pointer2,
+				    const char *filename, int line);
+bool __bounds_check_ptr_gt_ptr (object * obj1, object * obj2,
+				void *pointer1, void *pointer2,
+				const char *filename, int line);
+bool __bounds_check_ptr_gt_ptr_obj (void *pointer1, void *pointer2,
+				    const char *filename, int line);
+bool __bounds_check_ptr_ne_ptr (void *pointer1, void *pointer2,
+				const char *filename, int line);
+bool __bounds_check_ptr_eq_ptr (void *pointer1, void *pointer2,
+				const char *filename, int line);
+
+/* Pre and post increment and decrement functions.
+   See also check.c  */
+
+void *__bounds_check_ptr_postinc (object * obj, void **ptr_to_ptr,
+				  int inc, const char *filename, int line);
+void *__bounds_check_ptr_preinc (object * obj, void **ptr_to_ptr,
+				 int inc, const char *filename, int line);
+void *__bounds_check_ptr_postdec (object * obj, void **ptr_to_ptr,
+				  int inc, const char *filename, int line);
+void *__bounds_check_ptr_predec (object * obj, void **ptr_to_ptr,
+				 int inc, const char *filename, int line);
+void *__bounds_check_ptr_postinc_obj (void **ptr_to_ptr,
+				      int inc, const char *filename,
+				      int line);
+void *__bounds_check_ptr_preinc_obj (void **ptr_to_ptr, int inc,
+				     const char *filename, int line);
+void *__bounds_check_ptr_postdec_obj (void **ptr_to_ptr, int inc,
+				      const char *filename, int line);
+void *__bounds_check_ptr_predec_obj (void **ptr_to_ptr, int inc,
+				     const char *filename, int line);
+
+void *__bounds_check_ptr_postinc_ref (object * obj, void **ptr_to_ptr,
+				      int inc, size_t size,
+				      const char *filename, int line);
+void *__bounds_check_ptr_preinc_ref (object * obj, void **ptr_to_ptr,
+				     int inc, size_t size,
+				     const char *filename, int line);
+void *__bounds_check_ptr_postdec_ref (object * obj, void **ptr_to_ptr,
+				      int inc, size_t size,
+				      const char *filename, int line);
+void *__bounds_check_ptr_predec_ref (object * obj, void **ptr_to_ptr,
+				     int inc, size_t size,
+				     const char *filename, int line);
+void *__bounds_check_ptr_postinc_ref_obj (void **ptr_to_ptr,
+					  int inc, size_t size,
+					  const char *filename, int line);
+void *__bounds_check_ptr_preinc_ref_obj (void **ptr_to_ptr,
+					 int inc, size_t size,
+					 const char *filename, int line);
+void *__bounds_check_ptr_postdec_ref_obj (void **ptr_to_ptr,
+					  int inc, size_t size,
+					  const char *filename, int line);
+void *__bounds_check_ptr_predec_ref_obj (void **ptr_to_ptr,
+					 int inc, size_t size,
+					 const char *filename, int line);
+
+/* Error reporting functions.
+   See also error.c  */
+
+void __bounds_error (const char *message,
+		     const char *filename, int line,
+		     void *pointer, object * obj);
+
+void __bounds_error_size (const char *message,
+			  const char *filename, int line,
+			  void *pointer, int size, object * obj);
+
+void __bounds_error2 (const char *message,
+		      const char *filename, int line,
+		      void *pointer1, void *pointer2,
+		      object * obj1, object * obj2);
+
+void __bounds_errorf (const char *filename, int line,
+		      void *pointer, object * obj, const char *message, ...);
+
+void __bounds_internal_error (const char *message, const char *filename,
+			      int line) __attribute__ ((noreturn));
+
+/* Warning functions.
+   See also error.c  */
+
+void __bounds_warning (const char *filename, int line, const char *function,
+		       const char *message, ...);
+void __bounds_warn1 (const char *message,
+		     const char *filename, int line,
+		     void *pointer, object * obj);
+void __bounds_warnf (const char *filename, int line,
+		     void *pointer, object * obj, const char *message, ...);
+
+/* Breakpoint for external debuggers.
+   See also error.c  */
+
+void __bounds_breakpoint (void);
+
+/* Debugging functions.  */
+
+void __bounds_debug_memory (void *, void *);	/* (objects.c) Produce memory map.  */
+void __bounds_debug_stack_trace (void);	/* (functions.c) Stack trace.  */
+void __bounds_no_checking_in_this_function (void);	/* (functions.c).  */
+void __bounds_tree_check (tree *);	/* (objects.c) Check tree is OK.  */
+void __bound_print_statistics (void);	/* (objects.c) print statistics.  */
+void __bound_print_heap (void);	/* (objects.c) print heap.  */
+
+
+/* Message printing functions (normal ones may call malloc).
+   See also print.c  */
+
+#if !defined(__osf__)
+void __bounds_printf (const char *format, ...);
+void __bounds_vprintf (const char *format, va_list list);
+
+#define printf __bounds_printf
+#define vprintf __bounds_vprintf
+#endif /* ! OSF */
+
+/* Unchecked versions of the string functions.
+   See also string.c  */
+
+void *__bounds_memcpy (void *, const void *, size_t);
+void *__bounds_mempcpy (void *, const void *, size_t);
+void *__bounds_memmove (void *, const void *, size_t);
+void *__bounds_memccpy (void *, const void *, int, size_t);
+void *__bounds_memset (void *, int, size_t);
+int __bounds_memcmp (const void *, const void *, size_t);
+void *__bounds_memchr (const void *, int, size_t);
+char *__bounds_strcpy (char *, const char *);
+char *__bounds_strncpy (char *, const char *, size_t);
+char *__bounds_strcat (char *, const char *);
+size_t __bounds_strlen (const char *);
+int __bounds_strcmp (const char *, const char *);
+int __bounds_strncmp (const char *, const char *, size_t);
+
+extern int (*__bounds_function_thread) (void);
+
+/* Prototypes for all check functions in string.c  */
+
+void *__bounds_check_memcpy (const char *filename, int line,
+			     void *dest, const void *src, size_t n);
+void *__bounds_check_mempcpy (const char *filename, int line,
+			     void *dest, const void *src, size_t n);
+void *__bounds_check_memmove (const char *filename, int line,
+			      void *dest, const void *src, size_t n);
+void __bounds_check_bcopy (const char *filename, int line,
+			   const void *src, void *dest, int n);
+void *__bounds_check_memset (const char *filename, int line,
+			     void *dest, int c, size_t n);
+void __bounds_check_bzero (const char *filename, int line, char *dest, int n);
+int __bounds_check_memcmp (const char *filename, int line,
+			   const void *s1, const void *s2, size_t n);
+int __bounds_check_bcmp (const char *filename, int line,
+			 void *s1, void *s2, int n);
+char *__bounds_check_strcpy (const char *filename, int line,
+			     char *dest, const char *src);
+char *__bounds_check_strncpy (const char *filename, int line,
+			      char *dest, const char *src, size_t n);
+size_t __bounds_check_strlen (const char *filename, int line, const char *s);
+int __bounds_check_strcmp (const char *filename, int line,
+			   const char *s1, const char *s2);
+int __bounds_check_strncmp (const char *filename, int line,
+			    const char *s1, const char *s2, size_t n);
+char *__bounds_check_strcat (const char *filename, int line,
+			     char *dest, const char *src);
+char *__bounds_check_strncat (const char *filename, int line,
+			      char *dest, const char *src, size_t n);
+char *__bounds_check_strpbrk (const char *filename, int line,
+			      const char *string, const char *chs);
+char *__bounds_check_strrchr (const char *filename, int line,
+			      const char *string, int c);
+char *__bounds_check_rindex (const char *filename, int line,
+			     const char *string, int c);
+size_t __bounds_check_strspn (const char *filename, int line,
+			      const char *string, const char *chs);
+size_t __bounds_check_strcspn (const char *filename, int line,
+			       const char *string, const char *chs);
+char *__bounds_check_strstr (const char *filename, int line,
+			     const char *s1, const char *s2);
+char *__bounds_check_strtok (const char *filename, int line,
+			     char *str1, const char *str2);
+char *__bounds_check_strtok_r (const char *filename, int line,
+			       char *str1, const char *str2, char **lasts);
+char *__bounds_check_strchr (const char *filename, int line,
+			     const char *string, int ch);
+char *__bounds_check_strdup (const char *filename, int line,
+			     const char *string);
+char *__bounds_check_index (const char *filename, int line,
+			    const char *string, int ch);
+int __bounds_check_strcoll (const char *filename, int line,
+			    const char *string1, const char *string2);
+size_t __bounds_check_strxfrm (const char *filename, int line,
+			       char *to, const char *from, size_t n);
+void *__bounds_check_memchr (const char *filename, int line,
+			     const void *s, int c, size_t n);
+void *__bounds_check_memccpy (const char *filename, int line,
+			      void *dest, const void *src, int c, size_t n);
+int __bounds_check_strcasecmp (const char *filename, int line,
+			       const char *s1, const char *s2);
+int __bounds_check_strncasecmp (const char *filename, int line,
+				const char *s1, const char *s2, size_t n);
+
+/* Prototypes for all check functions in bounds.c  */
+
+void *__bounds_check_malloc (const char *filename, int line, size_t size);
+void __bounds_check_free (const char *filename, int line, void *pointer);
+void *__bounds_check_realloc (const char *filename, int line,
+			      void *pointer, size_t new_size);
+void *__bounds_check_memalign (const char *filename, int line,
+			       size_t alignment, size_t size);
+void *__bounds_check_calloc (const char *filename, int line,
+			     size_t size1, size_t size2);
+void *__bounds_check_valloc (const char *filename, int line, size_t size);
+void *__bounds_check_mmap (const char *filename, int line,
+			   void *start, size_t size, int prot,
+			   int flags, int fd, off_t offset);
+int __bounds_check_munmap (const char *filename, int line,
+			   void *start, size_t size);
+
+/* Prototypes for all oob pointer stuff.  */
+void *__bounds_create_oob_pointer (object *, void *, const char *, int);
+void __bounds_setup_oob_pointer (object **, void **, const char *, int);
+void __bounds_setup2_oob_pointer (object **, void **, object **, void **,
+				  const char *, int);
+void __bounds_delete_oob_entries (object *);
+
+/* I always call `abort' in the case of a bounds error. Sometimes `exit' tries
+   to allocate memory for some reason, so `abort' is safer.  */
+
+#define ABORT() abort()
+
+#endif /* _BOUNDS_LIB_H_ */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/breakpoint.c gcc-4.0.2/gcc/bounds/lib/breakpoint.c
--- gcc-4.0.2.org/gcc/bounds/lib/breakpoint.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/breakpoint.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,40 @@
+/* Bounds Checking for GCC.
+   Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.	
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   File:
+  	lib/breakpoint.c
+   Summary:
+  	Debug break point
+*/
+
+#include "bounds-lib.h"
+
+#if defined(__BOUNDS_CHECKING_ON)
+#error "This file must not be compiled with bounds checking enabled."
+#endif
+
+/* Breakpoint for use with debuggers such as GDB. If you place
+   a breakpoint here, then GDB will stop whenever a bounds error
+   occurs. You can use 'print __bounds_debug_memory (0,0)' to list
+   out the known memory objects, and 'where' to give a stack trace.  */
+
+
+void
+__bounds_breakpoint (void)
+{
+  return;
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/calloc.c gcc-4.0.2/gcc/bounds/lib/calloc.c
--- gcc-4.0.2.org/gcc/bounds/lib/calloc.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/calloc.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,40 @@
+/* Copyright (C) 1991, 1992, 1994 Free Software Foundation, Inc.
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public License as
+published by the Free Software Foundation; either version 2 of the
+License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with this library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.
+
+   The author may be reached (Email) at the address mike@ai.mit.edu,
+   or (US mail) as Mike Haertel c/o Free Software Foundation.  */
+
+
+#include "bounds-lib.h"
+
+#ifndef	_MALLOC_INTERNAL
+#define	_MALLOC_INTERNAL
+#include <malloc.h>
+#endif
+
+/* Allocate an array of NMEMB elements each SIZE bytes long.
+   The entire array is initialized to zeros.  */
+__ptr_t
+__bounds_calloc (__malloc_size_t nmemb, __malloc_size_t size)
+{
+  register __ptr_t result = __bounds_malloc (nmemb * size);
+
+  if (result != NULL)
+    (void) __bounds_memset (result, 0, nmemb * size);
+
+  return result;
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/cfree.c gcc-4.0.2/gcc/bounds/lib/cfree.c
--- gcc-4.0.2.org/gcc/bounds/lib/cfree.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/cfree.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,42 @@
+/* Copyright (C) 1991, 1993, 1994 Free Software Foundation, Inc.
+This file is part of the GNU C Library.
+
+The GNU C Library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public License as
+published by the Free Software Foundation; either version 2 of the
+License, or (at your option) any later version.
+
+The GNU C Library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with the GNU C Library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.  */
+
+#include "bounds-lib.h"
+
+#ifndef	_MALLOC_INTERNAL
+#define _MALLOC_INTERNAL
+#include <malloc.h>
+#endif
+
+#ifdef _LIBC
+
+#include <ansidecl.h>
+#include <gnu-stabs.h>
+
+#undef	cfree
+
+function_alias (cfree, free, void, (ptr), DEFUN (cfree, (ptr), PTR ptr))
+#else
+
+void
+__bounds_cfree (__ptr_t ptr)
+{
+  __bounds_free (ptr);
+}
+
+#endif
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/check.c gcc-4.0.2/gcc/bounds/lib/check.c
--- gcc-4.0.2.org/gcc/bounds/lib/check.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/check.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,1300 @@
+/* Bounds Checking for GCC
+   Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.
+ 
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.		
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software	
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   File:
+  	lib/check.c
+   Summary:
+  	This file contains all the functions that are used to check pointers
+  	at run time, and to manage the list of memory objects.
+   Other notes:
+  	
+   Author      	Date		Notes
+   RWMJ		5/12/94		Initial implementation.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "bounds-lib.h"
+#include "check.h"
+
+#if defined(__BOUNDS_CHECKING_ON)
+#error "This file must not be compiled with bounds checking enabled."
+#endif
+
+/* Return whether a pointer is aligned with respect to an object.  */
+static __inline__ int
+pointer_not_aligned (void *pointer, object * obj)
+{
+  unsigned long offset = PTR_TO_UNSIGNED (pointer)
+    - PTR_TO_UNSIGNED (obj->base);
+  return obj->align_mask ? (offset & (obj->align - 1)) != 0
+    : (offset % obj->align) != 0;
+}
+
+/* __bounds_check_ptr_plus_int, __bounds_check_ptr_minus_int is
+   generated by cc1 whenever the expression (pointer +/- offset*size)
+   needs to be evaluated. If the arithmetic produces an oob pointer
+   (ie. object pointed to is under/over-run or misaligned), we return an
+   ILLEGAL pointer that will be caught if it is dereferenced or used in
+   further arithmetic.  */
+
+static __inline__ void *
+check_ptr_plus_minus_int (object * obj, void *new_pointer,
+			  void *pointer, int offset, size_t size,
+			  int is_plus, const char *filename, int line)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_ptr_plus_int;
+#endif
+
+  if (!__bounds_debug_no_checking)
+    {
+#if DEBUG_FEATURES
+      if (__bounds_debug_print_calls)
+	printf ("__bounds_check_ptr_%s_int "
+		"(p=%p, off=%d, sz=%u, file=\"%s\", ln=%d)\n",
+		is_plus ? "plus" : "minus", pointer, offset, size, filename,
+		line);
+#endif
+
+      if (pointer == NULL)
+	;
+      else if (pointer == ILLEGAL)
+	/* ILLEGAL pointers clearly mustn't be used in pointer arithmetic.  */
+	__bounds_error ("ILLEGAL pointer used in pointer arithmetic",
+			filename, line, pointer, NULL);
+      else if (obj == NULL)
+	{
+	  if (__bounds_oob_pointers)
+	    __bounds_setup_oob_pointer (&obj, &pointer, filename, line);
+	  if (obj == NULL)
+	    maybe_is_unchecked (pointer, filename, line, NULL);
+	  else
+	    {
+	      if (is_plus)
+		new_pointer = (char *) pointer + (int) size *offset;
+	      else
+		new_pointer = (char *) pointer - (int) size *offset;
+
+	      if (new_pointer < obj->base || new_pointer > obj->extent)
+		new_pointer = __bounds_create_oob_pointer (obj, new_pointer,
+							   filename, line);
+	    }
+	}
+
+      /* Check to see if this operation is OK for this type of object. If so,
+         we return the result as usual. Otherwise, we return an ILLEGAL pointer
+         that will be caught some time in the future (if it is used).  */
+      else if (new_pointer < obj->base || new_pointer > obj->extent)
+	{
+	  if (__bounds_warn_illegal)
+	    __bounds_warn1
+	      ("created an ILLEGAL pointer in pointer arithmetic", filename,
+	       line, new_pointer, obj);
+	  if (__bounds_oob_pointers)
+	    /* create entry for out of bounds pointer */
+	    new_pointer = __bounds_create_oob_pointer (obj, new_pointer,
+						       filename, line);
+	  else
+	    new_pointer = ILLEGAL;
+	}
+      else if (__bounds_warn_unaligned
+	       && pointer_not_aligned (new_pointer, obj))
+	/* Note: We might return ILLEGAL here, but I think generating a non-
+	   aligned pointer at any time must be an error.  */
+	__bounds_error ("created an unaligned pointer in pointer arithmetic",
+			filename, line, new_pointer, obj);
+    }
+  return new_pointer;
+}
+
+void *
+__bounds_check_ptr_plus_int (object * obj, void *pointer, int offset,
+			     size_t size, const char *filename, int line)
+{
+  return check_ptr_plus_minus_int (obj,
+				   (char *) pointer + (int) size * offset,
+				   pointer, offset, size, 1, filename, line);
+}
+
+void *
+__bounds_check_ptr_plus_int_obj (void *pointer, int offset,
+				 size_t size, const char *filename, int line)
+{
+  return check_ptr_plus_minus_int (__bounds_find_object (pointer),
+				   (char *) pointer + (int) size * offset,
+				   pointer, offset, size, 1, filename, line);
+}
+
+void *
+__bounds_check_ptr_minus_int (object * obj, void *pointer, int offset,
+			      size_t size, const char *filename, int line)
+{
+  return check_ptr_plus_minus_int (obj,
+				   (char *) pointer - (int) size * offset,
+				   pointer, offset, size, 0, filename, line);
+}
+
+void *
+__bounds_check_ptr_minus_int_obj (void *pointer, int offset,
+				  size_t size, const char *filename, int line)
+{
+  return check_ptr_plus_minus_int (__bounds_find_object (pointer),
+				   (char *) pointer - (int) size * offset,
+				   pointer, offset, size, 0, filename, line);
+}
+
+/* __bounds_check_array_reference is generated by cc1 whenever the
+   expression (pointer + offset*size) needs to be evaluated in an
+   array reference. It is almost equivalent to the `ptr_plus_int'
+   case, except that the pointer returned must always be correct,
+   so we will never return ILLEGAL here, but always fail.  */
+
+__inline__ int
+__bounds_check_array_reference (object * obj, void *pointer, int offset,
+				size_t size, size_t array_size,
+				const char *filename, int line)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_array_reference;
+#endif
+
+  if (!__bounds_debug_no_checking)
+    {
+#if DEBUG_FEATURES
+      if (__bounds_debug_print_calls)
+	printf ("__bounds_check_array_reference "
+		"(p=%p, off=%d, sz=%u, ar_sz=%u, file=\"%s\", ln=%d)\n",
+		pointer, offset, size, array_size, filename, line);
+#endif
+
+      if (pointer == NULL || pointer == ILLEGAL)
+	/* NULL or ILLEGAL pointers clearly mustn't be used in pointer
+	   arithmetic.  */
+	__bounds_error ("NULL or ILLEGAL pointer used in array reference",
+			filename, line, pointer, NULL);
+
+      else
+	{
+	  void *new_pointer = (char *) pointer + (int) size * offset;
+
+	  if (__bounds_array_index_check && array_size > size)
+	    {
+	      if (offset < 0 || ((int) size * offset) >= (int) array_size)
+		{
+
+		  if (obj == NULL)
+		    {
+		      /* Create dummy object for printing.  */
+		      __bounds_note_constructed_object (pointer, -array_size,
+							size,
+							filename, line, NULL);
+		      obj = __bounds_find_object (pointer);
+		      __bounds_errorf (filename, line, new_pointer, obj,
+				       "array reference (%d) outside bounds of "
+				       "the array", offset);
+		      /* Delete dummy object.  */
+		      __bounds_delete_object (obj);
+		    }
+		  else
+		    {
+		      void *savebase, *saveextent;
+		      size_t savesize, savealign;
+
+		      savebase = obj->base;
+		      saveextent = obj->extent;
+		      savesize = obj->size;
+		      savealign = obj->line;
+		      obj->base = pointer;
+		      obj->extent = (char *) pointer + array_size;
+		      obj->size = array_size;
+		      obj->align = size;
+		      __bounds_errorf (filename, line, new_pointer, obj,
+				       "array reference (%d) outside bounds of "
+				       "the array", offset);
+		      obj->base = savebase;
+		      obj->extent = saveextent;
+		      obj->size = savesize;
+		      obj->align = savealign;
+		    }
+		}
+	    }
+
+	  if (obj == NULL)
+	    {
+	      if (__bounds_oob_pointers)
+		__bounds_setup_oob_pointer (&obj, &pointer, filename, line);
+	      if (obj)
+		/* Illegal pointer used in further arithmetic. This arithmetic
+		   must be wrong.  */
+		__bounds_error ("illegal pointer used in array reference",
+				filename, line, pointer, NULL);
+	      else
+		maybe_is_unchecked (pointer, filename, line, NULL);
+	    }
+	  else
+	    {
+	      /* Check to see if this operation is OK for this type of object.
+	         If so, we return the result as usual, which will be
+	         immediately be referenced, so it had better be correct.  */
+	      if (new_pointer < obj->base ||
+		  (char *) new_pointer + size > (char *) obj->extent)
+		__bounds_error ("array reference outside bounds of the array",
+				filename, line, new_pointer, obj);
+	      if (__bounds_warn_unaligned &&
+		  pointer_not_aligned (new_pointer, obj))
+		/* I'm sure this must be a compiler error if it ever happens,
+		   unless the programmer has done some nasty casting.  */
+		__bounds_error ("created an unaligned pointer in "
+				"array reference",
+				filename, line, new_pointer, obj);
+	    }
+	}
+    }
+
+  return offset;
+}
+
+int
+__bounds_check_array_reference_obj (void *pointer, int offset,
+				    size_t size, size_t array_size,
+				    const char *filename, int line)
+{
+  return __bounds_check_array_reference (__bounds_find_object (pointer),
+					 pointer, offset, size, array_size,
+					 filename, line);
+}
+
+/* __bounds_check_component_reference
+   Check expressions of the form 'p->e' correctly at run time.  */
+
+__inline__ void *
+__bounds_check_component_reference (object * obj, void *pointer, int offset,
+				    int size, const char *filename, int line)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_component_reference;
+#endif
+
+  if (!__bounds_debug_no_checking)
+    {
+#if DEBUG_FEATURES
+      if (__bounds_debug_print_calls)
+	printf ("__bounds_check_component_reference "
+		"(p=%p, off=%d, sz=%d, file=\"%s\", ln=%d)\n",
+		pointer, offset, size, filename, line);
+#endif
+
+      /* Check for NULL and ILLEGAL pointers passed here. Pointer arithmetic on
+         these is certainly wrong.  */
+      if (pointer == NULL || pointer == ILLEGAL)
+	__bounds_error ("NULL or ILLEGAL pointer used in component reference",
+			filename, line, pointer, NULL);
+      else if (obj == NULL)
+	{
+	  if (__bounds_oob_pointers)
+	    __bounds_setup_oob_pointer (&obj, &pointer, filename, line);
+	  if (obj)
+	    __bounds_error ("illegal pointer used in component reference",
+			    filename, line, pointer, NULL);
+	  else
+	    maybe_is_unchecked (pointer, filename, line, NULL);
+	}
+
+      /* Check that the operation will not overrun the end of the object.  */
+      else if ((char *) pointer + offset < (char *) obj->base
+	       || (char *) pointer + offset + size > (char *) obj->extent)
+	__bounds_error_size ("pointer arithmetic would overrun the end"
+			     " of the object",
+			     filename, line, (char *) pointer + offset,
+			     size, obj);
+    }
+
+  return pointer;
+}
+
+void *
+__bounds_check_component_reference_obj (void *pointer, int offset, int size,
+					const char *filename, int line)
+{
+  return __bounds_check_component_reference (__bounds_find_object (pointer),
+					     pointer, offset, size,
+					     filename, line);
+}
+
+/* __bounds_check_ptr_diff is generated by cc1 whenever we need
+   to evaluate an expression of the form (pointer - pointer). This
+   object is valid only if the two pointers are pointing to the
+   same object.  */
+
+__inline__ int
+__bounds_check_ptr_diff (object * obj1, object * obj2,
+			 void *pointer1, void *pointer2, size_t size,
+			 const char *filename, int line)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_ptr_diff;
+#endif
+
+  if (!__bounds_debug_no_checking)
+    {
+#if DEBUG_FEATURES
+      if (__bounds_debug_print_calls)
+	printf ("__bounds_check_ptr_diff "
+		"(p1=%p, p2=%p, sz=%u, file=\"%s\", ln=%d)\n",
+		pointer1, pointer2, size, filename, line);
+#endif
+
+      if (pointer1 == NULL || pointer2 == NULL)
+	;
+      /* Check for ILLEGAL pointers passed here. Pointer arithmetic on these
+         is wrong.  */
+      else if (pointer1 == ILLEGAL || pointer2 == ILLEGAL)
+	__bounds_error2 ("ILLEGAL pointer used in pointer arithmetic",
+			 filename, line, pointer1, pointer2, NULL, NULL);
+      else
+	{
+	  if (obj1 == NULL)
+	    obj1 = __bounds_find_object (pointer1);
+	  if (obj2 == NULL)
+	    obj2 = __bounds_find_object (pointer2);
+	  if (__bounds_oob_pointers)
+	    {
+	      if (obj1 == NULL && obj2 == NULL)
+		__bounds_setup2_oob_pointer (&obj1, &pointer1,
+					     &obj2, &pointer2,
+					     filename, line);
+	      else if (obj1 == NULL)
+		__bounds_setup_oob_pointer (&obj1, &pointer1, filename, line);
+	      else if (obj2 == NULL)
+		__bounds_setup_oob_pointer (&obj2, &pointer2, filename, line);
+	    }
+	  if (obj1 == NULL || obj2 == NULL)
+	    {
+	      /* Two unchecked static objects or two unchecked stack objects.
+	         Allow the arithmetic to go ahead.  */
+	      if (obj1 == NULL)
+		maybe_is_unchecked (pointer1, filename, line, NULL);
+	      if (obj2 == NULL)
+		maybe_is_unchecked (pointer2, filename, line, NULL);
+	    }
+
+	  /* Check that the objects pointed to by the pointers are the same.
+	     Since object structures are unique, checking obj1 == obj2 is
+	     sufficient.  */
+	  else if (obj1 != obj2)
+	    {
+	      /* if objects are adjacent function parameters (i.e no padding)
+	         then no error.  */
+	      if (!(obj1->no_padding && obj2->no_padding
+		    && (obj2->base == obj1->extent
+			|| obj1->base == obj2->extent)))
+		__bounds_error2 ("in pointer difference, pointers point"
+				 " to different objects",
+				 filename, line, pointer1, pointer2,
+				 obj1, obj2);
+	    }
+	  /* Check that the size of the pointers (size, passed to this function)
+	     is a whole multiple of the size of the object's elements.  */
+	  else if (__bounds_warn_unaligned)
+	    {
+	      if (obj1->align_mask
+		  ? (size & (obj1->align - 1)) != 0
+		  : (size % obj1->align) != 0)
+		__bounds_errorf (filename, line, pointer1, obj1,
+				 "size of pointer (%d bytes) not a whole"
+				 " multiple of size of elements (%d bytes)"
+				 " in pointer difference", size, obj1->align);
+	      /* Check that both pointers are aligned w.r.t. the object
+	         they point to.  */
+	      else if (pointer_not_aligned (pointer1, obj1))
+		__bounds_error ("unaligned pointer used in"
+				" pointer arithmetic",
+				filename, line, pointer1, obj1);
+	      else if (pointer_not_aligned (pointer2, obj2))
+		__bounds_error ("unaligned pointer used in"
+				" pointer arithmetic",
+				filename, line, pointer2, obj2);
+	    }
+	}
+    }
+
+  return (int) ((char *) pointer1 - (char *) pointer2) / (int) size;
+}
+
+int
+__bounds_check_ptr_diff_obj (void *pointer1, void *pointer2, size_t size,
+			     const char *filename, int line)
+{
+  return __bounds_check_ptr_diff (NULL, NULL,
+				  pointer1, pointer2, size,
+				  filename, line);
+}
+
+/* __bounds_check_reference is generated by cc1 whenever a reference
+   is about to be made to a pointer. This function does not actually
+   do the reference, but checks that it can proceed correctly.  */
+
+__inline__ void *
+__bounds_check_reference (object * obj, void *pointer, size_t size,
+			  const char *filename, int line)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_reference;
+#endif
+
+  if (!__bounds_debug_no_checking)
+    {
+#if DEBUG_FEATURES
+      if (__bounds_debug_print_calls)
+	printf ("__bounds_check_reference "
+		"(p=%p, sz=%u, file=\"%s\", ln=%d)\n",
+		pointer, size, filename, line);
+#endif
+
+      /* Check for NULL or ILLEGAL pointers, or pointers that don't seem to
+         point to known memory objects.  */
+      if (pointer == NULL || pointer == ILLEGAL)
+	__bounds_error ("attempt to reference a NULL or ILLEGAL pointer",
+			filename, line, pointer, NULL);
+      else if (obj == NULL)
+	{
+	  if (__bounds_oob_pointers)
+	    __bounds_setup_oob_pointer (&obj, &pointer, filename, line);
+	  if (obj)
+	    __bounds_error ("attempt to reference an illegal pointer",
+			    filename, line, pointer, NULL);
+	  else
+	    maybe_is_unchecked (pointer, filename, line, NULL);
+	}
+
+      /* Check that the size is a whole multiple of the element size, and that
+         the pointer is aligned.  */
+      else
+	{
+	  if (__bounds_warn_unaligned)
+	    {
+	      if (obj->align_mask
+		  ? (size & (obj->align - 1)) != 0 : (size % obj->align) != 0)
+		__bounds_errorf (filename, line, pointer, obj,
+				 "size of pointer (%d bytes) not a whole"
+				 " multiple of size of elements (%d bytes)"
+				 " in pointer reference", size, obj->align);
+	      else if (pointer_not_aligned (pointer, obj))
+		__bounds_error ("unaligned pointer used in pointer reference",
+				filename, line, pointer, obj);
+	    }
+	  /* Check that reference will not overrun the end of the object.  */
+	  if ((char *) pointer < (char *) obj->base
+	      || (char *) pointer + size > (char *) obj->extent)
+	    __bounds_error_size ("attempt to reference memory overrunning"
+				 " the end of an object",
+				 filename, line, pointer, size, obj);
+	}
+    }
+  return pointer;
+}
+
+void *
+__bounds_check_reference_obj (void *pointer, size_t size,
+			      const char *filename, int line)
+{
+  return __bounds_check_reference (__bounds_find_object (pointer),
+				   pointer, size, filename, line);
+}
+
+/* __bounds_check_ptr_true and __bounds_check_ptr_false. These are
+   generated by cc1 whenever we meet truthvalue conversion of a
+   pointer or '! pointer', ie.
+ 	if (pointer) { ... }	or	if (!pointer) { ... }
+   They both check the same thing - namely that the pointer is
+   NULL or pointing to valid memory. ILLEGAL pointers fail this test.  */
+
+static __inline__ void
+check_true_or_false (void *pointer, const char *filename, int line)
+{
+  if (pointer != NULL)
+    {
+      if (pointer == ILLEGAL)
+	__bounds_error ("attempt to find truthvalue of an ILLEGAL pointer",
+			filename, line, pointer, NULL);
+#if 0
+      /* Disable this because we can still test pointers after we free
+         them. We can not dereference them but that will be checked
+         somewhere else.  */
+      else if (obj == NULL)
+	/* Second chance for possible unchecked pointers.  */
+	maybe_is_unchecked (pointer, filename, line, NULL);
+#endif
+    }
+}
+
+__inline__ bool
+__bounds_check_ptr_true (void *pointer, const char *filename, int line)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_ptr_true;
+#endif
+
+  if (!__bounds_debug_no_checking)
+    {
+#if DEBUG_FEATURES
+      if (__bounds_debug_print_calls)
+	printf ("__bounds_check_ptr_true (p=%p, file=\"%s\", ln=%d)\n",
+		pointer, filename, line);
+#endif
+
+      check_true_or_false (pointer, filename, line);
+    }
+
+  return pointer != NULL;
+}
+
+bool
+__bounds_check_ptr_true_obj (void *pointer, const char *filename, int line)
+{
+  return __bounds_check_ptr_true (pointer, filename, line);
+}
+
+__inline__ bool
+__bounds_check_ptr_false (void *pointer, const char *filename, int line)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_ptr_false;
+#endif
+
+  if (!__bounds_debug_no_checking)
+    {
+#if DEBUG_FEATURES
+      if (__bounds_debug_print_calls)
+	printf ("__bounds_check_ptr_false (p=%p, file=\"%s\", ln=%d)\n",
+		pointer, filename, line);
+#endif
+
+      check_true_or_false (pointer, filename, line);
+    }
+
+  return pointer == NULL;
+}
+
+bool
+__bounds_check_ptr_false_obj (void *pointer, const char *filename, int line)
+{
+  return __bounds_check_ptr_false (pointer, filename, line);
+}
+
+/* __bounds_check_ptr_OP_ptr, where 'OP' is le, lt, ge, gt are
+   generated by cc1 when we meet comparison operations <=, <, >=, >
+   respectively.  */
+
+static __inline__ void
+check_inequality (object * obj1, object * obj2,
+		  void **pointer1, void **pointer2,
+		  const char *filename, int line)
+{
+  /* Doing an inequality operation against a NULL pointer is a strange thing
+     to want to do. Against an ILLEGAL pointer, it's definitely wrong.  */
+  if (*pointer1 == NULL || *pointer2 == NULL)
+    ;
+  else if (*pointer1 == ILLEGAL || *pointer2 == ILLEGAL)
+    __bounds_error2 ("ILLEGAL pointer used in <, >, <= or >= of pointers",
+		     filename, line, *pointer1, *pointer2, NULL, NULL);
+  else if ((obj1 == NULL
+	    && (obj1 = __bounds_find_object (*pointer1)) == NULL)
+	   || (obj2 == NULL
+	       && (obj2 = __bounds_find_object (*pointer2)) == NULL))
+    {
+      if (__bounds_oob_pointers)
+	{
+	  if (obj1 == NULL && obj2 == NULL)
+	    __bounds_setup2_oob_pointer (&obj1, pointer1,
+					 &obj2, pointer2, filename, line);
+	  else if (obj1 == NULL)
+	    __bounds_setup_oob_pointer (&obj1, pointer1, filename, line);
+	  else if (obj2 == NULL)
+	    __bounds_setup_oob_pointer (&obj2, pointer2, filename, line);
+	}
+      if (__bounds_warn_compare_objects && obj1 && obj2 && obj1 != obj2)
+	__bounds_error2 ("in <, >, <= or >= of pointers, pointers"
+			 " point to different objects",
+			 filename, line, *pointer1, *pointer2, obj1, obj2);
+      /* Two unchecked static objects or two unchecked stack objects.
+         Allow the arithmetic to go ahead.  */
+      else
+	{
+	  if (obj1 == NULL)
+	    maybe_is_unchecked (*pointer1, filename, line, NULL);
+	  if (obj2 == NULL)
+	    maybe_is_unchecked (*pointer2, filename, line, NULL);
+	}
+    }
+  /* Check that the objects pointed to by the pointers are the same. Since
+     object structures are unique, checking obj1 == obj2 is sufficient.  */
+  else if (__bounds_warn_compare_objects && obj1 != obj2)
+    __bounds_error2 ("in <, >, <= or >= of pointers, pointers"
+		     " point to different objects",
+		     filename, line, *pointer1, *pointer2, obj1, obj2);
+}
+
+__inline__ bool
+__bounds_check_ptr_le_ptr (object * obj1, object * obj2,
+			   void *pointer1, void *pointer2,
+			   const char *filename, int line)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_ptr_le_ptr;
+#endif
+
+  if (!__bounds_debug_no_checking)
+    {
+#if DEBUG_FEATURES
+      if (__bounds_debug_print_calls)
+	printf ("__bounds_check_ptr_le_ptr "
+		"(p1=%p, p2=%p, file=\"%s\", ln=%d)\n",
+		pointer1, pointer2, filename, line);
+#endif
+      check_inequality (obj1, obj2, &pointer1, &pointer2, filename, line);
+    }
+
+  return pointer1 <= pointer2;
+}
+
+bool
+__bounds_check_ptr_le_ptr_obj (void *pointer1, void *pointer2,
+                               const char *filename, int line)
+{
+  return __bounds_check_ptr_le_ptr (NULL, NULL, pointer1, pointer2,
+				    filename, line);
+}
+
+__inline__ bool
+__bounds_check_ptr_lt_ptr (object * obj1, object * obj2,
+			   void *pointer1, void *pointer2,
+			   const char *filename, int line)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_ptr_lt_ptr;
+#endif
+
+  if (!__bounds_debug_no_checking)
+    {
+#if DEBUG_FEATURES
+      if (__bounds_debug_print_calls)
+	printf ("__bounds_check_ptr_lt_ptr "
+		"(p1=%p, p2=%p, file=\"%s\", ln=%d)\n",
+		pointer1, pointer2, filename, line);
+#endif
+      check_inequality (obj1, obj2, &pointer1, &pointer2, filename, line);
+    }
+
+  return pointer1 < pointer2;
+}
+
+bool
+__bounds_check_ptr_lt_ptr_obj (void *pointer1, void *pointer2,
+                               const char *filename, int line)
+{
+  return __bounds_check_ptr_lt_ptr (NULL, NULL, pointer1, pointer2,
+				    filename, line);
+			
+}
+
+__inline__ bool
+__bounds_check_ptr_ge_ptr (object * obj1, object * obj2,
+			   void *pointer1, void *pointer2,
+			   const char *filename, int line)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_ptr_ge_ptr;
+#endif
+
+  if (!__bounds_debug_no_checking)
+    {
+#if DEBUG_FEATURES
+      if (__bounds_debug_print_calls)
+	printf ("__bounds_check_ptr_ge_ptr "
+		"(p1=%p, p2=%p, file=\"%s\", ln=%d)\n",
+		pointer1, pointer2, filename, line);
+#endif
+      check_inequality (obj1, obj2, &pointer1, &pointer2, filename, line);
+    }
+
+  return pointer1 >= pointer2;
+}
+
+bool
+__bounds_check_ptr_ge_ptr_obj (void *pointer1, void *pointer2,
+                               const char *filename, int line)
+{
+  return __bounds_check_ptr_ge_ptr (NULL, NULL, pointer1, pointer2,
+				    filename, line);
+}
+
+__inline__ bool
+__bounds_check_ptr_gt_ptr (object * obj1, object * obj2,
+			   void *pointer1, void *pointer2,
+			   const char *filename, int line)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_ptr_gt_ptr;
+#endif
+
+  if (!__bounds_debug_no_checking)
+    {
+#if DEBUG_FEATURES
+      if (__bounds_debug_print_calls)
+	printf ("__bounds_check_ptr_gt_ptr "
+		"(p1=%p, p2=%p, file=\"%s\", ln=%d)\n",
+		pointer1, pointer2, filename, line);
+#endif
+      check_inequality (obj1, obj2, &pointer1, &pointer2, filename, line);
+    }
+
+  return pointer1 > pointer2;
+}
+
+bool
+__bounds_check_ptr_gt_ptr_obj (void *pointer1, void *pointer2,
+                               const char *filename, int line)
+{
+  return __bounds_check_ptr_gt_ptr (NULL, NULL, pointer1, pointer2,
+				    filename, line);
+				
+}
+
+/* __bounds_check_ptr_ne_ptr and __bounds_check_ptr_eq_ptr are
+   generated by cc1 when we get pointer != pointer or pointer ==
+   pointer respectively. We check that the pointers used aren't
+   ILLEGAL.
+   Note (5/3/95): Stale pointers used in == and != are OK, because
+   of the following piece of code:
+ 	  oldPtr = ptr;
+ 	  ptr = realloc (ptr, n);
+ 	  if (ptr != oldPtr) {
+ 	    ** execute code if the realloc'd memory moved. **
+ 	    ...
+ 	  }
+   Note (31/5/95): NULL pointers are OK.  */
+
+static __inline__ void
+check_equality (void **pointer1, void **pointer2,
+		const char *filename, int line)
+{
+  object *obj1;
+  object *obj2;
+
+  if (__bounds_oob_pointers)
+    __bounds_setup2_oob_pointer (&obj1, pointer1, &obj2, pointer2,
+				 filename, line);
+  if (*pointer1 == ILLEGAL || *pointer2 == ILLEGAL)
+    __bounds_error2
+      ("ILLEGAL pointer used in == or != comparison of pointers", filename,
+       line, pointer1, pointer2, NULL, NULL);
+#if 0				/* (See note 5/3/95 above) */
+  /* Make sure we know about each pointer, or the pointer points to an
+     unchecked object.  */
+  if (!((pointer1 == NULL
+	 || __bounds_find_object (pointer1) != NULL)
+	&& (pointer2 == NULL || __bounds_find_object (pointer2) != NULL)))
+    /* One of the pointers is invalid. */
+    __bounds_error2
+      ("invalid pointer used in == or != comparison of pointers", filename,
+       line, pointer1, pointer2, __bounds_find_object (pointer1),
+       __bounds_find_object (pointer2));
+#endif
+}
+
+bool
+__bounds_check_ptr_ne_ptr (void *pointer1, void *pointer2,
+			   const char *filename, int line)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_ptr_ne_ptr;
+#endif
+
+  if (!__bounds_debug_no_checking)
+    {
+#if DEBUG_FEATURES
+      if (__bounds_debug_print_calls)
+	printf ("__bounds_check_ptr_ne_ptr "
+		"(p1=%p, p2=%p, file=\"%s\", ln=%d)\n",
+		pointer1, pointer2, filename, line);
+#endif
+
+      check_equality (&pointer1, &pointer2, filename, line);
+    }
+
+  return pointer1 != pointer2;
+}
+
+bool
+__bounds_check_ptr_eq_ptr (void *pointer1, void *pointer2,
+			   const char *filename, int line)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_ptr_eq_ptr;
+#endif
+
+  if (!__bounds_debug_no_checking)
+    {
+#if DEBUG_FEATURES
+      if (__bounds_debug_print_calls)
+	printf ("__bounds_check_ptr_eq_ptr "
+		"(p1=%p, p2=%p, file=\"%s\", ln=%d)\n",
+		pointer1, pointer2, filename, line);
+#endif
+
+      check_equality (&pointer1, &pointer2, filename, line);
+    }
+
+  return pointer1 == pointer2;
+}
+
+/* Post- and pre-increment and decrement functions. These functions
+   change the value of the pointer through the 'void **' argument.
+   They return the value of the pointer either before or after the
+   pointer was changed, as appropriate.  */
+
+static __inline__ void *
+check_inc_or_dec (object * obj, void **ptr_to_ptr, int inc, int is_post,
+		  const char *operation, const char *filename, int line)
+{
+  void *old_ptr = *ptr_to_ptr;	/* Current value of the pointer. */
+  void *new_ptr;		/* New value after increment. */
+
+  /* Evaluate the new pointer, assuming the operation will be able to go
+     ahead.  */
+  new_ptr = (void *) ((char *) old_ptr + inc);
+
+  /* Check we are not using a NULL or ILLEGAL pointer in arithmetic.  */
+  if (old_ptr == NULL || old_ptr == ILLEGAL)
+    {
+      __bounds_errorf (filename, line, old_ptr, NULL,
+		       "NULL or ILLEGAL pointer used in %s", operation);
+      old_ptr = new_ptr = ILLEGAL;
+    }
+  /* See if we can find what the pointer points to, or if it is an unchecked
+     pointer.  */
+  else if (obj == NULL)
+    {
+      if (__bounds_oob_pointers)
+	__bounds_setup_oob_pointer (&obj, &old_ptr, filename, line);
+      if (obj == NULL)
+	maybe_is_unchecked (old_ptr, filename, line, NULL);
+      else
+	{
+	  new_ptr = (void *) ((char *) old_ptr + inc);
+	  if (new_ptr < obj->base || new_ptr > obj->extent)
+	    new_ptr = __bounds_create_oob_pointer (obj, new_ptr,
+						   filename, line);
+	}
+    }
+  /* Check the alignment of the pointer and increment size.  */
+  else
+    {
+      if (__bounds_warn_unaligned)
+	{
+	  if (obj->align_mask
+	      ? (inc & (obj->align - 1)) != 0 : (inc % obj->align) != 0)
+	    __bounds_errorf (filename, line, old_ptr, obj,
+			     "%srement size (%d bytes) not a whole multiple"
+			     " of size of elements (%d bytes) in %s",
+			     inc >= 0 ? "inc" : "dec", abs (inc), obj->align,
+			     operation);
+	  else if (pointer_not_aligned (old_ptr, obj))
+	    __bounds_errorf (filename, line, old_ptr, obj,
+			     "unaligned pointer used in %s", operation);
+	}
+      /* Check the increment or decrement will not overrun the object.  */
+      if (new_ptr < obj->base || new_ptr > obj->extent)
+	{
+	  if (__bounds_warn_illegal)
+	    __bounds_warnf (filename, line, new_ptr, obj,
+			    "created an ILLEGAL pointer in %s", operation);
+	  if (__bounds_oob_pointers)
+	    /* create entry for out of bounds pointer */
+	    new_ptr = __bounds_create_oob_pointer (obj, new_ptr,
+						   filename, line);
+	  else
+	    new_ptr = ILLEGAL;	/* Catch this error later.  */
+	}
+    }
+
+  /* Set the pointer value to the new pointer value, and return the required
+     pointer.  */
+  *ptr_to_ptr = new_ptr;
+  return is_post ? old_ptr : new_ptr;
+}
+
+__inline__ void *
+__bounds_check_ptr_postinc (object * obj, void **ptr_to_ptr, int inc,
+			    const char *filename, int line)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_ptr_postinc;
+#endif
+
+  if (__bounds_debug_no_checking)
+    {
+      void *result = *ptr_to_ptr;
+      char *tmp = (char *)ptr_to_ptr;
+      *tmp += inc;
+      return result;
+    }
+#if DEBUG_FEATURES
+  if (__bounds_debug_print_calls)
+    printf ("__bounds_check_ptr_postinc (p=%p, inc=%d, file=\"%s\", ln=%d)\n",
+	    *ptr_to_ptr, inc, filename, line);
+#endif
+
+  return check_inc_or_dec (obj, ptr_to_ptr, inc, 1,
+			   "postincrement (p++)", filename, line);
+}
+
+__inline__ void *
+__bounds_check_ptr_preinc (object * obj, void **ptr_to_ptr, int inc,
+			   const char *filename, int line)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_ptr_preinc;
+#endif
+
+  if (__bounds_debug_no_checking)
+    return (*(char **) ptr_to_ptr) += inc;
+#if DEBUG_FEATURES
+  if (__bounds_debug_print_calls)
+    printf ("__bounds_check_ptr_preinc (p=%p, inc=%d, file=\"%s\", ln=%d)\n",
+	    *ptr_to_ptr, inc, filename, line);
+#endif
+
+  return check_inc_or_dec (obj, ptr_to_ptr, inc, 0,
+			   "preincrement (++p)", filename, line);
+}
+
+__inline__ void *
+__bounds_check_ptr_postdec (object * obj, void **ptr_to_ptr, int inc,
+			    const char *filename, int line)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_ptr_postdec;
+#endif
+
+  if (__bounds_debug_no_checking)
+    {
+      void *result = *ptr_to_ptr;
+      char *tmp = (char *)ptr_to_ptr;
+      *tmp -= inc;
+      return result;
+    }
+#if DEBUG_FEATURES
+  if (__bounds_debug_print_calls)
+    printf ("__bounds_check_ptr_postdec (p=%p, inc=%d, file=\"%s\", ln=%d)\n",
+	    *ptr_to_ptr, inc, filename, line);
+#endif
+
+  return check_inc_or_dec (obj, ptr_to_ptr, -inc, 1,
+			   "postdecrement (p--)", filename, line);
+}
+
+__inline__ void *
+__bounds_check_ptr_predec (object * obj, void **ptr_to_ptr, int inc,
+			   const char *filename, int line)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_ptr_predec;
+#endif
+
+  if (__bounds_debug_no_checking)
+    return (*(char **) ptr_to_ptr) -= inc;
+#if DEBUG_FEATURES
+  if (__bounds_debug_print_calls)
+    printf ("__bounds_check_ptr_predec (p=%p, inc=%d, file=\"%s\", ln=%d)\n",
+	    *ptr_to_ptr, inc, filename, line);
+#endif
+
+  return check_inc_or_dec (obj, ptr_to_ptr, -inc, 0,
+			   "predecrement (--p)", filename, line);
+}
+
+void *
+__bounds_check_ptr_postinc_obj (void **ptr_to_ptr, int inc,
+				const char *filename, int line)
+{
+  return __bounds_check_ptr_postinc (__bounds_find_object (*ptr_to_ptr),
+				     ptr_to_ptr, inc, filename, line);
+}
+
+void *
+__bounds_check_ptr_preinc_obj (void **ptr_to_ptr, int inc,
+			       const char *filename, int line)
+{
+  return __bounds_check_ptr_preinc (__bounds_find_object (*ptr_to_ptr),
+				    ptr_to_ptr, inc, filename, line);
+}
+
+void *
+__bounds_check_ptr_postdec_obj (void **ptr_to_ptr, int inc,
+				const char *filename, int line)
+{
+  return __bounds_check_ptr_postdec (__bounds_find_object (*ptr_to_ptr),
+				     ptr_to_ptr, inc, filename, line);
+}
+
+void *
+__bounds_check_ptr_predec_obj (void **ptr_to_ptr, int inc,
+			       const char *filename, int line)
+{
+  return __bounds_check_ptr_predec (__bounds_find_object (*ptr_to_ptr),
+				    ptr_to_ptr, inc, filename, line);
+}
+
+/* Post- and pre-increment and decrement functions. These functions
+   change the value of the pointer through the 'void **' argument.
+   They return the value of the pointer either before or after the
+   pointer was changed, as appropriate.  */
+
+static __inline__ void *
+check_inc_or_dec_ref (object * obj, void **ptr_to_ptr, int inc, size_t size,
+		      int is_post, const char *operation,
+		      const char *filename, int line)
+{
+  void *old_ptr = *ptr_to_ptr;	/* Current value of the pointer. */
+  void *new_ptr;		/* New value after increment. */
+
+  /* Evaluate the new pointer, assuming the operation will be able to go
+     ahead.  */
+  new_ptr = (void *) ((char *) old_ptr + inc);
+
+  /* Check we are not using a NULL or ILLEGAL pointer in arithmetic.  */
+  if (old_ptr == NULL || old_ptr == ILLEGAL)
+    {
+      __bounds_errorf (filename, line, old_ptr, NULL,
+		       "NULL or ILLEGAL pointer used in %s", operation);
+      old_ptr = new_ptr = ILLEGAL;
+    }
+  /* See if we can find what the pointer points to, or if it is an unchecked
+     pointer.  */
+  else if (obj == NULL)
+    {
+      if (__bounds_oob_pointers)
+	__bounds_setup_oob_pointer (&obj, &old_ptr, filename, line);
+      if (obj == NULL)
+	maybe_is_unchecked (old_ptr, filename, line, NULL);
+      else
+	{
+	  new_ptr = (void *) ((char *) old_ptr + inc);
+	  if (inc && (new_ptr < obj->base || new_ptr > obj->extent))
+	    new_ptr = __bounds_create_oob_pointer (obj, new_ptr,
+						   filename, line);
+	}
+    }
+  /* Check the alignment of the pointer and increment size.  */
+  else
+    {
+      if (__bounds_warn_unaligned)
+	{
+	  if (obj->align_mask
+	      ? (inc & (obj->align - 1)) != 0 : (inc % obj->align) != 0)
+	    __bounds_errorf (filename, line, old_ptr, obj,
+			     "%srement size (%d bytes) not a whole multiple"
+			     " of size of elements (%d bytes) in %s",
+			     inc >= 0 ? "inc" : "dec", abs (inc), obj->align,
+			     operation);
+	  else if (pointer_not_aligned (old_ptr, obj))
+	    __bounds_errorf (filename, line, old_ptr, obj,
+			     "unaligned pointer used in %s", operation);
+	}
+      /* Check the increment or decrement will not overrun the object.  */
+      if (new_ptr < obj->base || new_ptr > obj->extent)
+	{
+	  if (__bounds_warn_illegal)
+	    __bounds_warnf (filename, line, new_ptr, obj,
+			    "created an ILLEGAL pointer in %s", operation);
+	  if (__bounds_oob_pointers)
+	    /* create entry for out of bounds pointer */
+	    new_ptr = __bounds_create_oob_pointer (obj, new_ptr,
+						   filename, line);
+	  else
+	    new_ptr = ILLEGAL;	/* Catch this error later.  */
+	}
+    }
+
+  /* Set the pointer value to the new pointer value, and return the required
+     pointer.  */
+  *ptr_to_ptr = new_ptr;
+  new_ptr = is_post ? old_ptr : new_ptr;
+  if (new_ptr == NULL || new_ptr == ILLEGAL)
+    __bounds_errorf (filename, line, new_ptr, NULL,
+		     "NULL or ILLEGAL pointer used in %s", operation);
+  else if (obj != NULL)
+    {
+      /* If size != inc check the pointer again. This is rare.  */
+      if ((int) size != inc && __bounds_warn_unaligned)
+	{
+	  if (obj->align_mask
+	      ? (size & (obj->align - 1)) != 0 : (size % obj->align) != 0)
+	    __bounds_errorf (filename, line, new_ptr, obj,
+			     "size of pointer (%d bytes) not a whole"
+			     " multiple of size of elements (%d bytes)"
+			     " in %s", size, obj->align, operation);
+	  else if (pointer_not_aligned (new_ptr, obj))
+	    __bounds_errorf (filename, line, new_ptr, obj,
+			     "unaligned pointer used in %s", operation);
+	}
+      if ((char *) new_ptr < (char *) obj->base
+	  || (char *) new_ptr + size > (char *) obj->extent)
+	__bounds_errorf (filename, line, new_ptr, obj,
+			 "created an ILLEGAL pointer in %s", operation);
+    }
+  return new_ptr;
+}
+
+__inline__ void *
+__bounds_check_ptr_postinc_ref (object * obj, void **ptr_to_ptr, int inc,
+				size_t size, const char *filename, int line)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_ptr_postinc;
+#endif
+
+  if (__bounds_debug_no_checking)
+    {
+      void *result = *ptr_to_ptr;
+      char *tmp = (char *)ptr_to_ptr;
+      *tmp += inc;
+      return result;
+    }
+#if DEBUG_FEATURES
+  if (__bounds_debug_print_calls)
+    printf ("__bounds_check_ptr_postinc_ref "
+	    "(p=%p, inc=%d, sz=%u, file=\"%s\", ln=%d)\n",
+	    *ptr_to_ptr, inc, size, filename, line);
+#endif
+
+  return check_inc_or_dec_ref (obj, ptr_to_ptr, inc, size, 1,
+			       "postincrement (*p++)", filename, line);
+}
+
+__inline__ void *
+__bounds_check_ptr_preinc_ref (object * obj, void **ptr_to_ptr, int inc,
+			       size_t size, const char *filename, int line)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_ptr_preinc;
+#endif
+
+  if (__bounds_debug_no_checking)
+    return (*(char **) ptr_to_ptr) += inc;
+#if DEBUG_FEATURES
+  if (__bounds_debug_print_calls)
+    printf ("__bounds_check_ptr_preinc_ref "
+	    "(p=%p, inc=%d, sz=%u, file=\"%s\", ln=%d)\n",
+	    *ptr_to_ptr, inc, size, filename, line);
+#endif
+
+  return check_inc_or_dec_ref (obj, ptr_to_ptr, inc, size, 0,
+			       "preincrement (*++p)", filename, line);
+}
+
+__inline__ void *
+__bounds_check_ptr_postdec_ref (object * obj, void **ptr_to_ptr, int inc,
+				size_t size, const char *filename, int line)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_ptr_postdec;
+#endif
+
+  if (__bounds_debug_no_checking)
+    {
+      void *result = *ptr_to_ptr;
+      char *tmp = (char *)ptr_to_ptr;
+      *tmp -= inc;
+      return result;
+    }
+#if DEBUG_FEATURES
+  if (__bounds_debug_print_calls)
+    printf ("__bounds_check_ptr_postdec_ref "
+	    "(p=%p, inc=%d, sz=%u, file=\"%s\", ln=%d)\n",
+	    *ptr_to_ptr, inc, size, filename, line);
+#endif
+
+  return check_inc_or_dec_ref (obj, ptr_to_ptr, -inc, size, 1,
+			       "postdecrement (*p--)", filename, line);
+}
+
+__inline__ void *
+__bounds_check_ptr_predec_ref (object * obj, void **ptr_to_ptr, int inc,
+			       size_t size, const char *filename, int line)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_ptr_predec;
+#endif
+
+  if (__bounds_debug_no_checking)
+    return (*(char **) ptr_to_ptr) -= inc;
+#if DEBUG_FEATURES
+  if (__bounds_debug_print_calls)
+    printf ("__bounds_check_ptr_predec_ref "
+	    "(p=%p, inc=%d, sz=%u, file=\"%s\", ln=%d)\n",
+	    *ptr_to_ptr, inc, size, filename, line);
+#endif
+
+  return check_inc_or_dec_ref (obj, ptr_to_ptr, -inc, size, 0,
+			       "predecrement (*--p)", filename, line);
+}
+
+void *
+__bounds_check_ptr_postinc_ref_obj (void **ptr_to_ptr, int inc,
+				    size_t size, const char *filename,
+				    int line)
+{
+  return __bounds_check_ptr_postinc_ref (__bounds_find_object (*ptr_to_ptr),
+					 ptr_to_ptr, inc, size, filename,
+					 line);
+}
+
+void *
+__bounds_check_ptr_preinc_ref_obj (void **ptr_to_ptr, int inc,
+				   size_t size, const char *filename,
+				   int line)
+{
+  return __bounds_check_ptr_preinc_ref (__bounds_find_object (*ptr_to_ptr),
+					ptr_to_ptr, inc, size, filename,
+					line);
+}
+
+void *
+__bounds_check_ptr_postdec_ref_obj (void **ptr_to_ptr, int inc,
+				    size_t size, const char *filename,
+				    int line)
+{
+  return __bounds_check_ptr_postdec_ref (__bounds_find_object (*ptr_to_ptr),
+					 ptr_to_ptr, inc, size, filename,
+					 line);
+}
+
+void *
+__bounds_check_ptr_predec_ref_obj (void **ptr_to_ptr, int inc,
+				   size_t size, const char *filename,
+				   int line)
+{
+  return __bounds_check_ptr_predec_ref (__bounds_find_object (*ptr_to_ptr),
+					ptr_to_ptr, inc, size, filename,
+					line);
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/check.h gcc-4.0.2/gcc/bounds/lib/check.h
--- gcc-4.0.2.org/gcc/bounds/lib/check.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/check.h	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,62 @@
+/* Bounds Checking for GCC.
+   Written by Richard W.M. Jones
+
+   File:
+  	lib/check.h
+   Summary:
+  	Functions are provided here to guess whether an object is
+  	unchecked or not.
+   Other notes:
+  	
+   Author      	Date		Notes
+   RWMJ		13/7/95		Initial implementation.
+*/
+
+#ifndef _CHECK_H_
+#define _CHECK_H_
+
+/* We can not find all unchecked objects. For example we can not detect
+   calls to mmap, brk or sbrk. We simply check if the pointer is
+   below or above the stack pointer.  */
+
+/* This is the generic method that will work on most 32-bit and 64-bit
+   architectures. (Note: 64-bit support is *untested*, since we have no
+   Alphas around here).  */
+#define DECLARE_SP int i; register void *sp = &i
+#define POINTER_ON_STACK(p) ((void *)sp <= (p) && (p) <= (void *)-1)
+
+/* We have looked up a pointer in the tree and not found it. Give it
+   a second chance here, where we may determine that it is an unchecked
+   static object. We give a warning if it is.
+   Similarly for unchecked stack objects, we can test if the pointer is
+   between SP and the top of the stack.  */
+
+static __inline__ void
+maybe_is_unchecked (void *pointer, const char *filename,
+		    int line, const char *function)
+{
+  DECLARE_SP;
+
+  if (POINTER_ON_STACK (pointer))
+    {
+#if COLLECT_STATS
+      ++__bounds_stats_unchecked_stack;
+#endif
+      if (__bounds_debug_no_checking == 0 && __bounds_warn_unchecked_stack)
+	__bounds_warning (filename, line, function,
+			  "unchecked stack object used at address %p",
+			  pointer);
+    }
+  else
+    {
+#if COLLECT_STATS
+      ++__bounds_stats_unchecked_static;
+#endif
+      if (__bounds_debug_no_checking == 0 && __bounds_warn_unchecked_statics)
+	__bounds_warning (filename, line, function,
+			  "unchecked static object used at address %p",
+			  pointer);
+    }
+}
+
+#endif /* _CHECK_H_ */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/error.c gcc-4.0.2/gcc/bounds/lib/error.c
--- gcc-4.0.2.org/gcc/bounds/lib/error.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/error.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,280 @@
+/* Bounds Checking for GCC.
+   Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.	
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   File:
+  	lib/error.c
+   Summary:
+  	Error reporting functions for the bounds checking library.
+   Other notes:
+  	
+   Author      	Date		Notes
+   RWMJ		5/12/94		Initial implementation.
+   RWMJ		10/1/96		New format for errors with `file:line'
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdarg.h>
+
+#include "bounds-lib.h"
+
+#if defined(__BOUNDS_CHECKING_ON)
+#error "This file must not be compiled with bounds checking enabled."
+#endif
+
+/* Print something about this object (if obj != NULL).  */
+
+static __inline__ const char *
+sclass_name (object * obj)
+{
+  switch (obj->sclass)
+    {
+    case obj_sclass_static:
+      return "static";
+    case obj_sclass_external:
+      return "external";
+    case obj_sclass_stack:
+      return "stack";
+    case obj_sclass_heap:
+      return "heap";
+    }
+  return NULL;
+}
+
+static void
+print_object (const char *filename, int line, object * obj)
+{
+  if (!obj)
+    return;
+
+  printf ("%s:%d:  Object `%s':\n"
+	  "%s:%d:    Address in memory:    %p .. %p\n"
+	  "%s:%d:    Size:                 %u bytes\n"
+	  "%s:%d:    Element size:         %u bytes\n"
+	  "%s:%d:    Number of elements:   %d\n",
+	  filename, line, obj->name ? obj->name : "(unnamed)",
+	  filename, line, obj->base, (char *) obj->extent - 1,
+	  filename, line, obj->size,
+	  filename, line, obj->align, filename, line, obj->size / obj->align);
+  if (obj->filename && obj->line > 0)
+    printf ("%s:%d:    Created at:           %s, line %d\n",
+	    filename, line, obj->filename, obj->line);
+  printf ("%s:%d:    Storage class:        %s\n",
+	  filename, line, sclass_name (obj));
+}
+
+/* Report errors involving single pointers.  */
+
+void
+__bounds_error (const char *message, const char *filename, int line,
+		void *pointer, object * obj)
+{
+  void *temp;
+
+  if (filename == NULL)
+    {
+      filename = "<unknown>";
+      line = 0;
+    }
+  if (__bounds_oob_pointers)
+    {
+      temp = pointer;
+      __bounds_setup_oob_pointer (&obj, &temp, filename, line);
+      if (temp != pointer)
+	pointer = ILLEGAL;
+    }
+  printf ("%s:%d:Bounds error: %s.\n", filename, line, message);
+  printf ("%s:%d:  Pointer value: %p\n", filename, line, pointer);
+  print_object (filename, line, obj);
+
+  __bounds_breakpoint ();
+  if (!__bounds_never_fatal)
+    ABORT ();
+}
+
+/* Report errors involving single pointers.  */
+
+void
+__bounds_error_size (const char *message, const char *filename, int line,
+		     void *pointer, int size, object * obj)
+{
+  if (filename == NULL)
+    {
+      filename = "<unknown>";
+      line = 0;
+    }
+  printf ("%s:%d:Bounds error: %s.\n", filename, line, message);
+  printf ("%s:%d:  Pointer value: %p, Size: %d\n", filename, line,
+	  pointer, size);
+  print_object (filename, line, obj);
+
+  __bounds_breakpoint ();
+  if (!__bounds_never_fatal)
+    ABORT ();
+}
+
+/* Report errors involving two pointers.  */
+
+void
+__bounds_error2 (const char *message, const char *filename, int line,
+		 void *pointer1, void *pointer2, object * obj1, object * obj2)
+{
+  void *temp;
+
+  if (filename == NULL)
+    {
+      filename = "<unknown>";
+      line = 0;
+    }
+  if (__bounds_oob_pointers)
+    {
+      temp = pointer1;
+      __bounds_setup_oob_pointer (&obj1, &temp, filename, line);
+      if (temp != pointer1)
+	pointer1 = ILLEGAL;
+    }
+  if (__bounds_oob_pointers)
+    {
+      temp = pointer2;
+      __bounds_setup_oob_pointer (&obj2, &temp, filename, line);
+      if (temp != pointer2)
+	pointer2 = ILLEGAL;
+    }
+  printf ("%s:%d:Bounds error: %s.\n", filename, line, message);
+  printf ("%s:%d:  Left pointer value: %p\n", filename, line, pointer1);
+  print_object (filename, line, obj1);
+  printf ("%s:%d:  Right pointer value: %p\n", filename, line, pointer2);
+  print_object (filename, line, obj2);
+
+  __bounds_breakpoint ();
+  if (!__bounds_never_fatal)
+    ABORT ();
+}
+
+/* Report errors with optional format string.  */
+
+void
+__bounds_errorf (const char *filename, int line,
+		 void *pointer, object * obj, const char *format, ...)
+{
+  void *temp;
+  va_list args;
+
+  if (filename == NULL)
+    {
+      filename = "<unknown>";
+      line = 0;
+    }
+  if (__bounds_oob_pointers)
+    {
+      temp = pointer;
+      __bounds_setup_oob_pointer (&obj, &temp, filename, line);
+      if (temp != pointer)
+	pointer = ILLEGAL;
+    }
+  printf ("%s:%d:Bounds error: ", filename, line);
+  va_start (args, format);
+  vprintf (format, args);
+  va_end (args);
+  printf (".\n");
+  printf ("%s:%d:  Pointer value: %p\n", filename, line, pointer);
+  print_object (filename, line, obj);
+
+  __bounds_breakpoint ();
+  if (!__bounds_never_fatal)
+    ABORT ();
+}
+
+/* Function for reporting internal errors in the library.  */
+
+void
+__bounds_internal_error (const char *message, const char *filename, int line)
+{
+  if (filename == NULL)
+    {
+      filename = "<unknown>";
+      line = 0;
+    }
+  printf ("%s:%d:Internal error: %s.\n", filename, line, message);
+
+  ABORT ();
+}
+
+/* Give a warning message as appropriate.  */
+
+void
+__bounds_warning (const char *filename, int line, const char *function,
+		  const char *format, ...)
+{
+  va_list args;
+
+  if (filename == NULL)
+    {
+      filename = "<unknown>";
+      line = 0;
+    }
+  if (function)
+    printf ("%s:%d:In function %s,\n", filename, line, function);
+  printf ("%s:%d:Bounds warning: ", filename, line);
+  va_start (args, format);
+  vprintf (format, args);
+  va_end (args);
+  printf (".\n");
+}
+
+/* Report warnings involving single pointers.  */
+
+void
+__bounds_warn1 (const char *message, const char *filename, int line,
+		void *pointer, object * obj)
+{
+  if (filename == NULL)
+    {
+      filename = "<unknown>";
+      line = 0;
+    }
+  printf ("%s:%d:Bounds warning: %s.\n", filename, line, message);
+  printf ("%s:%d:  Pointer value: %p\n", filename, line, pointer);
+  print_object (filename, line, obj);
+
+  __bounds_breakpoint ();
+}
+
+/* Report warnings with optional format string.  */
+
+void
+__bounds_warnf (const char *filename, int line,
+		void *pointer, object * obj, const char *format, ...)
+{
+  va_list args;
+
+  if (filename == NULL)
+    {
+      filename = "<unknown>";
+      line = 0;
+    }
+  printf ("%s:%d:Bounds warning: ", filename, line);
+  va_start (args, format);
+  vprintf (format, args);
+  va_end (args);
+  printf (".\n");
+  printf ("%s:%d:  Pointer value: %p\n", filename, line, pointer);
+  print_object (filename, line, obj);
+
+  __bounds_breakpoint ();
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/exstatics.c gcc-4.0.2/gcc/bounds/lib/exstatics.c
--- gcc-4.0.2.org/gcc/bounds/lib/exstatics.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/exstatics.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,117 @@
+/* Bounds Checking for GCC.
+   Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   File:
+  	lib/exstatics.c
+   Summary:
+  	Add a lot of external statics to the object tree in one go, making
+  	suitable checks along the way.
+   Other notes:
+  	Use this in conjunction with the grab-statics util. in the tools
+  	directory.
+   Author      	Date		Notes
+   RWMJ		5/9/95		Initial implementation.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "bounds-lib.h"
+
+#if defined(__BOUNDS_CHECKING_ON)
+#error "This file must not be compiled with bounds checking enabled."
+#endif
+
+#define DUMP 0			/* Dump a list of the objects in order (for dbg).  */
+
+static int
+compare_entries (const void *p1, const void *p2)
+{
+  external_statics_table *entry1 = *(external_statics_table **) p1;
+  external_statics_table *entry2 = *(external_statics_table **) p2;
+
+  return (char *) entry1->address - (char *) entry2->address;
+}
+
+void
+__bounds_add_static_objects_table (external_statics_table * table)
+{
+  int len, i;
+  external_statics_table **ptrs;
+  void *last_address;
+
+  /* Compute the length of the table.  */
+  for (len = 0; table[len].address != NULL; ++len)
+    ;
+  if (len == 0)
+    return;
+
+  /* Allocate memory for an array of pointers into the table. We will sort
+     the table by swapping these pointers, rather than swapping actual
+     entries in the table. This is more efficient & doesn't cause problems
+     if the table was allocated in r/o memory.
+     N.B. Deliberately allocate a _checked_ heap object here. There is
+     no danger of recursion.  */
+  ptrs = malloc (sizeof (external_statics_table *) * len);
+  if (ptrs == NULL)
+    __bounds_internal_error ("out of memory allocating table",
+			     __FILE__, __LINE__);
+  for (i = 0; i < len; ++i)
+    ptrs[i] = &table[i];
+
+  /* Sort the table into address order.  */
+  qsort (ptrs, len, sizeof (external_statics_table *), compare_entries);
+
+#if DUMP
+  /* Dump the objects for debugging.  */
+  for (i = 0; i < len; ++i)
+    printf ("%p - %p: %s (at %s:%d)\n",
+	    ptrs[i]->address,
+	    (char *) (ptrs[i]->address) + ptrs[i]->size - 1,
+	    ptrs[i]->name, ptrs[i]->filename, ptrs[i]->line);
+#endif
+
+  /* Check that the objects in the table are disjoint.  */
+  last_address = (char *) ptrs[0]->address + ptrs[0]->size;
+  for (i = 1; i < len; ++i)
+    {
+      if (last_address > ptrs[i]->address)
+	{
+	  __bounds_errorf (__FILE__, __LINE__,
+			   NULL, NULL,
+			   "overlapping objects `%s:%s' and `%s:%s'"
+			   " in __bounds_add_static_objects_table",
+			   ptrs[i - 1]->filename,
+			   ptrs[i - 1]->name,
+			   ptrs[i]->filename, ptrs[i]->name);
+	  ABORT ();
+	}
+      last_address = (char *) ptrs[i]->address + ptrs[i]->size;
+    }
+
+  /* Add the objects to the splay tree.  */
+  for (i = 0; i < len; ++i)
+    {
+      external_statics_table *p = ptrs[i];
+
+      __bounds_note_constructed_object (p->address, p->size, p->align,
+					p->filename, p->line, p->name);
+    }
+
+  /* Free up the table.  */
+  free (ptrs);
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/ext-tree.h gcc-4.0.2/gcc/bounds/lib/ext-tree.h
--- gcc-4.0.2.org/gcc/bounds/lib/ext-tree.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/ext-tree.h	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,55 @@
+/* Bounds Checking for GCC.
+   Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.	
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   File:
+  	lib/ext-tree.h
+   Summary:
+  	Describes the external representation of the splay tree used in
+  	the `splaytree.aa' etc. files.
+   Other notes:
+  	
+   Author      	Date		Notes
+   RWMJ		28/5/95		Initial implementation.
+*/
+
+#ifndef _EXT_TREE_H_
+#define _EXT_TREE_H_
+
+struct ext_tree
+{
+  char magic[8];		/* Contains `EXT_TREE_MAGIC'.  */
+  unsigned index;		/* Index of file in time.  */
+  unsigned dump_every;		/* Frequency of dump operations.  */
+  unsigned add_operations;
+  unsigned del_operations;
+  unsigned splay_operations;
+  unsigned look_up_operations;
+  unsigned nlook_up_operations;
+  unsigned splay_steps;
+  unsigned look_up_steps;
+  unsigned nlook_up_steps;
+  unsigned splay_look_up_operations;
+  unsigned splay_look_up_steps;
+  unsigned splay_add_operations;
+  unsigned splay_add_steps;
+  unsigned splay_del_operations;
+  unsigned splay_del_steps;
+};
+
+#define EXT_TREE_MAGIC "STD-003"	/* Magic & version #.  */
+
+#endif /* _EXT_TREE_H_ */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/free.c gcc-4.0.2/gcc/bounds/lib/free.c
--- gcc-4.0.2.org/gcc/bounds/lib/free.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/free.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,212 @@
+/* Free a block of memory allocated by `malloc'.
+   Copyright 1990, 1991, 1992, 1994 Free Software Foundation, Inc.
+		  Written May 1989 by Mike Haertel.
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public License as
+published by the Free Software Foundation; either version 2 of the
+License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with this library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.
+
+   The author may be reached (Email) at the address mike@ai.mit.edu,
+   or (US mail) as Mike Haertel c/o Free Software Foundation.  */
+
+#include "bounds-lib.h"
+
+#ifndef	_MALLOC_INTERNAL
+#define _MALLOC_INTERNAL
+#include <malloc.h>
+#endif
+
+/* Debugging hook for free.  */
+void (*__free_hook) (__ptr_t __ptr);
+
+/* List of blocks allocated by memalign.  */
+struct alignlist *_aligned_blocks = NULL;
+
+/* Return memory to the heap.
+   Like `free' but don't call a __free_hook if there is one.  */
+void
+_free_internal (__ptr_t ptr)
+{
+  int type;
+  __malloc_size_t block, blocks;
+  register __malloc_size_t i;
+  struct list *prev, *next;
+
+  block = BLOCK (ptr);
+
+  type = _heapinfo[block].busy.type;
+  switch (type)
+    {
+    case 0:
+      /* Get as many statistics as early as we can.  */
+      --_chunks_used;
+      _bytes_used -= _heapinfo[block].busy.info.size * BLOCKSIZE;
+      _bytes_free += _heapinfo[block].busy.info.size * BLOCKSIZE;
+
+      /* Find the free cluster previous to this one in the free list.
+         Start searching at the last block referenced; this may benefit
+         programs with locality of allocation.  */
+      i = _heapindex;
+      if (i > block)
+	while (i > block)
+	  i = _heapinfo[i].free.prev;
+      else
+	{
+	  do
+	    i = _heapinfo[i].free.next;
+	  while (i > 0 && i < block);
+	  i = _heapinfo[i].free.prev;
+	}
+
+      /* Determine how to link this block into the free list.  */
+      if (block == i + _heapinfo[i].free.size)
+	{
+	  /* Coalesce this block with its predecessor.  */
+	  _heapinfo[i].free.size += _heapinfo[block].busy.info.size;
+	  block = i;
+	}
+      else
+	{
+	  /* Really link this block back into the free list.  */
+	  _heapinfo[block].free.size = _heapinfo[block].busy.info.size;
+	  _heapinfo[block].free.next = _heapinfo[i].free.next;
+	  _heapinfo[block].free.prev = i;
+	  _heapinfo[i].free.next = block;
+	  _heapinfo[_heapinfo[block].free.next].free.prev = block;
+	  ++_chunks_free;
+	}
+
+      /* Now that the block is linked in, see if we can coalesce it
+         with its successor (by deleting its successor from the list
+         and adding in its size).  */
+      if (block + _heapinfo[block].free.size == _heapinfo[block].free.next)
+	{
+	  _heapinfo[block].free.size
+	    += _heapinfo[_heapinfo[block].free.next].free.size;
+	  _heapinfo[block].free.next
+	    = _heapinfo[_heapinfo[block].free.next].free.next;
+	  _heapinfo[_heapinfo[block].free.next].free.prev = block;
+	  --_chunks_free;
+	}
+
+      /* Now see if we can return stuff to the system.  */
+      blocks = _heapinfo[block].free.size;
+      if (blocks >= FINAL_FREE_BLOCKS && block + blocks == _heaplimit
+	  && (*__morecore) (0) == ADDRESS (block + blocks))
+	{
+	  register __malloc_size_t bytes = blocks * BLOCKSIZE;
+	  _heaplimit -= blocks;
+	  (*__morecore) (-bytes);
+	  _heapinfo[_heapinfo[block].free.prev].free.next
+	    = _heapinfo[block].free.next;
+	  _heapinfo[_heapinfo[block].free.next].free.prev
+	    = _heapinfo[block].free.prev;
+	  block = _heapinfo[block].free.prev;
+	  --_chunks_free;
+	  _bytes_free -= bytes;
+	}
+
+      /* Set the next search to begin at this block.  */
+      _heapindex = block;
+      break;
+
+    default:
+      /* Do some of the statistics.  */
+      --_chunks_used;
+      _bytes_used -= 1 << type;
+      ++_chunks_free;
+      _bytes_free += 1 << type;
+
+      /* Get the address of the first free fragment in this block.  */
+      prev = (struct list *) ((char *) ADDRESS (block) +
+			      (_heapinfo[block].busy.info.frag.
+			       first << type));
+
+      if (_heapinfo[block].busy.info.frag.nfree ==
+	  (__malloc_size_t) ((BLOCKSIZE >> type) - 1))
+	{
+	  /* If all fragments of this block are free, remove them
+	     from the fragment list and free the whole block.  */
+	  next = prev;
+	  for (i = 1; i < (__malloc_size_t) (BLOCKSIZE >> type); ++i)
+	    next = next->next;
+	  prev->prev->next = next;
+	  if (next != NULL)
+	    next->prev = prev->prev;
+	  _heapinfo[block].busy.type = 0;
+	  _heapinfo[block].busy.info.size = 1;
+
+	  /* Keep the statistics accurate.  */
+	  ++_chunks_used;
+	  _bytes_used += BLOCKSIZE;
+	  _chunks_free -= BLOCKSIZE >> type;
+	  _bytes_free -= BLOCKSIZE;
+
+	  __bounds_free (ADDRESS (block));
+	}
+      else if (_heapinfo[block].busy.info.frag.nfree != 0)
+	{
+	  /* If some fragments of this block are free, link this
+	     fragment into the fragment list after the first free
+	     fragment of this block. */
+	  next = (struct list *) ptr;
+	  next->next = prev->next;
+	  next->prev = prev;
+	  prev->next = next;
+	  if (next->next != NULL)
+	    next->next->prev = next;
+	  ++_heapinfo[block].busy.info.frag.nfree;
+	}
+      else
+	{
+	  /* No fragments of this block are free, so link this
+	     fragment into the fragment list and announce that
+	     it is the first free fragment of this block. */
+	  prev = (struct list *) ptr;
+	  _heapinfo[block].busy.info.frag.nfree = 1;
+	  _heapinfo[block].busy.info.frag.first = (unsigned long int)
+	    ((unsigned long int) ((char *) ptr - (char *) NULL)
+	     % BLOCKSIZE >> type);
+	  prev->next = _fraghead[type].next;
+	  prev->prev = &_fraghead[type];
+	  prev->prev->next = prev;
+	  if (prev->next != NULL)
+	    prev->next->prev = prev;
+	}
+      break;
+    }
+}
+
+/* Return memory to the heap.  */
+void
+__bounds_free (__ptr_t ptr)
+{
+  register struct alignlist *l;
+
+  if (ptr == NULL)
+    return;
+
+  for (l = _aligned_blocks; l != NULL; l = l->next)
+    if (l->aligned == ptr)
+      {
+	l->aligned = NULL;	/* Mark the slot in the list as free.  */
+	ptr = l->exact;
+	break;
+      }
+
+  if (__free_hook != NULL)
+    (*__free_hook) (ptr);
+  else
+    _free_internal (ptr);
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/functions.c gcc-4.0.2/gcc/bounds/lib/functions.c
--- gcc-4.0.2.org/gcc/bounds/lib/functions.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/functions.c	2005-09-29 18:00:22.000000000 +0200
@@ -0,0 +1,717 @@
+/* Bounds Checking for GCC.
+   Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   File:
+  	lib/functions.c
+   Summary:
+  	Deal with pushing and popping of function contexts and parameters
+  	of those function contexts.
+   Other notes:
+  	
+   Author      	Date		Notes
+   RWMJ		6/3/95		Initial implementation.
+   RWMJ		3/4/95		Some optimizations.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "bounds-lib.h"
+
+#include "mutex.h"		/* for 'enter|leave_critical_section'  */
+#include "check.h"
+
+#if defined(__BOUNDS_CHECKING_ON)
+#error "This file must not be compiled with bounds checking enabled."
+#endif
+
+cur_context *__bounds_function_context = NULL;
+static cur_context *__bounds_function_list = NULL;
+
+/* Helper functions that allocate and deallocate function contexts.
+   We used to allocate and free them immediately, but that was
+   quite inefficient, so now we allocate blocks of function contexts
+   and never free them. (RWMJ, 3/4/95).  */
+
+static __inline__ cur_context *
+get_context_no_lock (void)
+{
+  int current_thread;
+  cur_context *current_context;
+
+  if (__bounds_function_thread)
+    current_thread = (*__bounds_function_thread) ();
+  else
+    current_thread = 0;
+  current_context = __bounds_function_context;
+  if (current_context && current_context->current_thread != current_thread)
+    {
+      current_context->func_context.no_checking = __bounds_debug_no_checking;
+      current_context = __bounds_function_list;
+      while (current_context)
+	{
+	  if (current_context->current_thread == current_thread)
+	    {
+              __bounds_debug_no_checking = current_context->func_context.no_checking;
+	      break;
+	    }
+	  current_context = current_context->next;
+	}
+      __bounds_function_context = current_context;
+    }
+  if (current_context == NULL)
+    {
+      current_context = __bounds_malloc (sizeof (cur_context));
+      if (!current_context)
+	__bounds_internal_error ("out of memory allocating a block"
+				 " of function contexts", __FILE__, __LINE__);
+      current_context->current_thread = current_thread;
+      current_context->nesting_nr = 0;
+      current_context->func_context.next =
+	current_context->func_context.prev = &current_context->func_context;
+      current_context->hist_func = NULL;
+      current_context->last_end = NULL;
+      current_context->func_context.no_checking = 0;
+      current_context->next = __bounds_function_list;
+      current_context->func_context.no_checking = 0;
+      __bounds_debug_no_checking = 0;
+      __bounds_function_list = current_context;
+      __bounds_function_context = current_context;
+    }
+  return current_context;
+}
+
+static __inline__ cur_context *
+get_context (void)
+{
+  cur_context *current_context;
+  sigset_t old_mask;
+
+  enter_critical_section (&old_mask);
+  current_context = get_context_no_lock ();
+  leave_critical_section (&old_mask);
+  return current_context;
+}
+
+/* Return a pointer to a thread safe strtok pointer.  */
+
+char **
+__bounds_strtok_last_end (void)
+{
+  cur_context *cc = get_context ();
+  return &cc->last_end;
+}
+
+static __inline__ function_context *
+allocate_new_context (cur_context * cc)
+{
+  function_context *fc;
+  sigset_t old_mask;
+
+  if (cc->hist_func)
+    {
+      fc = cc->hist_func;
+      cc->hist_func = fc->next;
+    }
+  else
+    {
+      enter_critical_section (&old_mask);
+      fc = __bounds_malloc (sizeof (function_context));
+      leave_critical_section (&old_mask);
+      if (fc == NULL)
+	__bounds_internal_error
+	  ("out of memory allocating a function contexts", __FILE__,
+	   __LINE__);
+      /* Mark a function context so we can find it when deleting a spurious
+         stack object.  */
+      fc->parms.base = fc->stack.base = ILLEGAL;
+    }
+
+  fc->next = cc->func_context.next;
+  fc->prev = &cc->func_context;
+  fc->next->prev = fc;
+  cc->func_context.next = fc;
+
+  return fc;
+}
+
+static __inline__ void
+remove_this_context (cur_context * cc, function_context * fc)
+{
+  /* Never realy free function context. Put it in a history list.  */
+  fc->prev->next = fc->next;
+  fc->next->prev = fc->prev;
+  fc->next = cc->hist_func;
+  cc->hist_func = fc;
+}
+
+/* Pop out of a function context.  */
+
+static __inline__ void
+__bounds_internal_pop_function (const char *name, int nesting_nr)
+{
+  int current_nesting_nr;
+  const char *context_name;
+  cur_context *cc;
+  function_context *fc;
+  object *obj, *nobj;
+
+  cc = get_context_no_lock ();
+  for (;;)
+    {
+      fc = cc->func_context.next;
+      if (fc == &cc->func_context)
+	__bounds_internal_error ("too many function context pops",
+				 __FILE__, __LINE__);
+      current_nesting_nr = fc->nesting_nr;
+      context_name = fc->name;
+      /* Delete all the parameters to this function.  */
+      obj = fc->parms.next;
+      while (obj != &fc->parms)
+	{
+	  nobj = obj->next;
+	  __bounds_internal_delete_stack_object (obj, -1);
+	  obj = nobj;
+	}
+      /* Delete all the stack parameters in this function.  */
+      obj = fc->stack.next;
+      while (obj != &fc->stack)
+	{
+	  nobj = obj->next;
+	  __bounds_internal_delete_stack_object (obj, -1);
+	  obj = nobj;
+	}
+
+      /* Call the alloca module to (if necessary) delete items from the
+         alloca stack. Only do this if `alloca_stack' is non-NULL to try
+         to avoid the function call.  */
+      if (fc->alloca_stack != NULL)
+	__bounds_alloca_free (fc->alloca_stack);
+
+      /* Delete the function_context structure.  */
+      remove_this_context (cc, fc);
+      if (nesting_nr == current_nesting_nr)
+	break;
+    }
+  cc->nesting_nr = current_nesting_nr;
+
+  /* Check that the name passed matches the name pushed into. If not, this
+     is probably a compiler error, else longjmp was used.  */
+  if (context_name != name && __bounds_strcmp (context_name, name) != 0)
+    __bounds_internal_error ("popped out of a mismatched function context",
+			     __FILE__, __LINE__);
+
+  /* If we aren't checking bounds in this function context, switch off
+     bounds checking now.  */
+  __bounds_debug_no_checking = cc->func_context.next->no_checking;
+}
+
+/* Add a stack object to the function list nesting_nr.
+   This call is made when we are inside a critical section.  */
+
+void
+__bounds_add_function_object (object * obj, int nesting_nr)
+{
+  cur_context *cc = get_context_no_lock ();
+  function_context *fc = cc->func_context.next;
+
+  if (fc == &cc->func_context)
+    __bounds_internal_error ("__bounds_add_function_object called when"
+			     " not in a function context",
+			     __FILE__, __LINE__);
+
+  /* If not at correct level pop context until we are.  */
+  while (fc->nesting_nr != nesting_nr)
+    {
+      __bounds_internal_pop_function (fc->name, fc->nesting_nr);
+      fc = cc->func_context.next;
+    }
+
+  if (fc == &cc->func_context)
+    __bounds_internal_error ("__bounds_add_function_object called when"
+			     " not in a function context",
+			     __FILE__, __LINE__);
+
+  /* Make a reverse list. This will make remove_function_object faster.  */
+  obj->next = fc->stack.next;
+  fc->stack.next = obj;
+}
+
+/* Delete a stack object of the function list nesting_nr.
+   This call is made when we are inside a critical section.  */
+
+int
+__bounds_remove_function_object (object * obj, int nesting_nr)
+{
+  cur_context *cc = get_context_no_lock ();
+  function_context *fc = cc->func_context.next;
+  object *nobj, *lobj;
+
+  if (fc == &cc->func_context)
+    __bounds_internal_error ("__bounds_remove_function_object called when"
+			     " not in a function context",
+			     __FILE__, __LINE__);
+
+  /* If not at correct level pop context until we are.  */
+  while (fc->nesting_nr != nesting_nr)
+    {
+      __bounds_internal_pop_function (fc->name, fc->nesting_nr);
+      fc = cc->func_context.next;
+    }
+
+  if (fc == &cc->func_context)
+    __bounds_internal_error ("__bounds_remove_function_object called when"
+			     " not in a function context",
+			     __FILE__, __LINE__);
+
+  /* Walk through the list. It is most likely that the first
+     object is our target cause we add them in reverse order
+     in the list.  */
+  nobj = fc->stack.next;
+  if (obj == nobj)
+    {
+      fc->stack.next = nobj->next;
+    }
+  else
+    {
+      lobj = nobj;
+      nobj = nobj->next;
+      while (nobj != &fc->stack)
+	{
+	  if (obj == nobj)
+	    {
+	      lobj->next = nobj->next;
+	      return 1;
+	    }
+	  lobj = nobj;
+	  nobj = nobj->next;
+	}
+      nobj = fc->parms.next;
+      if (obj == nobj)
+	{
+	  fc->parms.next = nobj->next;
+	}
+      else
+	{
+	  lobj = nobj;
+	  nobj = nobj->next;
+	  while (nobj != &fc->parms)
+	    {
+	      if (obj == nobj)
+		{
+		  lobj->next = nobj->next;
+		  return 1;
+		}
+	      lobj = nobj;
+	      nobj = nobj->next;
+	    }
+	  return 0;
+	}
+    }
+  return 1;
+}
+
+/* Delete a stack object of the function context below the
+   current function context.
+   This call is made when we are inside a critical section.  */
+
+int
+__bounds_remove_lower_function_object (function_context *fc, object * obj)
+{
+  object *nobj, *lobj;
+
+  /* Walk through the list. It is most likely that the first
+     object is our target cause we add them in reverse order
+     in the list.  */
+  nobj = fc->stack.next;
+  if (obj == nobj)
+    {
+      fc->stack.next = nobj->next;
+    }
+  else
+    {
+      lobj = nobj;
+      nobj = nobj->next;
+      while (nobj != &fc->stack)
+	{
+	  if (obj == nobj)
+	    {
+	      lobj->next = nobj->next;
+	      return 1;
+	    }
+	  lobj = nobj;
+	  nobj = nobj->next;
+	}
+      nobj = fc->parms.next;
+      if (obj == nobj)
+	{
+	  fc->parms.next = nobj->next;
+	}
+      else
+	{
+	  lobj = nobj;
+	  nobj = nobj->next;
+	  while (nobj != &fc->parms)
+	    {
+	      if (obj == nobj)
+		{
+		  lobj->next = nobj->next;
+		  return 1;
+		}
+	      lobj = nobj;
+	      nobj = nobj->next;
+	    }
+          return 0;
+	}
+    }
+  return 1;
+}
+
+/* Delete a function context when a spurious stack object is found. See
+   also function __bounds_internal_add_stack_object in objects.c
+   This call is made when we are inside a critical section.  */
+
+void
+__bounds_remove_function_context (object * obj, int nesting_nr)
+{
+  cur_context *cc;
+  function_context *fc;
+  object *nobj = obj;
+
+  /* Find current function context.  */
+  while (nobj->base != ILLEGAL)
+    nobj = nobj->next;
+  cc = (cur_context *) nobj->parent;
+  fc = (function_context *) nobj->left;
+
+  if (fc->nesting_nr == nesting_nr
+      && __bounds_remove_function_object (obj, nesting_nr))
+    {
+      __bounds_internal_delete_stack_object (obj, -1);
+      return;
+    }
+  if ((unsigned)fc->nesting_nr < (unsigned)nesting_nr
+      && __bounds_remove_lower_function_object (fc, obj))
+    {
+      __bounds_internal_delete_stack_object (obj, -1);
+      return;
+    }
+#if DEBUG_FEATURES
+  if (__bounds_debug_print_calls)
+    printf ("__bounds_remove_function_context (name=\"%s\", nesting_nr=%d)\n",
+	    fc->name, fc->nesting_nr);
+#endif
+
+  /* Delete all the parameters to this function.  */
+  obj = fc->parms.next;
+  while (obj != &fc->parms)
+    {
+      nobj = obj->next;
+      __bounds_internal_delete_stack_object (obj, -1);
+      obj = nobj;
+    }
+
+  /* Delete all the stack parameters in this function.  */
+  obj = fc->stack.next;
+  while (obj != &fc->stack)
+    {
+      nobj = obj->next;
+      __bounds_internal_delete_stack_object (obj, -1);
+      obj = nobj;
+    }
+
+  /* Delete alloca objects.  */
+  if (fc->alloca_stack != NULL)
+    __bounds_alloca_free (fc->alloca_stack);
+
+  if (cc->func_context.next == fc)
+    cc->nesting_nr = fc->nesting_nr;
+
+  remove_this_context (cc, fc);
+}
+
+/* Push into a function context.  */
+
+int
+__bounds_push_function (const char *name, int in_main,
+			const char *filename, int line)
+{
+  cur_context *cc = get_context ();
+  function_context *fc;
+
+#if COLLECT_STATS
+  ++__bounds_stats_push_function;
+#endif
+#if DEBUG_FEATURES
+  if (__bounds_debug_print_function)
+    printf ("__bounds_push_function"
+	    "(thread=%d, name=\"%s\", main=%d, file=\"%s\", ln=%d), nesting_nr=%d\n",
+	    cc->current_thread, name, in_main, filename, line,
+	    cc->nesting_nr);
+#endif
+
+  if (in_main)
+    {
+      static int count_main = 0;
+
+      /* This function is supposedly `main'. `main' should occur once and only
+         once. ANSI doesn't allow `main' to be called recursively. Notice that
+         `main' is not usually the first function to be called. That is usually
+         one of our global constructor functions.  */
+      count_main++;
+
+      if (count_main > 1)
+	{
+	  in_main = 0;		/* Not really in main, if called recursively.  */
+	  if (count_main == 2)
+	    __bounds_warning (filename, line, NULL,
+			      "ANSI does not allow main ()"
+			      " to be called recursively");
+	}
+    }
+
+  /* Allocate space for the function_context structure plus all the
+     arguments we're going to get.  */
+  fc = allocate_new_context (cc);
+
+  /* Set the context variables as appropriate.  */
+  fc->nesting_nr = cc->nesting_nr;
+  cc->nesting_nr++;
+  fc->in_main = in_main;
+  fc->no_checking = 0;
+  fc->name = name;
+  fc->filename = filename;
+  fc->line = line;
+  fc->parms.next = &fc->parms;
+  fc->stack.next = &fc->stack;
+  fc->alloca_stack = NULL;
+  /* Make base special so we can find the current context and 
+     function context pointers when we have to delete a stack object.  */
+  fc->parms.parent = fc->stack.parent = (object *) cc;
+  fc->parms.left = fc->stack.left = (object *) fc;
+
+  /* Switch on checking for this function by default. It may be switched off
+     by a call to `__bounds_no_checking_in_this_function'.  */
+  __bounds_debug_no_checking = 0;
+  return fc->nesting_nr;
+}
+
+/* Pop out of a function context.  */
+
+void
+__bounds_pop_function (const char *name, int nesting_nr)
+{
+  sigset_t old_mask;
+
+#if COLLECT_STATS
+  ++__bounds_stats_pop_function;
+#endif
+
+
+#if DEBUG_FEATURES
+  if (__bounds_debug_print_function)
+    {
+      cur_context *cc = get_context ();
+
+      printf
+	("__bounds_pop_function (thread=%d, name=\"%s\", nesting_nr=%d)\n",
+	 cc->current_thread, name, nesting_nr);
+    }
+#endif
+
+  enter_critical_section (&old_mask);
+  __bounds_internal_pop_function (name, nesting_nr);
+  leave_critical_section (&old_mask);
+}
+
+/* Add a parameter. This function may be called repeatedly as we
+   enter a function context.  */
+
+void
+__bounds_add_param_object (void *ptr, size_t size, size_t align,
+			   const char *filename, int line, const char *name,
+			   int nesting_nr)
+{
+  sigset_t old_mask;
+  cur_context *cc;
+  function_context *fc;
+  object *obj;
+
+#if COLLECT_STATS
+  ++__bounds_stats_param_function;
+#endif
+
+#if DEBUG_FEATURES
+  if (__bounds_debug_print_calls)
+    printf ("__bounds_add_param_object"
+	    "(p=%p, sz=%u, align=%u, file=\"%s\", ln=%d, name=\"%s\""
+	    " nesting_nr=%d)\n",
+	    ptr, size, align, filename, line, name, nesting_nr);
+#endif
+
+  enter_critical_section (&old_mask);
+  cc = get_context_no_lock ();
+  fc = cc->func_context.next;
+  if (fc == &cc->func_context)
+    __bounds_internal_error ("__bounds_add_param_object called when"
+			     " not in a function context",
+			     __FILE__, __LINE__);
+
+  /* Add the stack object, and note it down in the function_context, so
+     we can automatically delete it later. We set the `no padding' flag
+     in the object since padding isn't added between parameters for
+     compatibility reasons.  */
+  obj = __bounds_internal_add_stack_object (ptr, size, align,
+					    filename, line, name, 1, -1);
+  obj->next = fc->parms.next;
+  fc->parms.next = obj;
+
+  /* If this is `main' and we have the first two arguments, then note the
+     positions of the command line arguments here.  */
+  if (fc->in_main && obj && obj->next && obj->next->next == &fc->parms)
+    {
+      void *arg0_ptr, *arg1_ptr;
+      int argc;
+      char **argv;
+
+      /* points to `argc'.  */
+      arg0_ptr = obj->next->base;
+      /* points to `argv'.  */
+      arg1_ptr = obj->base;
+
+      argc = *(int *) arg0_ptr;	/* get them */
+      argv = *(char ***) arg1_ptr;
+
+      __bounds_note_main_args (argc, argv);
+    }
+  leave_critical_section (&old_mask);
+}
+
+/* If you don't want to check bounds in the currently active function,
+   then call this somewhere near the beginning of the function.  */
+
+void
+__bounds_no_checking_in_this_function (void)
+{
+  cur_context *cc = get_context ();
+  function_context *fc = cc->func_context.next;
+  if (fc != &cc->func_context)
+    {
+      fc->no_checking = 1;
+      __bounds_debug_no_checking = 1;
+    }
+}
+
+/* Print a stack trace. This function is of little interest, since
+  (a) it misses out all unchecked functions, and
+  (b) GDB does a better stack trace already.  */
+
+void
+__bounds_debug_stack_trace (void)
+{
+  cur_context *cc = get_context_no_lock ();
+  function_context *fc = cc->func_context.next;
+  object *obj;
+
+  if (fc == &cc->func_context)
+    {
+      printf ("No stack.\n");
+      return;
+    }
+
+  printf ("Stack trace (params are reversed):\n");
+  while (fc != &cc->func_context)
+    {
+      printf ("- %s (", fc->name);
+      obj = fc->parms.next;
+      while (obj != &fc->parms)
+	{
+	  if (obj != fc->parms.next)
+	    printf (", ");
+	  printf ("%s = ", obj->name);
+	  /* We can only print the argument value if it's an int or a
+	     pointer.  */
+	  if (obj->size == sizeof (int) && obj->align == sizeof (int))
+	    printf ("%u", *(unsigned *) (obj->base));
+	  else
+	    printf ("?");
+	  obj = obj->next;
+	}
+      printf (") at %s:%d\n", fc->filename, fc->line);
+      fc = fc->next;
+    }
+}
+
+/* The following function is called from the `alloca.c' code to
+   update the alloca chain in the current function context. Placing
+   this function here adds some modularity at the expense of some
+   speed. Returns the current function name. */
+
+void
+__bounds_add_alloca_chain (alloca_item * item)
+{
+  cur_context *cc = get_context_no_lock ();
+  function_context *fc = cc->func_context.next;
+
+  if (fc != &cc->func_context)
+    {
+      item->next = fc->alloca_stack;
+      fc->alloca_stack = item;
+    }
+  else
+    {
+      /* Allow this because we can have mixed objects from bounds checked code
+         and non bounds checked code. This also means that the item will never
+         be freed.  */
+#if 0
+      __bounds_internal_error ("added item to alloca stack in NULL"
+			       " function context", __FILE__, __LINE__);
+#else
+#endif
+    }
+}
+
+void
+__bounds_delete_alloca_chain (object *obj)
+{
+  cur_context *cc = get_context_no_lock ();
+  function_context *fc = cc->func_context.next;
+  alloca_item *last, *cur;
+
+  if (fc != &cc->func_context)
+    {
+      last = NULL;
+      cur = fc->alloca_stack;
+      while (cur) {
+	if (cur->pointer == obj->base)
+	  {
+	    if (last)
+	      last->next = cur->next;
+	    else
+	      fc->alloca_stack = cur->next;
+            __bounds_delete_heap_object (cur->pointer, -1,
+                                         "invalid pointer used in `alloca'",
+                                         cur->filename,
+                                         cur->line, NULL);
+	    __bounds_free (cur);
+	    break;
+	  }
+	last = cur;
+	cur = cur->next;
+      }
+    }
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/functions.h gcc-4.0.2/gcc/bounds/lib/functions.h
--- gcc-4.0.2.org/gcc/bounds/lib/functions.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/functions.h	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,63 @@
+/* Bounds Checking for GCC.
+   Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   File:
+  	lib/functions.h
+   Summary:
+  	Header file describing the function stack used by "functions.c".
+   Other notes:
+  	
+   Author      	Date		Notes
+   RWMJ		6/3/95		Initial implementation.
+*/
+
+#ifndef _FUNCTIONS_H_
+#define _FUNCTIONS_H_
+
+/* This is the structure used to store a record of a single function call.  */
+
+typedef struct _function_context
+{
+  int nesting_nr;		/* nesting level nr.  */
+  unsigned char in_main;	/* True if this is `main ()'.  */
+  unsigned char no_checking;	/* True if we don't check this fn.  */
+  const char *name;		/* Pointer to function name.  */
+  const char *filename;		/* File where declared.  */
+  int line;			/* Line where declared.  */
+  object parms;			/* Parms for this function.  */
+  object stack;			/* Stack elements for this function.  */
+  alloca_item *alloca_stack;	/* List of calls to alloca.  */
+  struct _function_context *next;	/* Next function_context.  */
+  struct _function_context *prev;	/* Previous function_context.  */
+} function_context;
+
+typedef struct _cur_context
+{
+  int current_thread;
+  int nesting_nr;
+  /* The current function context.  */
+  function_context func_context;
+  function_context *hist_func;
+  char *last_end;		/* strtok last_end pointer.  */
+  struct _cur_context *next;
+} cur_context;
+
+extern char **__bounds_strtok_last_end (void);
+extern void __bounds_add_function_object (object * obj, int nesting_nr);
+extern int __bounds_remove_function_object (object * obj, int nesting_nr);
+
+#endif /* _FUNCTIONS_H_ */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/getpagesize.h gcc-4.0.2/gcc/bounds/lib/getpagesize.h
--- gcc-4.0.2.org/gcc/bounds/lib/getpagesize.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/getpagesize.h	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,39 @@
+/* Emulate getpagesize on systems that lack it.  */
+
+#ifndef HAVE_GETPAGESIZE
+
+#ifdef VMS
+#define getpagesize() 512
+#endif
+
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#ifdef _SC_PAGESIZE
+#define getpagesize() sysconf(_SC_PAGESIZE)
+#else
+
+#include <sys/param.h>
+
+#ifdef EXEC_PAGESIZE
+#define getpagesize() EXEC_PAGESIZE
+#else
+#ifdef NBPG
+#define getpagesize() NBPG * CLSIZE
+#ifndef CLSIZE
+#define CLSIZE 1
+#endif /* no CLSIZE */
+#else /* no NBPG */
+#ifdef NBPC
+#define getpagesize() NBPC
+#else /* no NBPC */
+#ifdef PAGESIZE
+#define getpagesize() PAGESIZE
+#endif
+#endif /* NBPC */
+#endif /* no NBPG */
+#endif /* no EXEC_PAGESIZE */
+#endif /* no _SC_PAGESIZE */
+
+#endif /* not HAVE_GETPAGESIZE */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/globals.c gcc-4.0.2/gcc/bounds/lib/globals.c
--- gcc-4.0.2.org/gcc/bounds/lib/globals.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/globals.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,194 @@
+/* Bounds Checking for GCC.
+   Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   File:
+  	lib/globals.c
+   Summary:
+  	I moved all the global variables here. All globals have to start
+  	with '__bounds' so they don't conflict with any other symbols in
+  	the program.
+   Other notes:
+  	
+   Author      	Date		Notes
+   RWMJ		15/3/95		Moved all globals to this file.
+*/
+
+#include "bounds-lib.h"
+
+#include <signal.h>
+
+#include "mutex.h"
+
+/* This flag may be set by bounds-checking-aware programs to enable debugging
+   of all calls to this library. This flag is only available if DEBUG_FEATURES
+   is set in `bounds-lib.h'.  */
+
+int __bounds_debug_print_calls = 0;
+
+/* This flag may be set to print the heap contents at program exit.  */
+
+int __bounds_debug_print_heap = 0;
+
+/* When this flag is set calls to mmap / munmap are checked.  */
+
+int __bounds_check_mmap_calls = 1;
+
+/* This flag prints debug information on function calls */
+
+int __bounds_debug_print_function = 0;
+
+/* This flag may be set to disable checking for a section of the program.  */
+
+int __bounds_debug_no_checking = 0;
+
+/* Warn if references are made to an unchecked static object.  */
+
+int __bounds_warn_unchecked_statics = 0;
+
+/* Warn if references are made to an unchecked stack object.  */
+
+int __bounds_warn_unchecked_stack = 0;
+
+#if COLLECT_STATS
+/* Collect statistics on calling frequencies. The statistics are taken in
+   'check.c'.  */
+
+unsigned __bounds_stats_ptr_plus_int = 0;
+unsigned __bounds_stats_array_reference = 0;
+unsigned __bounds_stats_component_reference = 0;
+unsigned __bounds_stats_ptr_diff = 0;
+unsigned __bounds_stats_reference = 0;
+unsigned __bounds_stats_ptr_le_ptr = 0;
+unsigned __bounds_stats_ptr_lt_ptr = 0;
+unsigned __bounds_stats_ptr_ge_ptr = 0;
+unsigned __bounds_stats_ptr_gt_ptr = 0;
+unsigned __bounds_stats_ptr_ne_ptr = 0;
+unsigned __bounds_stats_ptr_eq_ptr = 0;
+unsigned __bounds_stats_ptr_postinc = 0;
+unsigned __bounds_stats_ptr_preinc = 0;
+unsigned __bounds_stats_ptr_postdec = 0;
+unsigned __bounds_stats_ptr_predec = 0;
+unsigned __bounds_stats_ptr_true = 0;
+unsigned __bounds_stats_ptr_false = 0;
+unsigned __bounds_stats_push_function = 0;
+unsigned __bounds_stats_pop_function = 0;
+unsigned __bounds_stats_param_function = 0;
+unsigned __bounds_stats_environment = 0;
+unsigned __bounds_stats_add_stack = 0;
+unsigned __bounds_stats_delete_stack = 0;
+unsigned __bounds_stats_add_heap = 0;
+unsigned __bounds_stats_delete_heap = 0;
+unsigned __bounds_stats_unchecked_static = 0;
+unsigned __bounds_stats_unchecked_stack = 0;
+unsigned __bounds_stats_add_oob_table = 0;
+unsigned __bounds_stats_find_oob_table = 0;
+unsigned __bounds_stats_delete_oob_table = 0;
+#if DEBUG_OBJECTS
+unsigned __bounds_stats_find_object = 0;
+unsigned __bounds_stats_maybe_find_object = 0;
+unsigned __bounds_stats_maybe_find_object_search = 0;
+#endif
+
+#endif /* COLLECT_STATS */
+
+/* check the array indexes by default. This does also work for structures
+   like:
+  	struct ... {
+  		...other data ...
+  		char text[1]; -- string: structure expands to actual len .
+  	};
+   where you overwrite the end of the structure by the actual name. 
+   This is why array checking is only performed on arrays with sizes
+   greater than 1.  */
+
+int __bounds_array_index_check = 1;
+
+/* Don't free up VM addresses on the heap. We can track stale heap pointers
+   this way, the disadvantage being that we may run out of VM addresses. It
+   is best to ensure that 'munmap' is being called in 'malloc.c', so that
+   physical memory is recycled when this option is being used.  */
+/* Free up VM addresses on the heap after an age limit has expired. We can
+   track most stale heap pointers this way if 'age_limit' is set large
+   enough. However, if you really want to check all stale pointer, then
+   set 'never_free_heap' to 1 and stale pointers over the whole lifetime
+   of the program will be found.  */
+
+int __bounds_never_free_heap = 0;
+int __bounds_age_limit = 0;
+
+/* Warn if 'free (0)' is called. This is apparently valid in ANSI C.  */
+
+int __bounds_warn_free_null = 0;
+
+/* Give warnings for miscellaneous strangenesses in the strings library, eg.
+   NULL pointer passed to memcpy but with zero size. X11 likes to do
+   this sort of thing.  */
+
+int __bounds_warn_misc_strings = 0;
+
+/* Warn when ILLEGAL pointers are generated, so you can track them down more
+   easily. These patches were provided by Don Lewis <gdonl@gv.ssi1.com>.  */
+
+int __bounds_warn_illegal = 0;
+
+/* Warn if a pointer is used unaligned, for instance, if the user attempts to
+   read an array of integers as chars. Being able to switch this off was
+   suggested by Stuart Kemp and Eberhard Mattes (see CONTRIBUTORS).  */
+
+int __bounds_warn_unaligned = 0;
+
+/* Warn if a pointer is used unaligned, for instance, if the user attempts to
+   read an array of integers as chars. Being able to switch this off was
+   suggested by Stuart Kemp and Eberhard Mattes (see CONTRIBUTORS).  */
+
+int __bounds_warn_overlap = 1;
+
+/* Warn about greater-than or less-than comparisons of pointers that point to
+   different objects. This is usually a problem, but programs that do their
+   own memory management and build a tree of malloc'ed objects need to
+   do this.  */
+
+int __bounds_warn_compare_objects = 0;
+
+/* By popular demand, a flag that causes the library to continue after hitting
+   a bounds error. The second and subsequent errors may be unpredictable
+   results of the first error.  */
+
+int __bounds_never_fatal = 0;
+
+/* Flag to track oob pointers to accomodate codes which use such pointers 
+   subsequently e.g for comparision. Turned by default and controlled by
+   "-no-oob-pointers" environment variable.  */
+
+int __bounds_oob_pointers = 1;
+int __bounds_print_oob_pointers = 0;
+
+/* Redirect all error output to stderr normally or use this filename
+   if spefified.  */
+
+char *__bounds_error_filename = NULL;
+int __bounds_error_filename_append = 0;
+
+/* If we are using Sys V-style signal handling, and we want mutual exclusion
+   when we enter and leave critical library functions, this variable is used
+   to store the current signal mask state.  */
+
+int __bounds_mutex_signal = 0;
+sigset_t __bounds_new_mask;
+void (*__bounds_mutex_start) (void) = NULL;
+void (*__bounds_mutex_end) (void) = NULL;
+int (*__bounds_function_thread) (void) = NULL;
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/init.c gcc-4.0.2/gcc/bounds/lib/init.c
--- gcc-4.0.2.org/gcc/bounds/lib/init.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/init.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,606 @@
+/* Bounds Checking for GCC.
+   Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   File:
+  	lib/init.c
+   Summary:
+  	Code that initializes the library, and reads the bounds checking
+  	options from the environment variable.
+   Other notes:
+  	
+   Author      	Date		Notes
+   RWMJ		12/2/95		Initial implementation.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <ctype.h>
+
+#include "ansidecl.h"
+#include "bounds-lib.h"
+#include "mutex.h"
+
+#if defined(__BOUNDS_CHECKING_ON)
+#error "This file must not be compiled with bounds checking enabled."
+#endif
+
+/* The contents of the following environment variable determine how the
+   library works at run time.  */
+
+#define BOUNDS_CHECKING_VAR	"GCC_BOUNDS_OPTS"
+
+#define PRINT_WELCOME_MSG	1	/* Print welcome message by default.  */
+#define IGNORE_BAD_FLAGS	0	/* Ignore badly formed env. variable. */
+
+static int print_welcome_msg = 1;
+#if COLLECT_STATS
+static int print_statistics = 1;
+#endif
+
+static int process_opts (char *);
+static void usage (void);
+#if COLLECT_STATS
+static void print_stats (void);
+#endif
+
+#ifndef __vxworks
+extern char **environ;
+#endif
+
+/* Initialize the library.
+   This function may be called multiple times while constructing
+   objects. (It is called once for each object file that was compiled
+   with bounds checking). We set the '__bounds_checking_on' flag
+   (which is in libgcc2.c) to 1, so we know if we have been
+   called before. If this function is never called, then the
+   '__bounds_checking_on' flag will remain at 0, which is what
+   we want.
+   Look for the location of environment variables (from 'environ').  */
+
+void
+__bounds_initialize_library (void)
+{
+  char *v;
+  int i;
+
+  if (!__bounds_checking_on)
+    {
+      /* Init the malloc library. This is needed because we could run
+         into problems when using dynamic libraries. They will use
+         strcmp and then we get a nested call to find_object when
+         we allocate the first object. This then fails when we use mutex
+         locks.  */
+      __bounds_free (__bounds_malloc (1));
+      free (malloc (1));
+#if COLLECT_STATS
+      __bounds_stats_add_heap = 0;
+      __bounds_stats_delete_heap = 0;
+#endif
+#if DEBUG_FEATURES
+      if (__bounds_debug_print_calls)
+	printf ("__bounds_initialize_library ()\n");
+#endif
+
+      /* Set the __bounds_checking_on flag, so that we don't call this function
+         twice.  */
+      __bounds_checking_on = 1;
+
+      /* Look for the environment variable containing run-time options.  */
+      v = getenv (BOUNDS_CHECKING_VAR);
+      if (v && !process_opts (v))
+	{
+	  printf ("bounds-checking: Badly formed variable '"
+		  BOUNDS_CHECKING_VAR "'.\n");
+	  usage ();
+#if !IGNORE_BAD_FLAGS
+	  exit (1);
+#endif
+	}
+
+#if PRINT_WELCOME_MSG
+      /* Print a welcome message. This message can be suppressed by using
+         '-no-message' in the options variable, or by setting PRINT_WELCOME_MSG
+         to 0 at the top of this file.  */
+      if (print_welcome_msg)
+	printf ("Bounds Checking GCC v " VERSION_STRING
+		" Copyright (C) 1995 Richard W.M. Jones\n"
+		"Bounds Checking comes with ABSOLUTELY NO WARRANTY."
+		" For details see file\n"
+		"`COPYING' that should have come with the source"
+		" to this program.\n"
+		"Bounds Checking is free software, and you are welcome"
+		" to redistribute it\n"
+		"under certain conditions. See the file `COPYING'"
+		" for details.\n"
+		"For more information, set " BOUNDS_CHECKING_VAR
+		" to `-help'\n");
+#endif /* PRINT_WELCOME_MSG */
+
+      /* Register the environment variables as static objects.
+         31/5/95: Now use stack objects. Set 'no_padding' to 1.  */
+#ifndef __CYGWIN__
+#ifndef __vxworks
+      for (i = 0; environ[i]; ++i)
+	{
+#if COLLECT_STATS
+	  ++__bounds_stats_environment;
+#endif
+	  __bounds_internal_add_stack_object (environ[i],
+					      __bounds_strlen (environ[i]) +
+					      1, 1, "main", 0, "environ", 1,
+					      -1);
+	}
+#if COLLECT_STATS
+      ++__bounds_stats_environment;
+#endif
+      /* RWMJ: (21/9/95) Although the documentation suggests otherwise, SunOS
+         and Solaris need `i+2' here, because they appear to use 2 extra
+         NULL pointers to terminate environ, instead of 1. Whether this
+         will make a difference on other systems, I do not know.
+         RWMJ: (10/1/96) This breaks OS/2 and possibly others. Now only use
+         the `+2' on Suns. Thanks Eberhard Mattes.  */
+#if defined(sun)
+#define ENV_SUN_HACK 2
+#else
+#define ENV_SUN_HACK 1
+#endif
+      __bounds_internal_add_stack_object (environ,
+					  (i +
+					   ENV_SUN_HACK) * sizeof (char *),
+					  sizeof (char *), "main", 0,
+					  "environ", 1, -1);
+#endif
+#endif
+#undef ENV_SUN_HACK
+
+      /* This could probebly be solved by changing the include files in
+         the gcc include directory. I put it here because I dont know how
+         to modify the fix-includes script's.  */
+#if defined(__svr4__) || defined(svr4)
+#if defined(__STDC__)
+      __bounds_note_constructed_object (__ctype, -514, 1, NULL, 0, "__ctype");
+#else
+      __bounds_note_constructed_object (_ctype, -514, 1, NULL, 0, "_ctype");
+#endif
+      /* iob struct has already a size on svr4 so whe do not have to 
+         include it here. It is included as an external reference.  */
+#elif defined(sun)
+      /* This is reported not to work on standard Solaris 2.4. If
+         you get a problem, then simply comment out the next two lines. Can
+         someone tell me what the compiler symbol I need to look out for
+         is?  */
+#if defined (__svr4__)
+#if defined(__STDC__)
+      __bounds_note_constructed_object (__ctype, -514, 1, NULL, 0, "__ctype");
+#else
+      __bounds_note_constructed_object (_ctype, -514, 1, NULL, 0, "_ctype");
+#endif
+#else
+      __bounds_note_constructed_object (_ctype_, -257, 1, NULL, 0, "_ctype_");
+      __bounds_note_constructed_object (_iob, -32 * sizeof (struct _iobuf), 1,
+					NULL, 0, "_iob");
+#endif
+#endif
+
+#if defined(__linux__)
+#ifndef __GLIBC_PREREQ
+#define __GLIBC_PREREQ(major,minor) 0
+#endif
+#if __GLIBC_PREREQ(2,3)
+      __bounds_note_constructed_object ((void *) (__ctype_b_loc ()),
+					-1 * sizeof (unsigned short *),
+					1, NULL, 0, "__ctype_b_loc");
+      __bounds_note_constructed_object ((void *) (*__ctype_b_loc () - 128),
+					-384 * sizeof (unsigned short),
+					1, NULL, 0, "__ctype_b");
+      __bounds_note_constructed_object ((void *) (__ctype_tolower_loc ()),
+					-1 * sizeof (int *),
+					1, NULL, 0, "__ctype_tolower_loc");
+      __bounds_note_constructed_object ((void *) (*__ctype_tolower_loc () -
+						  128), -384 * sizeof (int),
+					1, NULL, 0, "__ctype_tolower");
+      __bounds_note_constructed_object ((void *) (__ctype_toupper_loc ()),
+					-1 * sizeof (int *), 1, NULL, 0,
+					"__ctype_toupper_loc");
+      __bounds_note_constructed_object ((void *) (*__ctype_toupper_loc () -
+						  128), -384 * sizeof (int),
+					1, NULL, 0, "__ctype_toupper");
+#else
+      __bounds_note_constructed_object ((void *) (__ctype_b - 128),
+					-384 * sizeof (unsigned short),
+					1, NULL, 0, "__ctype_b");
+      __bounds_note_constructed_object ((void *) (__ctype_tolower - 128),
+					-384 * sizeof (int),
+					1, NULL, 0, "__ctype_tolower");
+      __bounds_note_constructed_object ((void *) (__ctype_toupper - 128),
+					-384 * sizeof (int),
+					1, NULL, 0, "__ctype_toupper");
+#if 0				/* present in library but not in ctype.h  */
+      __bounds_note_constructed_object ((void *) __ctype_names,
+					-256 * sizeof (unsigned int),
+					1, NULL, 0, "__ctype_names");
+      __bounds_note_constructed_object ((void *) __ctype_width,
+					-256 * sizeof (unsigned char),
+					1, NULL, 0, "__ctype_width");
+#endif
+#endif
+#endif
+
+#if COLLECT_STATS && !defined(__vxworks)
+      /* If we are collecting statistics, print them out when the program
+         exits.  */
+      atexit (print_stats);
+#endif
+      sigfillset (&__bounds_new_mask);
+    }
+}
+
+/* The following functions and tables deal with processing arguments
+   passed in the environment variable.  */
+
+static void
+usage (void)
+{
+  printf ("You may supply a list of the following arguments"
+	  " to a bounds-checked program\n"
+	  "by listing them in the environment variable '" BOUNDS_CHECKING_VAR
+	  "' before\n"
+	  "running the program. Separate the arguments by spaces.\n"
+	  "General:\n"
+#if PRINT_WELCOME_MSG
+	  "  -no-message                 Don't print introductory message.\n"
+#endif
+#if COLLECT_STATS
+	  "  -no-statistics              Don't print statistics.\n"
+#endif
+	  "  -?, -help                   Print this table of usage.\n"
+	  "Control runtime behaviour:\n"
+	  "  -array-index-check         *Check the index of all array"
+	  " references.\n"
+	  "  -no-array-index-check       Only check the pointer is within"
+	  " the array.\n"
+	  "  -never-fatal                Don't abort after a bounds error.\n"
+	  "  -check-mmap                *Check mmap calls.\n"
+	  "  -no-check-mmap              Switch off the above.\n"
+	  "  -reuse-heap                *Re-use the heap.\n"
+	  "  -reuse-age=<age>            Set the age limit before freeing"
+	  " (default: 0).\n"
+	  "  -no-reuse-heap              Never really free old heap blocks.\n"
+	  "  -warn-unchecked-statics     Warn if unchecked static objects"
+	  " are referenced.\n"
+	  "  -no-warn-unchecked-statics *Switch off the above.\n"
+	  "  -warn-unchecked-stack       Warn if unchecked stack objects"
+	  " are referenced.\n"
+	  "  -no-warn-unchecked-stack   *Switch off the above.\n"
+	  "  -warn-free-null            *Warn if free (0) is used.\n"
+	  "  -no-warn-free-null          Switch off the above.\n"
+	  "  -warn-misc-strings         *Warn for miscellaneous"
+	  " strings usage.\n"
+	  "  -no-warn-misc-strings       Switch off the above.\n"
+	  "  -warn-illegal               Warn when ILLEGAL pointers"
+	  " are created.\n"
+	  "  -no-warn-illegal           *Switch off the above.\n"
+	  "  -warn-unaligned             Warn when pointers are used"
+	  " unaligned.\n"
+	  "  -no-warn-unaligned         *Switch off the above.\n"
+	  "  -warn-overlap              *Warn if memcpy arguments overlap.\n"
+	  "  -no-warn-overlap            Switch off the above.\n"
+	  "  -warn-compare-objects       Warn if comparing pointers to"
+	  " different objects.\n"
+	  "  -no-warn-compare-objects   *Switch off the above.\n"
+	  "  -warn-all                   Turn on all warnings.\n"
+	  "  -no-print-heap             *Don't print heap data at exit.\n"
+	  "  -print-heap                 Print all heap data at exit.\n"
+	  "  -print-heap-long            Print all heap data at exit"
+	  " (long version).\n"
+	  "  -oob-pointers              *Enable out of bound pointer checks.\n"
+	  "  -no-oob-pointers            Switch off the above.\n"
+	  "  -output-file=<name>         Redirect all output to file <name>.\n"
+	  "                               Use '%%p' in <name> to insert"
+	  " process number.\n"
+	  "  -output-file-append=<name>  Same as above but file is opened in"
+	  " append mode.\n"
+#if DEBUG_FEATURES
+	  "Debugging:\n"
+	  "  -print-calls                Print calls to the bounds-checking"
+	  " library.\n"
+	  "  -no-print-calls            *Don't print calls.\n"
+	  "  -print-oob-pointers         Warn when oob pointers added"
+	  " to hashtable\n"
+	  "  -no-print-oob-pointers     *Switch off the above.\n"
+	  "  -print-functions            Print info at function start/end.\n"
+	  "  -no-print-functions        *Switch off the above.\n"
+#endif
+	  "Note: `*' means this is the default behaviour.\n");
+}
+
+static int
+process_opts (char *opts)
+{
+  int len = __bounds_strlen (opts), done = 0;
+  char buffer[len + 1], *in_opts = opts;
+
+  while (!done)
+    {
+      /* Copy the next option into the private buffer (`buffer') and deal with
+         it there. Allow the user to escape spaces with `\ ' and to insert
+         tabs and newlines with `\t' and `\n' resp. A double quoted string
+         also shields spaces.  */
+      char *p = buffer;
+      int in_quote = 0;
+
+      do
+	{
+	  switch (*in_opts)
+	    {
+	    case ' ':		/* Last character in the argument.  */
+	      if (!in_quote)
+		*p = 0;
+	      else
+		*p = ' ';
+	      break;
+	    case '\0':		/* Last character in the string.  */
+	      if (in_quote)
+		return 0;	/* Unterminated quote character.  */
+	      *p = 0;
+	      done = 1;
+	      break;
+	    case '\\':		/* Escaped character.  */
+	      in_opts++;
+	      switch (*in_opts)
+		{		/* Process \t and \n.  */
+		case 't':
+		  *p = '\t';
+		  break;
+		case 'n':
+		  *p = '\n';
+		  break;
+		case '\0':
+		  return 0;	/* \ cannot be at end of the string.  */
+		default:
+		  *p = *in_opts;
+		}
+	      break;
+	    case '"':		/* Start or end of "...".  */
+	      in_quote = !in_quote;
+	      break;
+	    default:		/* Another character.  */
+	      *p = *in_opts;
+	    }
+	  ++in_opts;
+	}
+      while (*p++);
+
+      /* Now we have a single argument in the private buffer. See if we know
+         what it is. If we don't understand it, we return 0 immediately, which
+         causes the calling function to print usage. Arguments like '-no-
+         statistics' which are enabled & disabled by #defines in the library
+         are ignored silently if not applicable.  */
+      p = buffer;
+      /* Skip leading whitespace. */
+      while (*p && (*p == ' ' || *p == '\t' || *p == '\n' || *p == '\r'))
+	p++;
+      if (*p != 0)
+	{
+	  if (__bounds_strcmp (p, "-no-message") == 0)
+	    print_welcome_msg = 0;
+	  else if (__bounds_strcmp (p, "-no-statistics") == 0)
+#if COLLECT_STATS
+	    print_statistics = 0
+#endif
+	      ;
+	  else if (__bounds_strcmp (p, "-?") == 0
+		   || __bounds_strcmp (p, "-help") == 0)
+	    {
+	      usage ();
+	      exit (0);
+	    }
+	  else if (__bounds_strcmp (p, "-array-index-check") == 0)
+	    __bounds_array_index_check = 1;
+	  else if (__bounds_strcmp (p, "-no-array-index-check") == 0)
+	    __bounds_array_index_check = 0;
+	  else if (__bounds_strcmp (p, "-never-fatal") == 0)
+	    __bounds_never_fatal = 1;
+	  else if (__bounds_strcmp (p, "-reuse-heap") == 0)
+	    __bounds_never_free_heap = 0;
+	  else if (__bounds_strcmp (p, "-no-reuse-heap") == 0)
+	    __bounds_never_free_heap = 1;
+	  else if (__bounds_strcmp (p, "-check-mmap") == 0)
+	    __bounds_check_mmap_calls = 1;
+	  else if (__bounds_strcmp (p, "-no-check-mmap") == 0)
+	    __bounds_check_mmap_calls = 0;
+	  else if (__bounds_strncmp (p, "-reuse-age=", 11) == 0)
+	    __bounds_age_limit = atoi (p + 11);
+	  else if (__bounds_strcmp (p, "-print-calls") == 0)
+	    {
+#if DEBUG_FEATURES
+	      __bounds_print_oob_pointers = 1;
+	      __bounds_debug_print_function = 1;
+	      __bounds_debug_print_calls = 1;
+#endif
+	    }
+	  else if (__bounds_strcmp (p, "-no-print-calls") == 0)
+	    {
+#if DEBUG_FEATURES
+	      __bounds_print_oob_pointers = 0;
+	      __bounds_debug_print_function = 0;
+	      __bounds_debug_print_calls = 0;
+#endif
+	    }
+	  else if (__bounds_strcmp (p, "-print-oob-pointers") == 0)
+#if DEBUG_FEATURES
+	    __bounds_print_oob_pointers = 1
+#endif
+	      ;
+	  else if (__bounds_strcmp (p, "-no-print-oob-pointers") == 0)
+#if DEBUG_FEATURES
+	    __bounds_print_oob_pointers = 0
+#endif
+	      ;
+	  else if (__bounds_strcmp (p, "-print-functions") == 0)
+#if DEBUG_FEATURES
+	    __bounds_debug_print_function = 1
+#endif
+	      ;
+	  else if (__bounds_strcmp (p, "-no-print-functions") == 0)
+#if DEBUG_FEATURES
+	    __bounds_debug_print_function = 0
+#endif
+	      ;
+	  else if (__bounds_strcmp (p, "-print-heap") == 0)
+	    __bounds_debug_print_heap = 1;
+	  else if (__bounds_strcmp (p, "-print-heap-long") == 0)
+	    __bounds_debug_print_heap = 2;
+	  else if (__bounds_strcmp (p, "-no-print-heap") == 0)
+	    __bounds_debug_print_heap = 0;
+	  else if (__bounds_strcmp (p, "-warn-unchecked-statics") == 0)
+	    __bounds_warn_unchecked_statics = 1;
+	  else if (__bounds_strcmp (p, "-no-warn-unchecked-statics") == 0)
+	    __bounds_warn_unchecked_statics = 0;
+	  else if (__bounds_strcmp (p, "-warn-unchecked-stack") == 0)
+	    __bounds_warn_unchecked_stack = 1;
+	  else if (__bounds_strcmp (p, "-no-warn-unchecked-stack") == 0)
+	    __bounds_warn_unchecked_stack = 0;
+	  else if (__bounds_strcmp (p, "-warn-free-null") == 0)
+	    __bounds_warn_free_null = 1;
+	  else if (__bounds_strcmp (p, "-no-warn-free-null") == 0)
+	    __bounds_warn_free_null = 0;
+	  else if (__bounds_strcmp (p, "-warn-misc-strings") == 0)
+	    __bounds_warn_misc_strings = 1;
+	  else if (__bounds_strcmp (p, "-no-warn-misc-strings") == 0)
+	    __bounds_warn_misc_strings = 0;
+	  else if (__bounds_strcmp (p, "-warn-illegal") == 0)
+	    __bounds_warn_illegal = 1;
+	  else if (__bounds_strcmp (p, "-no-warn-illegal") == 0)
+	    __bounds_warn_illegal = 0;
+	  else if (__bounds_strcmp (p, "-warn-unaligned") == 0)
+	    __bounds_warn_unaligned = 1;
+	  else if (__bounds_strcmp (p, "-no-warn-unaligned") == 0)
+	    __bounds_warn_unaligned = 0;
+	  else if (__bounds_strcmp (p, "-warn-overlap") == 0)
+	    __bounds_warn_overlap = 1;
+	  else if (__bounds_strcmp (p, "-no-warn-overlap") == 0)
+	    __bounds_warn_overlap = 0;
+	  else if (__bounds_strcmp (p, "-warn-compare-objects") == 0)
+	    __bounds_warn_compare_objects = 1;
+	  else if (__bounds_strcmp (p, "-no-warn-compare-objects") == 0)
+	    __bounds_warn_compare_objects = 0;
+	  else if (__bounds_strcmp (p, "-oob-pointers") == 0)
+	    __bounds_oob_pointers = 1;
+	  else if (__bounds_strcmp (p, "-no-oob-pointers") == 0)
+	    __bounds_oob_pointers = 0;
+	  else if (__bounds_strcmp (p, "-warn-all") == 0)
+	    __bounds_warn_unchecked_statics =
+	      __bounds_warn_unchecked_stack =
+	      __bounds_warn_misc_strings =
+	      __bounds_warn_free_null =
+	      __bounds_warn_illegal =
+	      __bounds_warn_unaligned =
+	      __bounds_warn_overlap = __bounds_warn_compare_objects = 1;
+	  else if (__bounds_strncmp (p, "-output-file=", 13) == 0)
+	    {
+	      __bounds_error_filename =
+		__bounds_malloc (__bounds_strlen (p + 13) + 1);
+	      if (__bounds_error_filename)
+		__bounds_strcpy (__bounds_error_filename, p + 13);
+	      __bounds_error_filename_append = 0;
+	    }
+	  else if (__bounds_strncmp (p, "-output-file-append=", 20) == 0)
+	    {
+	      __bounds_error_filename =
+		__bounds_malloc (__bounds_strlen (p + 20) + 1);
+	      if (__bounds_error_filename)
+		__bounds_strcpy (__bounds_error_filename, p + 20);
+	      __bounds_error_filename_append = 1;
+	    }
+	  else
+	    return 0;		/* Unrecognized option. */
+	}
+    }
+
+  return 1;
+}
+
+#if COLLECT_STATS
+
+/* Print call frequency statistics when the program exits.  */
+static void
+print_stats (void)
+{
+  if (print_statistics)
+    {
+      printf ("Bounds library call frequency statistics:\n"
+	      "  Calls to push, pop, param function:        %u, %u, %u\n"
+	      "  Calls to add, delete stack:                %u, %u\n"
+	      "  Calls to add, delete heap:                 %u, %u\n"
+#if DEBUG_OBJECTS
+	      "  Calls to find_object, maybe, search:       %u, %u, %u\n"
+#endif
+	      "  Calls to check pointer +/- integer:        %u\n"
+	      "  Calls to check array references:           %u\n"
+	      "  Calls to check pointer differences:        %u\n"
+	      "  Calls to check object references:          %u\n"
+	      "  Calls to check component references:       %u\n"
+	      "  Calls to check truth, falsity of pointers: %u, %u\n"
+	      "  Calls to check <, >, <=, >= of pointers:   %u\n"
+	      "  Calls to check ==, != of pointers:         %u\n"
+	      "  Calls to check p++, ++p, p--, --p:         %u, %u, %u, %u\n"
+	      "  Calls to add, find, delete oob pointers:   %u, %u, %u\n"
+	      "  References to unchecked static, stack:     %u, %u\n",
+	      __bounds_stats_push_function,
+	      __bounds_stats_pop_function,
+	      __bounds_stats_param_function,
+	      __bounds_stats_add_stack -
+	      __bounds_stats_environment,
+	      __bounds_stats_delete_stack,
+	      __bounds_stats_add_heap, __bounds_stats_delete_heap,
+#if DEBUG_OBJECTS
+	      __bounds_stats_find_object,
+	      __bounds_stats_maybe_find_object,
+	      __bounds_stats_maybe_find_object_search,
+#endif
+	      __bounds_stats_ptr_plus_int,
+	      __bounds_stats_array_reference,
+	      __bounds_stats_ptr_diff,
+	      __bounds_stats_reference,
+	      __bounds_stats_component_reference,
+	      __bounds_stats_ptr_true,
+	      __bounds_stats_ptr_false,
+	      __bounds_stats_ptr_lt_ptr +
+	      __bounds_stats_ptr_le_ptr +
+	      __bounds_stats_ptr_gt_ptr +
+	      __bounds_stats_ptr_ge_ptr,
+	      __bounds_stats_ptr_ne_ptr +
+	      __bounds_stats_ptr_eq_ptr,
+	      __bounds_stats_ptr_postinc,
+	      __bounds_stats_ptr_preinc,
+	      __bounds_stats_ptr_postdec,
+	      __bounds_stats_ptr_predec,
+	      __bounds_stats_add_oob_table,
+	      __bounds_stats_find_oob_table,
+	      __bounds_stats_delete_oob_table,
+	      __bounds_stats_unchecked_static,
+	      __bounds_stats_unchecked_stack);
+      __bound_print_statistics ();
+    }
+  if (__bounds_debug_print_heap)
+    __bound_print_heap ();
+}
+
+#endif /* COLLECT_STATS */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/Makefile gcc-4.0.2/gcc/bounds/lib/Makefile
--- gcc-4.0.2.org/gcc/bounds/lib/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/Makefile	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,108 @@
+#	Makefile for:
+#	----------------------------------------------------------------------
+#	Bounds Checking Project, by Richard W.M. Jones.
+#	Library of checking functions linked by modified GCC.
+#	----------------------------------------------------------------------
+
+SHELL	= /bin/sh
+
+OPTIMIZE= -O3 -finline-limit=1000000 --param inline-unit-growth=10000 \
+	  -fomit-frame-pointer
+
+VPATH = $(srcdir)/bounds/lib
+
+# Always search these dirs when compiling.
+SUBDIR_INCLUDES = -I../.. -I$(srcdir)/bounds/lib -I$(srcdir) \
+		  -I$(srcdir)/config -I$(srcdir)/../include \
+		  -I$(srcdir)/../newlib/libc/include
+
+# Use this on System V.
+CPPFLAGS = -DUSG
+
+DEBUG = -g
+
+.c.o:
+	$(GCC_FOR_TARGET) -Wall $(OPTIMIZE) $(CPPFLAGS) $(DEBUG) \
+		-c $(GCC_CFLAGS) $(SUBDIR_INCLUDES) $(MULTI_FLAGS) $<
+
+# If we were not invoked from the gcc dir invoke make
+# in the gcc dir and reinvoke this makefile.
+# That's necessary to get the right values for srcdir, etc.
+all:
+	cd ../..; $(MAKE) CFLAGS="$(CFLAGS)" sublibboundscheck
+
+MALLOC_HEADERS = getpagesize.h malloc.h mem-limits.h obstack.h
+MALLOC_SOURCES = bounds.c mmap.c calloc.c cfree.c free.c malloc.c \
+	         mcheck.c memalign.c morecore.c mstats.c mtrace.c \
+	         realloc.c valloc.c vm-limit.c
+MALLOC_OBJECTS = $(MALLOC_SOURCES:.c=.o)
+SOURCES	= alloca.c check.c error.c breakpoint.c exstatics.c functions.c \
+	  globals.c init.c objects.c print.c pthread_init.c $(MALLOC_SOURCES)
+OBJECTS	= $(SOURCES:.c=.o)
+HEADERS = alloca.h bounds-lib.h check.h ext-tree.h functions.h \
+	  mutex.h objects.h version.h ../VERSION $(MALLOC_HEADERS)
+LIBFUNCS = memcpy mempcpy memmove bcopy memset bzero memcmp bcmp \
+	   strcpy strncpy strlen strcmp strncmp strcat strncat strpbrk \
+	   strrchr rindex strspn strcspn strstr strtok strtok_r strchr strdup \
+	   index strcoll strxfrm memchr memccpy strcasecmp strncasecmp
+
+RM	= rm -f
+
+mostlyclean:
+	$(RM) libboundscheck.a $(OBJECTS) core
+	$(RM) -r func stmp_func
+	cd malloc; $(MAKE) clean
+
+distclean: clean
+	$(RM) *~ *.BAK
+
+clean: mostlyclean
+extraclean: mostlyclean
+
+install: libboundscheck.a
+	-if [ -f libboundscheck.a ]; then \
+	 rm -f $(DESTDIR)$(libsubdir)/libboundscheck.a; \
+	 $(INSTALL_DATA) libboundscheck.a $(DESTDIR)$(libsubdir)/libboundscheck.a; \
+	 (cd $(DESTDIR)$(libsubdir); $(RANLIB_FOR_TARGET) libboundscheck.a); \
+	 chmod a-x $(DESTDIR)$(libsubdir)/libboundscheck.a; \
+	 else true; fi
+
+libboundscheck.a: $(OBJECTS) stmp_func
+	$(RM) libboundscheck.a
+	$(AR) $(AR_FLAGS) libboundscheck.a $(OBJECTS) func/*.o
+	-$(RANLIB_FOR_TARGET) libboundscheck.a
+	$(RM) $(LIBBOUNDSCHECKDIR)/libboundscheck.a
+	cp libboundscheck.a $(LIBBOUNDSCHECKDIR)
+	-$(RANLIB_FOR_TARGET) $(LIBBOUNDSCHECKDIR)/libboundscheck.a
+
+alloca.o: $(srcdir)/bounds/lib/alloca.c $(HEADERS)
+	$(GCC_FOR_TARGET) -fno-builtin -Wall $(OPTIMIZE) $(CPPFLAGS) $(DEBUG) \
+		-c $(GCC_CFLAGS) $(SUBDIR_INCLUDES) $(MULTI_FLAGS) \
+		$(srcdir)/bounds/lib/alloca.c -o alloca.o
+
+pthread_init.o: $(srcdir)/bounds/lib/pthread_init.c $(HEADERS)
+	if [ -f /usr/include/pthread.h ]; then R=-D_REENTRANT; else R=; fi; \
+	$(GCC_FOR_TARGET) $$R -Wall $(OPTIMIZE) $(CPPFLAGS) $(DEBUG) \
+		-c $(GCC_CFLAGS) $(SUBDIR_INCLUDES) $(MULTI_FLAGS) \
+		$(srcdir)/bounds/lib/pthread_init.c -o pthread_init.o
+
+stmp_func: $(srcdir)/bounds/lib/string.c $(HEADERS)
+	if [ -d func ]; then true; else mkdir func; fi; \
+	cd func; \
+	for name in $(LIBFUNCS); \
+	do \
+	  echo $${name}; \
+	  rm -f bc_$${name}.o; \
+	  $(GCC_FOR_TARGET) -DLbounds_$${name} -fno-builtin -Wall $(OPTIMIZE) \
+		$(DEBUG) -c $(CPPFLAGS) $(GCC_CFLAGS) $(SUBDIR_INCLUDES) \
+		$(MULTI_FLAGS) $(srcdir)/bounds/lib/string.c -o bc_$${name}.o; \
+	  if [ $$? -eq 0 ] ; then true; else exit 1; fi; \
+	  rm -f $${name}.o; \
+	  $(GCC_FOR_TARGET) -DL$${name} -fno-builtin -Wall $(OPTIMIZE) \
+		$(DEBUG) -c $(CPPFLAGS) $(GCC_CFLAGS) $(SUBDIR_INCLUDES) \
+		$(MULTI_FLAGS) $(srcdir)/bounds/lib/string.c -o $${name}.o; \
+	  if [ $$? -eq 0 ] ; then true; else exit 1; fi; \
+	done; \
+	cd .. ; touch stmp_func
+
+$(OBJECTS): $(HEADERS)
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/mallocbug.c gcc-4.0.2/gcc/bounds/lib/mallocbug.c
--- gcc-4.0.2.org/gcc/bounds/lib/mallocbug.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/mallocbug.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,66 @@
+/* Reproduce a GNU malloc bug.  */
+#include <stdio.h>
+extern char *malloc ();
+
+#define size_t unsigned int
+
+int
+main ()
+{
+  char *dummy0;
+  char *dummy1;
+  char *fill_info_table1;
+  char *over_top;
+  size_t over_top_size = 0x3000;
+  char *over_top_dup;
+  size_t over_top_dup_size = 0x7000;
+  char *x;
+  size_t i;
+
+  /* Here's what memory is supposed to look like (hex):
+     size  contents
+     3000  original_info_table, later fill_info_table1
+     3fa000  dummy0
+     3fa000  dummy1
+     6000  info_table_2
+     3000  over_top
+
+   */
+  /* mem: original_info_table */
+  dummy0 = malloc (0x3fa000);
+  /* mem: original_info_table, dummy0 */
+  dummy1 = malloc (0x3fa000);
+  /* mem: free, dummy0, dummy1, info_table_2 */
+  fill_info_table1 = malloc (0x3000);
+  /* mem: fill_info_table1, dummy0, dummy1, info_table_2 */
+
+  x = malloc (0x1000);
+  free (x);
+  /* mem: fill_info_table1, dummy0, dummy1, info_table_2, freexx */
+
+  /* This is what loses; info_table_2 and freexx get combined unbeknownst
+     to mmalloc, and mmalloc puts over_top in a section of memory which
+     is on the free list as part of another block (where info_table_2 had
+     been).  */
+  over_top = malloc (over_top_size);
+  over_top_dup = malloc (over_top_dup_size);
+  __bounds_memset (over_top, 0, over_top_size);
+  __bounds_memset (over_top_dup, 1, over_top_dup_size);
+
+  for (i = 0; i < over_top_size; ++i)
+    if (over_top[i] != 0)
+      {
+	printf ("FAIL: malloc expands info table\n");
+	return 0;
+      }
+
+  for (i = 0; i < over_top_dup_size; ++i)
+    if (over_top_dup[i] != 1)
+      {
+	printf ("FAIL: malloc expands info table\n");
+	return 0;
+      }
+
+  printf ("PASS: malloc expands info table\n");
+  return 0;
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/malloc.c gcc-4.0.2/gcc/bounds/lib/malloc.c
--- gcc-4.0.2.org/gcc/bounds/lib/malloc.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/malloc.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,363 @@
+/* Memory allocator `malloc'.
+   Copyright 1990, 1991, 1992, 1993, 1994 Free Software Foundation, Inc.
+		  Written May 1989 by Mike Haertel.
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public License as
+published by the Free Software Foundation; either version 2 of the
+License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with this library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.
+
+   The author may be reached (Email) at the address mike@ai.mit.edu,
+   or (US mail) as Mike Haertel c/o Free Software Foundation.  */
+
+#include "bounds-lib.h"
+
+#ifndef	_MALLOC_INTERNAL
+#define _MALLOC_INTERNAL
+#include <malloc.h>
+#endif
+
+/* How to really get more memory.  */
+__ptr_t (*__morecore) (ptrdiff_t __size) = __default_morecore;
+
+/* Debugging hook for `malloc'.  */
+__ptr_t (*__malloc_hook) (__malloc_size_t __size);
+
+/* Pointer to the base of the first block.  */
+char *_heapbase;
+
+/* Block information table.  Allocated with align/__free (not malloc/free).  */
+malloc_info *_heapinfo;
+
+/* Number of info entries.  */
+static __malloc_size_t heapsize;
+
+/* Search index in the info table.  */
+__malloc_size_t _heapindex;
+
+/* Limit of valid info table indices.  */
+__malloc_size_t _heaplimit;
+
+/* Free lists for each fragment size.  */
+struct list _fraghead[BLOCKLOG];
+
+/* Instrumentation.  */
+__malloc_size_t _chunks_used;
+__malloc_size_t _bytes_used;
+__malloc_size_t _chunks_free;
+__malloc_size_t _bytes_free;
+
+/* Are you experienced?  */
+int __malloc_initialized;
+
+void (*__after_morecore_hook) (void);
+
+/* Aligned allocation.  */
+static __ptr_t align (__malloc_size_t);
+
+static __ptr_t
+align (__malloc_size_t size)
+{
+  __ptr_t result;
+  unsigned long int adj;
+
+  result = (*__morecore) (size);
+  adj = (unsigned long int) ((unsigned long int) ((char *) result -
+						  (char *) NULL)) % BLOCKSIZE;
+  if (adj != 0)
+    {
+      adj = BLOCKSIZE - adj;
+      (void) (*__morecore) (adj);
+      result = (char *) result + adj;
+    }
+
+  if (__after_morecore_hook)
+    (*__after_morecore_hook) ();
+
+  return result;
+}
+
+/* Set everything up and remember that we have.  */
+static int initialize (void);
+
+static int
+initialize (void)
+{
+  heapsize = HEAP / BLOCKSIZE;
+  _heapinfo = (malloc_info *) align (heapsize * sizeof (malloc_info));
+  if (_heapinfo == NULL)
+    return 0;
+  __bounds_memset (_heapinfo, 0, heapsize * sizeof (malloc_info));
+  _heapinfo[0].free.size = 0;
+  _heapinfo[0].free.next = _heapinfo[0].free.prev = 0;
+  _heapindex = 0;
+  _heapbase = (char *) _heapinfo;
+
+  /* Account for the _heapinfo block itself in the statistics.  */
+  _bytes_used = heapsize * sizeof (malloc_info);
+  _chunks_used = 1;
+
+  __malloc_initialized = 1;
+  return 1;
+}
+
+/* Get neatly aligned memory, initializing or
+   growing the heap info table as necessary. */
+static __ptr_t morecore (__malloc_size_t);
+
+static __ptr_t
+morecore (__malloc_size_t size)
+{
+  __ptr_t result;
+  malloc_info *newinfo, *oldinfo;
+  __malloc_size_t newsize;
+
+  result = align (size);
+  if (result == NULL)
+    return NULL;
+
+  /* Check if we need to grow the info table.  */
+  if ((__malloc_size_t) BLOCK ((char *) result + size) > heapsize)
+    {
+      newsize = heapsize;
+      while ((__malloc_size_t) BLOCK ((char *) result + size) > newsize)
+	newsize *= 2;
+      newinfo = (malloc_info *) align (newsize * sizeof (malloc_info));
+      if (newinfo == NULL)
+	{
+	  (*__morecore) (-size);
+	  return NULL;
+	}
+      __bounds_memcpy (newinfo, _heapinfo, heapsize * sizeof (malloc_info));
+      __bounds_memset (&newinfo[heapsize], 0,
+		       (newsize - heapsize) * sizeof (malloc_info));
+      oldinfo = _heapinfo;
+      newinfo[BLOCK (oldinfo)].busy.type = 0;
+      newinfo[BLOCK (oldinfo)].busy.info.size
+	= BLOCKIFY (heapsize * sizeof (malloc_info));
+      _heapinfo = newinfo;
+      /* Account for the _heapinfo block itself in the statistics.  */
+      _bytes_used += newsize * sizeof (malloc_info);
+      ++_chunks_used;
+      _free_internal (oldinfo);
+      heapsize = newsize;
+    }
+
+  _heaplimit = BLOCK ((char *) result + size);
+  return result;
+}
+
+/* Allocate memory from the heap.  */
+__ptr_t
+__bounds_malloc (__malloc_size_t size)
+{
+  __ptr_t result;
+  __malloc_size_t block, blocks, lastblocks, start;
+  register __malloc_size_t i;
+  struct list *next;
+
+  /* ANSI C allows `malloc (0)' to either return NULL, or to return a
+     valid address you can realloc and free (though not dereference).
+
+     It turns out that some extant code (sunrpc, at least Ultrix's version)
+     expects `malloc (0)' to return non-NULL and breaks otherwise.
+     Be compatible.  */
+
+#if	0
+  if (size == 0)
+    return NULL;
+#endif
+
+  if (__malloc_hook != NULL)
+    return (*__malloc_hook) (size);
+
+  if (!__malloc_initialized)
+    if (!initialize ())
+      return NULL;
+
+  if (size < sizeof (struct list))
+    size = sizeof (struct list);
+
+#ifdef SUNOS_LOCALTIME_BUG
+  if (size < 16)
+    size = 16;
+#endif
+
+  /* Determine the allocation policy based on the request size.  */
+  if (size <= BLOCKSIZE / 2)
+    {
+      /* Small allocation to receive a fragment of a block.
+         Determine the logarithm to base two of the fragment size. */
+      register __malloc_size_t log = 1;
+      --size;
+      while ((size /= 2) != 0)
+	++log;
+
+      /* Look in the fragment lists for a
+         free fragment of the desired size. */
+      next = _fraghead[log].next;
+      if (next != NULL)
+	{
+	  /* There are free fragments of this size.
+	     Pop a fragment out of the fragment list and return it.
+	     Update the block's nfree and first counters. */
+	  result = (__ptr_t) next;
+	  next->prev->next = next->next;
+	  if (next->next != NULL)
+	    next->next->prev = next->prev;
+	  block = BLOCK (result);
+	  if (--_heapinfo[block].busy.info.frag.nfree != 0)
+	    _heapinfo[block].busy.info.frag.first = (unsigned long int)
+	      ((unsigned long int) ((char *) next->next - (char *) NULL)
+	       % BLOCKSIZE) >> log;
+
+	  /* Update the statistics.  */
+	  ++_chunks_used;
+	  _bytes_used += 1 << log;
+	  --_chunks_free;
+	  _bytes_free -= 1 << log;
+	}
+      else
+	{
+	  /* No free fragments of the desired size, so get a new block
+	     and break it into fragments, returning the first.  */
+	  result = __bounds_malloc (BLOCKSIZE);
+	  if (result == NULL)
+	    return NULL;
+
+	  /* Link all fragments but the first into the free list.  */
+	  for (i = 1; i < (__malloc_size_t) (BLOCKSIZE >> log); ++i)
+	    {
+	      next = (struct list *) ((char *) result + (i << log));
+	      next->next = _fraghead[log].next;
+	      next->prev = &_fraghead[log];
+	      next->prev->next = next;
+	      if (next->next != NULL)
+		next->next->prev = next;
+	    }
+
+	  /* Initialize the nfree and first counters for this block.  */
+	  block = BLOCK (result);
+	  _heapinfo[block].busy.type = log;
+	  _heapinfo[block].busy.info.frag.nfree = i - 1;
+	  _heapinfo[block].busy.info.frag.first = i - 1;
+
+	  _chunks_free += (BLOCKSIZE >> log) - 1;
+	  _bytes_free += BLOCKSIZE - (1 << log);
+	  _bytes_used -= BLOCKSIZE - (1 << log);
+	}
+    }
+  else
+    {
+      /* Large allocation to receive one or more blocks.
+         Search the free list in a circle starting at the last place visited.
+         If we loop completely around without finding a large enough
+         space we will have to get more memory from the system.  */
+      blocks = BLOCKIFY (size);
+      start = block = _heapindex;
+      while (_heapinfo[block].free.size < blocks)
+	{
+	  block = _heapinfo[block].free.next;
+	  if (block == start)
+	    {
+	      /* Need to get more from the system.  Check to see if
+	         the new core will be contiguous with the final free
+	         block; if so we don't need to get as much.  */
+	      block = _heapinfo[0].free.prev;
+	      lastblocks = _heapinfo[block].free.size;
+	      if (_heaplimit != 0 && block + lastblocks == _heaplimit &&
+		  (*__morecore) (0) == ADDRESS (block + lastblocks) &&
+		  (morecore ((blocks - lastblocks) * BLOCKSIZE)) != NULL)
+		{
+		  /* Which block we are extending (the `final free
+		     block' referred to above) might have changed, if
+		     it got combined with a freed info table.  */
+		  block = _heapinfo[0].free.prev;
+		  _heapinfo[block].free.size += (blocks - lastblocks);
+		  _bytes_free += (blocks - lastblocks) * BLOCKSIZE;
+		  continue;
+		}
+	      result = morecore (blocks * BLOCKSIZE);
+	      if (result == NULL)
+		return NULL;
+	      block = BLOCK (result);
+	      _heapinfo[block].busy.type = 0;
+	      _heapinfo[block].busy.info.size = blocks;
+	      ++_chunks_used;
+	      _bytes_used += blocks * BLOCKSIZE;
+	      return result;
+	    }
+	}
+
+      /* At this point we have found a suitable free list entry.
+         Figure out how to remove what we need from the list. */
+      result = ADDRESS (block);
+      if (_heapinfo[block].free.size > blocks)
+	{
+	  /* The block we found has a bit left over,
+	     so relink the tail end back into the free list. */
+	  _heapinfo[block + blocks].free.size
+	    = _heapinfo[block].free.size - blocks;
+	  _heapinfo[block + blocks].free.next = _heapinfo[block].free.next;
+	  _heapinfo[block + blocks].free.prev = _heapinfo[block].free.prev;
+	  _heapinfo[_heapinfo[block].free.prev].free.next
+	    = _heapinfo[_heapinfo[block].free.next].free.prev
+	    = _heapindex = block + blocks;
+	}
+      else
+	{
+	  /* The block exactly matches our requirements,
+	     so just remove it from the list. */
+	  _heapinfo[_heapinfo[block].free.next].free.prev
+	    = _heapinfo[block].free.prev;
+	  _heapinfo[_heapinfo[block].free.prev].free.next
+	    = _heapindex = _heapinfo[block].free.next;
+	  --_chunks_free;
+	}
+
+      _heapinfo[block].busy.type = 0;
+      _heapinfo[block].busy.info.size = blocks;
+      ++_chunks_used;
+      _bytes_used += blocks * BLOCKSIZE;
+      _bytes_free -= blocks * BLOCKSIZE;
+    }
+
+  return result;
+}
+
+#if 0				/* Disabled - RWMJ */
+#ifndef _LIBC
+
+/* On some ANSI C systems, some libc functions call _malloc, _free
+   and _realloc.  Make them use the GNU functions.  */
+
+__ptr_t
+_malloc (__malloc_size_t size)
+{
+  return malloc (size);
+}
+
+void
+_free (__ptr_t ptr)
+{
+  free (ptr);
+}
+
+__ptr_t
+_realloc (__ptr_t ptr, __malloc_size_t size)
+{
+  return realloc (ptr, size);
+}
+
+#endif
+#endif /* 0 */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/malloc.h gcc-4.0.2/gcc/bounds/lib/malloc.h
--- gcc-4.0.2.org/gcc/bounds/lib/malloc.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/malloc.h	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,278 @@
+/* Declarations for `malloc' and friends.
+   Copyright 1990, 1991, 1992, 1993 Free Software Foundation, Inc.
+		  Written May 1989 by Mike Haertel.
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public License as
+published by the Free Software Foundation; either version 2 of the
+License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with this library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.
+
+   The author may be reached (Email) at the address mike@ai.mit.edu,
+   or (US mail) as Mike Haertel c/o Free Software Foundation.  */
+
+#ifndef _MALLOC_H
+
+#define _MALLOC_H	1
+
+#ifdef _MALLOC_INTERNAL
+
+#ifdef	HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#if	defined(_LIBC) || defined(STDC_HEADERS) || defined(USG)
+#include <string.h>
+#else
+#ifndef memset
+#define	memset(s, zero, n)	__bounds_memset ((s), (n))
+#endif
+#ifndef memcpy
+#define	memcpy(d, s, n)		__bounds_memmove ((s), (d), (n))
+#endif
+#endif
+
+#if	defined (__GNU_LIBRARY__) || (defined (__STDC__) && __STDC__)
+#include <limits.h>
+#else
+#ifndef CHAR_BIT
+#define	CHAR_BIT	8
+#endif
+#endif
+
+#ifdef	HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#endif /* _MALLOC_INTERNAL.  */
+
+
+#ifdef	__cplusplus
+extern "C"
+{
+#endif
+
+#if defined (__cplusplus) || (defined (__STDC__) && __STDC__)
+#undef	__ptr_t
+#define	__ptr_t		void *
+#else				/* Not C++ or ANSI C.  */
+#undef	const
+#define	const
+#undef	__ptr_t
+#define	__ptr_t		char *
+#endif				/* C++ or ANSI C.  */
+
+#if defined (__STDC__) && __STDC__
+#include <stddef.h>
+#define	__malloc_size_t	size_t
+#else
+#define	__malloc_size_t	unsigned int
+#endif
+
+#ifndef	NULL
+#define	NULL	0
+#endif
+
+
+/* Allocate SIZE bytes of memory.  */
+  extern __ptr_t malloc (size_t __size);
+/* Re-allocate the previously allocated block
+   in __ptr_t, making the new block SIZE bytes long.  */
+  extern __ptr_t realloc (__ptr_t __ptr, size_t __size);
+/* Allocate NMEMB elements of SIZE bytes each, all initialized to 0.  */
+  extern __ptr_t calloc (size_t __nmemb, size_t __size);
+/* Free a block allocated by `malloc', `realloc' or `calloc'.  */
+  extern void free (__ptr_t __ptr);
+
+/* Allocate SIZE bytes allocated to ALIGNMENT bytes.  */
+  extern __ptr_t memalign (size_t __alignment, size_t __size);
+
+/* Allocate SIZE bytes on a page boundary.  */
+  extern __ptr_t valloc (size_t __size);
+
+
+#ifdef _MALLOC_INTERNAL
+
+/* The allocator divides the heap into blocks of fixed size; large
+   requests receive one or more whole blocks, and small requests
+   receive a fragment of a block.  Fragment sizes are powers of two,
+   and all fragments of a block are the same size.  When all the
+   fragments in a block have been freed, the block itself is freed.  */
+#define INT_BIT		(CHAR_BIT * sizeof(int))
+#define BLOCKLOG	(INT_BIT > 16 ? 12 : 9)
+#define BLOCKSIZE	(1 << BLOCKLOG)
+#define BLOCKIFY(SIZE)	(((SIZE) + BLOCKSIZE - 1) / BLOCKSIZE)
+
+/* Determine the amount of memory spanned by the initial heap table
+   (not an absolute limit).  */
+#define HEAP		(INT_BIT > 16 ? 4194304 : 65536)
+
+/* Number of contiguous free blocks allowed to build up at the end of
+   memory before they will be returned to the system.  */
+#define FINAL_FREE_BLOCKS	8
+
+/* Data structure giving per-block information.  */
+  typedef union
+  {
+    /* Heap information for a busy block.  */
+    struct
+    {
+      /* Zero for a large block, or positive giving the
+         logarithm to the base two of the fragment size.  */
+      int type;
+      union
+      {
+	struct
+	{
+	  __malloc_size_t nfree;	/* Free frags in a fragmented block.  */
+	  __malloc_size_t first;	/* First free fragment of the block.  */
+	} frag;
+	/* Size (in blocks) of a large cluster.  */
+	__malloc_size_t size;
+      } info;
+    } busy;
+    /* Heap information for a free block
+       (that may be the first of a free cluster).  */
+    struct
+    {
+      __malloc_size_t size;	/* Size (in blocks) of a free cluster.  */
+      __malloc_size_t next;	/* Index of next free cluster.  */
+      __malloc_size_t prev;	/* Index of previous free cluster.  */
+    } free;
+  } malloc_info;
+
+/* Pointer to first block of the heap.  */
+  extern char *_heapbase;
+
+/* Table indexed by block number giving per-block information.  */
+  extern malloc_info *_heapinfo;
+
+/* Address to block number and vice versa.  */
+#define BLOCK(A)	(((char *) (A) - _heapbase) / BLOCKSIZE + 1)
+#define ADDRESS(B)	((__ptr_t) (((B) - 1) * BLOCKSIZE + _heapbase))
+
+/* Current search index for the heap table.  */
+  extern __malloc_size_t _heapindex;
+
+/* Limit of valid info table indices.  */
+  extern __malloc_size_t _heaplimit;
+
+/* Doubly linked lists of free fragments.  */
+  struct list
+  {
+    struct list *next;
+    struct list *prev;
+  };
+
+/* Free list headers for each fragment size.  */
+  extern struct list _fraghead[];
+
+/* List of blocks allocated with `memalign' (or `valloc').  */
+  struct alignlist
+  {
+    struct alignlist *next;
+    __ptr_t aligned;		/* The address that memaligned returned.  */
+    __ptr_t exact;		/* The address that malloc returned.  */
+  };
+  extern struct alignlist *_aligned_blocks;
+
+/* Instrumentation.  */
+  extern __malloc_size_t _chunks_used;
+  extern __malloc_size_t _bytes_used;
+  extern __malloc_size_t _chunks_free;
+  extern __malloc_size_t _bytes_free;
+
+/* Internal version of `free' used in `morecore' (malloc.c). */
+  extern void _free_internal (__ptr_t __ptr);
+
+#endif				/* _MALLOC_INTERNAL.  */
+
+/* Underlying allocation function; successive calls should
+   return contiguous pieces of memory.  */
+  extern __ptr_t (*__morecore) (ptrdiff_t __size);
+
+/* Default value of `__morecore'.  */
+  extern __ptr_t __default_morecore (ptrdiff_t __size);
+
+/* If not NULL, this function is called after each time
+   `__morecore' is called to increase the data size.  */
+  extern void (*__after_morecore_hook) (void);
+
+/* Nonzero if `malloc' has been called and done its initialization.  */
+  extern int __malloc_initialized;
+
+/* Hooks for debugging versions.  */
+  extern void (*__free_hook) (__ptr_t __ptr);
+  extern __ptr_t (*__malloc_hook) (size_t __size);
+  extern __ptr_t (*__realloc_hook) (__ptr_t __ptr, size_t __size);
+
+/* Return values for `mprobe': these are the kinds of inconsistencies that
+   `mcheck' enables detection of.  */
+  enum mcheck_status
+  {
+    MCHECK_DISABLED = -1,	/* Consistency checking is not turned on.  */
+    MCHECK_OK,			/* Block is fine.  */
+    MCHECK_FREE,		/* Block freed twice.  */
+    MCHECK_HEAD,		/* Memory before the block was clobbered.  */
+    MCHECK_TAIL			/* Memory after the block was clobbered.  */
+  };
+
+/* Activate a standard collection of debugging hooks.  This must be called
+   before `malloc' is ever called.  ABORTFUNC is called with an error code
+   (see enum above) when an inconsistency is detected.  If ABORTFUNC is
+   null, the standard function prints on stderr and then calls `abort'.  */
+  extern int mcheck (void (*__abortfunc) (enum mcheck_status));
+
+/* Check for aberrations in a particular malloc'd block.  You must have
+   called `mcheck' already.  These are the same checks that `mcheck' does
+   when you free or reallocate a block.  */
+  extern enum mcheck_status mprobe (__ptr_t __ptr);
+
+/* Activate a standard collection of tracing hooks.  */
+  extern void mtrace (void);
+  extern void muntrace (void);
+
+/* Statistics available to the user.  */
+  struct mstats
+  {
+    __malloc_size_t bytes_total;	/* Total size of the heap. */
+    __malloc_size_t chunks_used;	/* Chunks allocated by the user. */
+    __malloc_size_t bytes_used;	/* Byte total of user-allocated chunks. */
+    __malloc_size_t chunks_free;	/* Chunks in the free list. */
+    __malloc_size_t bytes_free;	/* Byte total of chunks in the free list. */
+  };
+
+/* Pick up the current statistics. */
+  extern struct mstats mstats (void);
+
+/* Call WARNFUN with a warning message when memory usage is high.  */
+  extern void memory_warnings (__ptr_t __start,
+			       void (*__warnfun) (const char *));
+
+
+/* Relocating allocator.  */
+
+/* Allocate SIZE bytes, and store the address in *HANDLEPTR.  */
+  extern __ptr_t r_alloc (__ptr_t * __handleptr, size_t __size);
+
+/* Free the storage allocated in HANDLEPTR.  */
+  extern void r_alloc_free (__ptr_t * __handleptr);
+
+/* Adjust the block at HANDLEPTR to be SIZE bytes long.  */
+  extern __ptr_t r_re_alloc (__ptr_t * __handleptr, size_t __size);
+
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif				/* malloc.h  */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/mcheck.c gcc-4.0.2/gcc/bounds/lib/mcheck.c
--- gcc-4.0.2.org/gcc/bounds/lib/mcheck.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/mcheck.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,213 @@
+/* Standard debugging hooks for `malloc'.
+   Copyright 1990, 1991, 1992, 1993, 1994 Free Software Foundation, Inc.
+   Written May 1989 by Mike Haertel.
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public License as
+published by the Free Software Foundation; either version 2 of the
+License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with this library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.
+
+   The author may be reached (Email) at the address mike@ai.mit.edu,
+   or (US mail) as Mike Haertel c/o Free Software Foundation.  */
+
+#include "bounds-lib.h"
+
+#ifndef	_MALLOC_INTERNAL
+#define	_MALLOC_INTERNAL
+#include <malloc.h>
+#include <stdio.h>
+#endif
+
+/* Old hook values.  */
+static void (*old_free_hook) (__ptr_t ptr);
+static __ptr_t (*old_malloc_hook) (__malloc_size_t size);
+static __ptr_t (*old_realloc_hook) (__ptr_t ptr, __malloc_size_t size);
+
+/* Function to call when something awful happens.  */
+static void (*abortfunc) (enum mcheck_status);
+
+/* Arbitrary magical numbers.  */
+#define MAGICWORD	0xfedabeeb
+#define MAGICFREE	0xd8675309
+#define MAGICBYTE	((char) 0xd7)
+#define MALLOCFLOOD	((char) 0x93)
+#define FREEFLOOD	((char) 0x95)
+
+struct hdr
+{
+  __malloc_size_t size;		/* Exact size requested by user.  */
+  unsigned long int magic;	/* Magic number to check header integrity.  */
+};
+
+#if	defined(_LIBC) || defined(STDC_HEADERS) || defined(USG)
+#define flood __bounds_memset
+#else
+static void flood (__ptr_t, int, __malloc_size_t);
+
+static void
+flood (__ptr_t ptr, int val, __malloc_size_t size)
+{
+  char *cp = ptr;
+  while (size--)
+    *cp++ = val;
+}
+#endif
+
+static enum mcheck_status checkhdr (const struct hdr *);
+
+static enum mcheck_status
+checkhdr (const struct hdr *hdr)
+{
+  enum mcheck_status status;
+  switch (hdr->magic)
+    {
+    default:
+      status = MCHECK_HEAD;
+      break;
+    case MAGICFREE:
+      status = MCHECK_FREE;
+      break;
+    case MAGICWORD:
+      if (((char *) &hdr[1])[hdr->size] != MAGICBYTE)
+	status = MCHECK_TAIL;
+      else
+	status = MCHECK_OK;
+      break;
+    }
+  if (status != MCHECK_OK)
+    (*abortfunc) (status);
+  return status;
+}
+
+static void freehook (__ptr_t);
+
+static void
+freehook (__ptr_t ptr)
+{
+  struct hdr *hdr = ((struct hdr *) ptr) - 1;
+  checkhdr (hdr);
+  hdr->magic = MAGICFREE;
+  flood (ptr, FREEFLOOD, hdr->size);
+  __free_hook = old_free_hook;
+  __bounds_free (hdr);
+  __free_hook = freehook;
+}
+
+static __ptr_t mallochook (__malloc_size_t);
+
+static __ptr_t
+mallochook (__malloc_size_t size)
+{
+  struct hdr *hdr;
+
+  __malloc_hook = old_malloc_hook;
+  hdr = (struct hdr *) __bounds_malloc (sizeof (struct hdr) + size + 1);
+  __malloc_hook = mallochook;
+  if (hdr == NULL)
+    return NULL;
+
+  hdr->size = size;
+  hdr->magic = MAGICWORD;
+  ((char *) &hdr[1])[size] = MAGICBYTE;
+  flood ((__ptr_t) (hdr + 1), MALLOCFLOOD, size);
+  return (__ptr_t) (hdr + 1);
+}
+
+static __ptr_t reallochook (__ptr_t, __malloc_size_t);
+
+static __ptr_t
+reallochook (__ptr_t ptr, __malloc_size_t size)
+{
+  struct hdr *hdr = ((struct hdr *) ptr) - 1;
+  __malloc_size_t osize = hdr->size;
+
+  checkhdr (hdr);
+  if (size < osize)
+    flood ((char *) ptr + size, FREEFLOOD, osize - size);
+  __free_hook = old_free_hook;
+  __malloc_hook = old_malloc_hook;
+  __realloc_hook = old_realloc_hook;
+  hdr =
+    (struct hdr *) __bounds_realloc ((__ptr_t) hdr,
+				     sizeof (struct hdr) + size + 1);
+  __free_hook = freehook;
+  __malloc_hook = mallochook;
+  __realloc_hook = reallochook;
+  if (hdr == NULL)
+    return NULL;
+
+  hdr->size = size;
+  hdr->magic = MAGICWORD;
+  ((char *) &hdr[1])[size] = MAGICBYTE;
+  if (size > osize)
+    flood ((char *) (hdr + 1) + osize, MALLOCFLOOD, size - osize);
+  return (__ptr_t) (hdr + 1);
+}
+
+static void
+mabort (enum mcheck_status status)
+{
+  const char *msg;
+  switch (status)
+    {
+    case MCHECK_OK:
+      msg = "memory is consistent, library is buggy";
+      break;
+    case MCHECK_HEAD:
+      msg = "memory clobbered before allocated block";
+      break;
+    case MCHECK_TAIL:
+      msg = "memory clobbered past end of allocated block";
+      break;
+    case MCHECK_FREE:
+      msg = "block freed twice";
+      break;
+    default:
+      msg = "bogus mcheck_status, library is buggy";
+      break;
+    }
+#if 0 && defined(__GNU_LIBRARY__)
+  __libc_fatal (msg);
+#else
+  printf ("mcheck: %s\n", msg);
+  abort ();
+#endif
+}
+
+static int mcheck_used = 0;
+
+int
+mcheck (void (*func) (enum mcheck_status))
+{
+  abortfunc = (func != NULL) ? func : &mabort;
+
+  /* These hooks may not be safely inserted if malloc is already in use.  */
+  if (!__malloc_initialized && !mcheck_used)
+    {
+      old_free_hook = __free_hook;
+      __free_hook = freehook;
+      old_malloc_hook = __malloc_hook;
+      __malloc_hook = mallochook;
+      old_realloc_hook = __realloc_hook;
+      __realloc_hook = reallochook;
+      mcheck_used = 1;
+    }
+
+  return mcheck_used ? 0 : -1;
+}
+
+enum mcheck_status
+mprobe (__ptr_t ptr)
+{
+  return mcheck_used ? checkhdr (ptr) : MCHECK_DISABLED;
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/mcheck-init.c gcc-4.0.2/gcc/bounds/lib/mcheck-init.c
--- gcc-4.0.2.org/gcc/bounds/lib/mcheck-init.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/mcheck-init.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,36 @@
+/* Copyright (C) 1991 Free Software Foundation, Inc.
+This file is part of the GNU C Library.
+
+The GNU C Library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public License as
+published by the Free Software Foundation; either version 2 of the
+License, or (at your option) any later version.
+
+The GNU C Library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with the GNU C Library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.  */
+
+/* The object of this file should be installed as libmcheck.a,
+   so one can do -lmcheck to turn on mcheck.  */
+
+#ifdef	HAVE_GNU_LD
+
+#include <ansidecl.h>
+#include <malloc.h>
+#include <gnu-stabs.h>
+
+static void
+DEFUN_VOID (turn_on_mcheck)
+{
+  mcheck (NULL);
+}
+
+text_set_element (__libc_subinit, turn_on_mcheck);
+
+#endif
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/memalign.c gcc-4.0.2/gcc/bounds/lib/memalign.c
--- gcc-4.0.2.org/gcc/bounds/lib/memalign.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/memalign.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,62 @@
+/* Copyright (C) 1991, 1992, 1993, 1994 Free Software Foundation, Inc.
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public License as
+published by the Free Software Foundation; either version 2 of the
+License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with this library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.  */
+
+#include "bounds-lib.h"
+
+#ifndef	_MALLOC_INTERNAL
+#define _MALLOC_INTERNAL
+#include <malloc.h>
+#endif
+
+__ptr_t
+__bounds_memalign (__malloc_size_t alignment, __malloc_size_t size)
+{
+  __ptr_t result;
+  unsigned long int adj;
+
+  size = ((size + alignment - 1) / alignment) * alignment;
+
+  result = __bounds_malloc (size);
+  if (result == NULL)
+    return NULL;
+  adj = (unsigned long int) ((unsigned long int) ((char *) result -
+						  (char *) NULL)) % alignment;
+  if (adj != 0)
+    {
+      struct alignlist *l;
+      for (l = _aligned_blocks; l != NULL; l = l->next)
+	if (l->aligned == NULL)
+	  /* This slot is free.  Use it.  */
+	  break;
+      if (l == NULL)
+	{
+	  l =
+	    (struct alignlist *) __bounds_malloc (sizeof (struct alignlist));
+	  if (l == NULL)
+	    {
+	      __bounds_free (result);
+	      return NULL;
+	    }
+	  l->next = _aligned_blocks;
+	  _aligned_blocks = l;
+	}
+      l->exact = result;
+      result = l->aligned = (char *) result + alignment - adj;
+    }
+
+  return result;
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/mem-limits.h gcc-4.0.2/gcc/bounds/lib/mem-limits.h
--- gcc-4.0.2.org/gcc/bounds/lib/mem-limits.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/mem-limits.h	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,193 @@
+/* Includes for memory limit warnings.
+   Copyright (C) 1990, 1993, 1994 Free Software Foundation, Inc.
+
+
+This file is part of the GNU C Library.  Its master source is NOT part of
+the C library, however.  The master source lives in /gd/gnu/lib.
+
+The GNU C Library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public License as
+published by the Free Software Foundation; either version 2 of the
+License, or (at your option) any later version.
+
+The GNU C Library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with the GNU C Library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.  */
+
+#ifdef MSDOS
+#include <dpmi.h>
+#endif
+
+/* Some systems need this before <sys/resource.h>.  */
+#include <sys/types.h>
+
+#ifdef _LIBC
+
+#include <sys/resource.h>
+#define BSD4_2			/* Tell code below to use getrlimit.  */
+
+#else
+
+#if defined (__osf__) && (defined (__mips) || defined (mips) || defined(__alpha))
+#include <sys/time.h>
+#include <sys/resource.h>
+#endif
+
+#ifdef __bsdi__
+#define BSD4_2
+#endif
+
+#if defined(__FreeBSD__) && !defined(BSD4_2)
+#define BSD4_2
+#ifdef USG
+#undef USG
+#endif
+#endif
+
+#ifndef BSD4_2
+#ifndef USG
+#ifndef MSDOS
+#ifndef WINDOWSNT
+#include <sys/vlimit.h>
+#endif /* not WINDOWSNT */
+#endif /* not MSDOS */
+#endif /* not USG */
+#else /* if BSD4_2 */
+#include <sys/time.h>
+#include <sys/resource.h>
+#endif /* BSD4_2 */
+
+#endif /* _LIBC */
+
+#ifdef emacs
+/* The important properties of this type are that 1) it's a pointer, and
+   2) arithmetic on it should work as if the size of the object pointed
+   to has a size of 1.  */
+#ifdef __STDC__
+typedef void *POINTER;
+#else
+typedef char *POINTER;
+#endif
+
+typedef unsigned long SIZE;
+
+#ifdef NULL
+#undef NULL
+#endif
+#define NULL ((POINTER) 0)
+
+extern POINTER start_of_data ();
+#ifdef DATA_SEG_BITS
+#define EXCEEDS_LISP_PTR(ptr) \
+  (((EMACS_UINT) (ptr) & ~DATA_SEG_BITS) >> VALBITS)
+#else
+#define EXCEEDS_LISP_PTR(ptr) ((EMACS_UINT) (ptr) >> VALBITS)
+#endif
+
+#ifdef BSD
+#ifndef DATA_SEG_BITS
+extern char etext;
+#define start_of_data() &etext
+#endif
+#endif
+
+#else /* Not emacs */
+extern char etext;
+#define start_of_data() &etext
+#endif /* Not emacs */
+
+#ifdef __vxworks
+#define	NO_LIM_DATA
+#endif
+
+/* start of data space; can be changed by calling malloc_init */
+static POINTER data_space_start;
+
+/* Number of bytes of writable memory we can expect to be able to get */
+static unsigned int lim_data;
+
+#ifdef NO_LIM_DATA
+static void
+get_lim_data ()
+{
+  lim_data = -1;
+}
+#else /* not NO_LIM_DATA */
+
+#ifdef USG
+
+static void
+get_lim_data (void)
+{
+  extern long ulimit (int, long);
+
+  lim_data = -1;
+
+  /* Use the ulimit call, if we seem to have it.  */
+#if !defined (ULIMIT_BREAK_VALUE) || defined (LINUX)
+  lim_data = ulimit (3, 0);
+#endif
+
+  /* If that didn't work, just use the macro's value.  */
+#ifdef ULIMIT_BREAK_VALUE
+  if (lim_data == -1)
+    lim_data = ULIMIT_BREAK_VALUE;
+#endif
+
+  lim_data -= (long) data_space_start;
+}
+
+#else /* not USG */
+#ifdef WINDOWSNT
+
+static void
+get_lim_data ()
+{
+  extern unsigned long data_region_size;
+  lim_data = data_region_size;
+}
+
+#else
+#if !defined (BSD4_2) && !defined (__osf__)
+
+#ifdef MSDOS
+void
+get_lim_data ()
+{
+  _go32_dpmi_meminfo info;
+
+  _go32_dpmi_get_free_memory_information (&info);
+  lim_data = info.available_memory;
+}
+#else /* not MSDOS */
+static void
+get_lim_data ()
+{
+  lim_data = vlimit (LIM_DATA, -1);
+}
+#endif /* not MSDOS */
+
+#else /* BSD4_2 */
+
+static void
+get_lim_data ()
+{
+  struct rlimit XXrlimit;
+
+  getrlimit (RLIMIT_DATA, &XXrlimit);
+#ifdef RLIM_INFINITY
+  lim_data = XXrlimit.rlim_cur & RLIM_INFINITY;	/* soft limit */
+#else
+  lim_data = XXrlimit.rlim_cur;	/* soft limit */
+#endif
+}
+#endif /* BSD4_2 */
+#endif /* not WINDOWSNT */
+#endif /* not USG */
+#endif /* not NO_LIM_DATA */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/mmap.c gcc-4.0.2/gcc/bounds/lib/mmap.c
--- gcc-4.0.2.org/gcc/bounds/lib/mmap.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/mmap.c	2005-09-29 18:00:27.000000000 +0200
@@ -0,0 +1,74 @@
+/* Bounds Checking for GCC.
+   Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+ 
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   File:
+  	lib/malloc/mmap.c
+   Summary:
+  	Bounds checking interface to the GNU C malloc library. The GNU
+  	malloc has been modified to provide the unchecked functions
+  	like '__bounds_malloc' directly. We provide the checked versions
+  	(eg. 'mmap') here.
+   Other notes:
+  	
+   Author      	Date		Notes
+   HtB		1/7/99		Initial implementation.
+*/
+
+#include <stddef.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include "bounds-lib.h"
+#include "mutex.h"		/* for 'enter|leave_critical_section'  */
+
+void *mmap (void *start, size_t size, int prot,
+	    int flags, int fd, off_t offset);
+int munmap (void *start, size_t size);
+
+void *
+__bounds_check_mmap (const char *filename, int line,
+		     void *start, size_t size, int prot,
+		     int flags, int fd, off_t offset)
+{
+  void *result;
+  sigset_t old_mask;
+
+  enter_critical_section (&old_mask);
+  result = mmap (start, size, prot, flags, fd, offset);
+  if (__bounds_check_mmap_calls && result != (void *) -1)
+    __bounds_add_heap_object (result, size, 1, "mmap", 1, filename, line);
+  leave_critical_section (&old_mask);
+
+  return result;
+}
+
+int
+__bounds_check_munmap (const char *filename, int line, void *start,
+		       size_t size)
+{
+  int result;
+  sigset_t old_mask;
+
+  enter_critical_section (&old_mask);
+  result = munmap (start, size);
+  if (__bounds_check_mmap_calls && result == 0)
+    __bounds_delete_heap_object (start, size,
+				 "invalid pointer passed to `munmap'",
+				 filename, line, NULL);
+  leave_critical_section (&old_mask);
+
+  return result;
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/morecore.c gcc-4.0.2/gcc/bounds/lib/morecore.c
--- gcc-4.0.2.org/gcc/bounds/lib/morecore.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/morecore.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,140 @@
+/*	Default implementation of `morecore'. Only use this if you lack
+ *	`__default_morecore' in your C library.
+ *	Written By Richard W.M. Jones <rjones@orchestream.com>
+ *
+ * Further notes (21/8/95):
+ *	Lots more people than I anticipated don't have `__default_morecore'
+ *	so this file has caused a bit of trouble. So I'll explain here what
+ *	this does so I don't have to tell 100s of people the same thing
+ *	separately. Basically, `__default_morecore' is required by GNU
+ *	malloc to grab large chunks of memory from the OS. There are two
+ *	ways of doing this in modern Unix systems. The original way was
+ *	to extend the data area by calling `sbrk'. However, what with DLLs
+ *	and advanced memory mapping, this method has generally been super-
+ *	ceeded by making direct calls to `mmap' which gives a lot more
+ *	control over where in the address space the new memory is placed.
+ *	Now, there are two versions of `__default_morecore' here. The first
+ *	(for Linux, etc.) is the `mmap' version. I recommend you try
+ *	this first. If it doesn't work, use the second version (for
+ *	Suns, SVR-4, etc.). If you get a particular machine to work with
+ *	one or other version, then can you send me patches to this file to
+ *	support the project for other users.
+ *
+ * Even more notes (12/1/96):
+ *	As suggested by Eberhard Mattes <mattes@
+ *	azu.informatik.uni-stuttgart.de>, I have added HAVE_MMAP and
+ *	HAVE_DEFAULT_MORECORE symbols at the top of the file, to make it easier
+ *	to fix this.
+ *   ->	If you have `__default_morecore' in your C library already, set
+ *	HAVE_DEFAULT_MORECORE.
+ *   ->	If you have `mmap' (most modern Unix machines do), set HAVE_MMAP.
+ */
+
+#include "malloc.h"
+#include "bounds-lib.h"
+
+#if defined(linux) || defined(hpux)
+#define HAVE_MMAP
+#undef HAVE_DEFAULT_MORECORE
+#endif
+
+#if defined(sun) || defined (__svr4__) || defined (_AIX) || defined (__osf__) || defined (ultrix) || defined (__EMX__)
+#undef HAVE_MMAP
+#undef HAVE_DEFAULT_MORECORE
+#endif
+
+#ifdef __vxworks
+
+void *
+__default_morecore (ptrdiff_t incr)
+{
+  void *ptr = malloc (incr);
+  if (ptr == (void *) -1)
+    return NULL;
+  else
+    return ptr;
+}
+
+#else
+
+#if !defined(HAVE_DEFAULT_MORECORE)
+
+#if defined(HAVE_MMAP)
+
+/* Note: `sbrk' doesn't seem to work properly under Linux. For some reason
+ * it returns ENOMEM more often than it should. I'm using mmap/munmap here
+ * which is (supposedly) faster anyhow.
+ */
+
+#include <stddef.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include "getpagesize.h"
+
+#define PERMISSIONS (PROT_READ | PROT_WRITE)
+#define MAPPING_TYPE (MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS)
+
+void *
+__default_morecore (ptrdiff_t incr)
+{
+  static void *address = NULL;
+
+  if (address == NULL)
+    {
+      unsigned pagesize = getpagesize ();
+
+      address = sbrk (0);
+      if (address == NULL)
+	return NULL;
+
+      /* Address may not be aligned to a page. Make it so. `malloc' seems
+       * to only ask for multiples of whole pages so it should remain
+       * aligned after this.
+       */
+      if (((unsigned) address & (pagesize - 1)) != 0)
+	address += pagesize - ((unsigned) address & (pagesize - 1));
+    }
+  if (incr == 0)
+    return address;
+  if (incr < 0)			/* Allow the heap to shrink by unmapping memory. */
+    {
+      address += incr;
+      munmap (address, -incr);
+      return address;
+    }
+  if (mmap (address, incr, PERMISSIONS, MAPPING_TYPE, -1, 0) != address)
+    return NULL;
+  address += incr;
+  return address - incr;
+}
+
+#else /* Not HAVE_MMAP */
+
+/* This is the sbrk version of __default_morecore for use on Suns
+ * and other machines.
+ */
+
+#include <stddef.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#if defined (sun) || defined (_AIX)
+void *sbrk (ptrdiff_t);
+#endif
+
+void *
+__default_morecore (ptrdiff_t incr)
+{
+  void *ptr = sbrk (incr);
+  if (ptr == (void *) -1)
+    return NULL;
+  else
+    return ptr;
+}
+
+#endif /* Not HAVE_MMAP */
+
+#endif /* Not HAVE_DEFAULT_MORECORE */
+
+#endif /* __vxworks */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/mstats.c gcc-4.0.2/gcc/bounds/lib/mstats.c
--- gcc-4.0.2.org/gcc/bounds/lib/mstats.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/mstats.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,41 @@
+/* Access the statistics maintained by `malloc'.
+   Copyright 1990, 1991, 1992 Free Software Foundation, Inc.
+		  Written May 1989 by Mike Haertel.
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public License as
+published by the Free Software Foundation; either version 2 of the
+License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with this library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.
+
+   The author may be reached (Email) at the address mike@ai.mit.edu,
+   or (US mail) as Mike Haertel c/o Free Software Foundation.  */
+
+#include "bounds-lib.h"
+
+#ifndef	_MALLOC_INTERNAL
+#define _MALLOC_INTERNAL
+#include <malloc.h>
+#endif
+
+struct mstats
+mstats (void)
+{
+  struct mstats result;
+
+  result.bytes_total = (char *) (*__morecore) (0) - _heapbase;
+  result.chunks_used = _chunks_used;
+  result.bytes_used = _bytes_used;
+  result.chunks_free = _chunks_free;
+  result.bytes_free = _bytes_free;
+  return result;
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/mtrace.awk gcc-4.0.2/gcc/bounds/lib/mtrace.awk
--- gcc-4.0.2.org/gcc/bounds/lib/mtrace.awk	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/mtrace.awk	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,50 @@
+#
+#  Awk program to analyze mtrace.c output.
+#
+{
+  if ($1 == "@") {
+    where = " (" $2 ")"
+    n = 3
+  } else {
+    where = ""
+    n = 1
+  }
+  if ($n == "+") {
+    if (allocated[$(n+1)] != "")
+      print "+", $(n+1), "Alloc", NR, "duplicate:", allocated[$(n+1)], wherewas[$(n+1)], where;
+    else {
+      wherewas[$(n+1)] = where;
+      allocated[$(n+1)] = $(n+2);
+    }
+  } else if ($n == "-") {
+    if (allocated[$(n+1)] != "") {
+      wherewas[$(n+1)] = "";
+      allocated[$(n+1)] = "";
+      if (allocated[$(n+1)] != "")
+	print "DELETE FAILED", $(n+1), allocated[$(n+1)];
+    } else
+      print "-", $(n+1), "Free", NR, "was never alloc'd", where;
+  } else if ($n == "<")	{
+    if (allocated[$(n+1)] != "") {
+      wherewas[$(n+1)] = "";
+      allocated[$(n+1)] = "";
+    } else
+      print "-", $(n+1), "Realloc", NR, "was never alloc'd", where;
+  } else if ($n == ">") {
+    if (allocated[$(n+1)] != "")
+      print "+", $(n+1), "Realloc", NR, "duplicate:", allocated[$(n+1)], where;
+    else {
+      wherewas[$(n+1)] = $(n+2);
+      allocated[$(n+1)] = $(n+2);
+    }
+  } else if ($n == "=") {
+    # Ignore "= Start"
+  } else if ($n == "!") {
+    # Ignore failed realloc attempts for now
+  }
+}
+END {
+  for (x in allocated) 
+    if (allocated[x] != "")
+      print "+", x, allocated[x], wherewas[x];
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/mtrace.c gcc-4.0.2/gcc/bounds/lib/mtrace.c
--- gcc-4.0.2.org/gcc/bounds/lib/mtrace.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/mtrace.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,189 @@
+/* More debugging hooks for `malloc'.
+   Copyright (C) 1991, 1992, 1993, 1994 Free Software Foundation, Inc.
+		 Written April 2, 1991 by John Gilmore of Cygnus Support.
+		 Based on mcheck.c by Mike Haertel.
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public License as
+published by the Free Software Foundation; either version 2 of the
+License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with this library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.
+
+   The author may be reached (Email) at the address mike@ai.mit.edu,
+   or (US mail) as Mike Haertel c/o Free Software Foundation.  */
+
+#include <stdio.h>
+
+#include "bounds-lib.h"
+
+#ifndef	_MALLOC_INTERNAL
+#define	_MALLOC_INTERNAL
+#include <malloc.h>
+#endif
+
+#ifndef	__GNU_LIBRARY__
+extern char *getenv (const char *);
+#else
+#include <stdlib.h>
+#endif
+
+static FILE *mallstream;
+static char mallenv[] = "MALLOC_TRACE";
+static char mallbuf[BUFSIZ];	/* Buffer for the output.  */
+
+/* Address to breakpoint on accesses to... */
+__ptr_t mallwatch;
+
+/* File name and line number information, for callers that had
+   the foresight to call through a macro.  */
+char *_mtrace_file;
+int _mtrace_line;
+
+/* Old hook values.  */
+static void (*tr_old_free_hook) (__ptr_t ptr);
+static __ptr_t (*tr_old_malloc_hook) (__malloc_size_t size);
+static __ptr_t (*tr_old_realloc_hook) (__ptr_t ptr, __malloc_size_t size);
+
+/* This function is called when the block being alloc'd, realloc'd, or
+   freed has an address matching the variable "mallwatch".  In a debugger,
+   set "mallwatch" to the address of interest, then put a breakpoint on
+   tr_break.  */
+
+void tr_break (void);
+
+void
+tr_break (void)
+{
+}
+
+static void tr_where (void);
+static void
+tr_where (void)
+{
+  if (_mtrace_file)
+    {
+      fprintf (mallstream, "@ %s:%d ", _mtrace_file, _mtrace_line);
+      _mtrace_file = NULL;
+    }
+}
+
+static void tr_freehook (__ptr_t);
+
+static void
+tr_freehook (__ptr_t ptr)
+{
+  tr_where ();
+  fprintf (mallstream, "- %p\n", ptr);	/* Be sure to print it first.  */
+  if (ptr == mallwatch)
+    tr_break ();
+  __free_hook = tr_old_free_hook;
+  __bounds_free (ptr);
+  __free_hook = tr_freehook;
+}
+
+static __ptr_t tr_mallochook (__malloc_size_t);
+
+static __ptr_t
+tr_mallochook (__malloc_size_t size)
+{
+  __ptr_t hdr;
+
+  __malloc_hook = tr_old_malloc_hook;
+  hdr = (__ptr_t) __bounds_malloc (size);
+  __malloc_hook = tr_mallochook;
+
+  tr_where ();
+  /* We could be printing a NULL here; that's OK.  */
+  fprintf (mallstream, "+ %p %lx\n", hdr, (unsigned long) size);
+
+  if (hdr == mallwatch)
+    tr_break ();
+
+  return hdr;
+}
+
+static __ptr_t tr_reallochook (__ptr_t, __malloc_size_t);
+
+static __ptr_t
+tr_reallochook (__ptr_t ptr, __malloc_size_t size)
+{
+  __ptr_t hdr;
+
+  if (ptr == mallwatch)
+    tr_break ();
+
+  __free_hook = tr_old_free_hook;
+  __malloc_hook = tr_old_malloc_hook;
+  __realloc_hook = tr_old_realloc_hook;
+  hdr = (__ptr_t) __bounds_realloc (ptr, size);
+  __free_hook = tr_freehook;
+  __malloc_hook = tr_mallochook;
+  __realloc_hook = tr_reallochook;
+  tr_where ();
+  if (hdr == NULL)
+    /* Failed realloc.  */
+    fprintf (mallstream, "! %p %lx\n", ptr, (unsigned long) size);
+  else
+    fprintf (mallstream, "< %p\n> %p %lx\n", ptr, hdr, (unsigned long) size);
+
+  if (hdr == mallwatch)
+    tr_break ();
+
+  return hdr;
+}
+
+/* We enable tracing if either the environment variable MALLOC_TRACE
+   is set, or if the variable mallwatch has been patched to an address
+   that the debugging user wants us to stop on.  When patching mallwatch,
+   don't forget to set a breakpoint on tr_break!  */
+
+void
+mtrace (void)
+{
+  char *mallfile;
+
+  /* Don't panic if we're called more than once.  */
+  if (mallstream != NULL)
+    return;
+
+  mallfile = getenv (mallenv);
+  if (mallfile != NULL || mallwatch != NULL)
+    {
+      mallstream = fopen (mallfile != NULL ? mallfile : "/dev/null", "w");
+      if (mallstream != NULL)
+	{
+	  /* Be sure it doesn't malloc its buffer!  */
+	  setbuf (mallstream, mallbuf);
+	  fprintf (mallstream, "= Start\n");
+	  tr_old_free_hook = __free_hook;
+	  __free_hook = tr_freehook;
+	  tr_old_malloc_hook = __malloc_hook;
+	  __malloc_hook = tr_mallochook;
+	  tr_old_realloc_hook = __realloc_hook;
+	  __realloc_hook = tr_reallochook;
+	}
+    }
+}
+
+void
+muntrace (void)
+{
+  if (mallstream == NULL)
+    return;
+
+  fprintf (mallstream, "= End\n");
+  fclose (mallstream);
+  mallstream = NULL;
+  __free_hook = tr_old_free_hook;
+  __malloc_hook = tr_old_malloc_hook;
+  __realloc_hook = tr_old_realloc_hook;
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/mutex.h gcc-4.0.2/gcc/bounds/lib/mutex.h
--- gcc-4.0.2.org/gcc/bounds/lib/mutex.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/mutex.h	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,74 @@
+/* Bounds Checking for GCC.
+   Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   File:
+  	lib/mutex.h
+   Summary:
+  	These functions provide mutual exclusion between signal handlers,
+  	and (in the future) threads when we update critical global data
+  	such as the object tree.
+   Other notes:
+  	You may need to fiddle around here to get round operating system
+  	dependencies, and also if you want to add support for threads.
+  	The overhead of providing mutual exclusion is so large that I've
+  	decided to turn it off by default. It requires two signal calls
+  	every time you enter the bounds checking library (at least two).
+   Author      	Date		Notes
+   RWMJ		15/3/95		Initial implementation.
+*/
+
+#ifndef _MUTEX_H_
+#define _MUTEX_H_
+
+#include <signal.h>
+
+extern void (*__bounds_mutex_start) (void);
+extern void (*__bounds_mutex_end) (void);
+extern int __bounds_mutex_signal;
+extern sigset_t __bounds_new_mask;
+
+/* The following function is called whenever we enter a critical section of
+   code.  */
+
+static __inline__ void
+enter_critical_section (sigset_t * old_mask)
+{
+  /* This is Sys V signal handling. BSD signal handling is different, so
+     someone needs to fix that.  */
+  if (__bounds_mutex_signal)
+    /* Block all signals. */
+    sigprocmask (SIG_BLOCK, &__bounds_new_mask, old_mask);
+  if (__bounds_mutex_start)
+    (*__bounds_mutex_start) ();
+}
+
+/* The following function is called whenever we leave a critical section.  */
+
+static __inline__ void
+leave_critical_section (sigset_t * old_mask)
+{
+  if (__bounds_mutex_end)
+    (*__bounds_mutex_end) ();
+
+  /* This is Sys V signal handling. BSD signal handling is different, so
+     someone needs to fix that.  */
+  if (__bounds_mutex_signal)
+    sigprocmask (SIG_SETMASK, old_mask, NULL);
+
+}
+
+#endif /* _MUTEX_H_ */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/objects.c gcc-4.0.2/gcc/bounds/lib/objects.c
--- gcc-4.0.2.org/gcc/bounds/lib/objects.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/objects.c	2005-09-29 20:00:56.000000000 +0200
@@ -0,0 +1,2388 @@
+/* Bounds Checking for GCC.
+   Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   File:
+  	lib/objects.c
+   Summary:
+  	Manage a list of memory objects. Allow the object that a pointer
+  	points to to be determined.
+   Other notes:
+  	The list of memory objects is stored as a binary tree. Clearly, we
+  	need to be able to allocate and free parts of this tree but without
+  	causing recursion. So, separate functions __bounds_malloc and
+  	__bounds_free are implemented in `lib/malloc.c' for this.
+   Author      	Date		Notes
+   RWMJ		5/12/94		Initial implementation.
+   RWMJ		23/1/95	       	Now using separate trees for static, etc.
+   RWMJ		9/2/95		Added splay trees. Removed hash table.
+   RWMJ		12/2/95		Put all the objects into a single tree.
+   RWMJ		15/3/95		Enter/leave critical section code.
+   RWMJ		4/4/95		`new_object' doesn't call `memset'.
+   RWMJ		25/4/95		Cache code added and removed!
+   RWMJ		27/5/95		Code to collect locality stats.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "bounds-lib.h"
+
+#include "mutex.h"		/* for 'enter|leave_critical_section'  */
+#include "functions.h"
+
+#if defined(__BOUNDS_CHECKING_ON)
+#error "This file must not be compiled with bounds checking enabled."
+#endif
+
+#if OBJECT_CLASS
+#if OBJECT_COUNT_CLASS
+#define	OBJECT_STATISTIC(r)	if (r) object_class[(r)->sclass]++
+#else
+#define	OBJECT_STATISTIC(r)
+#endif
+#define LOOKUP_OBJECT(f,r,p)                            \
+  do { 							\
+      if ((p) >= heap_object_tree.min                   \
+          && (p) <= heap_object_tree.max)               \
+	{						\
+          (r) = (f) (&heap_object_tree, (p));           \
+	  if (r)					\
+	    goto object_found;				\
+	}						\
+      if ((p) >= static_object_tree.min		        \
+          && (p) <= static_object_tree.max)             \
+	{						\
+          (r) = (f) (&static_object_tree, (p));         \
+	  if (r)					\
+	    goto object_found;				\
+	}						\
+      if ((p) >= stack_object_tree.min               	\
+          && (p) <= stack_object_tree.max)              \
+	{						\
+          (r) = (f) (&stack_object_tree, (p));          \
+	  if (r)					\
+	    goto object_found;				\
+	}						\
+      if ((p) >= extern_object_tree.min  	        \
+          && (p) <= extern_object_tree.max)             \
+	{						\
+          (r) = (f) (&extern_object_tree, (p));         \
+	  if (r)					\
+	    goto object_found;				\
+	}						\
+      (r) = NULL;                                       \
+object_found:						\
+      OBJECT_STATISTIC(r);				\
+  } while (0)
+#else
+#define LOOKUP_OBJECT(f,r,p)                            \
+  (r) = (f) (&object_tree, (p));
+#endif
+
+#if SPLAY_COUNT_STAT
+#define MAX_STEPS       	256
+
+static unsigned max_steps = 0;
+static unsigned max_no_steps = 0;
+static unsigned max_splay = 0;
+static unsigned *hits = NULL;
+static unsigned *no_hits = NULL;
+static unsigned *splay = NULL;
+#endif
+
+#if OBJECT_CLASS
+static tree hist_object = { NULL, NULL, NULL };
+#if OBJECT_COUNT_CLASS
+static unsigned object_class[4] = { 0, 0, 0, 0 };
+#endif
+#else
+static tree hist_object = { NULL };
+#endif
+
+/* Allocate/free object structures.  */
+
+static __inline__ object *
+new_object (void)
+{
+  object *p;
+
+  /* check if a object is in the hist_object list.  */
+  if (hist_object.root)
+    {
+      p = hist_object.root;
+      hist_object.root = p->left;
+      return (p);
+    }
+  p = __bounds_malloc (sizeof (struct object));
+  if (!p)
+    __bounds_internal_error ("out of memory allocating object structure",
+			     __FILE__, __LINE__);
+  /* The following call to `memset' resulted in considerable overhead. I've
+     altered all the calls to new_object so that clearing this area is no
+     longer necessary. Be careful when you add or change the contents of
+     the object structure.  */
+  /* __bounds_memset (p, 0, sizeof (struct object)); */
+  return p;
+}
+
+static __inline__ void
+free_object (object * p)
+{
+  /* never realy free object. Put it in the hist_object list.  */
+#if 0
+  __bounds_free (p);
+#else
+  p->left = hist_object.root;
+  hist_object.root = p;
+#endif
+}
+
+/* This is the splay tree used to keep track of memory locations.
+   The root node is called `root'. If it is non-NULL, then the
+   tree is arranged as in the following example:
+ 			root ----> [100..199]
+ 				    /      \
+ 			       [75..90]   [200..299]
+ 			        /
+ 			   [0..74]
+   This represents the following memory usage:
+ 		[0..74]		Allocated
+ 		[75..90]    	Allocated
+ 		[91..99]	Free
+ 		[100..199]	Allocated
+ 		[200..299]	Allocated
+   In general, that is, objects at lower addresses go on the left
+   side of the tree. The inline function `tree_lookup' turns a memory
+   location into the correct object pointer. The inline function
+   `tree_add' inserts a new object into the tree. The inline function
+   `tree_del' deletes an object from the tree.  */
+
+#if OBJECT_CLASS
+static tree static_object_tree = { NULL, NULL, NULL };
+static tree extern_object_tree = { NULL, NULL, NULL };
+static tree stack_object_tree  = { NULL, NULL, NULL };
+static tree heap_object_tree   = { NULL, NULL, NULL };
+#else
+static tree object_tree = { NULL };
+#endif
+
+#if SPLAY_COUNT_OPERATIONS
+
+/* Keep track of the number of operations performed, so we can work out if
+   we are successfully doing O(log n) work.  */
+static unsigned add_operations = 0;	/* Calls to tree_add. */
+static unsigned look_up_operations = 0;	/* Calls to tree_lookup (_base). */
+static unsigned look_up_steps = 0;	/* Steps taken in the above. */
+static unsigned nlook_up_operations = 0;	/* Failed calls to tree_lookup*. */
+static unsigned nlook_up_steps = 0;	/* Steps taken in the above. */
+static unsigned del_operations = 0;	/* Calls to tree_del. */
+
+/* We break down calls to `tree_splay' according to where they come
+   from.  */
+static unsigned splay_look_up_operations = 0;
+static unsigned splay_look_up_steps = 0;
+static unsigned splay_add_operations = 0;
+static unsigned splay_add_steps = 0;
+static unsigned splay_del_operations = 0;
+static unsigned splay_del_steps = 0;
+
+/* The following variables tell where we are coming from in tree_splay.  */
+static unsigned *splay_operations;
+static unsigned *splay_steps;
+
+/* Place the frequency with which you want dumps here. The tree will be saved
+   after this number of look-up operations.  */
+#define DUMP_EVERY	50000
+
+static void tree_dump_statistics (tree *);
+
+#endif
+
+/* Operations on splay trees.  */
+
+#if SPLAY_COUNT_STAT
+
+/* Calculate the splay statistics.  */
+
+static __inline__ void
+add_hits (unsigned steps)
+{
+  if (steps >= max_steps)
+    {
+      unsigned i;
+      unsigned lastmax = max_steps;
+
+      while (steps >= max_steps)
+	max_steps += MAX_STEPS;
+      if (hits == NULL)
+	hits = __bounds_malloc ((max_steps + 1) * sizeof (unsigned));
+      else
+	hits = __bounds_realloc (hits, (max_steps + 1) * sizeof (unsigned));
+      if (hits == NULL)
+	__bounds_internal_error ("out of memory allocating hits data",
+				 __FILE__, __LINE__);
+      for (i = lastmax + 1; i <= max_steps; i++)
+	hits[i] = 0;
+    }
+  hits[steps]++;
+}
+
+static __inline__ void
+add_no_hits (unsigned steps)
+{
+  if (steps >= max_no_steps)
+    {
+      unsigned i;
+      unsigned lastmax = max_no_steps;
+
+      while (steps >= max_no_steps)
+	max_no_steps += MAX_STEPS;
+      if (no_hits == NULL)
+	no_hits = __bounds_malloc ((max_no_steps + 1) * sizeof (unsigned));
+      else
+	no_hits = __bounds_realloc (no_hits, (max_no_steps + 1)
+				    * sizeof (unsigned));
+      if (no_hits == NULL)
+	__bounds_internal_error ("out of memory allocating hits data",
+				 __FILE__, __LINE__);
+      for (i = lastmax + 1; i <= max_no_steps; i++)
+	no_hits[i] = 0;
+    }
+  no_hits[steps]++;
+}
+
+static __inline__ void
+add_splay (unsigned steps)
+{
+  if (steps >= max_splay)
+    {
+      unsigned i;
+      unsigned lastmax = max_splay;
+
+      while (steps >= max_splay)
+	max_splay += MAX_STEPS;
+      if (splay == NULL)
+	splay = __bounds_malloc ((max_splay + 1) * sizeof (unsigned));
+      else
+	splay = __bounds_realloc (splay, (max_splay + 1) * sizeof (unsigned));
+      if (splay == NULL)
+	__bounds_internal_error ("out of memory allocating hits data",
+				 __FILE__, __LINE__);
+      for (i = lastmax + 1; i <= max_splay; i++)
+	splay[i] = 0;
+    }
+  splay[steps]++;
+}
+#endif
+
+/* SPLAY is the fundamental operation on splay trees. It takes node `n'
+   (assumed to exist within the splay tree) and pulls it up to the root
+   of the tree. The node returned (for convenience) is the root node, which
+   will be `n' and `t->root'.  */
+
+static __inline__ object *
+tree_splay (tree * t, object * n)
+{
+#if SPLAY_COUNT_STAT
+  unsigned hits = 0;
+#endif
+#if SPLAY_COUNT_OPERATIONS
+  ++(*splay_operations);
+#endif
+
+  if (t->root != n)
+    for (;;)
+      {
+	object *parent = n->parent, *grandparent = parent->parent;
+	object *obj;
+
+#if SPLAY_COUNT_OPERATIONS
+	++(*splay_steps);
+#endif
+#if SPLAY_COUNT_STAT
+	hits++;
+#endif
+
+	/* Determine which transformation to perform. Each of these
+	   transformations will move the node nearer to the root, and
+	   has the side effect of making the tree more balanced.  */
+	/* 1a,b. Parent is the root, so perform `zig' rotation.  */
+	if (grandparent == NULL)
+	  {
+	    if (n->left_of_parent)
+	      {
+		obj = n->right;
+		if (obj)
+		  {
+		    obj->parent = parent;
+		    obj->left_of_parent = 1;
+		  }
+		parent->left = obj;
+		n->right = parent;
+		n->parent = NULL;
+		n->left_of_parent = parent->left_of_parent;
+		parent->parent = n;
+		parent->left_of_parent = 0;
+	      }
+	    else
+	      {
+		obj = n->left;
+		if (obj)
+		  {
+		    obj->parent = parent;
+		    obj->left_of_parent = 0;
+		  }
+		parent->right = obj;
+		n->left = parent;
+		n->parent = NULL;
+		n->left_of_parent = parent->left_of_parent;
+		parent->parent = n;
+		parent->left_of_parent = 1;
+	      }
+	    t->root = n;
+	    break;
+	  }
+	/* 2a,b. `n', its parent and grandparent are in a straight line, so
+	   perform the `zig-zig' rotation.  */
+	else if (n->left_of_parent == parent->left_of_parent)
+	  {
+	    if (n->left_of_parent)
+	      {
+		obj = n->right;
+		if (obj)
+		  {
+		    obj->parent = parent;
+		    obj->left_of_parent = 1;
+		  }
+		parent->left = obj;
+		n->right = grandparent;
+		obj = n->parent = grandparent->parent;
+		n->left_of_parent = grandparent->left_of_parent;
+		grandparent->parent = n;
+		grandparent->left_of_parent = 0;
+	      }
+	    else
+	      {
+		obj = n->left;
+		if (obj)
+		  {
+		    obj->parent = parent;
+		    obj->left_of_parent = 0;
+		  }
+		parent->right = obj;
+		n->left = grandparent;
+		obj = n->parent = grandparent->parent;
+		n->left_of_parent = grandparent->left_of_parent;
+		grandparent->parent = n;
+		grandparent->left_of_parent = 1;
+	      }
+	    if (obj == NULL)
+	      {
+		t->root = n;
+		break;
+	      }
+	    else if (n->left_of_parent)
+	      n->parent->left = n;
+	    else
+	      n->parent->right = n;
+	  }
+	/* 3a,b. `n', its parent and grandparent aren't in a straight line, so
+	   perform the `zig-zag' rotation.  */
+	else
+	  {
+	    if (n->left_of_parent)
+	      {
+		obj = n->right;
+		if (obj)
+		  {
+		    obj->parent = parent;
+		    obj->left_of_parent = 1;
+		  }
+		parent->left = obj;
+		parent->parent = n;
+		parent->left_of_parent = 0;
+		obj = n->left;
+		if (obj)
+		  {
+		    obj->parent = grandparent;
+		    obj->left_of_parent = 0;
+		  }
+		grandparent->right = obj;
+		n->right = parent;
+		n->left = grandparent;
+		obj = n->parent = grandparent->parent;
+		n->left_of_parent = grandparent->left_of_parent;
+		grandparent->parent = n;
+		grandparent->left_of_parent = 1;
+	      }
+	    else
+	      {
+		obj = n->left;
+		if (obj)
+		  {
+		    obj->parent = parent;
+		    obj->left_of_parent = 0;
+		  }
+		parent->right = obj;
+		parent->parent = n;
+		parent->left_of_parent = 1;
+		obj = n->right;
+		if (obj)
+		  {
+		    obj->parent = grandparent;
+		    obj->left_of_parent = 1;
+		  }
+		grandparent->left = obj;
+		n->left = parent;
+		n->right = grandparent;
+		obj = n->parent = grandparent->parent;
+		n->left_of_parent = grandparent->left_of_parent;
+		grandparent->parent = n;
+		grandparent->left_of_parent = 0;
+	      }
+	    if (obj == NULL)
+	      {
+		t->root = n;
+		break;
+	      }
+	    else if (n->left_of_parent)
+	      n->parent->left = n;
+	    else
+	      n->parent->right = n;
+	  }
+      }
+
+#if SPLAY_STRICT_CHECKING
+  __bounds_tree_check (t);
+#endif
+#if SPLAY_COUNT_STAT
+  add_splay (hits);
+#endif
+
+  return n;
+}
+
+/* Add, look-up and delete operations. All these are done using the
+   fundamental `splay' operation.  */
+
+
+/* Print the splay statistics.  */
+
+void
+__bound_print_statistics (void)
+{
+#if SPLAY_COUNT_STAT
+  unsigned i;
+  double total1_hits = 0.0;
+  double total1_steps = 0.0;
+  double total2_hits = 0.0;
+  double total2_steps = 0.0;
+  double depth;
+  unsigned n1;
+  unsigned n2;
+  unsigned n3;
+  unsigned max = max_steps > max_no_steps ? max_steps : max_no_steps;
+
+  printf ("Depth     Found  Not Found      Splay\n");
+  for (i = 1; i <= max; i++)
+    {
+      n1 = i <= max_steps ? hits[i] : 0;
+      n2 = i <= max_no_steps ? no_hits[i] : 0;
+      n3 = i <= max_splay ? splay[i] : 0;
+      if (n1 || n2 || n3)
+	printf ("%4d %10u %10u %10u\n", i, n1, n2, n3);
+      if (n1)
+	{
+	  total1_hits += (double) n1;
+	  total1_steps += (double) n1 *(double) i;
+	}
+      if (n2)
+	{
+	  total2_hits += (double) n2;
+	  total2_steps += (double) n2 *(double) i;
+	}
+    }
+  depth =
+    total1_hits ? ((double) total1_steps * 100.0) /
+    (double) total1_hits : 0.0;
+  n1 = (unsigned) (depth / 100.0);
+  n2 = (unsigned) (depth - 100.0 * (double) n1);
+  printf ("Found     %10u. Steps %10u. Average steps hits    %4u.%02u\n",
+	  (unsigned) total1_hits, (unsigned) total1_steps, n1, n2);
+  depth =
+    total2_hits ? ((double) total2_steps * 100.0) /
+    (double) total2_hits : 0.0;
+  n1 = (unsigned) (depth / 100.0);
+  n2 = (unsigned) (depth - 100.0 * (double) n1);
+  printf ("Not Found %10u. Steps %10u. Average steps no hits %4u.%02u\n",
+	  (unsigned) total2_hits, (unsigned) total2_steps, n1, n2);
+#if 0
+  __bounds_debug_memory (NULL, NULL);
+#endif
+#endif
+#if OBJECT_CLASS
+#if OBJECT_COUNT_CLASS
+  printf("obj_sclass_static   %10d (%010p %010p)\n",
+                object_class[obj_sclass_static],
+                static_object_tree.min,
+                static_object_tree.max);
+  printf("obj_sclass_external %10d (%010p %010p)\n",
+                object_class[obj_sclass_external],
+                extern_object_tree.min,
+                extern_object_tree.max);
+  printf("obj_sclass_stack    %10d (%010p %010p)\n",
+                object_class[obj_sclass_stack],
+                stack_object_tree.min,
+                stack_object_tree.max);
+  printf("obj_sclass_heap     %10d (%010p %010p)\n",
+                object_class[obj_sclass_heap],
+                heap_object_tree.min,
+                heap_object_tree.max);
+#endif
+#endif
+}
+
+/* Return leftmost object below the current object node.  */
+static __inline__ object *
+leftmost (object * n)
+{
+  while (n->left)
+    n = n->left;
+  return n;
+}
+
+/* Look-up a node in the splay tree. Notice that the act of looking up a
+   node changes the tree. (In particular, the node, if found, moves to
+   the root of the tree). Returns the node, or NULL if not found.  */
+static __inline__ object *
+tree_lookup (tree * t, void *ptr)
+{
+  object *n = t->root;
+
+#if SPLAY_COUNT_STAT
+  unsigned hits_steps;
+#endif
+#if SPLAY_COUNT_OPERATIONS
+  unsigned steps = 0;
+  look_up_operations++;
+  if (look_up_operations == DUMP_EVERY)
+    tree_dump_statistics (t);
+  splay_operations = &splay_look_up_operations;
+  splay_steps = &splay_look_up_steps;
+#endif
+
+/* Handle the toplevel of the splay tree with this inline code. It it
+   faster than using the while loop and the tree_splay function.
+   If the FAST_UPDATE is set to 0 the tree is not balanced anymore. This
+   is faster than keeping the tree balanced.  */
+#ifdef FAST
+#undef FAST
+#endif
+#define	FAST 1
+#define	FAST_UPDATE 0
+#if FAST
+  if (n)
+    {
+      if (ptr < n->base)
+	{
+	  n = n->left;
+	  if (n)
+	    {
+	      if (ptr < n->base)
+		n = n->left;
+	      else if (ptr > n->extent)
+		n = n->right;
+	      else if (ptr != n->extent)
+		{
+#if FAST_UPDATE
+		  object *parent = n->parent;
+		  object *obj = n->right;
+
+		  if (obj)
+		    {
+		      obj->parent = parent;
+		      obj->left_of_parent = 1;
+		    }
+		  n->right = parent;
+		  n->parent = NULL;
+		  parent->left = obj;
+		  parent->parent = n;
+		  parent->left_of_parent = 0;
+		  t->root = n;
+#endif
+#if SPLAY_COUNT_STAT
+		  add_hits (2);
+		  n->hits++;
+		  n->steps += 2;
+#endif
+#if SPLAY_COUNT_OPERATIONS
+		  n->hits++;
+		  look_up_steps += 2;
+#endif
+		  return n;
+		}
+	    }
+	}
+      else if (ptr > n->extent)
+	{
+	  n = n->right;
+	  if (n)
+	    {
+	      if (ptr < n->base)
+		n = n->left;
+	      else if (ptr > n->extent)
+		n = n->right;
+	      else if (ptr != n->extent)
+		{
+#if FAST_UPDATE
+		  object *parent = n->parent;
+		  object *obj = n->left;
+
+		  if (obj)
+		    {
+		      obj->parent = parent;
+		      obj->left_of_parent = 0;
+		    }
+		  n->left = parent;
+		  n->parent = NULL;
+		  parent->right = obj;
+		  parent->parent = n;
+		  parent->left_of_parent = 1;
+		  t->root = n;
+#endif
+#if SPLAY_COUNT_STAT
+		  add_hits (2);
+		  n->hits++;
+		  n->steps += 2;
+#endif
+#if SPLAY_COUNT_OPERATIONS
+		  n->hits++;
+		  look_up_steps += 2;
+#endif
+		  return n;
+		}
+	    }
+	}
+      else if (ptr != n->extent)
+	{
+#if SPLAY_COUNT_STAT
+	  add_hits (1);
+	  n->hits++;
+	  n->steps += 1;
+#endif
+#if SPLAY_COUNT_OPERATIONS
+	  n->hits++;
+	  look_up_steps += 1;
+#endif
+	  return n;
+	}
+    }
+#endif
+#if SPLAY_COUNT_STAT
+  hits_steps = 2;
+#endif
+
+  while (n)
+    {
+#if SPLAY_COUNT_STAT
+      hits_steps++;
+#endif
+#if SPLAY_COUNT_OPERATIONS
+      steps++;
+#endif
+
+      if (ptr < n->base)
+	n = n->left;
+      else
+	{
+	  /* This is tricky. Normally, a pointer refers to an object if the
+	     pointer lies between base and extent inclusively. We add extra
+	     padding between checked objects to ensure this is true. However,
+	     if we aren't able to add this padding, then the next object may
+	     lie immediately after the previous object in memory, ie. extent
+	     and the base of the next object may be the same.  */
+	  if (ptr > n->extent)
+	    n = n->right;
+	  else if (ptr == n->extent)
+	    {
+	      /* This is the tricky boundary condition. Use the hints given. If
+	         `no_padding' is 0, there can be no immediate object on the
+	         right, so stop the search. If `no_padding' is true, we must
+	         look rightwards for the adjacent object, and go that way if the
+	         right base == this extent.  */
+	      if (n->no_padding == 0)
+		break;
+	      if (n->right && leftmost (n->right)->base == n->extent)
+		n = n->right;
+	      else
+		{
+		  /* if there could be a object next to this one. Do not use the
+		     current object.  */
+		  n = NULL;
+		  break;
+		}
+	    }
+	  else
+	    break;
+	}
+    }
+
+  if (n)
+    {
+#if SPLAY_COUNT_STAT
+      add_hits (hits_steps);
+      n->hits++;
+      n->steps += hits_steps;
+#endif
+#if SPLAY_COUNT_OPERATIONS
+      n->hits++;
+      look_up_steps += steps;
+#endif
+      return tree_splay (t, n);
+    }
+  else
+    {
+#if SPLAY_COUNT_STAT
+      add_no_hits (hits_steps);
+#endif
+#if SPLAY_COUNT_OPERATIONS
+      nlook_up_steps += steps;
+      nlook_up_operations++;
+#endif
+      return NULL;
+    }
+}
+
+/* Look-up a node in the splay tree, but only match on an object with an
+   identical base address.  */
+
+static __inline__ object *
+tree_lookup_base (tree * t, void *base)
+{
+  object *n = t->root;
+
+#if SPLAY_COUNT_OPERATIONS
+  int steps = 0;
+  look_up_operations++;
+  if (look_up_operations == DUMP_EVERY)
+    tree_dump_statistics (t);
+  splay_operations = &splay_look_up_operations;
+  splay_steps = &splay_look_up_steps;
+#endif
+#if FAST
+  if (n)
+    {
+      if (base < n->base)
+	{
+	  n = n->left;
+	  if (n)
+	    {
+	      if (base < n->base)
+		n = n->left;
+	      else if (base >= n->extent)
+		n = n->right;
+	      else if (base == n->base)
+		{
+#if FAST_UPDATE
+		  object *parent = n->parent;
+		  object *obj = n->right;
+
+		  if (obj)
+		    {
+		      obj->parent = parent;
+		      obj->left_of_parent = 1;
+		    }
+		  n->right = parent;
+		  n->parent = NULL;
+		  parent->left = obj;
+		  parent->parent = n;
+		  parent->left_of_parent = 0;
+		  t->root = n;
+#endif
+		  return n;
+		}
+	      else
+		return NULL;
+	    }
+	}
+      else if (base >= n->extent)
+	{
+	  n = n->right;
+	  if (n)
+	    {
+	      if (base < n->base)
+		n = n->left;
+	      else if (base >= n->extent)
+		n = n->right;
+	      else if (base == n->base)
+		{
+#if FAST_UPDATE
+		  object *parent = n->parent;
+		  object *obj = n->left;
+
+		  if (obj)
+		    {
+		      obj->parent = parent;
+		      obj->left_of_parent = 0;
+		    }
+		  n->left = parent;
+		  n->parent = NULL;
+		  parent->right = obj;
+		  parent->parent = n;
+		  parent->left_of_parent = 1;
+		  t->root = n;
+#endif
+		  return n;
+		}
+	      else
+		return NULL;
+	    }
+	}
+      else if (base == n->base)
+	return n;
+      else
+	return NULL;
+    }
+#endif
+
+  while (n)
+    {
+#if SPLAY_COUNT_OPERATIONS
+      steps++;
+#endif
+
+      if (base < n->base)
+	n = n->left;
+      else if (base >= n->extent)
+	n = n->right;
+      else
+	break;
+    }
+  if (n && n->base == base)
+    {
+#if SPLAY_COUNT_OPERATIONS
+      n->hits++;
+      look_up_steps += steps;
+#endif
+      return tree_splay (t, n);
+    }
+  else
+    {
+#if SPLAY_COUNT_OPERATIONS
+      nlook_up_steps += steps;
+      nlook_up_operations++;
+#endif
+      return NULL;
+    }
+}
+
+/* Add a node to the splay tree. We assume the node isn't already in the
+   tree, and that no node of the same value is in the tree. The node will
+   rise to the root of the tree (by splay), and we return it for convenience. */
+
+static __inline__ object *
+tree_add (tree * t, object * n)
+{
+  object *tmp = t->root, *prev;
+
+  n->parent = n->left = n->right = NULL;
+
+#if SPLAY_COUNT_OPERATIONS
+  add_operations++;
+  splay_operations = &splay_add_operations;
+  splay_steps = &splay_add_steps;
+#endif
+
+  if (tmp == NULL)
+    {
+      /* Tree is empty. Add the node at root and return immediately.  */
+      t->root = n;
+#if OBJECT_CLASS
+      t->min = n->base;
+      t->max = n->extent;
+#endif
+      return n;
+    }
+
+#if OBJECT_CLASS
+  if (n->base < t->min)
+    t->min = n->base;
+  if (n->extent > t->max)
+    t->max = n->extent;
+#endif
+
+  while (tmp)
+    {
+      prev = tmp;
+      if (n->base < tmp->base)
+	tmp = tmp->left;
+      else
+	tmp = tmp->right;
+    }
+
+  /* `prev' points to the last node before we fell off the bottom of the
+     tree.  */
+  if (prev->parent == NULL)
+    {
+      /* `prev' is the root of the tree, so we can just add the node here with
+         no problem.  */
+      if (n->base < prev->base)
+	{
+	  prev->left = n;
+	  n->parent = prev;
+	  n->left_of_parent = 1;
+	}
+      else
+	{
+	  prev->right = n;
+	  n->parent = prev;
+	  n->left_of_parent = 0;
+	}
+    }
+
+  /* If parent to prev and prev to new node are in the same direction, we
+     can just add the new node.  */
+  else if (n->base < prev->base && prev->left_of_parent)
+    {
+      prev->left = n;
+      n->parent = prev;
+      n->left_of_parent = 1;
+    }
+  else if (n->base > prev->base && !prev->left_of_parent)
+    {
+      prev->right = n;
+      n->parent = prev;
+      n->left_of_parent = 0;
+    }
+
+  /* If parent to prev and prev to new node are not in a straight line, we
+     insert the new node between parent and prev.  */
+  else if (prev->left_of_parent)
+    {
+      object *parent = prev->parent;
+
+      parent->left = n;
+      n->left = prev;
+      n->parent = parent;
+      n->left_of_parent = 1;
+      prev->parent = n;
+      prev->left_of_parent = 1;
+    }
+  else
+    {
+      object *parent = prev->parent;
+
+      parent->right = n;
+      n->right = prev;
+      n->parent = parent;
+      n->left_of_parent = 0;
+      prev->parent = n;
+      prev->left_of_parent = 0;
+    }
+  return tree_splay (t, n);
+}
+
+/* Delete a node from the tree. We assume that the node to be deleted exists
+   in the tree.  */
+
+static __inline__ void
+tree_del (tree * t, object * n)
+{
+  object *left, *right, *largest;
+  tree tmp_left;
+
+#if SPLAY_COUNT_OPERATIONS
+  del_operations++;
+  splay_operations = &splay_del_operations;
+  splay_steps = &splay_del_steps;
+#endif
+
+  if (n->left == NULL)
+    {
+      right = n->right;
+      if (n->parent == NULL)
+	{
+	  t->root = right;
+	  if (right)
+	    right->parent = NULL;
+	}
+      else if (n->left_of_parent)
+	{
+	  n->parent->left = right;
+	  if (right)
+	    right->parent = n->parent, right->left_of_parent = 1;
+	}
+      else
+	{
+	  n->parent->right = right;
+	  if (right)
+	    right->parent = n->parent, right->left_of_parent = 0;
+	}
+      return;
+    }
+
+  if (n->right == NULL)
+    {
+      left = n->left;
+      if (n->parent == NULL)
+	{
+	  t->root = left;
+	  if (left)
+	    left->parent = NULL;
+	}
+      else if (n->left_of_parent)
+	{
+	  n->parent->left = left;
+	  if (left)
+	    left->parent = n->parent, left->left_of_parent = 1;
+	}
+      else
+	{
+	  n->parent->right = left;
+	  if (left)
+	    left->parent = n->parent, left->left_of_parent = 0;
+	}
+      return;
+    }
+
+  right = n->right;
+  left = n->left;
+
+  /* Search the left orphaned subtree for the largest value it contains. This
+     will necessarily be smaller than the deleted node, and all the nodes in
+     the right subtree.
+     (Notice that the largest value is just found by going right as far as
+     possible in the left subtree).  */
+  largest = left;
+  while (largest->right)
+    largest = largest->right;
+
+  /* Splay the left tree again so that the largest node is brought to the
+     top.  */
+  left->parent = NULL;
+  tmp_left.root = left;
+  tree_splay (&tmp_left, largest);
+
+  /* Now, since the largest valued node in the left tree is at the top, we
+     know that its right pointer is NULL, and we can just attach the right
+     tree there.  */
+  if (n->parent == NULL)
+    {
+      t->root = largest;
+      largest->parent = NULL;
+    }
+  else if (n->left_of_parent)
+    {
+      n->parent->left = largest;
+      largest->parent = n->parent;
+      largest->left_of_parent = 1;
+    }
+  else
+    {
+      n->parent->right = largest;
+      largest->parent = n->parent;
+      largest->left_of_parent = 0;
+    }
+  largest->right = right;
+  right->parent = largest;
+  right->left_of_parent = 0;
+}
+
+/* Perform a strict check on the contents of the splay tree. This
+   check is done after each tree operation if 'SPLAY_STRICT_CHECKING'
+   is defined as 1. However, we include this code anyway so that
+   we can call it from the debugger or app. if necessary.  */
+
+static void tc_error (tree * t, object * n, const char *s)
+  __attribute__ ((noreturn));
+static void tc_test (tree * t, object * n, object * parent,
+		     int left_of_parent, void *min, void *max);
+
+void
+__bounds_tree_check (tree * t)
+{
+  object *root = t->root;
+
+  if (root == NULL)
+    return;
+
+  if (root->parent != NULL)
+    tc_error (t, root, "root node has a parent (should be NULL)");
+  if (root->left)
+    tc_test (t, root->left, root, 1, (void *) 0, (char *) root->base - 1);
+  if (root->right)
+    tc_test (t, root->right, root, 0, root->extent, (void *) ~0);
+}
+
+static void
+tc_test (tree * t, object * n, object * parent, int left_of_parent,
+	 void *min, void *max)
+{
+  if (n->parent != parent)
+    tc_error (t, n, "node has parent different from true parent");
+  if (n->left_of_parent != left_of_parent)
+    tc_error (t, n, "node has left_of_parent different from true direction");
+  if (n->base >= n->extent)
+    tc_error (t, n, "node has zero or negative size");
+  if (n->base < min || (void *) ((char *) n->extent - 1) > max)
+    tc_error (t, n, "node is out of order within the tree");
+  if (n->left)
+    tc_test (t, n->left, n, 1, min, (char *) n->base - 1);
+  if (n->right)
+    tc_test (t, n->right, n, 0, n->extent, max);
+}
+
+static void
+tc_error (tree * t, object * n, const char *msg)
+{
+  printf ("tree_check: %s\n"
+	  "  tree root at %p\n"
+	  "  object struct at %p\n"
+	  "  object refers to %p..%p\n",
+	  msg, t->root, n, n->base, (char *) n->extent - 1);
+  ABORT ();
+}
+
+/* If `SPLAY_COUNT_OPERATIONS' is set to 1, then we keep statistics
+   on the current state of the splay tree, and we dump the splay
+   tree every N look-ups so we can draw pictures and measure
+   stats on the tree, etc.  */
+
+#if SPLAY_COUNT_OPERATIONS
+
+#include "ext-tree.h"		/* Describes external format of splay tree files.  */
+#include <fcntl.h>
+
+static void tree_dump_tree (int fd, object * n);
+static void tree_write_file (int fd, void *, size_t);
+static void tree_close_file (int fd);
+static void tree_next_name (void);
+static char dumpfile[128] = "splaytree.aa";
+static int dump_index = 0;
+
+static void
+tree_dump_statistics (tree * t)
+{
+  int fd;
+  struct ext_tree et;
+
+  printf ("Dump tree after %d look-up operations.\n", DUMP_EVERY);
+
+  /* Notice that we can't make C library calls here, which would simplify
+     this code substantially.  */
+  fd = creat (dumpfile, 0644);
+  if (fd < 0)
+    {
+      printf ("Dump failed at: open\n");
+      return;
+    }
+  __bounds_strcpy (et.magic, EXT_TREE_MAGIC);
+  et.index = dump_index;
+  dump_index++;
+  et.dump_every = DUMP_EVERY;
+  et.add_operations = add_operations;
+  et.del_operations = del_operations;
+  et.look_up_operations = look_up_operations - nlook_up_operations;
+  et.look_up_steps = look_up_steps;
+  et.nlook_up_operations = nlook_up_operations;
+  et.nlook_up_steps = nlook_up_steps;
+  et.splay_operations = splay_look_up_operations
+    + splay_add_operations + splay_del_operations;
+  et.splay_steps = splay_look_up_steps + splay_add_steps + splay_del_steps;
+  et.splay_look_up_operations = splay_look_up_operations;
+  et.splay_look_up_steps = splay_look_up_steps;
+  et.splay_add_operations = splay_add_operations;
+  et.splay_add_steps = splay_add_steps;
+  et.splay_del_operations = splay_del_operations;
+  et.splay_del_steps = splay_del_steps;
+  tree_write_file (fd, &et, sizeof et);
+
+  add_operations = del_operations = look_up_operations = look_up_steps =
+    nlook_up_operations = nlook_up_steps =
+    splay_look_up_operations = splay_look_up_steps =
+    splay_add_operations = splay_add_steps =
+    splay_del_operations = splay_del_steps = 0;
+
+  tree_dump_tree (fd, t->root);
+
+  tree_close_file (fd);
+  tree_next_name ();
+}
+
+static void
+tree_dump_tree (int fd, object * n)
+{
+  /* Dump the current subtree to the dump file.  */
+  int zero_int = 0, one_int = 1;
+
+  if (n == NULL)
+    tree_write_file (fd, &zero_int, sizeof (int));
+  else
+    {
+      tree_write_file (fd, &one_int, sizeof (int));
+      tree_write_file (fd, n, sizeof (object));
+      tree_dump_tree (fd, n->left);
+      tree_dump_tree (fd, n->right);
+      n->hits = 0;
+    }
+}
+
+static void
+tree_next_name (void)
+{
+  /* Increment the name `splaytree.aa', `splaytree.ab', etc.  */
+  int sl = __bounds_strlen (dumpfile);
+  char p;
+
+  p = dumpfile[sl - 1];
+  p++;
+  if (p == 'z' + 1)
+    {
+      p = 'a';
+      (dumpfile[sl - 2])++;
+    }
+  dumpfile[sl - 1] = p;
+}
+
+#define BUFSIZE		4096
+
+char wr_buffer[BUFSIZE];
+int wr_pos = 0;
+
+static void
+tree_write_file (int fd, void *data, size_t size)
+{
+  /* Efficiently write data to given file, buffering nK internally. We can
+     safely assume that none of the writes will be larger than the buffer
+     size.  */
+  if (wr_pos + size > BUFSIZE)
+    {
+      if (write (fd, wr_buffer, wr_pos) != wr_pos)
+	printf ("Dump failed at: write\n");
+      wr_pos = 0;
+    }
+  __bounds_memcpy (wr_buffer + wr_pos, data, size);
+  wr_pos += size;
+}
+
+static void
+tree_close_file (int fd)
+{
+  /* Flush what's in our buffer and close the file.  */
+  if (wr_pos > 0)
+    {
+      if (write (fd, wr_buffer, wr_pos) != wr_pos)
+	printf ("Dump failed at: write\n");
+      wr_pos = 0;
+    }
+  close (fd);
+}
+
+#endif /* SPLAY_COUNT_OPERATIONS */
+
+/* A general function that looks up the object referred to by
+   a pointer.  */
+
+__inline__ object *
+__bounds_find_object (void *pointer)
+{
+  object *result;
+  sigset_t old_mask;
+
+  if (__bounds_debug_no_checking)
+    result = NULL;
+  else
+    {
+#if COLLECT_STATS && DEBUG_OBJECTS
+      ++__bounds_stats_find_object;
+#endif
+      enter_critical_section (&old_mask);
+      LOOKUP_OBJECT (tree_lookup, result, pointer);
+      leave_critical_section (&old_mask);
+    }
+  return result;
+}
+
+__inline__ object *
+__bounds_maybe_find_object (object * obj, void *pointer)
+{
+  sigset_t old_mask;
+
+  if (__bounds_debug_no_checking)
+    obj = NULL;
+  else if (obj)
+    {
+#if COLLECT_STATS && DEBUG_OBJECTS
+      ++__bounds_stats_maybe_find_object;
+#endif
+    }
+  else
+    {
+#if COLLECT_STATS && DEBUG_OBJECTS
+      ++__bounds_stats_maybe_find_object_search;
+#endif
+      enter_critical_section (&old_mask);
+      LOOKUP_OBJECT (tree_lookup, obj, pointer);
+      leave_critical_section (&old_mask);
+    }
+  return obj;
+}
+
+static __inline__ object *
+__bounds_find_object_by_base (void *base)
+{
+  object *result;
+
+  LOOKUP_OBJECT (tree_lookup_base, result, base);
+  return result;
+}
+
+/* Add, delete and lookup heap objects specifically.  */
+
+/* Check for power of 2 of aligment.
+   It is much faster doing an and than doing a mod function.  */
+
+static __inline__ int
+check_align (int n)
+{
+  return (((n - 1) & n) == 0);
+}
+
+void
+__bounds_add_heap_object (void *base, size_t count, size_t align,
+			  const char *name, int no_padding,
+			  const char *filename, int line)
+{
+  object *obj;
+
+#if COLLECT_STATS
+  ++__bounds_stats_add_heap;
+#endif
+#if DEBUG_FEATURES
+  if (__bounds_debug_print_calls)
+    printf
+      ("__bounds_add_heap_object (p=%p, sz=%u, align=%u, file=\"%s\", ln=%d)\n",
+       base, count, align, filename, line);
+#endif
+
+  if (count == 0 || align == 0)
+    __bounds_internal_error ("attempted to add a zero-sized heap object",
+			     NULL, 0);
+
+  obj = new_object ();
+  obj->left = obj->right = obj->parent = NULL;
+  obj->base = base;
+  obj->size = count * align;
+  obj->extent = (char *) base + count * align;
+  obj->align = align;
+  obj->sclass = obj_sclass_heap;
+  obj->filename = filename;
+  obj->line = line;
+  obj->name = name;
+  /* Padding can be added after every heap object by the run-time malloc
+     library.  */
+  obj->no_padding = no_padding;
+  obj->align_mask = check_align (align);
+  obj->oob_pointer = 0;
+#if SPLAY_COUNT_OPERATIONS || SPLAY_COUNT_STAT
+  obj->hits = 0;
+  obj->steps = 0;
+#endif
+#if OBJECT_CLASS
+  tree_add (&heap_object_tree, obj);
+#else
+  tree_add (&object_tree, obj);
+#endif
+}
+
+int
+__bounds_delete_heap_object (void *base, size_t size, const char *error,
+			     const char *filename, int line, size_t *org_size)
+{
+  object *obj;
+
+#if COLLECT_STATS
+  ++__bounds_stats_delete_heap;
+#endif
+#if DEBUG_FEATURES
+  if (__bounds_debug_print_calls)
+    printf
+      ("__bounds_delete_heap_object (p=%p, size=%u, file=\"%s\", ln=%d)\n",
+       base, size, filename, line);
+#endif
+
+  obj = __bounds_find_object_by_base (base);
+  if (obj == NULL || obj->sclass != obj_sclass_heap)
+    {
+      __bounds_error (error, filename, line, base, NULL);
+      return 1;
+    }
+
+  if (org_size)
+    *org_size = obj->size;
+
+  if (obj->oob_pointer)
+    __bounds_delete_oob_entries (obj);
+
+  base = obj->extent;
+  size -= obj->size;
+#if OBJECT_CLASS
+  tree_del (&heap_object_tree, obj);
+#else
+  tree_del (&object_tree, obj);
+#endif
+  free_object (obj);
+  while ((long) size > 0)
+    {
+      obj = __bounds_find_object_by_base (base);
+      if (obj == NULL || obj->sclass != obj_sclass_heap)
+	{
+	  __bounds_error (error, filename, line, base, NULL);
+	  return 1;
+	}
+
+      if (org_size)
+        (*org_size) += obj->size;
+
+      if (obj->oob_pointer)
+	__bounds_delete_oob_entries (obj);
+
+      base = obj->extent;
+      size -= obj->size;
+#if OBJECT_CLASS
+      tree_del (&heap_object_tree, obj);
+#else
+      tree_del (&object_tree, obj);
+#endif
+      free_object (obj);
+    }
+  return 0;
+}
+
+/* Add a static object to the list of objects. This function may be
+   called more than once for each object.  */
+
+object *
+__bounds_note_constructed_object (void *base, int size, size_t align,
+				  const char *filename, int line,
+				  const char *name)
+{
+  object *obj;
+  obj_sclass sclass = size < 0 ? obj_sclass_external : obj_sclass_static;
+  sigset_t old_mask;
+
+  enter_critical_section (&old_mask);
+  obj = __bounds_find_object_by_base (base);
+  if (size < 0)
+    size = -size;
+#if DEBUG_FEATURES
+  if (__bounds_debug_print_calls)
+    printf ("__bounds_note_constructed_object"
+	    "(p=%p, sz=%u, align=%u, file=\"%s\", ln=%d, name=\"%s\")\n",
+	    base, size, align, filename, line, name);
+#endif
+
+  if (size == 0 || align == 0)
+    __bounds_internal_error ("attempted to add a zero-sized static object",
+			     filename, line);
+
+  if (obj && obj->sclass == obj_sclass_static && sclass == obj_sclass_static)
+    {
+      /* Object has already constructed. Just check that it is declared the
+         same way here.  */
+      if (obj->size != (size_t) size || obj->align != align)
+	{
+	  __bounds_error ("static object redeclared with different"
+			  " size or alignment", filename, line, base, obj);
+	}
+    }
+
+  /* Allow a new static declaration to unconditionally overwrite an
+     external one, since external ones are tentative.
+     Also allow an external one to overwrite another external one.  */
+  else if (obj && obj->sclass == obj_sclass_external)
+    {
+#if OBJECT_CLASS
+      tree_del (&extern_object_tree, obj);
+#endif
+      obj->size = size;
+      obj->extent = (char *) base + size;
+      obj->align = align;
+      obj->sclass = sclass;
+      obj->filename = filename;
+      obj->name = name;
+      obj->line = line;
+      obj->no_padding = sclass == obj_sclass_external ? 1 : 0;
+      obj->align_mask = check_align (align);
+      obj->oob_pointer = 0;
+#if OBJECT_CLASS
+      tree_add (sclass == obj_sclass_static ? &static_object_tree
+                                            : &extern_object_tree, obj);
+#endif
+    }
+
+  /* Ignore an external declaration if we already have a firm static
+     declaration for this object.  */
+  else if (obj && sclass == obj_sclass_external)
+    ;
+  else
+    {
+      /* Create the object anew.  */
+      obj = new_object ();
+      obj->left = obj->right = obj->parent = NULL;
+      obj->base = base;
+      obj->size = size;
+      obj->extent = (char *) base + size;
+      obj->align = align;
+      obj->sclass = sclass;
+      obj->filename = filename;
+      obj->line = line;
+      obj->name = name;
+      /* Padding is added after every static object now by the compiler.  */
+      obj->no_padding = sclass == obj_sclass_external ? 1 : 0;
+      obj->align_mask = check_align (align);
+      obj->oob_pointer = 0;
+#if SPLAY_COUNT_OPERATIONS || SPLAY_COUNT_STAT
+      obj->hits = 0;
+      obj->steps = 0;
+#endif
+#if OBJECT_CLASS
+      tree_add (sclass == obj_sclass_static ? &static_object_tree
+                                            : &extern_object_tree, obj);
+#else
+      tree_add (&object_tree, obj);
+#endif
+    }
+  leave_critical_section (&old_mask);
+
+  return obj;
+}
+
+/* This is used to build a list of private static data. The table
+   is built by GCC, and a pointer to it is passed here.  */
+
+void
+__bounds_note_constructed_private_table (private_table * table,
+					 const char *filename, int line)
+{
+  const char *name;
+
+  while (table->ptr)
+    {
+      if (table->name != NULL)
+	name = table->name;
+      else
+	name = "(unnamed static)";
+      if (table->size)
+	__bounds_note_constructed_object (table->ptr, (size_t) table->size, 1,
+					  NULL, 0, name);
+      else
+	/* GCC with bounds checking sometimes generates zero-sized entries
+	   in the table, even though these ought to give warnings and be
+	   ignored at compile time. Generate warnings here. If these warnings
+	   appear, the compiler will need to be fixed.
+	   (4/4/95: These should be fixed now).  */
+	__bounds_warning (filename, line, NULL,
+			  "zero-sized object `%s' generated"
+			  " in private_statics table", name);
+      table++;
+    }
+}
+
+__inline__ void
+__bounds_internal_delete_stack_object (object * obj, int nesting_nr)
+{
+#if COLLECT_STATS
+  ++__bounds_stats_delete_stack;
+#endif
+  if (obj->sclass != obj_sclass_stack)
+    __bounds_internal_error ("__bounds_delete_stack_object passed pointer"
+			     " to non-stack object", __FILE__, __LINE__);
+
+  if (nesting_nr != -1)
+    __bounds_remove_function_object (obj, nesting_nr);
+
+  if (obj->oob_pointer)
+    __bounds_delete_oob_entries (obj);
+
+#if OBJECT_CLASS
+  { tree *t;
+    switch (obj->sclass)
+      {
+      case obj_sclass_static:
+        t = &static_object_tree;
+        break;
+      case obj_sclass_external:
+        t = &extern_object_tree;
+        break;
+      case obj_sclass_stack:
+        t = &stack_object_tree;
+        break;
+      case obj_sclass_heap:
+        t = &heap_object_tree;
+        break;
+      default:
+        abort();
+      }
+    tree_del (t, obj);
+  }
+#else
+  tree_del (&object_tree, obj);
+#endif
+  free_object (obj);
+}
+
+void
+__bounds_delete_object (object * obj)
+{
+  sigset_t old_mask;
+
+  if (obj == NULL)
+    __bounds_internal_error ("__bounds_delete_object passed pointer"
+			     " to NULL object", __FILE__, __LINE__);
+  enter_critical_section (&old_mask);
+#if OBJECT_CLASS
+  { tree *t;
+    switch (obj->sclass)
+      {
+      case obj_sclass_static:
+        t = &static_object_tree;
+        break;
+      case obj_sclass_external:
+        t = &extern_object_tree;
+        break;
+      case obj_sclass_stack:
+        t = &stack_object_tree;
+        break;
+      case obj_sclass_heap:
+        t = &heap_object_tree;
+        break;
+      default:
+        abort();
+      }
+    tree_del (t, obj);
+  }
+#else
+  tree_del (&object_tree, obj);
+#endif
+  free_object (obj);
+  leave_critical_section (&old_mask);
+}
+
+/* Create a record of a stack object. This function is called once
+   for each local variable when we enter a function or block.  */
+
+__inline__ object *
+__bounds_internal_add_stack_object (void *base, size_t size, size_t align,
+				    const char *filename, int line,
+				    const char *name, int no_padding,
+				    int nesting_nr)
+{
+  object *obj;
+#if COLLECT_STATS
+  ++__bounds_stats_add_stack;
+#endif
+  /* Check that we don't create duplicates of stack objects. This can
+     happen when multiple threads are active and a thread is deleted.
+     A new thread can reuse the stack.  This can also happen when
+     using setjmp/longjmp function calls.  */
+  LOOKUP_OBJECT (tree_lookup, obj, base);
+  if (obj)
+    {
+      /* If this is an alloca object then this is ok */
+      if (obj->sclass == obj_sclass_heap
+	  && __bounds_strcmp (obj->name, "alloca") == 0)
+        {
+	  if (obj->size != size)
+	    __bounds_internal_error ("__bounds_internal_add_stack_object found "
+				     "alloca object with wrong size",
+				     __FILE__, __LINE__);
+	  return obj;
+	}
+      /* Delete function context in functions.c. This only works when
+         the object is a stack object.  */
+      if (obj->sclass != obj_sclass_stack)
+	__bounds_internal_error ("__bounds_internal_add_stack_object found "
+				 "pointer to non-stack object",
+				 __FILE__, __LINE__);
+
+      __bounds_remove_function_context (obj, nesting_nr);
+    }
+
+  if (size == 0 || align == 0)
+    __bounds_internal_error ("attempted to add a zero-sized stack object",
+			     filename, line);
+
+  /* Create a new object record. */
+  obj = new_object ();
+  obj->left = obj->right = obj->parent = NULL;
+  obj->base = base;
+  obj->size = size;
+  obj->extent = (char *) base + size;
+  obj->align = align;
+  obj->sclass = obj_sclass_stack;
+  obj->filename = filename;
+  obj->line = line;
+  obj->name = name;
+  /* For parameters, no padding can be adding between adjacent objects. Setting
+     this flag allows you to increment a pointer beyond a parameter and get
+     to the next parameter in the list.  */
+  obj->no_padding = no_padding;
+  obj->align_mask = check_align (align);
+  obj->oob_pointer = 0;
+#if SPLAY_COUNT_OPERATIONS || SPLAY_COUNT_STAT
+  obj->hits = 0;
+  obj->steps = 0;
+#endif
+#if OBJECT_CLASS
+  tree_add (&stack_object_tree, obj);
+#else
+  tree_add (&object_tree, obj);
+#endif
+
+  if (nesting_nr != -1)
+    __bounds_add_function_object (obj, nesting_nr);
+
+  return obj;
+}
+
+void
+__bounds_add_stack_object (void *base, size_t size, size_t align,
+			   const char *filename, int line, const char *name,
+			   int nesting_nr)
+{
+  sigset_t old_mask;
+
+#if DEBUG_FEATURES
+  if (__bounds_debug_print_calls)
+    printf ("__bounds_add_stack_object"
+	    "(p=%p, sz=%u, align=%u, file=\"%s\", ln=%d, name=\"%s\""
+	    " nesting_nr=%d)\n",
+	    base, size, align, filename, line, name, nesting_nr);
+#endif
+
+  enter_critical_section (&old_mask);
+  __bounds_internal_add_stack_object (base, size, align,
+				      filename, line, name, 0, nesting_nr);
+  leave_critical_section (&old_mask);
+}
+
+void
+__bounds_delete_stack_object (void *base, object * obj, int nesting_nr)
+{
+  sigset_t old_mask;
+#if DEBUG_FEATURES
+  if (__bounds_debug_print_calls)
+    printf ("__bounds_delete_stack_object (p=%p, nesting_nr=%d)\n",
+	    base, nesting_nr);
+#endif
+
+  enter_critical_section (&old_mask);
+  if (obj == NULL)
+    obj = __bounds_find_object_by_base (base);
+  if (obj == NULL || obj->sclass != obj_sclass_stack)
+    {
+      if (obj && obj->sclass == obj_sclass_heap
+	  && __bounds_strcmp (obj->name, "alloca") == 0)
+	__bounds_delete_alloca_chain (obj);
+      else
+        __bounds_internal_error ("unknown or non-stack object passed"
+			         " to __bounds_delete_stack_object",
+			         __FILE__, __LINE__);
+
+    }
+  else
+    __bounds_internal_delete_stack_object (obj, nesting_nr);
+  leave_critical_section (&old_mask);
+}
+
+void
+__bounds_add_object (void *base, size_t size, size_t align,
+		     const char *filename, int line, const char *name,
+		     int no_padding)
+{
+  sigset_t old_mask;
+  object *obj;
+
+#if DEBUG_FEATURES
+  if (__bounds_debug_print_calls)
+    printf ("__bounds_add_object"
+	    "(p=%p, sz=%u, align=%u, file=\"%s\", ln=%d, name=\"%s\","
+	    " no_padding=%d)\n",
+	    base, size, align, filename, line, name, no_padding);
+#endif
+
+  enter_critical_section (&old_mask);
+  /* Create a new object record. */
+  obj = new_object ();
+  obj->left = obj->right = obj->parent = NULL;
+  obj->base = base;
+  obj->size = size;
+  obj->extent = (char *) base + size;
+  obj->align = align;
+  obj->sclass = obj_sclass_heap;
+  obj->filename = filename;
+  obj->line = line;
+  obj->name = name;
+  /* For parameters, no padding can be adding between adjacent objects. Setting
+     this flag allows you to increment a pointer beyond a parameter and get
+     to the next parameter in the list.  */
+  obj->no_padding = no_padding;
+  obj->align_mask = check_align (align);
+  obj->oob_pointer = 0;
+#if SPLAY_COUNT_OPERATIONS || SPLAY_COUNT_STAT
+  obj->hits = 0;
+  obj->steps = 0;
+#endif
+#if OBJECT_CLASS
+  tree_add (&heap_object_tree, obj);
+#else
+  tree_add (&object_tree, obj);
+#endif
+  leave_critical_section (&old_mask);
+}
+
+/* Note the location of the arguments to main.
+  (31/5/95: Made these into stack objects.)  */
+
+void
+__bounds_note_main_args (int argc, char **argv)
+{
+  int i;
+
+  if (__bounds_checking_on)
+    {
+#if COLLECT_STATS
+      ++__bounds_stats_environment;
+#endif
+      __bounds_internal_add_stack_object (argv, (argc + 1) * sizeof (char *),
+					  sizeof (char *), "main", 0,
+					  "argv", 1, -1);
+      for (i = 0; i < argc; ++i)
+	{
+#if DEBUG_FEATURES
+	  if (__bounds_debug_print_function || __bounds_error_filename)
+	    printf ("__bounds_note_main_args (arg %d, \"%s\")\n", i, argv[i]);
+#endif
+#if COLLECT_STATS
+	  ++__bounds_stats_environment;
+#endif
+	  __bounds_internal_add_stack_object (argv[i],
+					      __bounds_strlen (argv[i]) + 1,
+					      1, "main", 0, "argv", 1, -1);
+	}
+    }
+}
+
+/* Produce a debugging memory map on stderr. Only lists objects
+   between minbase and maxbase. If either of these are NULL, then
+   they default sensibly.  */
+
+static double total_hits = 0.0;
+static double total_steps = 0.0;
+
+static __inline__ const char *
+sclass_name (object * obj)
+{
+  switch (obj->sclass)
+    {
+    case obj_sclass_heap:
+      return "heap";
+    case obj_sclass_static:
+      return "static";
+    case obj_sclass_external:
+      return "external";
+    case obj_sclass_stack:
+      return "stack";
+    }
+  return NULL;
+}
+
+static unsigned
+__bounds_print_map (object * obj, int level, void *minbase, void *maxbase)
+{
+  unsigned count;
+#if SPLAY_COUNT_OPERATIONS || SPLAY_COUNT_STAT
+  double depth;
+  unsigned n1;
+  unsigned n2;
+#endif
+
+  if (obj && minbase <= obj->base && obj->base <= maxbase)
+    {
+      count = __bounds_print_map (obj->left, level + 1, minbase, maxbase);
+#if SPLAY_COUNT_OPERATIONS || SPLAY_COUNT_STAT
+      total_hits += (double) obj->hits;
+      total_steps += (double) obj->steps;
+      depth = obj->hits ? ((double) obj->steps * 100.0) / (double) obj->hits
+	: 0.0;
+      n1 = (unsigned) (depth / 100.0);
+      n2 = (unsigned) (depth - 100.0 * (double) n1);
+#endif
+      printf (
+#if SPLAY_COUNT_OPERATIONS || SPLAY_COUNT_STAT
+	       "%10u %2u.%02u %p-%p %4u %4u (%2u) %s %s %s %d\n",
+	       obj->hits, n1, n2,
+#else
+	       "%p-%p %4u %4u (%2u) %s %s %s %d\n",
+#endif
+	       obj->base,
+	       (char *) obj->extent - 1,
+	       obj->size,
+	       obj->align,
+	       level,
+	       sclass_name (obj),
+	       obj->name, obj->filename ? obj->filename : "?", obj->line);
+      count += __bounds_print_map (obj->right, level + 1, minbase, maxbase);
+      return count + 1;
+    }
+  else
+    return 0;
+}
+
+void
+__bounds_debug_memory (void *minbase, void *maxbase)
+{
+  unsigned count;
+#if SPLAY_COUNT_OPERATIONS || SPLAY_COUNT_STAT
+  double depth;
+  unsigned n1;
+  unsigned n2;
+#endif
+
+  if (maxbase == NULL)
+    maxbase = (void *) (-1);
+
+  total_hits = 0.0;
+  total_steps = 0.0;
+  printf ("Memory map:\n");
+#if OBJECT_CLASS
+  count = __bounds_print_map (static_object_tree.root, 0, minbase, maxbase);
+  count += __bounds_print_map (extern_object_tree.root, 0, minbase, maxbase);
+  count += __bounds_print_map (stack_object_tree.root, 0, minbase, maxbase);
+  count += __bounds_print_map (heap_object_tree.root, 0, minbase, maxbase);
+#else
+  count = __bounds_print_map (object_tree.root, 0, minbase, maxbase);
+#endif
+
+#if SPLAY_COUNT_OPERATIONS || SPLAY_COUNT_STAT
+  depth =
+    total_hits ? ((double) total_steps * 100.0) / (double) total_hits : 0.0;
+  n1 = (unsigned) (depth / 100.0);
+  n2 = (unsigned) (depth - 100.0 * (double) n1);
+  printf ("Number of objects: %u  average steps %u.%02u\n", count, n1, n2);
+#else
+  printf ("Number of objects: %u\n", count);
+#endif
+}
+
+#if OBJECT_CLASS
+static tree heap_tree = { NULL, NULL, NULL };
+#else
+static tree heap_tree = { NULL };
+#endif
+
+static void
+add_heap_object (object * obj)
+{
+  object *p, *last;
+  int n1, n2;
+
+  if (heap_tree.root == NULL)
+    {
+      heap_tree.root = obj;
+      obj->heap_next = NULL;
+      obj->hits = 1;
+      obj->steps = obj->size;
+    }
+  else
+    {
+      p = heap_tree.root;
+      last = NULL;
+      do
+	{
+	  if (obj->filename == NULL || p->filename == NULL)
+	    n1 = obj->filename - p->filename;
+	  else
+	    n1 = __bounds_strcmp (obj->filename, p->filename);
+	  n2 = obj->line - p->line;
+	  if (n1 == 0 && n2 == 0)
+	    {
+	      p->hits++;
+	      p->steps += obj->size;
+	      return;
+	    }
+	  else if (n1 < 0 || (n1 == 0 && n2 < 0))
+	    {
+	      obj->heap_next = p;
+	      if (last == NULL)
+		heap_tree.root = obj;
+	      else
+		last->heap_next = obj;
+	      obj->hits = 1;
+	      obj->steps = obj->size;
+	      return;
+	    }
+	  last = p;
+	  p = p->heap_next;
+	}
+      while (p);
+      last->heap_next = obj;
+      obj->heap_next = NULL;
+      obj->hits = 1;
+      obj->steps = obj->size;
+    }
+}
+
+static void
+__bounds_get_heap_objects (object * obj)
+{
+  if (obj)
+    {
+      __bounds_get_heap_objects (obj->left);
+      if (obj->sclass == obj_sclass_heap)
+	add_heap_object (obj);
+      __bounds_get_heap_objects (obj->right);
+    }
+}
+
+static void
+__bounds_print_heap_objects (object * obj)
+{
+  if (obj)
+    {
+      __bounds_print_heap_objects (obj->left);
+      if (obj->sclass == obj_sclass_heap)
+	__bounds_warn1 ("Leaked memory", obj->filename, obj->line, obj->base,
+			obj);
+      __bounds_print_heap_objects (obj->right);
+    }
+}
+
+void
+__bound_print_heap (void)
+{
+  object *p;
+  sigset_t old_mask;
+
+  enter_critical_section (&old_mask);
+#if OBJECT_CLASS
+  __bounds_get_heap_objects (static_object_tree.root);
+  __bounds_get_heap_objects (extern_object_tree.root);
+  __bounds_get_heap_objects (stack_object_tree.root);
+  __bounds_get_heap_objects (heap_object_tree.root);
+#else
+  __bounds_get_heap_objects (object_tree.root);
+#endif
+  p = heap_tree.root;
+  while (p)
+    {
+      printf
+	("Filename = %s, Line = %d, Function = %s, Count = %d Avg Size = %d, Total = %d\n",
+	 p->filename ? p->filename : "<noname>", p->line,
+	 p->name ? p->name : "<noname>", p->hits,
+	 p->steps / (p->hits > 0 ? p->hits : 1), p->steps);
+      p = p->heap_next;
+    }
+  if (__bounds_debug_print_heap >= 2)
+    {
+#if OBJECT_CLASS
+      __bounds_print_heap_objects (static_object_tree.root);
+      __bounds_print_heap_objects (extern_object_tree.root);
+      __bounds_print_heap_objects (stack_object_tree.root);
+      __bounds_print_heap_objects (heap_object_tree.root);
+#else
+      __bounds_print_heap_objects (object_tree.root);
+#endif
+    }
+  leave_critical_section (&old_mask);
+}
+
+/* The idea is that when an oob pointer is generated, a malloc is done and the 
+   address of the location newly allocated is assigned to the oob pointer. The
+   address of the object which the oob pointer used to reference is store in
+   this malloc'd location. So this becomes a pointer to the object. And the
+   address of this new location is stored in the hashtable, ie
+   pointer_to_pointer of object. We end up with only one entry per object for
+   each object with oob pointers, thus at creation of an oob pointer we enforce
+   this. Subsequently when we come across the created oob pointer, would seem
+   to be an unchecked pointer since it would not be found on our splay(object)
+   tree and it would not have the standard ILLEGAL(-2) value. But by checking
+   in our hashtable we can find the address it references we would be able
+   to correctly identify it.  */
+
+#define	HASH_SIZE	(32)	/* Must be power of 2.  */
+
+static struct oob_hashtable
+{
+  int size;
+  int maxsize;
+  oob_object **table;
+} oob_hashtable[HASH_SIZE] =
+{ [0 ... HASH_SIZE - 1] { 0, 0, NULL} };
+
+static oob_object *oob_list = NULL;
+
+static __inline__ long
+hash_oob_pointer (const void *elem)
+{
+  return ((long) elem >> 8) & (HASH_SIZE - 1);
+}
+
+void *
+__bounds_create_oob_pointer (object * obj, void *new_pointer,
+			     const char *filename, int line)
+{
+  int i;
+  int j;
+  int size;
+  long hash;
+  oob_object *oob_ptr;
+  struct oob_hashtable *oob;
+  sigset_t old_mask;
+
+  enter_critical_section (&old_mask);
+  /* Check for duplicate entries. We can speed this up by creating another
+     hash table with hash_value hash_oob_pointer (new_pointer). This
+     however creates a new problem because we have to delete the items
+     from this new hashtable as well.  */
+  if (obj->oob_pointer)
+    for (i = 0; i < HASH_SIZE; i++)
+      {
+	oob = &oob_hashtable[i];
+	size = oob->size;
+	for (j = 0; j < size; j++)
+	  if (oob->table[j]->obj == obj
+	      && oob->table[j]->oob_ptr_value == new_pointer)
+	    {
+	      oob_ptr = oob->table[j];
+	      leave_critical_section (&old_mask);
+#if DEBUG_FEATURES
+	      if (__bounds_print_oob_pointers)
+		printf ("DUPLICATE OOB-TABLE VALUE %p, OBJECT %p,"
+			" NEW %p '%s' %s:%d\n",
+			new_pointer, obj, oob_ptr,
+			obj->name ? obj->name : "(unnamed)",
+			filename ? filename : "??", line);
+#endif
+	      return oob_ptr;
+	    }
+      }
+  /* Use list of old oob objects is possible.  */
+  if (oob_list)
+    {
+      oob_ptr = oob_list;
+      oob_list = (oob_object *) oob_list->obj;
+    }
+  else
+    {
+      oob_ptr = (oob_object *) __bounds_malloc (sizeof (oob_object));
+      if (oob_ptr == NULL)
+	__bounds_internal_error ("out of memory allocating oob structure",
+				 __FILE__, __LINE__);
+    }
+  oob_ptr->obj = obj;
+  oob_ptr->oob_ptr_value = new_pointer;
+  hash = hash_oob_pointer (oob_ptr);
+  oob = &oob_hashtable[hash];
+  if (oob->size == oob->maxsize)
+    {
+      if (oob->size == 0)
+	{
+	  oob->maxsize = 8;
+	  oob->table = (oob_object **)
+	    __bounds_malloc (sizeof (oob_object *) * oob->maxsize);
+	  if (oob->table == NULL)
+	    __bounds_internal_error ("out of memory allocating oob structure",
+				     __FILE__, __LINE__);
+	}
+      else
+	{
+	  oob->maxsize *= 2;
+	  oob->table = (oob_object **)
+	    __bounds_realloc (oob->table,
+			      sizeof (oob_object *) * oob->maxsize);
+	  if (oob->table == NULL)
+	    __bounds_internal_error ("out of memory allocating oob structure",
+				     __FILE__, __LINE__);
+	}
+    }
+  oob->table[oob->size++] = oob_ptr;
+  obj->oob_pointer = 1;
+  leave_critical_section (&old_mask);
+#if DEBUG_FEATURES
+  if (__bounds_print_oob_pointers)
+    printf ("ADDED TO OOB-TABLE VALUE %p, OBJECT %p, NEW %p '%s' %s:%d\n",
+	    new_pointer, obj, oob_ptr,
+	    obj->name ? obj->name : "(unnamed)",
+	    filename ? filename : "??", line);
+#endif
+#if COLLECT_STATS
+  ++__bounds_stats_add_oob_table;
+#endif
+  return oob_ptr;
+}
+
+static __inline__ void
+__bounds_internal_setup_oob_pointer (object ** obj, void **ptr,
+				     const char *filename, int line)
+{
+  int i;
+  long hash;
+  oob_object *obj_ptr;
+  struct oob_hashtable *oob;
+
+  obj_ptr = (oob_object *) * ptr;
+  if (obj_ptr)
+    {
+      hash = hash_oob_pointer (obj_ptr);
+      oob = &oob_hashtable[hash];
+      for (i = oob->size - 1; i >= 0; i--)
+	if (oob->table[i] == obj_ptr)
+	  {
+	    *ptr = obj_ptr->oob_ptr_value;
+	    *obj = obj_ptr->obj;
+#if DEBUG_FEATURES
+	    if (__bounds_print_oob_pointers)
+	      printf ("FOUND OOB-POINTER VALUE %p, OBJECT %p, NEW %p"
+		      " '%s' %s:%d\n",
+		      obj_ptr, *obj, *ptr,
+		      (*obj)->name ? (*obj)->name : "(unnamed)",
+		      filename ? filename : "??", line);
+#endif
+#if COLLECT_STATS
+	    ++__bounds_stats_find_oob_table;
+#endif
+	    break;
+	  }
+    }
+}
+
+void
+__bounds_setup_oob_pointer (object ** obj, void **ptr,
+			    const char *filename, int line)
+{
+  sigset_t old_mask;
+
+  enter_critical_section (&old_mask);
+  __bounds_internal_setup_oob_pointer (obj, ptr, filename, line);
+  leave_critical_section (&old_mask);
+}
+
+void
+__bounds_setup2_oob_pointer (object ** obj1, void **ptr1,
+			     object ** obj2, void **ptr2,
+			     const char *filename, int line)
+{
+  sigset_t old_mask;
+
+  enter_critical_section (&old_mask);
+  __bounds_internal_setup_oob_pointer (obj1, ptr1, filename, line);
+  __bounds_internal_setup_oob_pointer (obj2, ptr2, filename, line);
+  leave_critical_section (&old_mask);
+}
+
+/* If there are a large number of oob pointers we probably should
+   rewrite the code to use a double linked list of objects. This can
+   be removed a lot faster. This will require a lot more memory.
+   Three pointers in the oob_object and one in every object.  */
+
+void
+__bounds_delete_oob_entries (object * obj)
+{
+  int i;
+  int j;
+  int k;
+  int size;
+  struct oob_hashtable *oob;
+
+  for (i = 0; i < HASH_SIZE; i++)
+    {
+      oob = &oob_hashtable[i];
+      size = oob->size;
+      for (j = 0; j < size; j++)
+	if (oob->table[j]->obj == obj)
+	  {
+	    oob->table[j]->obj = (object *) oob_list;
+	    oob_list = oob->table[j];
+	    oob->size--;
+#if DEBUG_FEATURES
+	    if (__bounds_print_oob_pointers)
+	      printf ("DELETED FROM OOB-TABLE VALUE %p, OBJECT %p, PTR %p"
+		      " '%s'\n",
+		      oob->table[j]->oob_ptr_value, obj,
+		      oob_list, obj->name ? obj->name : "(unnamed)");
+#endif
+#if COLLECT_STATS
+	    ++__bounds_stats_delete_oob_table;
+#endif
+	    k = j;
+	    for (j = j + 1; j < size; j++)
+	      if (oob->table[j]->obj == obj)
+		{
+		  oob->table[j]->obj = (object *) oob_list;
+		  oob_list = oob->table[j];
+		  oob->size--;
+#if DEBUG_FEATURES
+		  if (__bounds_print_oob_pointers)
+		    printf
+		      ("DELETED FROM OOB-TABLE VALUE %p, OBJECT %p, PTR %p"
+		       " '%s'\n", oob->table[j]->oob_ptr_value, obj, oob_list,
+		       obj->name ? obj->name : "(unnamed)");
+#endif
+#if COLLECT_STATS
+		  ++__bounds_stats_delete_oob_table;
+#endif
+		}
+	      else
+		oob->table[k++] = oob->table[j];
+	    break;
+	  }
+    }
+}
+
+/* For debugging oob pointers.  */
+
+void __bounds_print_oob_entries (void);
+
+void
+__bounds_print_oob_entries (void)
+{
+  int i;
+  int j;
+  int size = 0;
+  struct oob_hashtable *oob;
+
+  for (i = 0; i < HASH_SIZE; i++)
+    size += oob_hashtable[i].size;
+  printf ("Total of %d out of bound objects\n", size);
+  for (i = 0; i < HASH_SIZE; i++)
+    {
+      oob = &oob_hashtable[i];
+      size = oob->size;
+      for (j = 0; j < size; j++)
+	printf ("VALUE %p, OBJECT %p, PTR %p '%s' %s:%d BASE %p \n",
+		oob->table[j]->oob_ptr_value,
+		oob->table[j]->obj, oob->table[j],
+		oob->table[j]->obj->name ? oob->table[j]->obj->
+		name : "(unnamed)",
+		oob->table[j]->obj->filename ? oob->table[j]->obj->
+		filename : "??", oob->table[j]->obj->line,
+		oob->table[j]->obj->base);
+    }
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/objects.h gcc-4.0.2/gcc/bounds/lib/objects.h
--- gcc-4.0.2.org/gcc/bounds/lib/objects.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/objects.h	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,96 @@
+/* Bounds Checking for GCC.
+   Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   File:
+  	lib/objects.h
+   Summary:
+  	Format of the tree of memory objects used by the library.
+   Other notes:
+  	This file is shared with `tree/buildtree.c'.
+   Author      	Date		Notes
+   RWMJ		13/1/95		Copied this out of `bounds-lib.h'
+   RWMJ		9/2/95		Modified slightly for use with splay trees.
+*/
+
+#ifndef _BOUNDS_OBJECT_H_
+#define _BOUNDS_OBJECT_H_
+
+#define SPLAY_COUNT_OPERATIONS  0	/* Keep splay-tree statistics.  */
+#define SPLAY_STRICT_CHECKING   0	/* Stringent checks (slow).  */
+#define SPLAY_COUNT_STAT        0	/* Do splay statistics.  */
+#define	OBJECT_CLASS		0	/* Use trees for object classes */
+#define	OBJECT_COUNT_CLASS	0	/* Do object classes statistics */
+
+typedef enum
+{				/* Storage class.  */
+  obj_sclass_static,		/* Static, ie. global in low memory.  */
+  obj_sclass_external,		/* External objects.  */
+  obj_sclass_stack,		/* On the stack.  */
+  obj_sclass_heap		/* On the heap.  */
+} obj_sclass;
+
+/* The first three values of this structure are used in c-bounds.c.  */
+
+typedef struct object
+{
+  void *base;			/* Points to base of the object.  */
+  void *extent;			/* Points to last byte in object + 1.  */
+  size_t size;			/* Size of the object.  */
+  struct object *left, *right;	/* Left/right in tree.  */
+  struct object *parent;	/* Parent of this tree (NULL if root).  */
+  struct object *heap_next;	/* next heap object.  */
+  struct object *next;		/* Next param or stack object. Used in
+				   function.c  */
+  unsigned char left_of_parent;	/* Whether on left or right of parent.  */
+  unsigned char no_padding;	/* This is for parameters where no padding
+				   bytes are added after the object. */
+  unsigned char oob_pointer;	/* Flag set when an oob pointer is generated
+				   from the object.  */
+  obj_sclass sclass:2;		/* Storage class.  */
+  unsigned int align_mask:1;	/* Flag is set is align is power of two.  */
+  unsigned int:5;		/* Spare.  */
+  size_t align;			/* Size of elements in the object.  */
+  const char *filename;		/* Place where object was constructed.  */
+  int line;
+  const char *name;		/* Name of the object.  */
+
+#if defined (SPLAY_COUNT_OPERATIONS) || defined (SPLAY_COUNT_STAT)
+  unsigned hits;		/* Number of time this object has been found
+				   by tree_lookup or tree_lookup_base fns.  */
+  unsigned steps;		/* maximum steps to find object.  */
+#endif
+} object;
+
+/* This structure describes a whole splay tree. The root node in a splay
+   tree changes often.  */
+
+typedef struct
+{
+#if OBJECT_CLASS
+  void *min;
+  void *max;
+#endif
+  object *root;
+} tree;
+
+typedef struct
+{
+  object *obj;			/* pointer to referent object */
+  void *oob_ptr_value;		/* value of out-of-bounds pointer */
+} oob_object;
+
+#endif /* _BOUNDS_OBJECT_H_ */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/obstack.c gcc-4.0.2/gcc/bounds/lib/obstack.c
--- gcc-4.0.2.org/gcc/bounds/lib/obstack.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/obstack.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,475 @@
+/* obstack.c - subroutines used implicitly by object stack macros
+   Copyright (C) 1988, 89, 90, 91, 92, 93, 94 Free Software Foundation, Inc.
+
+This file is part of the GNU C Library.  Its master source is NOT part of
+the C library, however.  The master source lives in /gd/gnu/lib.
+
+The GNU C Library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public License as
+published by the Free Software Foundation; either version 2 of the
+License, or (at your option) any later version.
+
+The GNU C Library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with the GNU C Library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.  */
+
+#include "obstack.h"
+
+/* This is just to get __GNU_LIBRARY__ defined.  */
+#include <stdio.h>
+
+/* Comment out all this code if we are using the GNU C Library, and are not
+   actually compiling the library itself.  This code is part of the GNU C
+   Library, but also included in many other GNU distributions.  Compiling
+   and linking in this code is a waste when using the GNU C library
+   (especially if it is a shared library).  Rather than having every GNU
+   program understand `configure --with-gnu-libc' and omit the object files,
+   it is simpler to just do this in the source for each such file.  */
+
+#if defined (_LIBC) || !defined (__GNU_LIBRARY__)
+
+
+#ifdef __STDC__
+#define POINTER void *
+#else
+#define POINTER char *
+#endif
+
+/* Determine default alignment.  */
+struct fooalign
+{
+  char x;
+  double d;
+};
+#define DEFAULT_ALIGNMENT  \
+  ((PTR_INT_TYPE) ((char *)&((struct fooalign *) 0)->d - (char *)0))
+/* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.
+   But in fact it might be less smart and round addresses to as much as
+   DEFAULT_ROUNDING.  So we prepare for it to do that.  */
+union fooround
+{
+  long x;
+  double d;
+};
+#define DEFAULT_ROUNDING (sizeof (union fooround))
+
+/* When we copy a long block of data, this is the unit to do it with.
+   On some machines, copying successive ints does not work;
+   in such a case, redefine COPYING_UNIT to `long' (if that works)
+   or `char' as a last resort.  */
+#ifndef COPYING_UNIT
+#define COPYING_UNIT int
+#endif
+
+/* The non-GNU-C macros copy the obstack into this global variable
+   to avoid multiple evaluation.  */
+
+struct obstack *_obstack;
+
+/* Define a macro that either calls functions with the traditional malloc/free
+   calling interface, or calls functions with the mmalloc/mfree interface
+   (that adds an extra first argument), based on the state of use_extra_arg.
+   For free, do not use ?:, since some compilers, like the MIPS compilers,
+   do not allow (expr) ? void : void.  */
+
+#define CALL_CHUNKFUN(h, size) \
+  (((h) -> use_extra_arg) \
+   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
+   : (*(h)->chunkfun) ((size)))
+
+#define CALL_FREEFUN(h, old_chunk) \
+  do { \
+    if ((h) -> use_extra_arg) \
+      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
+    else \
+      (*(h)->freefun) ((old_chunk)); \
+  } while (0)
+
+
+/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).
+   Objects start on multiples of ALIGNMENT (0 means use default).
+   CHUNKFUN is the function to use to allocate chunks,
+   and FREEFUN the function to free them.
+
+   Return nonzero if successful, zero if out of memory.
+   To recover from an out of memory error,
+   free up some memory, then call this again.  */
+
+int
+_obstack_begin (struct obstack *h, int size, int alignment,
+		POINTER (*chunkfun) (), void (*freefun) ())
+{
+  register struct _obstack_chunk *chunk;	/* points to new chunk */
+
+  if (alignment == 0)
+    alignment = DEFAULT_ALIGNMENT;
+  if (size == 0)
+    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
+    {
+      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
+         Use the values for range checking, because if range checking is off,
+         the extra bytes won't be missed terribly, but if range checking is on
+         and we used a larger request, a whole extra 4096 bytes would be
+         allocated.
+
+         These number are irrelevant to the new GNU malloc.  I suspect it is
+         less sensitive to the size of the request.  */
+      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
+		    + 4 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1));
+      size = 4096 - extra;
+    }
+
+  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
+  h->freefun = freefun;
+  h->chunk_size = size;
+  h->alignment_mask = alignment - 1;
+  h->use_extra_arg = 0;
+
+  chunk = h->chunk = CALL_CHUNKFUN (h, h->chunk_size);
+  if (!chunk)
+    {
+      h->alloc_failed = 1;
+      return 0;
+    }
+  h->alloc_failed = 0;
+  h->next_free = h->object_base = chunk->contents;
+  h->chunk_limit = chunk->limit = (char *) chunk + h->chunk_size;
+  chunk->prev = 0;
+  /* The initial chunk now contains no empty object.  */
+  h->maybe_empty_object = 0;
+  return 1;
+}
+
+int
+_obstack_begin_1 (struct obstack *h, int size, int alignment,
+		  POINTER (*chunkfun) (), void (*freefun) (), POINTER arg)
+{
+  register struct _obstack_chunk *chunk;	/* points to new chunk */
+
+  if (alignment == 0)
+    alignment = DEFAULT_ALIGNMENT;
+  if (size == 0)
+    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
+    {
+      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
+         Use the values for range checking, because if range checking is off,
+         the extra bytes won't be missed terribly, but if range checking is on
+         and we used a larger request, a whole extra 4096 bytes would be
+         allocated.
+
+         These number are irrelevant to the new GNU malloc.  I suspect it is
+         less sensitive to the size of the request.  */
+      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
+		    + 4 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1));
+      size = 4096 - extra;
+    }
+
+  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
+  h->freefun = freefun;
+  h->chunk_size = size;
+  h->alignment_mask = alignment - 1;
+  h->extra_arg = arg;
+  h->use_extra_arg = 1;
+
+  chunk = h->chunk = CALL_CHUNKFUN (h, h->chunk_size);
+  if (!chunk)
+    {
+      h->alloc_failed = 1;
+      return 0;
+    }
+  h->alloc_failed = 0;
+  h->next_free = h->object_base = chunk->contents;
+  h->chunk_limit = chunk->limit = (char *) chunk + h->chunk_size;
+  chunk->prev = 0;
+  /* The initial chunk now contains no empty object.  */
+  h->maybe_empty_object = 0;
+  return 1;
+}
+
+/* Allocate a new current chunk for the obstack *H
+   on the assumption that LENGTH bytes need to be added
+   to the current object, or a new object of length LENGTH allocated.
+   Copies any partial object from the end of the old chunk
+   to the beginning of the new one.  */
+
+void
+_obstack_newchunk (struct obstack *h, int length)
+{
+  register struct _obstack_chunk *old_chunk = h->chunk;
+  register struct _obstack_chunk *new_chunk;
+  register long new_size;
+  register int obj_size = h->next_free - h->object_base;
+  register int i;
+  int already;
+
+  /* Compute size for new chunk.  */
+  new_size = (obj_size + length) + (obj_size >> 3) + 100;
+  if (new_size < h->chunk_size)
+    new_size = h->chunk_size;
+
+  /* Allocate and initialize the new chunk.  */
+  new_chunk = CALL_CHUNKFUN (h, new_size);
+  if (!new_chunk)
+    {
+      h->alloc_failed = 1;
+      return;
+    }
+  h->alloc_failed = 0;
+  h->chunk = new_chunk;
+  new_chunk->prev = old_chunk;
+  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;
+
+  /* Move the existing object to the new chunk.
+     Word at a time is fast and is safe if the object
+     is sufficiently aligned.  */
+  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)
+    {
+      for (i = obj_size / sizeof (COPYING_UNIT) - 1; i >= 0; i--)
+	((COPYING_UNIT *) new_chunk->contents)[i]
+	  = ((COPYING_UNIT *) h->object_base)[i];
+      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,
+         but that can cross a page boundary on a machine
+         which does not do strict alignment for COPYING_UNITS.  */
+      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);
+    }
+  else
+    already = 0;
+  /* Copy remaining bytes one by one.  */
+  for (i = already; i < obj_size; i++)
+    new_chunk->contents[i] = h->object_base[i];
+
+  /* If the object just copied was the only data in OLD_CHUNK,
+     free that chunk and remove it from the chain.
+     But not if that chunk might contain an empty object.  */
+  if (h->object_base == old_chunk->contents && !h->maybe_empty_object)
+    {
+      new_chunk->prev = old_chunk->prev;
+      CALL_FREEFUN (h, old_chunk);
+    }
+
+  h->object_base = new_chunk->contents;
+  h->next_free = h->object_base + obj_size;
+  /* The new chunk certainly contains no empty object yet.  */
+  h->maybe_empty_object = 0;
+}
+
+/* Return nonzero if object OBJ has been allocated from obstack H.
+   This is here for debugging.
+   If you use it in a program, you are probably losing.  */
+
+#ifdef __STDC__
+/* Suppress -Wmissing-prototypes warning.  We don't want to declare this in
+   obstack.h because it is just for debugging.  */
+int _obstack_allocated_p (struct obstack *h, POINTER obj);
+#endif
+
+int
+_obstack_allocated_p (struct obstack *h, POINTER obj)
+{
+  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
+  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
+
+  lp = (h)->chunk;
+  /* We use >= rather than > since the object cannot be exactly at
+     the beginning of the chunk but might be an empty object exactly
+     at the end of an adjacent chunk. */
+  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
+    {
+      plp = lp->prev;
+      lp = plp;
+    }
+  return lp != 0;
+}
+
+/* Free objects in obstack H, including OBJ and everything allocate
+   more recently than OBJ.  If OBJ is zero, free everything in H.  */
+
+#undef obstack_free
+
+/* This function has two names with identical definitions.
+   This is the first one, called from non-ANSI code.  */
+
+void
+_obstack_free (struct obstack *h, POINTER obj)
+{
+  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
+  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
+
+  lp = h->chunk;
+  /* We use >= because there cannot be an object at the beginning of a chunk.
+     But there can be an empty object at that address
+     at the end of another chunk.  */
+  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
+    {
+      plp = lp->prev;
+      CALL_FREEFUN (h, lp);
+      lp = plp;
+      /* If we switch chunks, we can't tell whether the new current
+         chunk contains an empty object, so assume that it may.  */
+      h->maybe_empty_object = 1;
+    }
+  if (lp)
+    {
+      h->object_base = h->next_free = (char *) (obj);
+      h->chunk_limit = lp->limit;
+      h->chunk = lp;
+    }
+  else if (obj != 0)
+    /* obj is not in any of the chunks! */
+    abort ();
+}
+
+/* This function is used from ANSI code.  */
+
+void
+obstack_free (struct obstack *h, POINTER obj)
+{
+  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
+  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
+
+  lp = h->chunk;
+  /* We use >= because there cannot be an object at the beginning of a chunk.
+     But there can be an empty object at that address
+     at the end of another chunk.  */
+  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
+    {
+      plp = lp->prev;
+      CALL_FREEFUN (h, lp);
+      lp = plp;
+      /* If we switch chunks, we can't tell whether the new current
+         chunk contains an empty object, so assume that it may.  */
+      h->maybe_empty_object = 1;
+    }
+  if (lp)
+    {
+      h->object_base = h->next_free = (char *) (obj);
+      h->chunk_limit = lp->limit;
+      h->chunk = lp;
+    }
+  else if (obj != 0)
+    /* obj is not in any of the chunks! */
+    abort ();
+}
+
+#if 0
+/* These are now turned off because the applications do not use it
+   and it uses bcopy via obstack_grow, which causes trouble on sysV.  */
+
+/* Now define the functional versions of the obstack macros.
+   Define them to simply use the corresponding macros to do the job.  */
+
+#ifdef __STDC__
+/* These function definitions do not work with non-ANSI preprocessors;
+   they won't pass through the macro names in parentheses.  */
+
+/* The function names appear in parentheses in order to prevent
+   the macro-definitions of the names from being expanded there.  */
+
+POINTER (obstack_base) (obstack)
+     struct obstack *obstack;
+{
+  return obstack_base (obstack);
+}
+
+POINTER (obstack_next_free) (obstack)
+     struct obstack *obstack;
+{
+  return obstack_next_free (obstack);
+}
+
+int (obstack_object_size) (obstack)
+     struct obstack *obstack;
+{
+  return obstack_object_size (obstack);
+}
+
+int (obstack_room) (obstack)
+     struct obstack *obstack;
+{
+  return obstack_room (obstack);
+}
+
+void (obstack_grow) (obstack, pointer, length)
+     struct obstack *obstack;
+     POINTER pointer;
+     int length;
+{
+  obstack_grow (obstack, pointer, length);
+}
+
+void (obstack_grow0) (obstack, pointer, length)
+     struct obstack *obstack;
+     POINTER pointer;
+     int length;
+{
+  obstack_grow0 (obstack, pointer, length);
+}
+
+void (obstack_1grow) (obstack, character)
+     struct obstack *obstack;
+     int character;
+{
+  obstack_1grow (obstack, character);
+}
+
+void (obstack_blank) (obstack, length)
+     struct obstack *obstack;
+     int length;
+{
+  obstack_blank (obstack, length);
+}
+
+void (obstack_1grow_fast) (obstack, character)
+     struct obstack *obstack;
+     int character;
+{
+  obstack_1grow_fast (obstack, character);
+}
+
+void (obstack_blank_fast) (obstack, length)
+     struct obstack *obstack;
+     int length;
+{
+  obstack_blank_fast (obstack, length);
+}
+
+POINTER (obstack_finish) (obstack)
+     struct obstack *obstack;
+{
+  return obstack_finish (obstack);
+}
+
+POINTER (obstack_alloc) (obstack, length)
+     struct obstack *obstack;
+     int length;
+{
+  return obstack_alloc (obstack, length);
+}
+
+POINTER (obstack_copy) (obstack, pointer, length)
+     struct obstack *obstack;
+     POINTER pointer;
+     int length;
+{
+  return obstack_copy (obstack, pointer, length);
+}
+
+POINTER (obstack_copy0) (obstack, pointer, length)
+     struct obstack *obstack;
+     POINTER pointer;
+     int length;
+{
+  return obstack_copy0 (obstack, pointer, length);
+}
+
+#endif /* __STDC__ */
+
+#endif /* 0 */
+
+#endif /* _LIBC or not __GNU_LIBRARY__.  */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/obstack.h gcc-4.0.2/gcc/bounds/lib/obstack.h
--- gcc-4.0.2.org/gcc/bounds/lib/obstack.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/obstack.h	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,517 @@
+/* obstack.h - object stack macros
+   Copyright (C) 1988, 89, 90, 91, 92, 93, 94 Free Software Foundation, Inc.
+
+This file is part of the GNU C Library.  Its master source is NOT part of
+the C library, however.  The master source lives in /gd/gnu/lib.
+
+The GNU C Library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public License as
+published by the Free Software Foundation; either version 2 of the
+License, or (at your option) any later version.
+
+The GNU C Library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with the GNU C Library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.  */
+
+/* Summary:
+
+All the apparent functions defined here are macros. The idea
+is that you would use these pre-tested macros to solve a
+very specific set of problems, and they would run fast.
+Caution: no side-effects in arguments please!! They may be
+evaluated MANY times!!
+
+These macros operate a stack of objects.  Each object starts life
+small, and may grow to maturity.  (Consider building a word syllable
+by syllable.)  An object can move while it is growing.  Once it has
+been "finished" it never changes address again.  So the "top of the
+stack" is typically an immature growing object, while the rest of the
+stack is of mature, fixed size and fixed address objects.
+
+These routines grab large chunks of memory, using a function you
+supply, called `obstack_chunk_alloc'.  On occasion, they free chunks,
+by calling `obstack_chunk_free'.  You must define them and declare
+them before using any obstack macros.
+
+Each independent stack is represented by a `struct obstack'.
+Each of the obstack macros expects a pointer to such a structure
+as the first argument.
+
+One motivation for this package is the problem of growing char strings
+in symbol tables.  Unless you are "fascist pig with a read-only mind"
+--Gosper's immortal quote from HAKMEM item 154, out of context--you
+would not like to put any arbitrary upper limit on the length of your
+symbols.
+
+In practice this often means you will build many short symbols and a
+few long symbols.  At the time you are reading a symbol you don't know
+how long it is.  One traditional method is to read a symbol into a
+buffer, realloc()ating the buffer every time you try to read a symbol
+that is longer than the buffer.  This is beaut, but you still will
+want to copy the symbol from the buffer to a more permanent
+symbol-table entry say about half the time.
+
+With obstacks, you can work differently.  Use one obstack for all symbol
+names.  As you read a symbol, grow the name in the obstack gradually.
+When the name is complete, finalize it.  Then, if the symbol exists already,
+free the newly read name.
+
+The way we do this is to take a large chunk, allocating memory from
+low addresses.  When you want to build a symbol in the chunk you just
+add chars above the current "high water mark" in the chunk.  When you
+have finished adding chars, because you got to the end of the symbol,
+you know how long the chars are, and you can create a new object.
+Mostly the chars will not burst over the highest address of the chunk,
+because you would typically expect a chunk to be (say) 100 times as
+long as an average object.
+
+In case that isn't clear, when we have enough chars to make up
+the object, THEY ARE ALREADY CONTIGUOUS IN THE CHUNK (guaranteed)
+so we just point to it where it lies.  No moving of chars is
+needed and this is the second win: potentially long strings need
+never be explicitly shuffled. Once an object is formed, it does not
+change its address during its lifetime.
+
+When the chars burst over a chunk boundary, we allocate a larger
+chunk, and then copy the partly formed object from the end of the old
+chunk to the beginning of the new larger chunk.  We then carry on
+accreting characters to the end of the object as we normally would.
+
+A special macro is provided to add a single char at a time to a
+growing object.  This allows the use of register variables, which
+break the ordinary 'growth' macro.
+
+Summary:
+	We allocate large chunks.
+	We carve out one object at a time from the current chunk.
+	Once carved, an object never moves.
+	We are free to append data of any size to the currently
+	  growing object.
+	Exactly one object is growing in an obstack at any one time.
+	You can run one obstack per control block.
+	You may have as many control blocks as you dare.
+	Because of the way we do it, you can `unwind' an obstack
+	  back to a previous state. (You may remove objects much
+	  as you would with a stack.)
+*/
+
+
+/* Don't do the contents of this file more than once.  */
+
+#ifndef __OBSTACK_H__
+#define __OBSTACK_H__
+
+/* We use subtraction of (char *)0 instead of casting to int
+   because on word-addressable machines a simple cast to int
+   may ignore the byte-within-word field of the pointer.  */
+
+#ifndef __PTR_TO_INT
+#define __PTR_TO_INT(P) ((P) - (char *)0)
+#endif
+
+#ifndef __INT_TO_PTR
+#define __INT_TO_PTR(P) ((P) + (char *)0)
+#endif
+
+/* We need the type of the resulting object.  In ANSI C it is ptrdiff_t
+   but in traditional C it is usually long.  If we are in ANSI C and
+   don't already have ptrdiff_t get it.  */
+
+#if defined (__STDC__) && ! defined (offsetof)
+#if defined (__GNUC__) && defined (IN_GCC)
+/* On Next machine, the system's stddef.h screws up if included
+   after we have defined just ptrdiff_t, so include all of stddef.h.
+   Otherwise, define just ptrdiff_t, which is all we need.  */
+#ifndef __NeXT__
+#define __need_ptrdiff_t
+#endif
+#endif
+
+#include <stddef.h>
+#endif
+
+#ifdef __STDC__
+#define PTR_INT_TYPE ptrdiff_t
+#else
+#define PTR_INT_TYPE long
+#endif
+
+struct _obstack_chunk		/* Lives at front of each chunk. */
+{
+  char *limit;			/* 1 past end of this chunk */
+  struct _obstack_chunk *prev;	/* address of prior chunk or NULL */
+  char contents[4];		/* objects begin here */
+};
+
+struct obstack			/* control current object in current chunk */
+{
+  long chunk_size;		/* preferred size to allocate chunks in */
+  struct _obstack_chunk *chunk;	/* address of current struct obstack_chunk */
+  char *object_base;		/* address of object we are building */
+  char *next_free;		/* where to add next char to current object */
+  char *chunk_limit;		/* address of char after current chunk */
+  PTR_INT_TYPE temp;		/* Temporary for some macros.  */
+  int alignment_mask;		/* Mask of alignment for each object. */
+  struct _obstack_chunk *(*chunkfun) ();	/* User's fcn to allocate a chunk.  */
+  void (*freefun) ();		/* User's function to free a chunk.  */
+  char *extra_arg;		/* first arg for chunk alloc/dealloc funcs */
+  unsigned use_extra_arg:1;	/* chunk alloc/dealloc funcs take extra arg */
+  unsigned maybe_empty_object:1;	/* There is a possibility that the current
+					   chunk contains a zero-length object.  This
+					   prevents freeing the chunk if we allocate
+					   a bigger chunk to replace it. */
+  unsigned alloc_failed:1;	/* chunk alloc func returned 0 */
+};
+
+/* Declare the external functions we use; they are in obstack.c.  */
+
+#ifdef __STDC__
+extern void _obstack_newchunk (struct obstack *, int);
+extern void _obstack_free (struct obstack *, void *);
+extern int _obstack_begin (struct obstack *, int, int,
+			   void *(*)(), void (*)());
+extern int _obstack_begin_1 (struct obstack *, int, int,
+			     void *(*)(), void (*)(), void *);
+#else
+extern void _obstack_newchunk ();
+extern void _obstack_free ();
+extern int _obstack_begin ();
+extern int _obstack_begin_1 ();
+#endif
+
+#ifdef __STDC__
+
+/* Do the function-declarations after the structs
+   but before defining the macros.  */
+
+void obstack_init (struct obstack *obstack);
+
+void *obstack_alloc (struct obstack *obstack, int size);
+
+void *obstack_copy (struct obstack *obstack, void *address, int size);
+void *obstack_copy0 (struct obstack *obstack, void *address, int size);
+
+void obstack_free (struct obstack *obstack, void *block);
+
+void obstack_blank (struct obstack *obstack, int size);
+
+void obstack_grow (struct obstack *obstack, void *data, int size);
+void obstack_grow0 (struct obstack *obstack, void *data, int size);
+
+void obstack_1grow (struct obstack *obstack, int data_char);
+void obstack_ptr_grow (struct obstack *obstack, void *data);
+void obstack_int_grow (struct obstack *obstack, int data);
+
+void *obstack_finish (struct obstack *obstack);
+
+int obstack_object_size (struct obstack *obstack);
+
+int obstack_room (struct obstack *obstack);
+void obstack_1grow_fast (struct obstack *obstack, int data_char);
+void obstack_ptr_grow_fast (struct obstack *obstack, void *data);
+void obstack_int_grow_fast (struct obstack *obstack, int data);
+void obstack_blank_fast (struct obstack *obstack, int size);
+
+void *obstack_base (struct obstack *obstack);
+void *obstack_next_free (struct obstack *obstack);
+int obstack_alignment_mask (struct obstack *obstack);
+int obstack_chunk_size (struct obstack *obstack);
+
+#endif /* __STDC__ */
+
+/* Non-ANSI C cannot really support alternative functions for these macros,
+   so we do not declare them.  */
+
+/* Pointer to beginning of object being allocated or to be allocated next.
+   Note that this might not be the final address of the object
+   because a new chunk might be needed to hold the final size.  */
+
+#define obstack_base(h) ((h)->alloc_failed ? 0 : (h)->object_base)
+
+/* Size for allocating ordinary chunks.  */
+
+#define obstack_chunk_size(h) ((h)->chunk_size)
+
+/* Pointer to next byte not yet allocated in current chunk.  */
+
+#define obstack_next_free(h)	((h)->alloc_failed ? 0 : (h)->next_free)
+
+/* Mask specifying low bits that should be clear in address of an object.  */
+
+#define obstack_alignment_mask(h) ((h)->alignment_mask)
+
+#define obstack_init(h) \
+  _obstack_begin ((h), 0, 0, \
+		  (void *(*) ()) obstack_chunk_alloc, (void (*) ()) obstack_chunk_free)
+
+#define obstack_begin(h, size) \
+  _obstack_begin ((h), (size), 0, \
+		  (void *(*) ()) obstack_chunk_alloc, (void (*) ()) obstack_chunk_free)
+
+#define obstack_specify_allocation(h, size, alignment, chunkfun, freefun) \
+  _obstack_begin ((h), (size), (alignment), \
+		    (void *(*) ()) (chunkfun), (void (*) ()) (freefun))
+
+#define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \
+  _obstack_begin_1 ((h), (size), (alignment), \
+		    (void *(*) ()) (chunkfun), (void (*) ()) (freefun), (arg))
+
+#define obstack_chunkfun(h, newchunkfun) \
+  ((h) -> chunkfun = (struct _obstack_chunk *(*)()) (newchunkfun))
+
+#define obstack_freefun(h, newfreefun) \
+  ((h) -> freefun = (void (*)()) (newfreefun))
+
+#define obstack_1grow_fast(h,achar) (*((h)->next_free)++ = achar)
+
+#define obstack_blank_fast(h,n) ((h)->next_free += (n))
+
+#if defined (__GNUC__) && defined (__STDC__)
+#if __GNUC__ < 2
+#define __extension__
+#endif
+
+/* For GNU C, if not -traditional,
+   we can define these macros to compute all args only once
+   without using a global variable.
+   Also, we can avoid using the `temp' slot, to make faster code.  */
+
+#define obstack_object_size(OBSTACK)					\
+  __extension__								\
+  ({ struct obstack *__o = (OBSTACK);					\
+     __o->alloc_failed ? 0 :						\
+     (unsigned) (__o->next_free - __o->object_base); })
+
+#define obstack_room(OBSTACK)						\
+  __extension__								\
+  ({ struct obstack *__o = (OBSTACK);					\
+     (unsigned) (__o->chunk_limit - __o->next_free); })
+
+#define obstack_grow(OBSTACK,where,length)				\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   int __len = (length);						\
+   if (__o->next_free + __len > __o->chunk_limit)			\
+     _obstack_newchunk (__o, __len);					\
+   if (!__o->alloc_failed)						\
+     {									\
+        __bounds_memmove ((char *) (where), __o->next_free, __len);	\
+	__o->next_free += __len;					\
+     }									\
+   (void) 0; })
+
+#define obstack_grow0(OBSTACK,where,length)				\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   int __len = (length);						\
+   if (__o->next_free + __len + 1 > __o->chunk_limit)			\
+     _obstack_newchunk (__o, __len + 1);				\
+   if (!__o->alloc_failed)						\
+     {									\
+       __bounds_memmove ((char *) (where), __o->next_free, __len);	\
+       __o->next_free += __len;						\
+       *(__o->next_free)++ = 0;						\
+     }									\
+   (void) 0; })
+
+#define obstack_1grow(OBSTACK,datum)					\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   if (__o->next_free + 1 > __o->chunk_limit)				\
+     _obstack_newchunk (__o, 1);					\
+   if (!__o->alloc_failed)						\
+     *(__o->next_free)++ = (datum);					\
+   (void) 0; })
+
+/* These assume that the obstack alignment is good enough for pointers or ints,
+   and that the data added so far to the current object
+   shares that much alignment.  */
+
+#define obstack_ptr_grow(OBSTACK,datum)					\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   if (__o->next_free + sizeof (void *) > __o->chunk_limit)		\
+     _obstack_newchunk (__o, sizeof (void *));				\
+   if (!__o->alloc_failed)						\
+     *((void **)__o->next_free)++ = ((void *)datum);			\
+   (void) 0; })
+
+#define obstack_int_grow(OBSTACK,datum)					\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   if (__o->next_free + sizeof (int) > __o->chunk_limit)		\
+     _obstack_newchunk (__o, sizeof (int));				\
+   if (!__o->alloc_failed)						\
+     *((int *)__o->next_free)++ = ((int)datum);				\
+   (void) 0; })
+
+#define obstack_ptr_grow_fast(h,aptr) (*((void **)(h)->next_free)++ = (void *)aptr)
+#define obstack_int_grow_fast(h,aint) (*((int *)(h)->next_free)++ = (int)aint)
+
+#define obstack_blank(OBSTACK,length)					\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   int __len = (length);						\
+   if (__o->chunk_limit - __o->next_free < __len)			\
+     _obstack_newchunk (__o, __len);					\
+   if (!__o->alloc_failed)						\
+     __o->next_free += __len;						\
+   (void) 0; })
+
+#define obstack_alloc(OBSTACK,length)					\
+__extension__								\
+({ struct obstack *__h = (OBSTACK);					\
+   obstack_blank (__h, (length));					\
+   obstack_finish (__h); })
+
+#define obstack_copy(OBSTACK,where,length)				\
+__extension__								\
+({ struct obstack *__h = (OBSTACK);					\
+   obstack_grow (__h, (where), (length));				\
+   obstack_finish (__h); })
+
+#define obstack_copy0(OBSTACK,where,length)				\
+__extension__								\
+({ struct obstack *__h = (OBSTACK);					\
+   obstack_grow0 (__h, (where), (length));				\
+   obstack_finish (__h); })
+
+/* The local variable is named __o1 to avoid a name conflict
+   when obstack_blank is called.  */
+#define obstack_finish(OBSTACK)  					\
+__extension__								\
+({ struct obstack *__o1 = (OBSTACK);					\
+   void *value;								\
+   if (__o1->alloc_failed)						\
+     value = 0;								\
+   else									\
+     {									\
+       value = (void *) __o1->object_base;				\
+       if (__o1->next_free == value)					\
+         __o1->maybe_empty_object = 1;					\
+       __o1->next_free							\
+	 = __INT_TO_PTR ((__PTR_TO_INT (__o1->next_free)+__o1->alignment_mask)\
+			 & ~ (__o1->alignment_mask));			\
+       if (__o1->next_free - (char *)__o1->chunk			\
+	   > __o1->chunk_limit - (char *)__o1->chunk)			\
+	 __o1->next_free = __o1->chunk_limit;				\
+       __o1->object_base = __o1->next_free;				\
+      }									\
+   value; })
+
+#define obstack_free(OBSTACK, OBJ)					\
+__extension__								\
+({ struct obstack *__o = (OBSTACK);					\
+   void *__obj = (OBJ);							\
+   if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit)  \
+     __o->next_free = __o->object_base = __obj;				\
+   else (obstack_free) (__o, __obj); })
+
+#else /* not __GNUC__ or not __STDC__ */
+
+#define obstack_object_size(h) \
+ (unsigned) ((h)->alloc_failed ? 0 : (h)->next_free - (h)->object_base)
+
+#define obstack_room(h)		\
+ (unsigned) ((h)->chunk_limit - (h)->next_free)
+
+/* Note that the call to _obstack_newchunk is enclosed in (..., 0)
+   so that we can avoid having void expressions
+   in the arms of the conditional expression.
+   Casting the third operand to void was tried before,
+   but some compilers won't accept it.  */
+
+#define obstack_grow(h,where,length)					\
+( (h)->temp = (length),							\
+  (((h)->next_free + (h)->temp > (h)->chunk_limit)			\
+   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),			\
+  ((h)->alloc_failed ? 0 :						\
+  (__bounds_memmove ((char *) (where), (h)->next_free, (h)->temp),	\
+  (h)->next_free += (h)->temp)))
+
+#define obstack_grow0(h,where,length)					\
+( (h)->temp = (length),							\
+  (((h)->next_free + (h)->temp + 1 > (h)->chunk_limit)			\
+   ? (_obstack_newchunk ((h), (h)->temp + 1), 0) : 0),			\
+  ((h)->alloc_failed ? 0 :						\
+  (__bounds_memmove ((char *) (where), (h)->next_free, (h)->temp),	\
+  (h)->next_free += (h)->temp,						\
+  *((h)->next_free)++ = 0)))
+
+#define obstack_1grow(h,datum)						\
+( (((h)->next_free + 1 > (h)->chunk_limit)				\
+   ? (_obstack_newchunk ((h), 1), 0) : 0),				\
+ ((h)->alloc_failed ? 0 :						\
+  (*((h)->next_free)++ = (datum))))
+
+#define obstack_ptr_grow(h,datum)					\
+( (((h)->next_free + sizeof (char *) > (h)->chunk_limit)		\
+   ? (_obstack_newchunk ((h), sizeof (char *)), 0) : 0),		\
+  ((h)->alloc_failed ? 0 :						\
+  (*((char **)(((h)->next_free+=sizeof(char *))-sizeof(char *))) = ((char *)datum))))
+
+#define obstack_int_grow(h,datum)					\
+( (((h)->next_free + sizeof (int) > (h)->chunk_limit)			\
+   ? (_obstack_newchunk ((h), sizeof (int)), 0) : 0),			\
+  ((h)->alloc_failed ? 0 :						\
+  (*((int *)(((h)->next_free+=sizeof(int))-sizeof(int))) = ((int)datum))))
+
+#define obstack_ptr_grow_fast(h,aptr) (*((char **)(h)->next_free)++ = (char *)aptr)
+#define obstack_int_grow_fast(h,aint) (*((int *)(h)->next_free)++ = (int)aint)
+
+#define obstack_blank(h,length)						\
+( (h)->temp = (length),							\
+  (((h)->chunk_limit - (h)->next_free < (h)->temp)			\
+   ? (_obstack_newchunk ((h), (h)->temp), 0) : 0),			\
+  ((h)->alloc_failed ? 0 :						\
+  ((h)->next_free += (h)->temp)))
+
+#define obstack_alloc(h,length)						\
+ (obstack_blank ((h), (length)), obstack_finish ((h)))
+
+#define obstack_copy(h,where,length)					\
+ (obstack_grow ((h), (where), (length)), obstack_finish ((h)))
+
+#define obstack_copy0(h,where,length)					\
+ (obstack_grow0 ((h), (where), (length)), obstack_finish ((h)))
+
+#define obstack_finish(h)  						\
+( (h)->alloc_failed ? 0 :						\
+  (((h)->next_free == (h)->object_base					\
+   ? (((h)->maybe_empty_object = 1), 0)					\
+   : 0),								\
+  (h)->temp = __PTR_TO_INT ((h)->object_base),				\
+  (h)->next_free							\
+    = __INT_TO_PTR ((__PTR_TO_INT ((h)->next_free)+(h)->alignment_mask)	\
+		    & ~ ((h)->alignment_mask)),				\
+  (((h)->next_free - (char *)(h)->chunk					\
+    > (h)->chunk_limit - (char *)(h)->chunk)				\
+   ? ((h)->next_free = (h)->chunk_limit) : 0),				\
+  (h)->object_base = (h)->next_free,					\
+  __INT_TO_PTR ((h)->temp)))
+
+#ifdef __STDC__
+#define obstack_free(h,obj)						\
+( (h)->temp = (char *)(obj) - (char *) (h)->chunk,			\
+  (((h)->temp > 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\
+   ? (int) ((h)->next_free = (h)->object_base				\
+	    = (h)->temp + (char *) (h)->chunk)				\
+   : (((obstack_free) ((h), (h)->temp + (char *) (h)->chunk), 0), 0)))
+#else
+#define obstack_free(h,obj)						\
+( (h)->temp = (char *)(obj) - (char *) (h)->chunk,			\
+  (((h)->temp > 0 && (h)->temp < (h)->chunk_limit - (char *) (h)->chunk)\
+   ? (int) ((h)->next_free = (h)->object_base				\
+	    = (h)->temp + (char *) (h)->chunk)				\
+   : (_obstack_free ((h), (h)->temp + (char *) (h)->chunk), 0)))
+#endif
+
+#endif /* not __GNUC__ or not __STDC__ */
+
+#endif /* not __OBSTACK_H__ */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/print.c gcc-4.0.2/gcc/bounds/lib/print.c
--- gcc-4.0.2.org/gcc/bounds/lib/print.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/print.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,337 @@
+/* Bounds Checking for GCC.
+   Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   File:
+  	lib/print.c
+   Summary:
+  	Simple printf/vprintf implementations that are guaranteed not to
+  	use malloc. (Calling malloc while printing an error message might
+  	cause recursion).
+   Other notes:
+  	The following specifiers are implemented:
+  		%p	pointer, prints NULL, ILLEGAL or value (as hex)
+  		%d	signed integer
+  		%u	unsigned integer
+  		%s	string, prints "(null)" if NULL pointer passed
+  		%x	hexadecimal integer
+   Author      	Date		Notes
+   RWMJ		5/12/94		Initial implementation.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdarg.h>
+#include <fcntl.h>
+
+#include "bounds-lib.h"
+
+#if defined(__BOUNDS_CHECKING_ON)
+#error "This file must not be compiled with bounds checking enabled."
+#endif
+
+/* Note: 5/10/95. OSF/1 3.0 appears to allow reentrant calls to printf and
+   friends. So this isn't needed ...  */
+
+#if !defined(__osf__)
+
+#if defined(printf)
+#undef printf
+#endif
+#if defined(vprintf)
+#undef vprintf
+#endif
+
+/* low level functions to convert numbers to strings.  */
+
+static __inline__ char *
+_ul_to_a (unsigned long u, char *buf)
+{
+  if (u != 0)
+    {
+      unsigned long n = u % 10;
+      buf = _ul_to_a (u / 10, buf);
+      *buf++ = n + '0';
+    }
+  return buf;
+}
+
+static __inline__ void
+l_to_a (long i, char *buf)
+{
+  if (i == 0)
+    *buf++ = '0';
+  else
+    {
+      if (i < 0)
+	{
+	  *buf++ = '-';
+	  i = -i;
+	}
+      buf = _ul_to_a ((unsigned long) i, buf);
+    }
+  *buf = 0;
+}
+
+static __inline__ void
+ul_to_a (unsigned long u, char *buf)
+{
+  if (u == 0)
+    *buf++ = '0';
+  else
+    buf = _ul_to_a (u, buf);
+  *buf = 0;
+}
+
+/* Low level functions to manage a simple output buffer.  */
+
+static __inline__ void
+printchar (char c)
+{
+  char *cp;
+  char *new;
+  int new_fd;
+  int flags;
+  static int fd = 2, first = 1;
+  static char buffer[256], *next = buffer;
+
+  *next++ = c;
+  if (c == '\n' || next - buffer == 256)
+    {
+      if (first)
+	{
+	  first = 0;
+	  if (__bounds_error_filename)
+	    {
+	      cp = __bounds_error_filename;
+	      while (*cp)
+		{
+		  if (cp[0] == '%' && cp[1] == 'p')
+		    {
+		      new =
+			__bounds_malloc (__bounds_strlen
+					 (__bounds_error_filename) + 10);
+		      if (new)
+			{
+			  __bounds_strncpy (new, __bounds_error_filename,
+					    cp - __bounds_error_filename);
+			  ul_to_a (getpid (),
+				   &new[cp - __bounds_error_filename]);
+
+			  __bounds_strcat (new, cp + 2);
+			  cp = new + (cp - __bounds_error_filename);
+			  __bounds_error_filename = new;
+			}
+		      else
+			cp++;
+		    }
+		  else
+		    cp++;
+		}
+	      flags = O_WRONLY | O_CREAT;
+	      if (__bounds_error_filename_append)
+		flags |= O_APPEND;
+	      else
+		flags |= O_TRUNC;
+#ifdef O_LARGEFILE
+	      flags |= O_LARGEFILE;
+#endif
+	      new_fd = open (__bounds_error_filename, flags, 0644);
+	      if (new_fd >= 0)
+		fd = new_fd;
+	    }
+	}
+      /* Flush output buffer.  */
+      write (fd, buffer, next - buffer);
+      next = buffer;
+    }
+}
+
+/* Print a hex number. `width' is the number of digits (ie. number of
+   hex nybbles) to print.  */
+
+static __inline__ void
+xtoa (unsigned long u, char *buf, int width)
+{
+  static char hexdigit[16] = { '0', '1', '2', '3', '4', '5',
+    '6', '7', '8', '9', 'a', 'b',
+    'c', 'd', 'e', 'f'
+  };
+  int i;
+  unsigned d;
+  unsigned long top_nybble_mask = 0xF << ((width - 1) * 4);
+
+  for (i = width - 1; i >= 1; --i)
+    {
+      if (u & top_nybble_mask)
+	break;
+      u <<= 4;
+    }
+  for (; i >= 0; --i)
+    {
+      d = u >> ((width - 1) * 4);
+      u <<= 4;
+      *buf++ = hexdigit[d];
+    }
+  *buf = 0;
+  return;
+}
+
+/* Like vprintf.  */
+
+void
+__bounds_vprintf (const char *format, va_list args)
+{
+  const char *p;
+  char *s;
+  int i;
+  int prec;
+  char pchar;
+  unsigned u;
+  void *vp;
+  char buf[64];
+
+  __bounds_debug_no_checking = 1;
+  p = format;
+  while (*p)
+    {
+      if (*p != '%')
+	{
+	  printchar (*p);
+	  p++;
+	}
+      else
+	{
+	  p++;
+	  prec = 0;
+	  pchar = ' ';
+	  if (*p == '0')
+	    pchar = *p++;	/* check for '%02d'    */
+	  while (*p >= '0' && *p <= '9')	/* calculate precision */
+	    prec = prec * 10 + *p++ - '0';
+	  switch (*p)
+	    {
+	    case 's':
+	      /* String. Print it, or print "(null)" if the pointer passed is
+	         NULL.  */
+	      s = va_arg (args, char *);
+	      if (s == NULL)
+		{
+		  prec -= __bounds_strlen ("(null)");
+		  while (prec-- > 0)
+		    printchar (pchar);
+		  __bounds_printf ("(null)");
+		}
+	      else
+		{
+		  prec -= __bounds_strlen (s);
+		  while (prec-- > 0)
+		    printchar (pchar);
+		  while (*s)
+		    {
+		      printchar (*s);
+		      ++s;
+		    }
+		}
+	      break;
+	    case 'd':
+	      /* Signed integer.  */
+	      i = va_arg (args, int);
+	      l_to_a (i, buf);
+	      prec -= __bounds_strlen (buf);
+	      while (prec-- > 0)
+		printchar (pchar);
+	      __bounds_printf ("%s", buf);
+	      break;
+	    case 'u':
+	      u = va_arg (args, unsigned);
+	      ul_to_a (u, buf);
+	      prec -= __bounds_strlen (buf);
+	      while (prec-- > 0)
+		printchar (pchar);
+	      __bounds_printf ("%s", buf);
+	      break;
+	    case 'p':
+	      /* Pointer. Print NULL, ILLEGAL or a representation of the
+	         pointer.  */
+	      vp = va_arg (args, void *);
+	      if (vp == NULL)
+		{
+		  prec -= __bounds_strlen ("NULL");
+		  while (prec-- > 0)
+		    printchar (pchar);
+		  __bounds_printf ("NULL");
+		}
+	      else if (vp == ILLEGAL)
+		{
+		  prec -= __bounds_strlen ("ILLEGAL");
+		  while (prec-- > 0)
+		    printchar (pchar);
+		  __bounds_printf ("ILLEGAL");
+		}
+	      else
+		{
+		  xtoa (PTR_TO_UNSIGNED (vp), buf,
+			sizeof (ptr_as_unsigned_t) * 2);
+		  prec -= __bounds_strlen ("0x") + __bounds_strlen (buf);
+		  while (prec-- > 0)
+		    printchar (pchar);
+		  __bounds_printf ("0x%s", buf);
+		}
+	      break;
+	    case 'x':
+	      /* Hexadecimal integer.  */
+	      u = va_arg (args, unsigned);
+	      xtoa (u, buf, sizeof (unsigned) * 2);
+	      prec -= __bounds_strlen (buf);
+	      while (prec-- > 0)
+		printchar (pchar);
+	      __bounds_printf ("%s", buf);
+	      break;
+	    case '%':
+	      printchar ('%');
+	      break;
+	    case 0:
+	      printchar ('\\');
+	      printchar ('0');
+	      break;
+	    default:
+	      /* Unrecognized format specifier. Print character and advance va
+	         pointer along one to ignore that argument.  */
+	      printchar (*p);
+	      (void) (va_arg (args, int));
+	    }
+	  if (*p)
+	    p++;
+	}
+    }
+  __bounds_debug_no_checking = 0;
+}
+
+/* Like printf.  */
+
+void
+__bounds_printf (const char *format, ...)
+{
+  va_list args;
+
+  va_start (args, format);
+  __bounds_vprintf (format, args);
+  va_end (args);
+}
+
+#endif /* !defined (__osf__) */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/pthread_init.c gcc-4.0.2/gcc/bounds/lib/pthread_init.c
--- gcc-4.0.2.org/gcc/bounds/lib/pthread_init.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/pthread_init.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,104 @@
+/*----------------------------------------------------------------------*
+ * Bounds Checking for GCC.                                             *
+ * Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.      *
+ *----------------------------------------------------------------------*
+ * This program is free software; you can redistribute it and/or modify *
+ * it under the terms of the GNU General Public License as published by *
+ * the Free Software Foundation; either version 2 of the License, or    *
+ * (at your option) any later version.                                  *
+ *                                                                      *
+ * This program is distributed in the hope that it will be useful,      *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of       *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        *
+ * GNU General Public License for more details.                         *
+ *                                                                      *
+ * You should have received a copy of the GNU General Public License    *
+ * along with this program; if not, write to the Free Software          *
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.            *
+ *----------------------------------------------------------------------*
+ * File:
+ *      thread/pthread_init.c
+ * Summary:
+ *      Init bounds checking for pthread library or signal handlers.
+ * Other notes:
+ *	Signal handlers are not turned on by default because it takes
+ *	a lot of cpu cycles. Most of the time this extra overhead is
+ *	not needed because the user code does not have signal handlers
+ *	or the user signal handlers do not call bounds_checking functions.
+ * Author       Date            Notes
+ * HtB         2/6/99         Initial implementation.
+ *----------------------------------------------------------------------*/
+
+#ifdef _REENTRANT
+
+/* If signal handlers are used set this define to '1' instead of '0'.  */
+
+#define	USE_SIGNAL	0
+
+/* If pthread is used set this define to '1' instead of '0'.  */
+
+#define	USE_PTHREAD	1
+
+#include <stdio.h>		/* NULL */
+#include <sys/types.h>
+#if USE_PTHREAD
+#include <pthread.h>
+#endif
+
+extern void __bounds_pthread_init (void);
+
+#if USE_SIGNAL
+extern int __bounds_mutex_signal;
+#endif
+
+#if USE_PTHREAD
+static void bounds_mutex_start (void);
+static void bounds_mutex_end (void);
+
+extern pthread_t (*__bounds_function_thread) (void);
+static pthread_mutex_t bounds_mutex_object;
+#endif
+
+extern void (*__bounds_mutex_start) (void);
+extern void (*__bounds_mutex_end) (void);
+
+/* These routine are called to protect static data in the bounds_checking
+   library.  */
+
+static void
+bounds_mutex_start (void)
+{
+#if USE_PTHREAD
+  pthread_mutex_lock (&bounds_mutex_object);
+#endif
+}
+
+static void
+bounds_mutex_end (void)
+{
+#if USE_PTHREAD
+  pthread_mutex_unlock (&bounds_mutex_object);
+#endif
+}
+
+/* Init routine to set up bounds_checking for the pthread library.  */
+
+void
+__bounds_pthread_init (void)
+{
+#if USE_PTHREAD
+  pthread_mutex_init (&bounds_mutex_object, NULL);
+  __bounds_function_thread = pthread_self;
+#endif
+#if USE_SIGNAL
+  __bounds_mutex_signal = 1;
+#endif
+  __bounds_mutex_start = bounds_mutex_start;
+  __bounds_mutex_end = bounds_mutex_end;
+}
+#else
+void
+__bounds_pthread_init (void)
+{
+}
+#endif
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/ralloc.c gcc-4.0.2/gcc/bounds/lib/ralloc.c
--- gcc-4.0.2.org/gcc/bounds/lib/ralloc.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/ralloc.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,1074 @@
+/* Block-relocating memory allocator. 
+   Copyright (C) 1993 Free Software Foundation, Inc.
+
+
+This file is part of the GNU C Library.  Its master source is NOT part of
+the C library, however.  The master source lives in /gd/gnu/lib.
+
+The GNU C Library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public License as
+published by the Free Software Foundation; either version 2 of the
+License, or (at your option) any later version.
+
+The GNU C Library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with the GNU C Library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.  */
+
+/* NOTES:
+
+   Only relocate the blocs necessary for SIZE in r_alloc_sbrk,
+   rather than all of them.  This means allowing for a possible
+   hole between the first bloc and the end of malloc storage.  */
+
+#ifdef emacs
+
+#include <config.h>
+#include "lisp.h"		/* Needed for VALBITS.  */
+
+#undef NULL
+
+/* The important properties of this type are that 1) it's a pointer, and
+   2) arithmetic on it should work as if the size of the object pointed
+   to has a size of 1.  */
+#if 0				/* Arithmetic on void* is a GCC extension.  */
+#ifdef __STDC__
+typedef void *POINTER;
+#else
+
+#ifdef	HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+typedef char *POINTER;
+
+#endif
+#endif /* 0 */
+
+/* Unconditionally use char * for this.  */
+typedef char *POINTER;
+
+typedef unsigned long SIZE;
+
+/* Declared in dispnew.c, this version doesn't screw up if regions
+   overlap.  */
+extern void safe_bcopy (char *, char *, int);
+
+#include "getpagesize.h"
+
+#else /* Not emacs.  */
+
+#include <stddef.h>
+
+typedef size_t SIZE;
+typedef void *POINTER;
+
+#include <unistd.h>
+#include <malloc.h>
+#include <string.h>
+
+#define safe_bcopy(x, y, z) __bounds_memmove (y, x, z)
+
+#endif /* emacs.  */
+
+#define NIL ((POINTER) 0)
+
+/* A flag to indicate whether we have initialized ralloc yet.  For
+   Emacs's sake, please do not make this local to malloc_init; on some
+   machines, the dumping procedure makes all static variables
+   read-only.  On these machines, the word static is #defined to be
+   the empty string, meaning that r_alloc_initialized becomes an
+   automatic variable, and loses its value each time Emacs is started up.  */
+static int r_alloc_initialized = 0;
+
+static void r_alloc_init (void);
+
+/* Declarations for working with the malloc, ralloc, and system breaks.  */
+
+/* Function to set the real break value.  */
+static POINTER (*real_morecore) (ptrdiff_t);
+
+/* The break value, as seen by malloc.  */
+static POINTER virtual_break_value;
+
+/* The address of the end of the last data in use by ralloc,
+   including relocatable blocs as well as malloc data.  */
+static POINTER break_value;
+
+/* This is the size of a page.  We round memory requests to this boundary.  */
+static int page_size;
+
+/* Whenever we get memory from the system, get this many extra bytes.  This 
+   must be a multiple of page_size.  */
+static int extra_bytes;
+
+/* Macros for rounding.  Note that rounding to any value is possible
+   by changing the definition of PAGE.  */
+#define PAGE (getpagesize ())
+#define ALIGNED(addr) (((unsigned long int) (addr) & (page_size - 1)) == 0)
+#define ROUNDUP(size) (((unsigned long int) (size) + page_size - 1) \
+		       & ~(page_size - 1))
+#define ROUND_TO_PAGE(addr) (addr & (~(page_size - 1)))
+
+#define MEM_ALIGN sizeof(double)
+#define MEM_ROUNDUP(addr) (((unsigned long int)(addr) + MEM_ALIGN - 1) \
+				   & ~(MEM_ALIGN - 1))
+
+/* Data structures of heaps and blocs.  */
+
+/* The relocatable objects, or blocs, and the malloc data
+   both reside within one or more heaps.
+   Each heap contains malloc data, running from `start' to `bloc_start',
+   and relocatable objects, running from `bloc_start' to `free'.
+
+   Relocatable objects may relocate within the same heap
+   or may move into another heap; the heaps themselves may grow
+   but they never move.
+
+   We try to make just one heap and make it larger as necessary.
+   But sometimes we can't do that, because we can't get continguous
+   space to add onto the heap.  When that happens, we start a new heap.  */
+
+typedef struct heap
+{
+  struct heap *next;
+  struct heap *prev;
+  /* Start of memory range of this heap.  */
+  POINTER start;
+  /* End of memory range of this heap.  */
+  POINTER end;
+  /* Start of relocatable data in this heap.  */
+  POINTER bloc_start;
+  /* Start of unused space in this heap.  */
+  POINTER free;
+  /* First bloc in this heap.  */
+  struct bp *first_bloc;
+  /* Last bloc in this heap.  */
+  struct bp *last_bloc;
+} *heap_ptr;
+
+#define NIL_HEAP ((heap_ptr) 0)
+#define HEAP_PTR_SIZE (sizeof (struct heap))
+
+/* This is the first heap object.
+   If we need additional heap objects, each one resides at the beginning of
+   the space it covers.   */
+static struct heap heap_base;
+
+/* Head and tail of the list of heaps.  */
+static heap_ptr first_heap, last_heap;
+
+/* These structures are allocated in the malloc arena.
+   The linked list is kept in order of increasing '.data' members.
+   The data blocks abut each other; if b->next is non-nil, then
+   b->data + b->size == b->next->data.  */
+typedef struct bp
+{
+  struct bp *next;
+  struct bp *prev;
+  POINTER *variable;
+  POINTER data;
+  SIZE size;
+  POINTER new_data;		/* tmporarily used for relocation */
+  /* Heap this bloc is in.  */
+  struct heap *heap;
+} *bloc_ptr;
+
+#define NIL_BLOC ((bloc_ptr) 0)
+#define BLOC_PTR_SIZE (sizeof (struct bp))
+
+/* Head and tail of the list of relocatable blocs.  */
+static bloc_ptr first_bloc, last_bloc;
+
+
+/* Functions to get and return memory from the system.  */
+
+/* Find the heap that ADDRESS falls within.  */
+
+static heap_ptr
+find_heap (POINTER address)
+{
+  heap_ptr heap;
+
+  for (heap = last_heap; heap; heap = heap->prev)
+    {
+      if (heap->start <= address && address <= heap->end)
+	return heap;
+    }
+
+  return NIL_HEAP;
+}
+
+/* Find SIZE bytes of space in a heap.
+   Try to get them at ADDRESS (which must fall within some heap's range)
+   if we can get that many within one heap.
+
+   If enough space is not presently available in our reserve, this means
+   getting more page-aligned space from the system. If the retuned space
+   is not contiguos to the last heap, allocate a new heap, and append it
+
+   obtain does not try to keep track of whether space is in use
+   or not in use.  It just returns the address of SIZE bytes that
+   fall within a single heap.  If you call obtain twice in a row
+   with the same arguments, you typically get the same value.
+   to the heap list.  It's the caller's responsibility to keep
+   track of what space is in use.
+
+   Return the address of the space if all went well, or zero if we couldn't
+   allocate the memory.  */
+
+static POINTER
+obtain (POINTER address, SIZE size)
+{
+  heap_ptr heap;
+  SIZE already_available;
+
+  /* Find the heap that ADDRESS falls within.  */
+  for (heap = last_heap; heap; heap = heap->prev)
+    {
+      if (heap->start <= address && address <= heap->end)
+	break;
+    }
+
+  if (!heap)
+    abort ();
+
+  /* If we can't fit SIZE bytes in that heap,
+     try successive later heaps.  */
+  while (heap && address + size > heap->end)
+    {
+      heap = heap->next;
+      if (heap == NIL_HEAP)
+	break;
+      address = heap->bloc_start;
+    }
+
+  /* If we can't fit them within any existing heap,
+     get more space.  */
+  if (heap == NIL_HEAP)
+    {
+      POINTER new = (*real_morecore) (0);
+      SIZE get;
+
+      already_available = (char *) last_heap->end - (char *) address;
+
+      if (new != last_heap->end)
+	{
+	  /* Someone else called sbrk.  Make a new heap.  */
+
+	  heap_ptr new_heap = (heap_ptr) MEM_ROUNDUP (new);
+	  POINTER bloc_start =
+	    (POINTER) MEM_ROUNDUP ((POINTER) (new_heap + 1));
+
+	  if ((*real_morecore) (bloc_start - new) != new)
+	    return 0;
+
+	  new_heap->start = new;
+	  new_heap->end = bloc_start;
+	  new_heap->bloc_start = bloc_start;
+	  new_heap->free = bloc_start;
+	  new_heap->next = NIL_HEAP;
+	  new_heap->prev = last_heap;
+	  new_heap->first_bloc = NIL_BLOC;
+	  new_heap->last_bloc = NIL_BLOC;
+	  last_heap->next = new_heap;
+	  last_heap = new_heap;
+
+	  address = bloc_start;
+	  already_available = 0;
+	}
+
+      /* Add space to the last heap (which we may have just created).
+         Get some extra, so we can come here less often.  */
+
+      get = size + extra_bytes - already_available;
+      get = (char *) ROUNDUP ((char *) last_heap->end + get)
+	- (char *) last_heap->end;
+
+      if ((*real_morecore) (get) != last_heap->end)
+	return 0;
+
+      last_heap->end += get;
+    }
+
+  return address;
+}
+
+/* Return unused heap space to the system
+   if there is a lot of unused space now.
+   This can make the last heap smaller;
+   it can also eliminate the last heap entirely.  */
+
+static void
+relinquish (void)
+{
+  register heap_ptr h;
+  int excess = 0;
+
+  /* Add the amount of space beyond break_value
+     in all heaps which have extend beyond break_value at all.  */
+
+  for (h = last_heap; h && break_value < h->end; h = h->prev)
+    {
+      excess += (char *) h->end - (char *) ((break_value < h->bloc_start)
+					    ? h->bloc_start : break_value);
+    }
+
+  if (excess > extra_bytes * 2 && (*real_morecore) (0) == last_heap->end)
+    {
+      /* Keep extra_bytes worth of empty space.
+         And don't free anything unless we can free at least extra_bytes.  */
+      excess -= extra_bytes;
+
+      if ((char *) last_heap->end - (char *) last_heap->bloc_start <= excess)
+	{
+	  /* This heap should have no blocs in it.  */
+	  if (last_heap->first_bloc != NIL_BLOC
+	      || last_heap->last_bloc != NIL_BLOC)
+	    abort ();
+
+	  /* Return the last heap, with its header, to the system.  */
+	  excess = (char *) last_heap->end - (char *) last_heap->start;
+	  last_heap = last_heap->prev;
+	  last_heap->next = NIL_HEAP;
+	}
+      else
+	{
+	  excess = (char *) last_heap->end
+	    - (char *) ROUNDUP ((char *) last_heap->end - excess);
+	  last_heap->end -= excess;
+	}
+
+      if ((*real_morecore) (-excess) == 0)
+	abort ();
+    }
+}
+
+/* The meat - allocating, freeing, and relocating blocs.  */
+
+/* Find the bloc referenced by the address in PTR.  Returns a pointer
+   to that block.  */
+
+static bloc_ptr
+find_bloc (POINTER * ptr)
+{
+  register bloc_ptr p = first_bloc;
+
+  while (p != NIL_BLOC)
+    {
+      if (p->variable == ptr && p->data == *ptr)
+	return p;
+
+      p = p->next;
+    }
+
+  return p;
+}
+
+/* Allocate a bloc of SIZE bytes and append it to the chain of blocs.
+   Returns a pointer to the new bloc, or zero if we couldn't allocate
+   memory for the new block.  */
+
+static bloc_ptr
+get_bloc (SIZE size)
+{
+  register bloc_ptr new_bloc;
+  register heap_ptr heap;
+
+  if (!(new_bloc = (bloc_ptr) malloc (BLOC_PTR_SIZE))
+      || !(new_bloc->data = obtain (break_value, size)))
+    {
+      if (new_bloc)
+	free (new_bloc);
+
+      return 0;
+    }
+
+  break_value = new_bloc->data + size;
+
+  new_bloc->size = size;
+  new_bloc->next = NIL_BLOC;
+  new_bloc->variable = (POINTER *) NIL;
+  new_bloc->new_data = 0;
+
+  /* Record in the heap that this space is in use.  */
+  heap = find_heap (new_bloc->data);
+  heap->free = break_value;
+
+  /* Maintain the correspondence between heaps and blocs.  */
+  new_bloc->heap = heap;
+  heap->last_bloc = new_bloc;
+  if (heap->first_bloc == NIL_BLOC)
+    heap->first_bloc = new_bloc;
+
+  /* Put this bloc on the doubly-linked list of blocs.  */
+  if (first_bloc)
+    {
+      new_bloc->prev = last_bloc;
+      last_bloc->next = new_bloc;
+      last_bloc = new_bloc;
+    }
+  else
+    {
+      first_bloc = last_bloc = new_bloc;
+      new_bloc->prev = NIL_BLOC;
+    }
+
+  return new_bloc;
+}
+
+/* Calculate new locations of blocs in the list beginning with BLOC,
+   relocating it to start at ADDRESS, in heap HEAP.  If enough space is
+   not presently available in our reserve, call obtain for
+   more space. 
+   
+   Store the new location of each bloc in its new_data field.
+   Do not touch the contents of blocs or break_value.  */
+
+static int
+relocate_blocs (bloc_ptr bloc, heap_ptr heap, POINTER address)
+{
+  register bloc_ptr b = bloc;
+
+  while (b)
+    {
+      /* If bloc B won't fit within HEAP,
+         move to the next heap and try again.  */
+      while (heap && address + b->size > heap->end)
+	{
+	  heap = heap->next;
+	  if (heap == NIL_HEAP)
+	    break;
+	  address = heap->bloc_start;
+	}
+
+      /* If BLOC won't fit in any heap,
+         get enough new space to hold BLOC and all following blocs.  */
+      if (heap == NIL_HEAP)
+	{
+	  register bloc_ptr tb = b;
+	  register SIZE s = 0;
+
+	  /* Add up the size of all the following blocs.  */
+	  while (tb != NIL_BLOC)
+	    {
+	      s += tb->size;
+	      tb = tb->next;
+	    }
+
+	  /* Get that space.  */
+	  address = obtain (address, s);
+	  if (address == 0)
+	    return 0;
+
+	  heap = last_heap;
+	}
+
+      /* Record the new address of this bloc
+         and update where the next bloc can start.  */
+      b->new_data = address;
+      address += b->size;
+      b = b->next;
+    }
+
+  return 1;
+}
+
+/* Reorder the bloc BLOC to go before bloc BEFORE in the doubly linked list.
+   This is necessary if we put the memory of space of BLOC
+   before that of BEFORE.  */
+
+static void
+reorder_bloc (bloc_ptr bloc, bloc_ptr before)
+{
+  bloc_ptr prev, next;
+
+  /* Splice BLOC out from where it is.  */
+  prev = bloc->prev;
+  next = bloc->next;
+
+  if (prev)
+    prev->next = next;
+  if (next)
+    next->prev = prev;
+
+  /* Splice it in before BEFORE.  */
+  prev = before->prev;
+
+  if (prev)
+    prev->next = bloc;
+  bloc->prev = prev;
+
+  before->prev = bloc;
+  bloc->next = before;
+}
+
+/* Update the records of which heaps contain which blocs, starting
+   with heap HEAP and bloc BLOC.  */
+
+static void
+update_heap_bloc_correspondence (bloc_ptr bloc, heap_ptr heap)
+{
+  register bloc_ptr b;
+
+  /* Initialize HEAP's status to reflect blocs before BLOC.  */
+  if (bloc != NIL_BLOC && bloc->prev != NIL_BLOC && bloc->prev->heap == heap)
+    {
+      /* The previous bloc is in HEAP.  */
+      heap->last_bloc = bloc->prev;
+      heap->free = bloc->prev->data + bloc->prev->size;
+    }
+  else
+    {
+      /* HEAP contains no blocs before BLOC.  */
+      heap->first_bloc = NIL_BLOC;
+      heap->last_bloc = NIL_BLOC;
+      heap->free = heap->bloc_start;
+    }
+
+  /* Advance through blocs one by one.  */
+  for (b = bloc; b != NIL_BLOC; b = b->next)
+    {
+      /* Advance through heaps, marking them empty,
+         till we get to the one that B is in.  */
+      while (heap)
+	{
+	  if (heap->bloc_start <= b->data && b->data <= heap->end)
+	    break;
+	  heap = heap->next;
+	  /* We know HEAP is not null now,
+	     because there has to be space for bloc B.  */
+	  heap->first_bloc = NIL_BLOC;
+	  heap->last_bloc = NIL_BLOC;
+	  heap->free = heap->bloc_start;
+	}
+
+      /* Update HEAP's status for bloc B.  */
+      heap->free = b->data + b->size;
+      heap->last_bloc = b;
+      if (heap->first_bloc == NIL_BLOC)
+	heap->first_bloc = b;
+
+      /* Record that B is in HEAP.  */
+      b->heap = heap;
+    }
+
+  /* If there are any remaining heaps and no blocs left,
+     mark those heaps as empty.  */
+  heap = heap->next;
+  while (heap)
+    {
+      heap->first_bloc = NIL_BLOC;
+      heap->last_bloc = NIL_BLOC;
+      heap->free = heap->bloc_start;
+      heap = heap->next;
+    }
+}
+
+/* Resize BLOC to SIZE bytes.  This relocates the blocs
+   that come after BLOC in memory.  */
+
+static int
+resize_bloc (bloc_ptr bloc, SIZE size)
+{
+  register bloc_ptr b;
+  heap_ptr heap;
+  POINTER address;
+  SIZE old_size;
+
+  if (bloc == NIL_BLOC || size == bloc->size)
+    return 1;
+
+  for (heap = first_heap; heap != NIL_HEAP; heap = heap->next)
+    {
+      if (heap->bloc_start <= bloc->data && bloc->data <= heap->end)
+	break;
+    }
+
+  if (heap == NIL_HEAP)
+    abort ();
+
+  old_size = bloc->size;
+  bloc->size = size;
+
+  /* Note that bloc could be moved into the previous heap.  */
+  address = (bloc->prev ? bloc->prev->data + bloc->prev->size
+	     : first_heap->bloc_start);
+  while (heap)
+    {
+      if (heap->bloc_start <= address && address <= heap->end)
+	break;
+      heap = heap->prev;
+    }
+
+  if (!relocate_blocs (bloc, heap, address))
+    {
+      bloc->size = old_size;
+      return 0;
+    }
+
+  if (size > old_size)
+    {
+      for (b = last_bloc; b != bloc; b = b->prev)
+	{
+	  safe_bcopy (b->data, b->new_data, b->size);
+	  *b->variable = b->data = b->new_data;
+	}
+      safe_bcopy (bloc->data, bloc->new_data, old_size);
+      bzero (bloc->new_data + old_size, size - old_size);
+      *bloc->variable = bloc->data = bloc->new_data;
+    }
+  else
+    {
+      for (b = bloc; b != NIL_BLOC; b = b->next)
+	{
+	  safe_bcopy (b->data, b->new_data, b->size);
+	  *b->variable = b->data = b->new_data;
+	}
+    }
+
+  update_heap_bloc_correspondence (bloc, heap);
+
+  break_value = (last_bloc ? last_bloc->data + last_bloc->size
+		 : first_heap->bloc_start);
+  return 1;
+}
+
+/* Free BLOC from the chain of blocs, relocating any blocs above it.
+   This may return space to the system.  */
+
+static void
+free_bloc (bloc_ptr bloc)
+{
+  heap_ptr heap = bloc->heap;
+
+  resize_bloc (bloc, 0);
+
+  if (bloc == first_bloc && bloc == last_bloc)
+    {
+      first_bloc = last_bloc = NIL_BLOC;
+    }
+  else if (bloc == last_bloc)
+    {
+      last_bloc = bloc->prev;
+      last_bloc->next = NIL_BLOC;
+    }
+  else if (bloc == first_bloc)
+    {
+      first_bloc = bloc->next;
+      first_bloc->prev = NIL_BLOC;
+    }
+  else
+    {
+      bloc->next->prev = bloc->prev;
+      bloc->prev->next = bloc->next;
+    }
+
+  /* Update the records of which blocs are in HEAP.  */
+  if (heap->first_bloc == bloc)
+    {
+      if (bloc->next->heap == heap)
+	heap->first_bloc = bloc->next;
+      else
+	heap->first_bloc = heap->last_bloc = NIL_BLOC;
+    }
+  if (heap->last_bloc == bloc)
+    {
+      if (bloc->prev->heap == heap)
+	heap->last_bloc = bloc->prev;
+      else
+	heap->first_bloc = heap->last_bloc = NIL_BLOC;
+    }
+
+  relinquish ();
+  free (bloc);
+}
+
+/* Interface routines.  */
+
+static int use_relocatable_buffers;
+static int r_alloc_freeze_level;
+
+/* Obtain SIZE bytes of storage from the free pool, or the system, as
+   necessary.  If relocatable blocs are in use, this means relocating
+   them.  This function gets plugged into the GNU malloc's __morecore
+   hook.
+
+   We provide hysteresis, never relocating by less than extra_bytes.
+
+   If we're out of memory, we should return zero, to imitate the other
+   __morecore hook values - in particular, __default_morecore in the
+   GNU malloc package.  */
+
+POINTER
+r_alloc_sbrk (long size)
+{
+  register bloc_ptr b;
+  POINTER address;
+
+  if (!use_relocatable_buffers)
+    return (*real_morecore) (size);
+
+  if (size == 0)
+    return virtual_break_value;
+
+  if (size > 0)
+    {
+      /* Allocate a page-aligned space.  GNU malloc would reclaim an
+         extra space if we passed an unaligned one.  But we could
+         not always find a space which is contiguos to the previous.  */
+      POINTER new_bloc_start;
+      heap_ptr h = first_heap;
+      SIZE get = ROUNDUP (size);
+
+      address = (POINTER) ROUNDUP (virtual_break_value);
+
+      /* Search the list upward for a heap which is large enough.  */
+      while ((char *) h->end < (char *) MEM_ROUNDUP ((char *) address + get))
+	{
+	  h = h->next;
+	  if (h == NIL_HEAP)
+	    break;
+	  address = (POINTER) ROUNDUP (h->start);
+	}
+
+      /* If not found, obtain more space.  */
+      if (h == NIL_HEAP)
+	{
+	  get += extra_bytes + page_size;
+
+	  if (r_alloc_freeze_level > 0 || !obtain (address, get))
+	    return 0;
+
+	  if (first_heap == last_heap)
+	    address = (POINTER) ROUNDUP (virtual_break_value);
+	  else
+	    address = (POINTER) ROUNDUP (last_heap->start);
+	  h = last_heap;
+	}
+
+      new_bloc_start = (POINTER) MEM_ROUNDUP ((char *) address + get);
+
+      if (first_heap->bloc_start < new_bloc_start)
+	{
+	  /* Move all blocs upward.  */
+	  if (r_alloc_freeze_level > 0
+	      || !relocate_blocs (first_bloc, h, new_bloc_start))
+	    return 0;
+
+	  /* Note that (POINTER)(h+1) <= new_bloc_start since
+	     get >= page_size, so the following does not destroy the heap
+	     header.  */
+	  for (b = last_bloc; b != NIL_BLOC; b = b->prev)
+	    {
+	      safe_bcopy (b->data, b->new_data, b->size);
+	      *b->variable = b->data = b->new_data;
+	    }
+
+	  h->bloc_start = new_bloc_start;
+
+	  update_heap_bloc_correspondence (first_bloc, h);
+	}
+
+      if (h != first_heap)
+	{
+	  /* Give up managing heaps below the one the new
+	     virtual_break_value points to.  */
+	  first_heap->prev = NIL_HEAP;
+	  first_heap->next = h->next;
+	  first_heap->start = h->start;
+	  first_heap->end = h->end;
+	  first_heap->free = h->free;
+	  first_heap->first_bloc = h->first_bloc;
+	  first_heap->last_bloc = h->last_bloc;
+	  first_heap->bloc_start = h->bloc_start;
+
+	  if (first_heap->next)
+	    first_heap->next->prev = first_heap;
+	  else
+	    last_heap = first_heap;
+	}
+
+      bzero (address, size);
+    }
+  else				/* size < 0 */
+    {
+      SIZE excess = (char *) first_heap->bloc_start
+	- ((char *) virtual_break_value + size);
+
+      address = virtual_break_value;
+
+      if (r_alloc_freeze_level == 0 && excess > 2 * extra_bytes)
+	{
+	  excess -= extra_bytes;
+	  first_heap->bloc_start
+	    =
+	    (POINTER) MEM_ROUNDUP ((char *) first_heap->bloc_start - excess);
+
+	  relocate_blocs (first_bloc, first_heap, first_heap->bloc_start);
+
+	  for (b = first_bloc; b != NIL_BLOC; b = b->next)
+	    {
+	      safe_bcopy (b->data, b->new_data, b->size);
+	      *b->variable = b->data = b->new_data;
+	    }
+	}
+
+      if ((char *) virtual_break_value + size < (char *) first_heap->start)
+	{
+	  /* We found an additional space below the first heap */
+	  first_heap->start = (POINTER) ((char *) virtual_break_value + size);
+	}
+    }
+
+  virtual_break_value = (POINTER) ((char *) address + size);
+  break_value = (last_bloc
+		 ? last_bloc->data + last_bloc->size
+		 : first_heap->bloc_start);
+  if (size < 0)
+    relinquish ();
+
+  return address;
+}
+
+/* Allocate a relocatable bloc of storage of size SIZE.  A pointer to
+   the data is returned in *PTR.  PTR is thus the address of some variable
+   which will use the data area.
+
+   If we can't allocate the necessary memory, set *PTR to zero, and
+   return zero.  */
+
+POINTER
+r_alloc (POINTER * ptr, SIZE size)
+{
+  register bloc_ptr new_bloc;
+
+  if (!r_alloc_initialized)
+    r_alloc_init ();
+
+  new_bloc = get_bloc (MEM_ROUNDUP (size));
+  if (new_bloc)
+    {
+      new_bloc->variable = ptr;
+      *ptr = new_bloc->data;
+    }
+  else
+    *ptr = 0;
+
+  return *ptr;
+}
+
+/* Free a bloc of relocatable storage whose data is pointed to by PTR.
+   Store 0 in *PTR to show there's no block allocated.  */
+
+void
+r_alloc_free (POINTER * ptr)
+{
+  register bloc_ptr dead_bloc;
+
+  dead_bloc = find_bloc (ptr);
+  if (dead_bloc == NIL_BLOC)
+    abort ();
+
+  free_bloc (dead_bloc);
+  *ptr = 0;
+}
+
+/* Given a pointer at address PTR to relocatable data, resize it to SIZE.
+   Do this by shifting all blocks above this one up in memory, unless
+   SIZE is less than or equal to the current bloc size, in which case
+   do nothing.
+
+   Change *PTR to reflect the new bloc, and return this value.
+
+   If more memory cannot be allocated, then leave *PTR unchanged, and
+   return zero.  */
+
+POINTER
+r_re_alloc (POINTER * ptr, SIZE size)
+{
+  register bloc_ptr bloc;
+
+  bloc = find_bloc (ptr);
+  if (bloc == NIL_BLOC)
+    abort ();
+
+  if (size <= bloc->size)
+    /* Wouldn't it be useful to actually resize the bloc here?  */
+    return *ptr;
+
+  if (!resize_bloc (bloc, MEM_ROUNDUP (size)))
+    return 0;
+
+  return *ptr;
+}
+
+/* Disable relocations, after making room for at least SIZE bytes
+   of non-relocatable heap if possible.  The relocatable blocs are
+   guaranteed to hold still until thawed, even if this means that
+   malloc must return a null pointer.  */
+
+void
+r_alloc_freeze (long size)
+{
+  /* If already frozen, we can't make any more room, so don't try.  */
+  if (r_alloc_freeze_level > 0)
+    size = 0;
+  /* If we can't get the amount requested, half is better than nothing.  */
+  while (size > 0 && r_alloc_sbrk (size) == 0)
+    size /= 2;
+  ++r_alloc_freeze_level;
+  if (size > 0)
+    r_alloc_sbrk (-size);
+}
+
+void
+r_alloc_thaw (void)
+{
+  if (--r_alloc_freeze_level < 0)
+    abort ();
+}
+
+/* The hook `malloc' uses for the function which gets more space
+   from the system.  */
+extern POINTER (*__morecore) (ptrdiff_t);
+
+/* Initialize various things for memory allocation.  */
+
+static void
+r_alloc_init (void)
+{
+  POINTER end;
+
+  if (r_alloc_initialized)
+    return;
+
+  r_alloc_initialized = 1;
+  real_morecore = __morecore;
+  __morecore = r_alloc_sbrk;
+
+  first_heap = last_heap = &heap_base;
+  first_heap->next = first_heap->prev = NIL_HEAP;
+  first_heap->start = first_heap->bloc_start
+    = virtual_break_value = break_value = (*real_morecore) (0);
+  if (break_value == NIL)
+    abort ();
+
+  page_size = PAGE;
+  extra_bytes = ROUNDUP (50000);
+
+  first_heap->end = (POINTER) ROUNDUP (first_heap->start);
+
+  /* The extra call to real_morecore guarantees that the end of the
+     address space is a multiple of page_size, even if page_size is
+     not really the page size of the system running the binary in
+     which page_size is stored.  This allows a binary to be built on a
+     system with one page size and run on a system with a smaller page
+     size.  */
+  (*real_morecore) (first_heap->end - first_heap->start);
+
+  /* Clear the rest of the last page; this memory is in our address space
+     even though it is after the sbrk value.  */
+  /* Doubly true, with the additional call that explicitly adds the
+     rest of that page to the address space.  */
+  bzero (first_heap->start, first_heap->end - first_heap->start);
+  virtual_break_value = break_value = first_heap->bloc_start =
+    first_heap->end;
+  use_relocatable_buffers = 1;
+}
+
+#ifdef DEBUG
+#include <assert.h>
+
+int
+r_alloc_check (void)
+{
+  int found = 0;
+  heap_ptr h, ph = 0;
+  bloc_ptr b, pb = 0;
+
+  if (!r_alloc_initialized)
+    return;
+
+  assert (first_heap);
+#if 0
+  assert (last_heap->end <= (POINTER) sbrk (0));
+#endif
+  assert ((POINTER) first_heap < first_heap->start);
+  assert (first_heap->start <= virtual_break_value);
+  assert (virtual_break_value <= first_heap->end);
+
+  for (h = first_heap; h; h = h->next)
+    {
+      assert (h->prev == ph);
+      assert ((POINTER) ROUNDUP (h->end) == h->end);
+      assert ((POINTER) MEM_ROUNDUP (h->start) == h->start);
+      assert ((POINTER) MEM_ROUNDUP (h->bloc_start) == h->bloc_start);
+      assert (h->start <= h->bloc_start && h->bloc_start <= h->end);
+
+      if (ph)
+	{
+	  assert (ph->end < h->start);
+	  assert (h->start <= (POINTER) h
+		  && (POINTER) (h + 1) <= h->bloc_start);
+	}
+
+      if (h->bloc_start <= break_value && break_value <= h->end)
+	found = 1;
+
+      ph = h;
+    }
+
+  assert (found);
+  assert (last_heap == ph);
+
+  for (b = first_bloc; b; b = b->next)
+    {
+      assert (b->prev == pb);
+      assert ((POINTER) MEM_ROUNDUP (b->data) == b->data);
+      assert ((SIZE) MEM_ROUNDUP (b->size) == b->size);
+
+      ph = 0;
+      for (h = first_heap; h; h = h->next)
+	{
+	  if (h->bloc_start <= b->data && b->data + b->size <= h->end)
+	    break;
+	  ph = h;
+	}
+
+      assert (h);
+
+      if (pb && pb->data + pb->size != b->data)
+	{
+	  assert (ph && b->data == h->bloc_start);
+	  while (ph)
+	    {
+	      if (ph->bloc_start <= pb->data
+		  && pb->data + pb->size <= ph->end)
+		{
+		  assert (pb->data + pb->size + b->size > ph->end);
+		  break;
+		}
+	      else
+		{
+		  assert (ph->bloc_start + b->size > ph->end);
+		}
+	      ph = ph->prev;
+	    }
+	}
+      pb = b;
+    }
+
+  assert (last_bloc == pb);
+
+  if (last_bloc)
+    assert (last_bloc->data + last_bloc->size == break_value);
+  else
+    assert (first_heap->bloc_start == break_value);
+}
+#endif /* DEBUG */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/realloc.c gcc-4.0.2/gcc/bounds/lib/realloc.c
--- gcc-4.0.2.org/gcc/bounds/lib/realloc.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/realloc.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,224 @@
+/* Change the size of a block allocated by `malloc'.
+   Copyright 1990, 1991, 1992, 1993, 1994 Free Software Foundation, Inc.
+		     Written May 1989 by Mike Haertel.
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public License as
+published by the Free Software Foundation; either version 2 of the
+License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with this library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.
+
+   The author may be reached (Email) at the address mike@ai.mit.edu,
+   or (US mail) as Mike Haertel c/o Free Software Foundation.  */
+
+#include "bounds-lib.h"
+
+#ifndef	_MALLOC_INTERNAL
+#define _MALLOC_INTERNAL
+#include <malloc.h>
+#endif
+
+#if  (defined (MEMMOVE_MISSING) || \
+      !defined(_LIBC) && !defined(STDC_HEADERS) && !defined(USG))
+
+/* Snarfed directly from Emacs src/dispnew.c:
+   XXX Should use system bcopy if it handles overlap.  */
+#if 0				/* not used because memmove() isn't used   #ifndef emacs */
+
+/* Like bcopy except never gets confused by overlap.  */
+
+static void
+safe_bcopy (char *from, char *to, int size)
+{
+  if (size <= 0 || from == to)
+    return;
+
+  /* If the source and destination don't overlap, then bcopy can
+     handle it.  If they do overlap, but the destination is lower in
+     memory than the source, we'll assume bcopy can handle that.  */
+  if (to < from || from + size <= to)
+    __bounds_memmove (from, to, size);
+
+  /* Otherwise, we'll copy from the end.  */
+  else
+    {
+      register char *endf = from + size;
+      register char *endt = to + size;
+
+      /* If TO - FROM is large, then we should break the copy into
+         nonoverlapping chunks of TO - FROM bytes each.  However, if
+         TO - FROM is small, then the bcopy function call overhead
+         makes this not worth it.  The crossover point could be about
+         anywhere.  Since I don't think the obvious copy loop is too
+         bad, I'm trying to err in its favor.  */
+      if (to - from < 64)
+	{
+	  do
+	    *--endt = *--endf;
+	  while (endf != from);
+	}
+      else
+	{
+	  for (;;)
+	    {
+	      endt -= (to - from);
+	      endf -= (to - from);
+
+	      if (endt < to)
+		break;
+
+	      __bounds_memmove (endf, endt, to - from);
+	    }
+
+	  /* If SIZE wasn't a multiple of TO - FROM, there will be a
+	     little left over.  The amount left over is
+	     (endt + (to - from)) - to, which is endt - from.  */
+	  __bounds_memmove (from, to, endt - from);
+	}
+    }
+}
+#endif /* Not emacs.  */
+
+#ifdef memmove
+#undef memmove
+#endif
+#define memmove(to, from, size) safe_bcopy ((from), (to), (size))
+
+#endif
+
+#ifdef min
+#undef min
+#endif
+#define min(A, B) ((A) < (B) ? (A) : (B))
+
+/* Debugging hook for realloc.  */
+__ptr_t (*__realloc_hook) (__ptr_t __ptr, __malloc_size_t __size);
+
+/* Resize the given region to the new size, returning a pointer
+   to the (possibly moved) region.  This is optimized for speed;
+   some benchmarks seem to indicate that greater compactness is
+   achieved by unconditionally allocating and copying to a
+   new region.  This module has incestuous knowledge of the
+   internals of both free and malloc. */
+__ptr_t
+__bounds_realloc (__ptr_t ptr, __malloc_size_t size)
+{
+  __ptr_t result;
+  int type;
+  __malloc_size_t block, blocks, oldlimit;
+
+  if (size == 0)
+    {
+      __bounds_free (ptr);
+      return __bounds_malloc (0);
+    }
+  else if (ptr == NULL)
+    return __bounds_malloc (size);
+
+  if (__realloc_hook != NULL)
+    return (*__realloc_hook) (ptr, size);
+
+  block = BLOCK (ptr);
+
+  type = _heapinfo[block].busy.type;
+  switch (type)
+    {
+    case 0:
+      /* Maybe reallocate a large block to a small fragment.  */
+      if (size <= BLOCKSIZE / 2)
+	{
+	  result = __bounds_malloc (size);
+	  if (result != NULL)
+	    {
+	      __bounds_memcpy (result, ptr, size);
+	      _free_internal (ptr);
+	      return result;
+	    }
+	}
+
+      /* The new size is a large allocation as well;
+         see if we can hold it in place. */
+      blocks = BLOCKIFY (size);
+      if (blocks < _heapinfo[block].busy.info.size)
+	{
+	  /* The new size is smaller; return
+	     excess memory to the free list. */
+	  _heapinfo[block + blocks].busy.type = 0;
+	  _heapinfo[block + blocks].busy.info.size
+	    = _heapinfo[block].busy.info.size - blocks;
+	  _heapinfo[block].busy.info.size = blocks;
+	  /* We have just created a new chunk by splitting a chunk in two.
+	     Now we will free this chunk; increment the statistics counter
+	     so it doesn't become wrong when _free_internal decrements it.  */
+	  ++_chunks_used;
+	  _free_internal (ADDRESS (block + blocks));
+	  result = ptr;
+	}
+      else if (blocks == _heapinfo[block].busy.info.size)
+	/* No size change necessary.  */
+	result = ptr;
+      else
+	{
+	  /* Won't fit, so allocate a new region that will.
+	     Free the old region first in case there is sufficient
+	     adjacent free space to grow without moving. */
+	  blocks = _heapinfo[block].busy.info.size;
+	  /* Prevent free from actually returning memory to the system.  */
+	  oldlimit = _heaplimit;
+	  _heaplimit = 0;
+	  _free_internal (ptr);
+	  _heaplimit = oldlimit;
+	  result = __bounds_malloc (size);
+	  if (result == NULL)
+	    {
+	      /* Now we're really in trouble.  We have to unfree
+	         the thing we just freed.  Unfortunately it might
+	         have been coalesced with its neighbors.  */
+	      if (_heapindex == block)
+		(void) __bounds_malloc (blocks * BLOCKSIZE);
+	      else
+		{
+		  __ptr_t previous
+		    = __bounds_malloc ((block - _heapindex) * BLOCKSIZE);
+		  (void) __bounds_malloc (blocks * BLOCKSIZE);
+		  _free_internal (previous);
+		}
+	      return NULL;
+	    }
+	  if (ptr != result)
+	    __bounds_memmove (result, ptr, blocks * BLOCKSIZE);
+	}
+      break;
+
+    default:
+      /* Old size is a fragment; type is logarithm
+         to base two of the fragment size.  */
+      if (size > (__malloc_size_t) (1 << (type - 1)) &&
+	  size <= (__malloc_size_t) (1 << type))
+	/* The new size is the same kind of fragment.  */
+	result = ptr;
+      else
+	{
+	  /* The new size is different; allocate a new space,
+	     and copy the lesser of the new size and the old. */
+	  result = __bounds_malloc (size);
+	  if (result == NULL)
+	    return NULL;
+	  __bounds_memcpy (result, ptr,
+			   min (size, (__malloc_size_t) 1 << type));
+	  __bounds_free (ptr);
+	}
+      break;
+    }
+
+  return result;
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/string.c gcc-4.0.2/gcc/bounds/lib/string.c
--- gcc-4.0.2.org/gcc/bounds/lib/string.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/string.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,1850 @@
+/* Bounds Checking for GCC.
+   Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   File:
+  	lib/string.c
+   Summary:
+  	Specially checked string and memory functions, replacing those
+  	found in your normal C library.
+   Other notes:
+  	Some of these functions are built into GCC, so you may need to
+  	use the '-fno-builtin' flag to get these checked versions. The
+  	rest of this library uses the '__bounds_*' versions which are
+  	unchecked.
+   Author      	Date		Notes
+   RWMJ		27/2/95		Initial implementation.
+   RWMJ		4/4/95		After profiling, some optimizations.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <ctype.h>
+
+#include "bounds-lib.h"
+#include "mutex.h"		/* for 'enter|leave_critical_section'  */
+#include "check.h"
+
+#if defined(__BOUNDS_CHECKING_ON)
+#error "This file must not be compiled with bounds checking enabled."
+#endif
+
+/* On `memchr' and `memccpy', it is probably valid to give a `n' (max. len.)
+   argument longer than the object, provided you know the `c' (character)
+   will match always before the end of the object. If you want strict
+   checking of `n', set these to `1'. If you do this, certain valid (?)
+   software fails, in particular GNU's `sprintf'.  */
+#define STRICT_MEMCHR		0
+#define STRICT_MEMCCPY		0
+
+/* Since `bcopy' varies from machine to machine in the way it handles
+   overlapping arguments, you may set its behaviour here. Set
+   `BCOPY_OVERLAPPING_ARGUMENTS' to 1 to get memmove-type behaviour, and
+   to 0 to get memcpy behaviour. Set `BCOPY_WARN_OVERLAPPING_ARGUMENTS'
+   if you want a warning when `bcopy' is called with overlapping arguments
+   (since relying on this is not necessarily portable).
+  
+   - RWMJ 16/1/96
+   - Thanks to Mark W. Snitily (mark@sgcs.com) for clarification here.  */
+
+#define BCOPY_OVERLAPPING_ARGUMENTS		1
+#define BCOPY_WARN_OVERLAPPING_ARGUMENTS	1	/* Enable for now.  */
+
+
+static __inline__ void *
+check_ptr (const char *filename, int line, void *pointer,
+	   const char *function, const char *ptr_name)
+{
+  if (__bounds_debug_no_checking == 0
+      && (pointer == NULL || pointer == ILLEGAL))
+    {
+      __bounds_errorf (filename, line, pointer, NULL,
+		       "NULL or ILLEGAL %s used in %s", ptr_name, function);
+      return NULL;
+    }
+  return pointer;
+}
+
+/* Inline function that does the donkey work checking a single
+   pointer is valid over a range of n bytes. If the pointer is
+   invalid, the function exits with an appropriate message.
+   If size == 0, the pointer points to a string. We work out the
+   size ourselves here, and check the extent will be OK.  */
+
+static __inline__ size_t
+check (const char *filename, int line, void *pointer, size_t size,
+       const char *function, const char *ptr_name)
+{
+  object *obj;
+
+  if (__bounds_debug_no_checking)
+    {
+      if (size)			/* not a string */
+	return 0;
+      else
+	{
+	  char *p = (char *) pointer;
+
+	  while (*p++);
+	  return p - (char *) pointer;
+	}
+    }
+  if (pointer == NULL || pointer == ILLEGAL)
+    {
+      __bounds_errorf (filename, line, pointer, NULL,
+		       "NULL or ILLEGAL %s used in %s", ptr_name, function);
+      return 0;
+    }
+  if ((obj = __bounds_find_object (pointer)) == NULL)
+    {
+      maybe_is_unchecked (pointer, NULL, 0, function);
+      /* Unchecked pointer is OK. We have already delivered a warning at
+         this point. If this is a string, return its length, else return
+         anything.  */
+      if (size)			/* not a string */
+	return 0;
+      /* unchecked operation => may fail.  */
+      {
+	char *p = (char *) pointer;
+
+	while (*p++);
+	return p - (char *) pointer;
+      }
+    }
+
+  if (size)
+    {
+      /* The pointer itself is valid, and points to a checked object. Now
+         make sure that we won't overrun the object by using this pointer
+         and size.  */
+      if ((char *) pointer + size > (char *) obj->extent)
+	__bounds_errorf (filename, line, pointer, obj,
+			 "%s with this %s and size %u would overrun"
+			 " the end of the object's allocated memory",
+			 function, ptr_name, size);
+      if ((char *) pointer + size < (char *) pointer)
+	__bounds_errorf (filename, line, pointer, obj,
+			 "%s with this %s and size %u would wrap"
+			 " around",
+			 function, ptr_name, size);
+      return 0;
+    }
+  else
+    {
+      /* This is a string.
+         Work out the size ourselves, and whether the pointer will be valid.
+         Return the length of the string + 1.  */
+      char *p = (char *) pointer;
+
+      while (*p++);
+      if (p > (char *) obj->extent)
+	__bounds_errorf (filename, line, pointer, obj,
+			 "in %s, %s is a string with size %u overrunning"
+			 " the end of the object's allocated memory",
+			 function, ptr_name, p - (char *) pointer);
+      return p - (char *) pointer;
+    }
+}
+
+/* Check for overlapping objects in functions (such as memcpy, strcpy)
+   where this is not permitted.  */
+
+static __inline__ void
+check_overlap (const char *filename, int line,
+	       void *p1, size_t n1,
+	       void *p2, size_t n2, const char *function_name)
+{
+  if (__bounds_debug_no_checking)
+    return;
+  if (__bounds_warn_overlap)
+    {
+      void *p1e = (void *) ((char *) p1 + n1 - 1);
+      void *p2e = (void *) ((char *) p2 + n2 - 1);
+
+      if ((p1 <= p2 && p1e >= p2) ||	/* p1----p2====p1e----p2e */
+	  (p2 <= p1 && p2e >= p1) ||	/* p2----p1====p2e----p1e */
+	  (p1 >= p2 && p1e <= p2e) ||	/* p2----p1====p1e----p2e */
+	  (p2 >= p1 && p2e <= p1e))
+	{			/* p1----p2====p2e----p1e */
+	  if (n1 == n2)
+	    {
+	      __bounds_errorf (filename, line, p1, __bounds_find_object (p1),
+			       "in %s with %p and %p for %u, source and destination objects overlap",
+			       function_name, p1, p2, n1);
+	    }
+	  else
+	    {
+	      __bounds_errorf (filename, line, p1, __bounds_find_object (p1),
+			       "in %s with %p for %u and %p for %u, source and destination objects overlap",
+			       function_name, p1, n1, p2, n2);
+	    }
+	}
+    }
+  else
+    {
+      void *p2e = (void *) ((char *) p2 + n2 - 1);
+
+      if (p1 > p2 && p1 <= p2e)
+	__bounds_errorf (filename, line, p1, __bounds_find_object (p1),
+			 "in %s with %p for %u and %p for %u, source and destination objects overlap",
+			 function_name, p1, n1, p2, n2);
+    }
+}
+
+/* These are the checked functions themselves. The '__bounds_*'
+   versions are internal unchecked functions used by this library
+   itself (to avoid reentrancy problems).
+     1.	The memory functions.  */
+
+#ifdef Lbounds_memcpy
+
+__inline__ void *
+__bounds_memcpy (void *dest, const void *src, size_t n)
+{
+  char *d = (char *) dest;
+  const char *s = (const char *) src;
+
+  for (; n; n--)
+    *d++ = *s++;
+  return dest;
+}
+
+void *
+__bounds_check_memcpy (const char *filename, int line,
+		       void *dest, const void *src, size_t n)
+{
+  if (n == 0 && (dest == NULL || src == NULL))
+    {
+      if (__bounds_warn_misc_strings)
+	__bounds_warning (filename, line, "memcpy",
+			  "NULL source or destination for a zero-sized memcpy");
+      return dest;
+    }
+  if (n == 0)
+    return dest;
+
+  check (filename, line, dest, n, "memcpy", "destination pointer");
+  check (filename, line, (void *) src, n, "memcpy", "source pointer");
+  check_overlap (filename, line, dest, n, (void *) src, n, "memcpy");
+  return __bounds_memcpy (dest, src, n);
+}
+
+#endif
+
+#ifdef Lmemcpy
+
+extern void *memcpy (void *dest, const void *src, size_t n);
+extern void *__bounds_check_memcpy (const char *filename, int line,
+				    void *dest, const void *src, size_t n);
+
+void *
+memcpy (void *dest, const void *src, size_t n)
+{
+  return __bounds_check_memcpy (NULL, 0, dest, src, n);
+}
+
+#endif
+
+/* These are the checked functions themselves. The '__bounds_*'
+   versions are internal unchecked functions used by this library
+   itself (to avoid reentrancy problems).
+     1.	The memory functions.  */
+
+#ifdef Lbounds_mempcpy
+
+__inline__ void *
+__bounds_mempcpy (void *dest, const void *src, size_t n)
+{
+  char *d = (char *) dest;
+  const char *s = (const char *) src;
+
+  for (; n; n--)
+    *d++ = *s++;
+  return d;
+}
+
+void *
+__bounds_check_mempcpy (const char *filename, int line,
+		       void *dest, const void *src, size_t n)
+{
+  if (n == 0 && (dest == NULL || src == NULL))
+    {
+      if (__bounds_warn_misc_strings)
+	__bounds_warning (filename, line, "mempcpy",
+			  "NULL source or destination for a zero-sized mempcpy");
+      return dest;
+    }
+  if (n == 0)
+    return dest;
+
+  check (filename, line, dest, n, "mempcpy", "destination pointer");
+  check (filename, line, (void *) src, n, "mempcpy", "source pointer");
+  check_overlap (filename, line, dest, n, (void *) src, n, "mempcpy");
+  return __bounds_mempcpy (dest, src, n);
+}
+
+#endif
+
+#ifdef Lmempcpy
+
+extern void *mempcpy (void *dest, const void *src, size_t n);
+extern void *__bounds_check_mempcpy (const char *filename, int line,
+				    void *dest, const void *src, size_t n);
+
+void *
+mempcpy (void *dest, const void *src, size_t n)
+{
+  return __bounds_check_mempcpy (NULL, 0, dest, src, n);
+}
+
+#endif
+
+#ifdef Lbounds_memmove
+
+__inline__ void *
+__bounds_memmove (void *dest, const void *src, size_t n)
+{
+  char *d = (char *) dest;
+  const char *s = (const char *) src;
+
+  if (dest < src)
+    for (; n; n--)
+      *d++ = *s++;
+  else if (dest > src)
+    {
+      d += n;
+      s += n;
+      for (; n; n--)
+	*--d = *--s;
+    }
+  return dest;
+}
+
+void *
+__bounds_check_memmove (const char *filename, int line,
+			void *dest, const void *src, size_t n)
+{
+  if (n == 0 && (dest == NULL || src == NULL))
+    {
+      if (__bounds_warn_misc_strings)
+	__bounds_warning (filename, line, "memmove",
+			  "NULL source or destination for a"
+			  " zero-sized memmove");
+      return dest;
+    }
+  if (n == 0)
+    return dest;
+
+  check (filename, line, dest, n, "memmove", "destination pointer");
+  check (filename, line, (void *) src, n, "memmove", "source pointer");
+  return __bounds_memmove (dest, src, n);
+}
+
+#endif
+
+#ifdef Lmemmove
+
+extern void *memmove (void *dest, const void *src, size_t n);
+extern void *__bounds_check_memmove (const char *filename, int line,
+				     void *dest, const void *src, size_t n);
+
+void *
+memmove (void *dest, const void *src, size_t n)
+{
+  return __bounds_check_memmove (NULL, 0, dest, src, n);
+}
+
+#endif
+
+#ifdef Lbounds_bcopy
+
+/* See comment on `bcopy' at the top of this file.  */
+
+#ifdef bcopy
+#undef bcopy
+#endif
+extern void *__bounds_check_memmove (const char *filename, int line,
+				     void *dest, const void *src, size_t n);
+
+void
+__bounds_check_bcopy (const char *filename, int line,
+		      const void *src, void *dest, int n)
+{
+#if BCOPY_OVERLAPPING_ARGUMENTS
+#if BCOPY_WARN_OVERLAPPING_ARGUMENTS
+  if (__bounds_warn_overlap)
+    check_overlap (filename, line, dest, n, (void *) src, n, "bcopy");
+#endif
+  __bounds_check_memmove (filename, line, dest, src, n);
+#else /* !BCOPY_OVERLAPPING_ARGUMENTS */
+  __bounds_check_memcpy (filename, line, dest, src, n);
+#endif /* !BCOPY_OVERLAPPING_ARGUMENTS */
+}
+
+#endif
+
+#ifdef Lbcopy
+
+extern void bcopy (const void *src, void *dest, int n);
+extern void __bounds_check_bcopy (const char *filename, int line,
+				  const void *src, void *dest, int n);
+
+void
+bcopy (const void *src, void *dest, int n)
+{
+  __bounds_check_bcopy (NULL, 0, src, dest, n);
+}
+
+#endif
+
+#ifdef Lbounds_memset
+
+__inline__ void *
+__bounds_memset (void *dest, int c, size_t n)
+{
+  /* `memset' is called very frequently, and therefore has to be fast. In a
+     future release of GCC, we will call '__builtin_memset' in this library,
+     but that isn't implemented yet. In the mean time, we spot the common
+     case when the memory is aligned, and write integers.  */
+  if (PTR_TO_UNSIGNED (dest) & (sizeof (int) - 1))	/* not aligned.  */
+    {
+      char *d = (char *) dest;
+
+      for (; n; n--)
+	*d++ = c;
+    }
+  else				/* aligned */
+    {
+      int *di = (int *) dest;
+      size_t n_longs = n / sizeof (int);
+      int wr = 0;
+      unsigned i;
+      char *dc;
+
+      for (i = 0; i < sizeof (int); i++)
+	wr = (wr << 8) | c;
+      n &= sizeof (int) - 1;
+      for (; n_longs; n_longs--)
+	*di++ = wr;
+      dc = (char *) di;
+      for (; n; n--)
+	*dc++ = c;
+    }
+
+  return dest;
+}
+
+void *
+__bounds_check_memset (const char *filename, int line,
+		       void *dest, int c, size_t n)
+{
+  if (n == 0 && dest == NULL)
+    {
+      if (__bounds_warn_misc_strings)
+	__bounds_warning (filename, line, "memset",
+			  "NULL destination for a zero-sized memset");
+      return dest;
+    }
+  if (n == 0)
+    return dest;
+
+  check (filename, line, dest, n, "memset", "destination pointer");
+  return __bounds_memset (dest, c, n);
+}
+
+#endif
+
+#ifdef Lmemset
+
+extern void *memset (void *dest, int c, size_t n);
+extern void *__bounds_check_memset (const char *filename, int line,
+				    void *dest, int c, size_t n);
+
+void *
+memset (void *dest, int c, size_t n)
+{
+  return __bounds_check_memset (NULL, 0, dest, c, n);
+}
+
+#endif
+
+#ifdef Lbounds_bzero
+
+#ifdef bzero
+#undef bzero
+#endif
+
+extern void *__bounds_check_memset (const char *filename, int line,
+				    void *dest, int c, size_t n);
+
+void
+__bounds_check_bzero (const char *filename, int line, char *dest, int n)
+{
+  __bounds_check_memset (filename, line, (void *) dest, 0, n);
+}
+
+#endif
+
+#ifdef Lbzero
+
+extern void bzero (char *dest, int n);
+extern void __bounds_check_bzero (const char *filename, int line,
+				  char *dest, int n);
+
+void
+bzero (char *dest, int n)
+{
+  __bounds_check_bzero (NULL, 0, dest, n);
+}
+
+#endif
+
+#ifdef Lbounds_memcmp
+
+__inline__ int
+__bounds_memcmp (const void *s1, const void *s2, size_t n)
+{
+  const unsigned char *cs1 = (const unsigned char *) s1;
+  const unsigned char *cs2 = (const unsigned char *) s2;
+  for (; n; n--)
+    {
+      if (*cs1 - *cs2 != 0)
+	return *cs1 - *cs2;
+      cs1++, cs2++;
+    }
+  return 0;
+}
+
+int
+__bounds_check_memcmp (const char *filename, int line,
+		       const void *s1, const void *s2, size_t n)
+{
+  if (n == 0 && (s1 == NULL || s2 == NULL))
+    {
+      if (__bounds_warn_misc_strings)
+	__bounds_warning (filename, line, "memcmp",
+			  "NULL source or destination for a zero-sized memcmp");
+      return 0;
+    }
+  if (n == 0)
+    return 0;
+
+  check (filename, line, (void *) s1, n, "memcmp", "first pointer argument");
+  check (filename, line, (void *) s2, n, "memcmp", "second pointer argument");
+  return __bounds_memcmp (s1, s2, n);
+}
+
+#endif
+
+#ifdef Lmemcmp
+
+extern int memcmp (const void *s1, const void *s2, size_t n);
+extern int __bounds_check_memcmp (const char *filename, int line,
+				  const void *s1, const void *s2, size_t n);
+
+int
+memcmp (const void *s1, const void *s2, size_t n)
+{
+  return __bounds_check_memcmp (NULL, 0, s1, s2, n);
+}
+
+#endif
+
+#ifdef Lbounds_bcmp
+
+/* I'm assuming here that bcmp is the pre-ANSI memcmp function. Since I've
+   never actually used the b* functions, I'm not sure if this is totally
+   right.  */
+
+#ifdef bcmp
+#undef bcmp
+#endif
+
+extern int __bounds_check_memcmp (const char *filename, int line,
+				  const void *s1, const void *s2, size_t n);
+
+int
+__bounds_check_bcmp (const char *filename, int line, void *s1, void *s2,
+		     int n)
+{
+  return __bounds_check_memcmp (filename, line, s1, s2, n);
+}
+
+#endif
+
+#ifdef Lbcmp
+
+extern int bcmp (void *s1, void *s2, int n);
+extern int __bounds_check_bcmp (const char *filename, int line,
+				void *s1, void *s2, int n);
+
+int
+bcmp (void *s1, void *s2, int n)
+{
+  return __bounds_check_bcmp (NULL, 0, s1, s2, n);
+}
+
+#endif
+
+/* 2. The string functions.  */
+
+#ifdef Lbounds_strcpy
+
+__inline__ char *
+__bounds_strcpy (char *dest, const char *src)
+{
+  char *d = dest;
+
+  while ((*dest++ = *src++) != 0);
+  return d;
+}
+
+char *
+__bounds_check_strcpy (const char *filename, int line,
+		       char *dest, const char *src)
+{
+  size_t n =
+    check (filename, line, (void *) src, 0, "strcpy", "source string");
+  check (filename, line, dest, n, "strcpy", "destination string");
+  check_overlap (filename, line, dest, n, (void *) src, n, "strcpy");
+  return __bounds_strcpy (dest, src);
+}
+
+#endif
+
+#ifdef Lstrcpy
+
+extern char *strcpy (char *dest, const char *src);
+extern char *__bounds_check_strcpy (const char *filename, int line,
+				    char *dest, const char *src);
+
+char *
+strcpy (char *dest, const char *src)
+{
+  return __bounds_check_strcpy (NULL, 0, dest, src);
+}
+
+#endif
+
+#ifdef Lbounds_strncpy
+
+__inline__ char *
+__bounds_strncpy (char *dest, const char *src, size_t n)
+{
+  char *d = dest;
+
+  if (n)
+    {
+      for (;;)
+	{
+	  if ((int) --n == -1)
+	    return d;
+	  else if ((*dest++ = *src++) == 0)
+	    break;
+	}
+      while (n--)
+	*dest++ = 0;
+    }
+  return d;
+}
+
+char *
+__bounds_check_strncpy (const char *filename, int line,
+			char *dest, const char *src, size_t n)
+{
+  char *t1;
+  size_t n1;
+
+  if (n == 0 && (dest == NULL || src == NULL))
+    {
+      if (__bounds_warn_misc_strings)
+	__bounds_warning (filename, line, "strncpy",
+			  "NULL source or destination for a"
+			  " zero-sized strncpy");
+      return dest;
+    }
+  if (n == 0)
+    return dest;
+  t1 = check_ptr (filename, line, (void *) src, "strncpy", "source argument");
+  if (t1 == NULL)
+    return NULL;
+  n1 = n;
+  while (n1 && *t1)
+    {
+      n1--;
+      t1++;
+    }
+  n1 = (((t1 - src) + 1) < (int) n) ? (size_t) (t1 - src) + 1 : n;
+  check (filename, line, (void *) src, n1, "strncpy", "source string");
+  check (filename, line, dest, n, "strncpy", "destination string");
+  check_overlap (filename, line, dest, n, (void *) src, n1, "strncpy");
+  return __bounds_strncpy (dest, src, n);
+}
+
+#endif
+
+#ifdef Lstrncpy
+
+extern char *strncpy (char *dest, const char *src, size_t n);
+extern char *__bounds_check_strncpy (const char *filename, int line,
+				     char *dest, const char *src, size_t n);
+
+char *
+strncpy (char *dest, const char *src, size_t n)
+{
+  return __bounds_check_strncpy (NULL, 0, dest, src, n);
+}
+
+#endif
+
+#ifdef Lbounds_strlen
+
+__inline__ size_t
+__bounds_strlen (const char *s)
+{
+  const char *r = s;
+
+  while (*s++);
+  return (s - r) - 1;
+}
+
+size_t
+__bounds_check_strlen (const char *filename, int line, const char *s)
+{
+  return check (filename, line, (void *) s, 0, "strlen",
+		"string argument") - 1;
+}
+
+#endif
+
+#ifdef Lstrlen
+
+extern size_t strlen (const char *s);
+extern size_t __bounds_check_strlen (const char *filename, int line,
+				     const char *s);
+
+size_t
+strlen (const char *s)
+{
+  return __bounds_check_strlen (NULL, 0, s);
+}
+
+#endif
+
+#ifdef Lbounds_strcmp
+
+__inline__ int
+__bounds_strcmp (const char *s1, const char *s2)
+{
+  const unsigned char *u1 = (const unsigned char *) s1;
+  const unsigned char *u2 = (const unsigned char *) s2;
+
+  while (*u1 && *u1 == *u2)
+    {
+      u1++;
+      u2++;
+    }
+  return (*u1 - *u2);
+}
+
+int
+__bounds_check_strcmp (const char *filename, int line,
+		       const char *s1, const char *s2)
+{
+  char *t1 = check_ptr (filename, line, (void *) s1, "strcmp",
+			"string1 argument");
+  char *t2 = check_ptr (filename, line, (void *) s2, "strcmp",
+			"string2 argument");
+  size_t n;
+
+  if (t1 == NULL || t2 == NULL)
+    return -1;
+
+  while (*t1 && *t2)
+    {
+      t1++;
+      t2++;
+    }
+  n = (t1 - s1) + 1;
+  check (filename, line, (void *) s1, n, "strcmp", "string1 argument");
+  check (filename, line, (void *) s2, n, "strcmp", "string2 argument");
+  return __bounds_strcmp (s1, s2);
+}
+
+#endif
+
+#ifdef Lstrcmp
+
+extern int strcmp (const char *s1, const char *s2);
+extern int __bounds_check_strcmp (const char *filename, int line,
+				  const char *s1, const char *s2);
+
+int
+strcmp (const char *s1, const char *s2)
+{
+  return __bounds_check_strcmp (NULL, 0, s1, s2);
+}
+
+#endif
+
+#ifdef Lbounds_strncmp
+
+__inline__ int
+__bounds_strncmp (const char *s1, const char *s2, size_t n)
+{
+  const unsigned char *u1 = (const unsigned char *) s1;
+  const unsigned char *u2 = (const unsigned char *) s2;
+
+  do
+    {
+      if ((int) --n == -1)
+	break;
+      else if (*u1 != *u2)
+	return *u1 - *u2;
+      u2++;
+    }
+  while (*u1++);
+  return 0;
+}
+
+int
+__bounds_check_strncmp (const char *filename, int line,
+			const char *s1, const char *s2, size_t n)
+{
+  char *t1;
+  char *t2;
+  size_t n1;
+
+  if (n == 0 && (s1 == NULL || s2 == NULL))
+    {
+      if (__bounds_warn_misc_strings)
+	__bounds_warning (filename, line, "strncmp",
+			  "NULL source or destination for a"
+			  " zero-sized strncmp");
+      return 0;
+    }
+  if (n == 0)
+    return 0;
+  t1 = check_ptr (filename, line, (void *) s1, "strncmp", "string1 argument");
+  t2 = check_ptr (filename, line, (void *) s2, "strncmp", "string2 argument");
+  if (t1 == NULL || t2 == NULL)
+    return -1;
+  n1 = n;
+  while (n1 && *t1 && *t2)
+    {
+      n1--;
+      t1++;
+      t2++;
+    }
+  if (((t1 - s1) + 1) < (int) n)
+    n = (t1 - s1) + 1;
+  check (filename, line, (void *) s1, n, "strncmp", "string1 argument");
+  check (filename, line, (void *) s2, n, "strncmp", "string2 argument");
+  return (__bounds_strncmp (s1, s2, n));
+}
+
+#endif
+
+#ifdef Lstrncmp
+
+extern int strncmp (const char *s1, const char *s2, size_t n);
+extern int __bounds_check_strncmp (const char *filename, int line,
+				   const char *s1, const char *s2, size_t n);
+
+int
+strncmp (const char *s1, const char *s2, size_t n)
+{
+  return __bounds_check_strncmp (NULL, 0, s1, s2, n);
+}
+
+#endif
+
+#ifdef Lbounds_strcat
+
+__inline__ char *
+__bounds_strcat (char *dest, const char *src)
+{
+  char *r = dest;
+
+  while (*dest++);
+  dest--;
+  while ((*dest++ = *src++) != 0);
+  return r;
+}
+
+char *
+__bounds_check_strcat (const char *filename, int line,
+		       char *dest, const char *src)
+{
+  char *r =
+    check_ptr (filename, line, dest, "strcat", "destination argument");
+  size_t n = check (filename, line, (void *) src, 0, "strcat",
+		    "source argument");
+
+  if (r == NULL)
+    return NULL;
+
+  while (*r++);
+  check (filename, line, dest, n + (r - dest) - 1, "strcat",
+	 "destination argument");
+  check_overlap (filename, line, r - 1, n, (void *) src, n, "strcat");
+  return (__bounds_strcat (dest, src));
+}
+
+#endif
+
+#ifdef Lstrcat
+
+extern char *strcat (char *dest, const char *src);
+extern char *__bounds_check_strcat (const char *filename, int line,
+				    char *dest, const char *src);
+
+char *
+strcat (char *dest, const char *src)
+{
+  return __bounds_check_strcat (NULL, 0, dest, src);
+}
+
+#endif
+
+#ifdef Lbounds_strncat
+
+static __inline__ char *
+__bounds_strncat (char *dest, const char *src, size_t n)
+{
+  char *r = dest;
+
+  while (*dest++);
+  dest--;
+  for (;;)
+    {
+      if (n-- == 0)
+	break;
+      else if ((*dest++ = *src++) == 0)
+	return (r);
+    }
+  *dest = 0;
+  return r;
+}
+
+
+char *
+__bounds_check_strncat (const char *filename, int line,
+			char *dest, const char *src, size_t n)
+{
+  char *r;
+  char *p;
+  size_t n1;
+
+  if (n == 0 && (dest == NULL || src == NULL))
+    {
+      if (__bounds_warn_misc_strings)
+	__bounds_warning (filename, line, "strncat",
+			  "NULL source or destination for a"
+			  " zero-sized strncat");
+      return dest;
+    }
+  if (n == 0)
+    return dest;
+  r = check_ptr (filename, line, dest, "strncat", "destination argument");
+  p = check_ptr (filename, line, (void *) src, "strncat", "source argument");
+  if (r == NULL || p == NULL)
+    return NULL;
+  n1 = n;
+  while (n1 && *p)
+    {
+      n1--;
+      p++;
+    }
+  if (((p - src) + 1) < (int) n)
+    n = (size_t) (p - src) + 1;
+  check (filename, line, (void *) src, n, "strncat", "source argument");
+  while (*r++);
+  check (filename, line, dest, n + (r - dest) - 1, "strncat",
+	 "destination argument");
+  check_overlap (filename, line, r - 1, n, (void *) src, n, "strncat");
+  return __bounds_strncat (dest, src, n);
+}
+
+#endif
+
+#ifdef Lstrncat
+
+extern char *strncat (char *dest, const char *src, size_t n);
+extern char *__bounds_check_strncat (const char *filename, int line,
+				     char *dest, const char *src, size_t n);
+
+char *
+strncat (char *dest, const char *src, size_t n)
+{
+  return __bounds_check_strncat (NULL, 0, dest, src, n);
+}
+
+#endif
+
+#ifdef Lbounds_strpbrk
+
+static __inline__ char *
+__bounds_strpbrk (const char *string, const char *chs)
+{
+  char ch;
+
+  while ((ch = *string++) != 0)
+    {
+      const char *chk = chs;
+      char tch;
+
+      while ((tch = *chk++) != 0)
+	if (ch == tch)
+	  return (char *) string - 1;
+    }
+  return (NULL);
+}
+
+char *
+__bounds_check_strpbrk (const char *filename, int line,
+			const char *string, const char *chs)
+{
+  check (filename, line, (void *) string, 0, "strpbrk", "string argument");
+  check (filename, line, (void *) chs, 0, "strpbrk", "check argument");
+  return __bounds_strpbrk (string, chs);
+}
+
+#endif
+
+#ifdef Lstrpbrk
+
+extern char *strpbrk (const char *string, const char *chs);
+extern char *__bounds_check_strpbrk (const char *filename, int line,
+				     const char *string, const char *chs);
+
+char *
+strpbrk (const char *string, const char *chs)
+{
+  return __bounds_check_strpbrk (NULL, 0, string, chs);
+}
+
+#endif
+
+#ifdef Lbounds_strrchr
+
+static __inline__ char *
+__bounds_strrchr (const char *string, int c)
+{
+  unsigned char ch = c;
+  unsigned char tch;
+  unsigned char *result = NULL;
+
+  for (;;)
+    {
+      if (ch == (tch = (unsigned char) (*string++)))
+	result = (unsigned char *) string - 1;
+      if (tch == 0)
+	break;
+    }
+  return (char *) result;
+}
+
+char *
+__bounds_check_strrchr (const char *filename, int line,
+			const char *string, int c)
+{
+  check (filename, line, (void *) string, 0, "strrchr", "string argument");
+  return __bounds_strrchr (string, c);
+}
+
+#endif
+
+#ifdef Lstrrchr
+
+extern char *strrchr (const char *string, int c);
+extern char *__bounds_check_strrchr (const char *filename, int line,
+				     const char *string, int c);
+
+char *
+strrchr (const char *string, int c)
+{
+  return __bounds_check_strrchr (NULL, 0, string, c);
+}
+
+#endif
+
+#ifdef Lbounds_rindex
+
+#ifdef rindex
+#undef rindex
+#endif
+
+extern char *__bounds_check_strrchr (const char *filename, int line,
+				     const char *string, int c);
+
+char *
+__bounds_check_rindex (const char *filename, int line,
+		       const char *string, int c)
+{
+  return __bounds_check_strrchr (filename, line, string, c);
+}
+
+#endif
+
+#ifdef Lrindex
+
+extern char *rindex (const char *string, int c);
+extern char *__bounds_check_rindex (const char *filename, int line,
+				    const char *string, int c);
+
+char *
+rindex (const char *string, int c)
+{
+  return __bounds_check_rindex (NULL, 0, string, c);
+}
+
+#endif
+
+#ifdef Lbounds_strspn
+
+extern size_t __bounds_strspn (const char *string, const char *chs);
+
+size_t
+__bounds_strspn (const char *string, const char *chs)
+{
+  const char *r = string;
+  char ch;
+
+  while ((ch = *r++) != 0)
+    {
+      const char *chk = chs;
+      char tch;
+
+      do
+	{
+	  if ((tch = *chk++) == 0)
+	    return (r - string) - 1;
+	}
+      while (tch != ch);
+    }
+  return (r - string) - 1;
+}
+
+size_t
+__bounds_check_strspn (const char *filename, int line,
+		       const char *string, const char *chs)
+{
+  check (filename, line, (void *) string, 0, "strspn", "string argument");
+  check (filename, line, (void *) chs, 0, "strspn", "check argument");
+  return __bounds_strspn (string, chs);
+}
+
+#endif
+
+#ifdef Lstrspn
+
+extern size_t strspn (const char *string, const char *chs);
+extern size_t __bounds_check_strspn (const char *filename, int line,
+				     const char *string, const char *chs);
+
+size_t
+strspn (const char *string, const char *chs)
+{
+  return __bounds_check_strspn (NULL, 0, string, chs);
+}
+
+#endif
+
+#ifdef Lbounds_strcspn
+
+extern size_t __bounds_strcspn (const char *string, const char *chs);
+
+size_t
+__bounds_strcspn (const char *string, const char *chs)
+{
+  const char *r = string;
+  char ch;
+
+  while ((ch = *r++) != 0)
+    {
+      const char *chk = chs;
+      char tch;
+
+      while ((tch = *chk++) != 0)
+	{
+	  if (ch == tch)
+	    return (r - string) - 1;
+	}
+    }
+  return (r - string) - 1;
+}
+
+size_t
+__bounds_check_strcspn (const char *filename, int line,
+			const char *string, const char *chs)
+{
+  check (filename, line, (void *) string, 0, "strcspn", "string argument");
+  check (filename, line, (void *) chs, 0, "strcspn", "check argument");
+  return __bounds_strcspn (string, chs);
+}
+
+#endif
+
+#ifdef Lstrcspn
+
+extern size_t strcspn (const char *string, const char *chs);
+extern size_t __bounds_check_strcspn (const char *filename, int line,
+				      const char *string, const char *chs);
+
+size_t
+strcspn (const char *string, const char *chs)
+{
+  return __bounds_check_strcspn (NULL, 0, string, chs);
+}
+
+#endif
+
+#ifdef Lbounds_strstr
+
+static __inline__ char *
+__bounds_strstr (const char *s1, const char *s2)
+{
+  char cp1, cp2;
+  const char *pos = s1;
+
+  while (*s1)
+    {
+      const char *cmp = s2;
+
+      while (((cp1 = *s1++) == (cp2 = *cmp++)) && cp1);
+      if (cp2 == 0)
+	return (char *) pos;
+      s1 = ++pos;
+    }
+  return NULL;
+}
+
+char *
+__bounds_check_strstr (const char *filename, int line,
+		       const char *s1, const char *s2)
+{
+  check (filename, line, (void *) s1, 0, "strstr", "string1 argument");
+  check (filename, line, (void *) s2, 0, "strstr", "string2 argument");
+  return __bounds_strstr (s1, s2);
+}
+
+#endif
+
+#ifdef Lstrstr
+
+extern char *strstr (const char *s1, const char *s2);
+extern char *__bounds_check_strstr (const char *filename, int line,
+				    const char *s1, const char *s2);
+
+char *
+strstr (const char *s1, const char *s2)
+{
+  return __bounds_check_strstr (NULL, 0, s1, s2);
+}
+
+#endif
+
+#ifdef Lbounds_strtok
+
+extern size_t __bounds_strspn (const char *string, const char *chs);
+extern size_t __bounds_strcspn (const char *string, const char *chs);
+
+static __inline__ char *
+__bounds_strtok (char *str1, const char *str2)
+{
+  char **last_end = __bounds_strtok_last_end ();
+  char *start;
+
+  if (str1)
+    *last_end = str1;
+
+  if (!*last_end)
+    return NULL;
+
+  *last_end += __bounds_strspn (*last_end, str2);
+  if (**last_end == '\0')
+    return NULL;
+
+  start = *last_end;
+  *last_end += __bounds_strcspn (*last_end, str2);
+
+  if (**last_end != '\0')
+    {
+      **last_end = '\0';
+      (*last_end)++;
+    }
+
+  return start;
+}
+
+char *
+__bounds_check_strtok (const char *filename, int line,
+		       char *str1, const char *str2)
+{
+  if (str1 != NULL)
+    check (filename, line, str1, 0, "strtok", "first argument");
+  check (filename, line, (void *) str2, 0, "strtok", "second argument");
+  return __bounds_strtok (str1, str2);
+}
+
+#endif
+
+#ifdef Lstrtok
+
+extern char *strtok (char *str1, const char *str2);
+extern char *__bounds_check_strtok (const char *filename, int line,
+				    char *str1, const char *str2);
+
+char *
+strtok (char *str1, const char *str2)
+{
+  return __bounds_check_strtok (NULL, 0, str1, str2);
+}
+
+#endif
+
+#ifdef Lbounds_strtok_r
+
+extern size_t __bounds_strspn (const char *string, const char *chs);
+extern size_t __bounds_strcspn (const char *string, const char *chs);
+
+static __inline__ char *
+__bounds_strtok_r (char *str1, const char *str2, char **lasts)
+{
+  char *start;
+
+  if (str1)
+    *lasts = str1;
+
+  if (!*lasts)
+    return NULL;
+
+  *lasts += __bounds_strspn (*lasts, str2);
+  if (**lasts == '\0')
+    return NULL;
+
+  start = *lasts;
+  *lasts += __bounds_strcspn (*lasts, str2);
+
+  if (**lasts != '\0')
+    {
+      **lasts = '\0';
+      (*lasts)++;
+    }
+
+  return start;
+}
+
+char *
+__bounds_check_strtok_r (const char *filename, int line,
+			 char *str1, const char *str2, char **lasts)
+{
+  if (str1 != NULL)
+    check (filename, line, str1, 0, "strtok", "first argument");
+  check (filename, line, (void *) str2, 0, "strtok", "second argument");
+  return __bounds_strtok_r (str1, str2, lasts);
+}
+
+#endif
+
+#ifdef Lstrtok
+
+extern char *strtok_r (char *str1, const char *str2, char **lasts);
+extern char *__bounds_check_strtok_r (const char *filename, int line,
+				      char *str1, const char *str2,
+				      char **lasts);
+
+char *
+strtok_r (char *str1, const char *str2, char **lasts)
+{
+  return __bounds_check_strtok_r (NULL, 0, str1, str2, lasts);
+}
+
+#endif
+
+#ifdef Lbounds_strchr
+
+static __inline__ char *
+__bounds_strchr (const char *string, int ch)
+{
+  int tch;
+
+  for (;;)
+    if ((tch = (unsigned char) (*string++)) == (unsigned char) ch)
+      return (char *) string - 1;
+    else if (tch == 0)
+      return NULL;
+}
+
+char *
+__bounds_check_strchr (const char *filename, int line,
+		       const char *string, int ch)
+{
+  check (filename, line, (void *) string, 0, "strchr", "string argument");
+  return __bounds_strchr (string, ch);
+}
+
+#endif
+
+#ifdef Lstrchr
+
+extern char *strchr (const char *string, int ch);
+extern char *__bounds_check_strchr (const char *filename, int line,
+				    const char *string, int ch);
+
+char *
+strchr (const char *string, int ch)
+{
+  return __bounds_check_strchr (NULL, 0, string, ch);
+}
+
+#endif
+
+#ifdef Lbounds_strdup
+
+char *
+__bounds_check_strdup (const char *filename, int line, const char *string)
+{
+  sigset_t old_mask;
+  char *new;
+  size_t n = check (filename, line, (void *) string, 0, "strdup",
+		    "string argument");
+  enter_critical_section (&old_mask);
+  new = __bounds_malloc (n + 1);
+  if (new != NULL)
+    __bounds_add_heap_object (new, n, 1, "strdup", 0, filename, line);
+  leave_critical_section (&old_mask);
+  return new ? __bounds_strcpy (new, string) : NULL;
+}
+
+#endif
+
+#ifdef Lstrdup
+
+extern char *strdup (const char *string);
+extern char *__bounds_check_strdup (const char *filename, int line,
+				    const char *string);
+
+char *
+strdup (const char *string)
+{
+  return __bounds_check_strdup (NULL, 0, string);
+}
+
+#endif
+
+#ifdef Lbounds_index
+
+#ifdef index
+#undef index
+#endif
+
+extern char *__bounds_check_strchr (const char *filename, int line,
+				    const char *string, int ch);
+
+char *
+__bounds_check_index (const char *filename, int line,
+		      const char *string, int ch)
+{
+  return __bounds_check_strchr (filename, line, string, ch);
+}
+
+#endif
+
+#ifdef Lindex
+
+extern char *index (const char *string, int ch);
+extern char *__bounds_check_index (const char *filename, int line,
+				   const char *string, int ch);
+
+char *
+index (const char *string, int ch)
+{
+  return __bounds_check_index (NULL, 0, string, ch);
+}
+
+#endif
+
+#ifdef Lbounds_strcoll
+
+static __inline__ int
+__bounds_strcoll (const char *string1, const char *string2)
+{
+  while (*string1 && (*string1 == *string2))
+    {
+      string1++;
+      string2++;
+    }
+  return *string1 - *string2;
+}
+
+int
+__bounds_check_strcoll (const char *filename, int line,
+			const char *string1, const char *string2)
+{
+  check (filename, line, (void *) string1, 0, "strcoll", "first argument");
+  check (filename, line, (void *) string2, 0, "strcoll", "second argument");
+  return __bounds_strcoll (string1, string2);
+}
+
+#endif
+
+#ifdef Lstrcoll
+
+extern int strcoll (const char *string1, const char *string2);
+extern int __bounds_check_strcoll (const char *filename, int line,
+				   const char *string1, const char *string2);
+
+int
+strcoll (const char *string1, const char *string2)
+{
+  return __bounds_check_strcoll (NULL, 0, string1, string2);
+}
+
+#endif
+
+#ifdef Lbounds_strxfrm
+
+static __inline__ size_t
+__bounds_strxfrm (char *to, const char *from, size_t n)
+{
+  int count = 0;
+  while (*from++)
+    count++;
+  from -= count;
+  from--;
+
+  if (n != 0)
+    while ((*to++ = *from++) && (--n != 0));
+
+  return ((size_t) count);
+}
+
+size_t
+__bounds_check_strxfrm (const char *filename, int line,
+			char *to, const char *from, size_t n)
+{
+  check (filename, line, (void *) from, 0, "strxfrm", "src argument");
+  if (n)
+    check (filename, line, to, n, "strxfrm", "dest argument");
+  return __bounds_strxfrm (to, from, n);
+}
+
+#endif
+
+#ifdef Lstrxfrm
+
+extern size_t strxfrm (char *to, const char *from, size_t n);
+extern size_t __bounds_check_strxfrm (const char *filename, int line,
+				      char *to, const char *from, size_t n);
+
+size_t
+strxfrm (char *to, const char *from, size_t n)
+{
+  return __bounds_check_strxfrm (NULL, 0, to, from, n);
+}
+
+#endif
+
+#define	LOW(c)	(islower((int)(c)) ? c : tolower((int)(c)))
+
+#ifdef Lbounds_strcasecmp
+
+static __inline__ int
+__bounds_strcasecmp (const char *s1, const char *s2)
+{
+  const unsigned char *u1 = (const unsigned char *) s1;
+  const unsigned char *u2 = (const unsigned char *) s2;
+
+  while (*u1 && LOW (*u1) == LOW (*u2))
+    {
+      u1++;
+      u2++;
+    }
+  return (LOW (*u1) - LOW (*u2));
+}
+
+int
+__bounds_check_strcasecmp (const char *filename, int line,
+			   const char *s1, const char *s2)
+{
+  char *t1 = check_ptr (filename, line, (void *) s1, "strcasecmp",
+			"first argument");
+  char *t2 = check_ptr (filename, line, (void *) s2, "strcasecmp",
+			"second argument");
+  size_t n;
+
+  if (t1 == NULL || t2 == NULL)
+    return 0;
+
+  while (*t1 && *t2)
+    {
+      t1++;
+      t2++;
+    }
+  n = (t1 - s1) + 1;
+  check (filename, line, (void *) s1, n, "strcasecmp", "string1 argument");
+  check (filename, line, (void *) s2, n, "strcasecmp", "string2 argument");
+  return __bounds_strcasecmp (s1, s2);
+}
+
+#endif
+
+#ifdef Lstrcasecmp
+
+extern int strcasecmp (const char *s1, const char *s2);
+extern int __bounds_check_strcasecmp (const char *filename, int line,
+				      const char *s1, const char *s2);
+
+int
+strcasecmp (const char *s1, const char *s2)
+{
+  return __bounds_check_strcasecmp (NULL, 0, s1, s2);
+}
+
+#endif
+
+#ifdef Lbounds_strncasecmp
+
+static __inline__ int
+__bounds_strncasecmp (const char *s1, const char *s2, size_t n)
+{
+  const unsigned char *u1 = (const unsigned char *) s1;
+  const unsigned char *u2 = (const unsigned char *) s2;
+
+  do
+    {
+      if ((int) --n == -1)
+	break;
+      else if (LOW (*u1) != LOW (*u2))
+	return LOW (*u1) - LOW (*u2);
+      u2++;
+    }
+  while (*u1++);
+  return 0;
+}
+
+int
+__bounds_check_strncasecmp (const char *filename, int line,
+			    const char *s1, const char *s2, size_t n)
+{
+  char *t1;
+  char *t2;
+  size_t n1;
+
+  if (n == 0 && (s1 == NULL || s2 == NULL))
+    {
+      if (__bounds_warn_misc_strings)
+	__bounds_warning (filename, line, "strncasecmp",
+			  "NULL source or destination for a"
+			  " zero-sized strncasecmp");
+      return 0;
+    }
+  if (n == 0)
+    return 0;
+  t1 = check_ptr (filename, line, (void *) s1, "strncasecmp",
+		  "string1 argument");
+  t2 = check_ptr (filename, line, (void *) s2, "strncasecmp",
+		  "string2 argument");
+  if (t1 == NULL || t2 == NULL)
+    return 0;
+  n1 = n;
+  while (n1 && *t1 && *t2)
+    {
+      n1--;
+      t1++;
+      t2++;
+    }
+  if (((t1 - s1) + 1) < (int) n)
+    n = (size_t) (t1 - s1) + 1;
+  check (filename, line, (void *) s1, n, "strncasecmp", "string1 argument");
+  check (filename, line, (void *) s2, n, "strncasecmp", "string2 argument");
+  return __bounds_strncasecmp (s1, s2, n);
+}
+
+#endif
+
+#ifdef Lstrncasecmp
+
+extern int strncasecmp (const char *s1, const char *s2, size_t n);
+extern int __bounds_check_strncasecmp (const char *filename, int line,
+				       const char *s1, const char *s2,
+				       size_t n);
+
+int
+strncasecmp (const char *s1, const char *s2, size_t n)
+{
+  return __bounds_check_strncasecmp (NULL, 0, s1, s2, n);
+}
+
+#endif
+
+/* The odd functions `memccpy' and `memchr' are treated separately
+   here. With these functions, it is permissible to have a `size'
+   argument that is too large, so long as we will always meet
+   the `c' terminating character before the end of the object.  */
+
+static __inline__ void
+check2 (const char *filename, int line,
+	void *pointer, size_t size, int c, const char *function,
+	const char *ptr_name)
+{
+  object *obj;
+
+  if (__bounds_debug_no_checking)
+    return;
+
+#if 0				/* This check is redundant. All callers should cast the argument to
+				   unsigned char before calling.
+				   - Eberhard Mattes <mattes@azu.informatik.uni-stuttgart.de>
+				   & RWMJ.  */
+  if (c < 0 || c > 255)
+    __bounds_errorf (filename, line, pointer, NULL,
+		     "%s called with terminating character < 0 or > 255",
+		     function);
+#endif
+
+  if (pointer == NULL || pointer == ILLEGAL)
+    {
+      __bounds_errorf (filename, line, pointer, NULL,
+		       "NULL or ILLEGAL %s used in %s", ptr_name, function);
+      return;
+    }
+  if ((obj = __bounds_find_object (pointer)) == NULL)
+    {
+      maybe_is_unchecked (pointer, NULL, 0, function);
+      /* Unchecked pointer is OK. We have already delivered a warning at
+         this point.  */
+      return;
+    }
+
+  /* The pointer itself is valid, and points to a checked object. Now make
+     sure that we won't overrun the object by using this pointer and size.
+     However, if size does overrun, give it a second chance by looking for
+     the terminating character.  */
+  if ((void *) ((char *) pointer + size) > obj->extent)
+    {
+      char *p = (char *) pointer;
+      size_t n = (char *) obj->extent - (char *) pointer;
+
+      for (; n && *p != c; n--, p++)
+	;
+      if (n == 0)
+	{
+	  __bounds_errorf (filename, line, pointer, obj,
+			   "%s with this %s would overrun the"
+			   " end of the object's allocated memory",
+			   function, ptr_name);
+	  return;
+	}
+      /* If n > 0, then OK: The area is still acceptable. */
+    }
+  return;
+}
+
+#ifdef Lbounds_memchr
+
+__inline__ void *
+__bounds_memchr (const void *s, int c, size_t n)
+{
+  const unsigned char *cs = (const unsigned char *) s;
+  for (; n; n--)
+    {
+      if (*cs == (unsigned char) c)
+	return (void *) cs;
+      cs++;
+    }
+  return NULL;
+}
+
+void *
+__bounds_check_memchr (const char *filename, int line,
+		       const void *s, int c, size_t n)
+{
+#if STRICT_MEMCHR
+  check (filename, line, (void *) s, n, "memchr", "pointer argument");
+#else
+  check2 (filename, line, (void *) s, n, (unsigned char) c, "memchr",
+	  "pointer argument");
+#endif
+  return __bounds_memchr (s, c, n);
+}
+
+#endif
+
+#ifdef Lmemchr
+
+extern void *memchr (const void *s, int c, size_t n);
+extern void *__bounds_check_memchr (const char *filename, int line,
+				    const void *s, int c, size_t n);
+
+void *
+memchr (const void *s, int c, size_t n)
+{
+  return __bounds_check_memchr (NULL, 0, s, c, n);
+}
+
+#endif
+
+#ifdef Lbounds_memccpy
+
+__inline__ void *
+__bounds_memccpy (void *dest, const void *src, int c, size_t n)
+{
+  char *d = (char *) dest;
+  const char *s = (const char *) src;
+
+  for (; n; n--)
+    {
+      if ((char) c == (*d++ = *s++))
+	return (void *) d;
+    }
+  return NULL;
+}
+
+void *
+__bounds_check_memccpy (const char *filename, int line,
+			void *dest, const void *src, int c, size_t n)
+{
+#if STRICT_MEMCCPY
+  check (filename, line, (void *) src, n, "memccpy", "source pointer");
+#else
+  check2 (filename, line, (void *) src, n, (unsigned char) c, "memccpy",
+	  "source pointer");
+#endif
+  check (filename, line, dest, n, "memccpy", "destination pointer");
+  check_overlap (filename, line, dest, n, (void *) src, n, "memccpy");
+  return __bounds_memccpy (dest, src, c, n);
+}
+
+#endif
+
+#ifdef Lmemccpy
+
+extern void *memccpy (void *dest, const void *src, int c, size_t n);
+extern void *__bounds_check_memccpy (const char *filename, int line,
+				     void *dest, const void *src,
+				     int c, size_t n);
+
+void *
+memccpy (void *dest, const void *src, int c, size_t n)
+{
+  return __bounds_check_memccpy (NULL, 0, dest, src, c, n);
+}
+
+#endif
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/valloc.c gcc-4.0.2/gcc/bounds/lib/valloc.c
--- gcc-4.0.2.org/gcc/bounds/lib/valloc.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/valloc.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,52 @@
+/* Allocate memory on a page boundary.
+   Copyright (C) 1991, 1992, 1993, 1994 Free Software Foundation, Inc.
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public License as
+published by the Free Software Foundation; either version 2 of the
+License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with this library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.
+
+   The author may be reached (Email) at the address mike@ai.mit.edu,
+   or (US mail) as Mike Haertel c/o Free Software Foundation.  */
+
+#include "bounds-lib.h"
+
+#ifdef __vxworks
+#include <stddef.h>
+#else
+
+#if defined (__GNU_LIBRARY__) || defined (_LIBC)
+#include <stddef.h>
+#include <sys/cdefs.h>
+extern size_t __getpagesize (void);
+#else
+#include "getpagesize.h"
+#define	 __getpagesize()	getpagesize()
+#endif
+#endif
+
+#ifndef	_MALLOC_INTERNAL
+#define	_MALLOC_INTERNAL
+#include <malloc.h>
+#endif
+
+static __malloc_size_t pagesize;
+
+__ptr_t
+__bounds_valloc (__malloc_size_t size)
+{
+  if (pagesize == 0)
+    pagesize = __getpagesize ();
+
+  return __bounds_memalign (pagesize, size);
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/version.h gcc-4.0.2/gcc/bounds/lib/version.h
--- gcc-4.0.2.org/gcc/bounds/lib/version.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/version.h	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,35 @@
+/* Bounds Checking for GCC.
+   Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+   File:
+  	lib/version.h
+   Summary:
+  	Get version number information automatically.
+   Other notes:
+  	
+   Author      	Date		Notes
+   RWMJ		16/8/95		Initial implementation.
+*/
+
+#ifndef _VERSION_H_
+#define _VERSION_H_
+
+#include "../VERSION"
+
+#define VERSION_STRING VERSION_GCC "-" VERSION_LIBRARY
+
+#endif /* _VERSION_H_ */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/lib/vm-limit.c gcc-4.0.2/gcc/bounds/lib/vm-limit.c
--- gcc-4.0.2.org/gcc/bounds/lib/vm-limit.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/lib/vm-limit.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,140 @@
+/* Functions for memory limit warnings.
+   Copyright (C) 1990, 1992 Free Software Foundation, Inc.
+
+
+This file is part of the GNU C Library.  Its master source is NOT part of
+the C library, however.  The master source lives in /gd/gnu/lib.
+
+The GNU C Library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Library General Public License as
+published by the Free Software Foundation; either version 2 of the
+License, or (at your option) any later version.
+
+The GNU C Library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Library General Public License for more details.
+
+You should have received a copy of the GNU Library General Public
+License along with the GNU C Library; see the file COPYING.LIB.  If
+not, write to the Free Software Foundation, Inc., 675 Mass Ave,
+Cambridge, MA 02139, USA.  */
+
+#ifdef emacs
+#include <config.h>
+#include "lisp.h"
+#endif
+
+#ifndef emacs
+#include <stddef.h>
+typedef size_t SIZE;
+typedef void *POINTER;
+#define EXCEEDS_LISP_PTR(x) 0
+#endif
+
+#include "malloc.h"
+#include "mem-limits.h"
+
+#include "bounds-lib.h"
+
+/*
+  Level number of warnings already issued.
+  0 -- no warnings issued.
+  1 -- 75% warning already issued.
+  2 -- 85% warning already issued.
+  3 -- 95% warning issued; keep warning frequently.
+*/
+static int warnlevel;
+
+/* Function to call to issue a warning;
+   0 means don't issue them.  */
+static void (*warn_function) (const char *);
+
+/* Get more memory space, complaining if we're near the end. */
+
+static void
+check_memory_limits (void)
+{
+  extern POINTER (*__morecore) (ptrdiff_t);
+
+  register POINTER cp;
+  unsigned long five_percent;
+  unsigned long data_size;
+
+  if (lim_data == 0)
+    get_lim_data ();
+  five_percent = lim_data / 20;
+
+  /* Find current end of memory and issue warning if getting near max */
+  cp = (char *) (*__morecore) (0);
+  data_size = (char *) cp - (char *) data_space_start;
+
+  if (warn_function)
+    switch (warnlevel)
+      {
+      case 0:
+	if (data_size > five_percent * 15)
+	  {
+	    warnlevel++;
+	    (*warn_function) ("Warning: past 75% of memory limit");
+	  }
+	break;
+
+      case 1:
+	if (data_size > five_percent * 17)
+	  {
+	    warnlevel++;
+	    (*warn_function) ("Warning: past 85% of memory limit");
+	  }
+	break;
+
+      case 2:
+	if (data_size > five_percent * 19)
+	  {
+	    warnlevel++;
+	    (*warn_function) ("Warning: past 95% of memory limit");
+	  }
+	break;
+
+      default:
+	(*warn_function) ("Warning: past acceptable memory limits");
+	break;
+      }
+
+  /* If we go down below 70% full, issue another 75% warning
+     when we go up again.  */
+  if (data_size < five_percent * 14)
+    warnlevel = 0;
+  /* If we go down below 80% full, issue another 85% warning
+     when we go up again.  */
+  else if (warnlevel > 1 && data_size < five_percent * 16)
+    warnlevel = 1;
+  /* If we go down below 90% full, issue another 95% warning
+     when we go up again.  */
+  else if (warnlevel > 2 && data_size < five_percent * 18)
+    warnlevel = 2;
+
+  if (EXCEEDS_LISP_PTR (cp))
+    (*warn_function) ("Warning: memory in use exceeds lisp pointer size");
+}
+
+/* Cause reinitialization based on job parameters;
+   also declare where the end of pure storage is. */
+
+void
+memory_warnings (POINTER start, void (*warnfun) (const char *))
+{
+  extern void (*__after_morecore_hook) (void);	/* From gmalloc.c */
+
+  if (start)
+    data_space_start = start;
+  else
+#ifdef __vxworks
+    data_space_start = NULL;
+#else
+    data_space_start = start_of_data ();
+#endif
+
+  warn_function = warnfun;
+  __after_morecore_hook = check_memory_limits;
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/MACHINES gcc-4.0.2/gcc/bounds/MACHINES
--- gcc-4.0.2.org/gcc/bounds/MACHINES	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/MACHINES	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,42 @@
+These are the machines on which GCC with bounds checking is known to work.
+Please send updates to this list to `rjones@orchestream.com' or
+'Haj.Ten.Brugge@net.HCC.nl'.
+
+Linux 1.2.13 (i386) <rjones@orchestream.com>
+
+SunOS 4.1.3 (Sparc) <rjones@orchestream.com>
+
+Solaris 2.4 (Sparc) <rjones@orchestream.com>
+
+Solaris 2.6 (Sparc) <Haj.Ten.Brugge@net.HCC.nl>
+
+Solaris 8 (Sparc) <Haj.Ten.Brugge@net.HCC.nl>
+
+HPUX 9.05 (HP-PA) <rjones@orchestream.com>
+
+ESIX SVR 4.0.4 (i386) <Haj.Ten.Brugge@net.HCC.nl>
+
+Unixware 2.0.3 (i586) <Haj.Ten.Brugge@net.HCC.nl>
+
+Linux 2.0.32 (i686) <Haj.Ten.Brugge@net.HCC.nl>
+
+SunOs 4.1.1 (M68k) <Haj.Ten.Brugge@net.HCC.nl>
+
+OSF 2.0 (DEC Alpha) <tuppa@iue.tuwien.ac.at>
+
+FreeBSD 2.0 (i386) <u27113@kb.be> (Danny Backx)
+
+	- Trouble caused when you set the environment variable ENABLE_STARTUP_
+	LOCALE. Danny Backx's advice is not to set this. Alternatively, static
+	linking works with and without this variable.
+
+Ultrix 4.2A (MIPS) <drochner@zelux6.zel.kfa-juelich.de> (Matthias Drochner)
+
+OS/2 (i386) <mattes@azu.informatik.uni-stuttgart.de> (Eberhard Mattes)
+
+AIX-4.3.2 (H50 RS/6000) <ad5gb@yahoo.com> (Randall DuCharme)
+
+SCO OpenServer 5.0.4 (x86) <ad5gb@yahoo.com> (Randall DuCharme)
+
+SCO UnixWare 7.1.1 (x86) <ad5gb@yahoo.com> (Randall DuCharme)
+
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/makediffs.sh gcc-4.0.2/gcc/bounds/makediffs.sh
--- gcc-4.0.2.org/gcc/bounds/makediffs.sh	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/makediffs.sh	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,141 @@
+:
+# makediffs.sh -- create a patch set
+#	This script expects that you are in a directory tree containing
+#	a bounds checked version of egcs with a root starting "begcs"
+#	and a parallel tree containing an unmodified egcs.
+#	For example,
+#		/home/gnu/egcs-yyyymmdd = unmodified egcs
+#		/home/gnu/begcs-yyyymmdd = bounds-checking egcs
+#		You are somewhere under /home/gnu/begcs-yyyymmdd
+#	The script will make a set of patches to capture the bounds checker.
+#
+# 13Jan00 wb initial version
+# 25Jan00 wb reject objc-parse.c (built from .y)
+# 29Mar00 wb reject cexp.c (built from .y)
+# 18May00 wb reject parse.[ch] (built, except for the ones in gcc/ch)
+# 31May00 wb reject c-parse.h (built from .c built from .in)
+# 05Jun00 wb reject configure, change diff from -x pattern to -X file
+# 17Jul00 wb reject objc-parse.y, parse-scan.c and tradcif.c
+# 25Oct01 wb reject tm.h
+# 05Jun02 wb reject core, a.out, general-test, *.o
+# 16Oct02 wb check libstdc++-v3, set LC_COLLATE for C
+
+# set -x
+
+# diff options;
+#	-r = scan directories recursively
+#	-N = treat new files as empty to the diffs include the contents of
+#		new files instead of just noting that they are in one directory
+#		but not the other
+#	-U # = unified diffs (for compactness) with # lines before and after
+#		Most files have only a few difference sections, so increasing
+#		# from the default of 2 has little effect on the total size
+#		while providing more context (to both you and patch) when
+#		run against different versions of egcs or gcc.
+#		I think it is better to have 'hunks' fail than for patch to
+#		update the wrong lines.
+#	-x PAT = exclude files matching pattern PAT
+
+# Search for gnu-diff
+
+DIFF=
+for name in /usr/local/bin/gdiff /usr/local/bin/diff
+do
+	if [ -x "$name" ] ; then DIFF="$name" ; break ; fi
+done
+
+if [ -z "$DIFF" ] ; then DIFF=diff ; fi
+
+# Sort in C order
+
+LC_COLLATE=C
+export LC_COLLATE
+
+# Find a starting directory
+
+begcs_root=
+
+name=`pwd`
+
+case "$name" in
+*/begcs-*)
+	begcs_root=`echo $name | sed -e 's/\(.*\/begcs-[^/]*\).*/\1/'`
+	;;
+*/bgcc-*)
+	begcs_root=`echo $name | sed -e 's/\(.*\/bgcc-[^/]*\).*/\1/'`
+	;;
+*)
+	echo "$0: Error: $name does not contain a begcs name segment"
+	exit
+	;;
+esac
+
+gnu_root=`dirname $begcs_root`
+begcs_dir=`basename $begcs_root`
+egcs_dir=`echo $begcs_dir | sed -e 's/^b//'`
+egcs_root="$gnu_root/$egcs_dir"
+
+ok=no
+
+if [ -z "$begcs_root" ]
+then
+	echo "$0: Error: could not find a begcs root in ${name}."
+elif [ ! -d "$begcs_root" ]
+then
+	echo "$0: Error: root $begcs_root derived from $name is not a directory."
+elif [ ! -d "$begcs_root/gcc/bounds" ]
+then
+	echo "$0: Error: directory $begcs_root/gcc/bounds not found."
+elif [ -z "$gnu_root" ]
+then
+	echo "$0: Error: could not find root in ${begcs_root}."
+elif [ ! -d "$gnu_root" ]
+then
+	echo "$0: Error: root $gnu_root in ${begcs_root} is not a directory."
+elif [ ! -d "$egcs_root" ]
+then
+	echo "$0: Error: original egcs $egcs_root not found."
+elif [ ! -d "$egcs_root/gcc" ]
+then
+	echo "$0: Error: original egcs $egcs_root/gcc not found."
+else
+	ok=yes
+fi
+
+if [ "$ok" != yes ]
+then
+	exit
+fi
+
+# Make the patch file
+
+cd "$gnu_root"
+
+patch_file="${gnu_root}/${egcs_dir}-${begcs_dir}.pat"
+if [ -f "$patch_file" ]
+then
+	mv "$patch_file" "${patch_file}-"
+fi
+if [ -f "$patch_file" ]
+then
+	echo "$0: Patch file $patch_file already exists."
+	exit
+fi
+
+set -x
+
+#	-x 'c-parse.[chy]*' -x 'objc-parse.c' -x 'parse.[ch]' \
+#	-x 'cexp.c' \
+#	-x 'configure' \
+#	-x '*.rej' -x '*-' -x '*~' -x 'junk*'
+
+touch "$patch_file"
+
+for dir in gcc libstdc++-v3
+do
+	$DIFF -rN -U 8 \
+		-X "$begcs_dir/gcc/bounds/diffexclude.dat" \
+		"$egcs_dir/$dir" "$begcs_dir/$dir" >> "$patch_file"
+done
+
+ls -l "$patch_file"
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/make_patch gcc-4.0.2/gcc/bounds/make_patch
--- gcc-4.0.2.org/gcc/bounds/make_patch	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/make_patch	2005-09-29 17:50:55.000000000 +0200
@@ -0,0 +1,9 @@
+#! /bin/sh
+
+REL=gcc-4.0.2
+(
+ cat $REL/gcc/bounds/README
+ diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' \
+	    -x 'parse.[ch]' -x '*.info*' \
+		$REL.org $REL
+) > bounds_patch_$REL
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/make.sh gcc-4.0.2/gcc/bounds/make.sh
--- gcc-4.0.2.org/gcc/bounds/make.sh	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/make.sh	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,415 @@
+:
+# make.sh -- build gcc/egcs
+#
+#	Passes options to the make
+#	no options = "bootstrap"
+#	use "all" to build all languages
+#
+# 02Jun00 wb initial version, only tested under SuSE Linux 6.2
+# 05Jun00 wb add more comments, add -bgcc to build with bounds checking
+# 06Jun00 wb update to configure for C only
+# 19Jul00 wb do not touch objc/objc-parse.y if it does not exist
+# 13Aug01 wb add Linux release to the objdir name
+# 03Sep01 wb update for FreeBSD
+# 05Jun02 wb added -with-gnu option, do --disable-multilib on old Suns
+
+#	Remove extra environment symbols
+
+dir=`dirname $0`
+if [ -f "$dir/unsetall.sh" ] ; then . $dir/unsetall.sh
+elif [ -f "$HOME/bin/unsetall.sh" ] ; then . $HOME/bin/unsetall.sh
+fi
+
+#	Find out where we are
+
+pwd=`pwd`
+program="`basename $pwd`"
+uname_s="`uname -s`"
+uname_n="`uname -n`"
+uname_r="`uname -r`"
+uname_m="`uname -m`"
+
+#	Parse the command line
+
+cpu=i686
+cc=
+cflags=
+mflags=
+langvar=
+cross=
+coff=
+as=
+config_flags=
+nice="nice nice"
+with_gnu=
+
+case "$program" in
+*egcs*)	opt=no ;;
+*)	opt=yes ;;
+esac
+
+case "$program" in
+*egcs*|*gcc*) echo "Building $program" ;;
+*)	echo "$0: Error: $pwd is not an egcs or gcc directory" ; exit 1 ;;
+esac
+
+while [ ! -z "$1" ]
+do
+	done=no
+
+	case "$1" in
+	-O0)	opt=no ;;			# No optimization
+	-Od)	opt=def ;;			# Default optimization
+	-Oy)	opt=yes ;;			# Enable optimization
+	-g)	cflags="$cflags -g" ;;		# Add symbol tables
+	-6)	cpu=i686 ;;			# Force 686 on SCO Unix
+	-5)	cpu=i586 ;;			# Force 586 on SCO Unix
+	-4)	cpu=i486 ;;			# Force 486 on SCO Unix
+	-gcc)	cc=gcc ;;			# Build with gcc
+	-bgcc)	cc=bgcc ;;			# Build with bgcc
+	-cc)	cc=cc ;;			# Build with cc
+	-rcc)	cc=rcc ;;			# Build with SCO rcc
+	-cross)	cross=yes ;;			# Test SCO cross-compile
+	-coff)	coff=yes ;;			# Build with COFF on SCO v5
+	-langc)	langvar="LANGUAGES='c'"		# Build C compiler only
+		config_flags="$config_flags --enable-languages=c" ;;
+	-j2)	mflags="$mflags -j 2" ;;	# Make with 2 jobs
+	-gas)	as=gas ;;			# Force gnu-as
+	-with-gnu|-gnu) with_gnu=yes ;;		# Force gnu-as and gnu-ld
+	-x)	set -x ;;			# Enable shell debugging
+	--)	shift ; done=yes ;;		# Pass remaining args to make
+	-*)	echo "$0: Unknown option $1" ;;	# Warning message
+	*)	done=yes ;;			# Found make target
+	esac
+
+	if [ "$done" = yes ]
+	then
+		break
+	fi
+
+	shift
+done
+
+#	Do a bootstrap if no arguments
+
+if [ -z "$*" ]
+then
+	set -- bootstrap
+fi
+
+#	Locate make
+
+make=make
+if [ -x /usr/local/bin/gmake ]
+then
+	make=/usr/local/bin/gmake
+fi
+
+#	Set the object directory and build flags
+
+objdir=objdir
+
+case "${uname_n}-${uname_s}" in
+*-SCO_SV)
+	if [ -z "$cc" ] ; then cc=cc ; fi
+	objdir="${objdir}v5"
+	;;
+*-Linux)
+	if [ -z "$cc" ] ; then cc=gcc ; fi
+	objdir="${objdir}lin"
+	case "$uname_r" in
+	[0-9].[0-9]*)	objdir="$objdir`echo $uname_r | awk -F . '{ print $1.$2 }'`"
+	esac
+	cflags="$cflags -pipe"
+	;;
+*-FreeBSD)
+	if [ -z "$cc" ] ; then cc=gcc ; fi
+	cflags="$cflags -pipe"
+	;;
+*-SunOS)
+	if [ -z "$cc" ]
+	then
+		if [ -x /usr/local/bin/gcc -o -x /usr/bin/gcc ]
+		then
+			cc=gcc
+		else
+			cc=cc
+		fi
+	fi
+	case "$cc" in
+	*gcc*)
+		if [ -x /usr/local/bin/as ]
+		then
+			cflags="$cflags -pipe"
+		fi
+		;;
+	esac
+	case "$uname_m" in
+	sun4c)
+		# disable-multilib is required on 32-bit Solaris builds
+		config_flags="$config_flags --disable-multilib"
+		;;
+	esac
+	;;
+*)
+	if [ -z "$cc" ]
+	then
+		if [ -x /usr/local/bin/gcc -o -x /usr/bin/gcc ]
+		then
+			cc=gcc
+		else
+			cc=cc
+		fi
+	fi
+	case "$cc" in
+	*gcc*)
+		if [ -x /usr/local/bin/as ]
+		then
+			cflags="$cflags -pipe"
+		fi
+		;;
+	esac
+	#	Check for sco 3.2v4 which has limited environment space
+	if [ "$uname_n" = "$uname_s" ]
+	then
+		mflags="$mflags -e"
+		echo "If this fails, try expmake.sh and rerun with make -e"
+	fi
+	;;
+esac
+
+case "$cc" in
+*bgcc*)	objdir="${objdir}bgcc" ;;
+*gcc*)	objdir="${objdir}gcc" ;;
+*rcc)	objdir="${objdir}rcc" ;;
+esac
+
+#	Check for sco 3.2v4, the configuration sometimes guesses wrong
+
+if [ "$uname_n" = "$uname_s" ]
+then
+	name="$cpu-pc-sco3.2v4.0"
+	config_flags="$config_flags --build=$name --host=$name --target=$name --verbose"
+fi
+
+#	Try to build a sco 3.2v4 cross-compiler hosted on sco v5
+
+if [ "$cross" = yes ]
+then
+	name="$cpu-pc-sco3.2v4.0"
+	config_flags="$config_flags --build=$cpu-pc-sco3.2v5.0.5 --host=$name --target=$name --verbose"
+	objdir="${objdir}x"
+fi
+
+#	Try to build a sco v5 compiler that generates coff instead of elf
+
+if [ "$coff" = yes ]
+then
+	if [ "$cc" = gcc ]
+	then
+		cflags="$cflags -mcoff"		# coff option for gcc
+		objdir="${objdir}gc"
+	else
+		cflags="$cflags -b coff"	# coff option for sco cc
+		objdir="${objdir}sc"
+	fi
+fi
+
+#	Locate the assembler
+
+case "$as" in
+*gas)
+	objdir="${objdir}gas"
+	config_flags="$config_flags --with-gnu-as"
+	if [ "$as" = gas -a \
+		-x /usr/local/bin/as -a \
+		! -x /usr/local/bin/gas ]
+	then
+		as=/usr/local/bin/as
+	fi
+	;;
+esac
+
+if [ "$with_gnu" = yes -a -z "$as" ]
+then
+	gas=/usr/local/bin/as
+	if [ -x "$gas" ]
+	then
+		as="$gas"
+		config_flags="$config_flags --with-gnu-as --with-as=$as"
+	fi
+	unset gas
+fi
+
+if [ -z "$as" ]
+then
+	as=as
+fi
+
+for dir in /usr/local/bin /bin /usr/bin
+do
+	if [ -x "$dir/$as" ]
+	then
+		as="$dir/$as"
+		break
+	fi
+done
+
+#	Check for the gnu linker
+
+if [ "$with_gnu" = yes ]
+then
+	gld=/usr/local/bin/ld
+	if [ -x "$gld" ]
+	then
+		config_flags="$config_flags --with-gnu-ld --with-ld=$gld"
+	fi
+	unset gld
+fi
+
+#	Check for a configure script
+
+if [ ! -f configure ]
+then
+	echo "$0: Error: Not the egcs root directory"
+	exit 1
+fi
+
+#	Check to touch input files after applying bounds checking patches
+#	Check to make extra scripts executable
+
+if [ -d gcc/bounds ]
+then
+	chmod +x gcc/bounds/bgcc gcc/bounds/*.sh
+
+	if [ ! -d "$objdir" -o ! -f "$objdir/Makefile" ]
+	then
+		for name in gcc/c-parse.in gcc/objc/objc-parse.y
+		do
+			if [ -f "$name" ]
+			then
+				echo "Touching $name"
+				touch "$name"
+			fi
+		done
+	fi
+fi
+
+#	Check for the object directory
+
+if [ -d "$objdir" ]
+then
+	echo "$0: Warning: objdir $objdir exists"
+else
+	mkdir "$objdir"
+fi
+
+if [ ! -d "$objdir" ]
+then
+	echo "$0: objdir $objdir does not exist"
+	exit 1
+fi
+
+#	Add shell tracing
+
+set -x
+
+#	Move to the work area
+
+cd "$objdir"
+
+#	Set more flags
+#		The GCC installation notes used to recommend
+#		setting -fno-implicit-templates
+
+case "$cc" in
+*bgcc*)
+	# Turn off the welcome message, it can mess things up that see stderr
+	GCC_BOUNDS_OPTS="$GCC_BOUNDS_OPTS -no-message"
+	# Turn off the statistics message, it can mess things up that see stderr
+	GCC_BOUNDS_OPTS="$GCC_BOUNDS_OPTS -no-statistics"
+	# Continue after bad accesses
+	GCC_BOUNDS_OPTS="$GCC_BOUNDS_OPTS -never-fatal"
+	export GCC_BOUNDS_OPTS
+	;;
+esac
+
+case "$cc" in
+*egcs*|*gcc*)
+	case "$opt" in
+	no)
+		cflags="-O0 $cflags"
+		libcflags="-O0 $libcflags"
+		libcxxflags="-O0 -fno-implicit-templates $libcxxflags"
+		;;
+	yes)
+		cflags="-O $cflags"
+		libcflags="-O2 $libcflags"
+		libcxxflags="-O2 -fno-implicit-templates $libcxxflags"
+		;;
+	*)
+		cflags="$cflags"
+		libcflags="$libcflags"
+		libcxxflags="-fno-implicit-templates $libcxxflags"
+		;;
+	esac
+esac
+
+echo "CC     is $cc"
+echo "CFLAGS is $cflags"
+
+#	Run configure
+
+echo ; beep ; date
+
+if [ -f "Makefile" ]
+then
+	echo "Makefile exists, remove $objdir for a clean build"
+elif [ ! -f "$pwd/configure" ]
+then
+	echo "$pwd/configure not found"
+else
+	echo "Running $pwd/configure $config_flags at `date`"
+
+	CC="$cc" \
+		CFLAGS="$cflags" \
+		LIBCFLAGS="$libcflags" \
+		LIBCXXFLAGS="$libcxxflags" \
+		AS="$as" \
+		$pwd/configure $config_flags
+fi
+
+#	Check that configure made a Makefile
+
+if [ ! -f Makefile ]
+then
+	echo
+	echo "no Makefile"
+	beep
+else
+	echo ; echo "Running $make $mflags $* in $objdir at `date`" ; echo
+	$nice $make $mflags \
+		CC="$cc" \
+		CFLAGS="$cflags" \
+		LIBCFLAGS="$libcflags" \
+		LIBCXXFLAGS="$libcxxflags" \
+		AS="$as" \
+		$langvar \
+		"$@"
+fi
+
+#	Write a message and send mail
+
+message="Finished $make $* for $program on $uname_n at `date`"
+
+echo "${message}"
+
+if [ -z "$LOGNAME" ]
+then
+	LOGNAME=`logname`
+fi
+
+if [ ! -z "$LOGNAME" ]
+then
+	echo "$message" | mail -s "$make $* for $program on $uname_n" "$LOGNAME"
+fi
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/mem-check.html gcc-4.0.2/gcc/bounds/mem-check.html
--- gcc-4.0.2.org/gcc/bounds/mem-check.html	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/mem-check.html	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,390 @@
+<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
+<html>
+  <head>
+    <title>A Memory Checking Framework</title>
+  </head>
+
+  <body>
+    <h1>A Memory Checking Framework</h1>
+
+<h2>Per Bothner</h2>
+<code>bothner@cygnus.com</code><br>
+January, 1999
+
+<h1>Goals</h1>
+<ul>
+<li> Should catch index-out-of-bounds errors in C and C++.
+<li> Should catch reading uninitialized memory.
+<li> Should catch reading or writing free'd memory.
+<li> Should work for heap, stack, or static memory.
+<li> Should provide programmer hooks to register memory blocks, so
+(for example) applications that use obstacks can catch errors in obstack usage.
+<li> Should not require re-compiling an entire application.
+You should be able to re-compile only the parts of the application
+you care about.
+<li> Should not violate known patents and copyrights.
+</ul>
+
+<h1>Introduction</h1>
+
+<p>
+The basic idea is that the run-time system must maintain a "memory map".
+This is a table of "chunk descriptors", where each chunk is a range
+of memory addresses.
+Because of the need to monitor out-of-bounds errors in non-malloc'd memory, 
+the chunk descriptors have to be separate from the data structures maintained
+by malloc.</p>
+<p>The other basic idea is that we modify the compiler so each pointer
+operation is validated against the memory map.  To do that we have
+to find the chunk descriptor for the memory containing the pointer.</p>
+<p>
+The most efficient way to map from a pointer to  chunk descriptors
+is to always carry the address
+of the chunk descriptor with the pointer value.  That is to use a
+"fat pointer", which is a pair of the actual pointer, and the
+descriptor for the chunk it points into.  The problem is that using
+a fat pointer instead of a regular pointer violates binary compatibility,
+which means all the libraries have to be recompiled.
+This is a major hassle, and impractical for many projects.
+There are also problems with sizeof and unions if pointer suddenly
+becomes twice as big.</p>
+<p>
+Therefore, pointer arguments and return values, and pointers in data
+structures (arrays, structs and unions), have to be normal "thin" pointer.
+However, we can use fat pointers for pointers stored in local variables,
+and that can be a major performance boost.</p>
+
+<h1>Basic types and operations</h1>
+
+<pre>
+/* A chunk descriptor. */
+typedef struct chunk {
+  void *start;  /* Start address of chunk. */
+  void *end;  /* End address of chunk. */
+  .... /* More later */
+} chunk_t;
+
+/* Create a new chunk descriptor for a chunk of memory. */
+chunk_t *
+add_chunk (void *start, void *end)
+{
+  chunk_t *chunk = allocate_chunk ();
+  chunk->start = start;
+  chunk->end = end;
+  link chunk into global memory map;
+  return chunk;
+}
+
+void
+remove_chunk (chunk_t *chunk)
+{
+  unlink chunk from global memory map;
+  de_allocate_chunk (chunk);
+}
+
+/* Dummy chunk representing memory not managed by any chunk descriptor. */
+struct chunk missing_chunk = { (void*) 0, (void *) 0xFFFFFFFF, ... };
+
+chunk_t *
+find_chunk (void *ptr)
+{
+  find a chunk containing ptr,
+  if there is none, return &missing_chunk.
+}
+
+/* Dummy chunk used to indicate we need to call find_chunk. */
+struct chunk unknown_chunk = { (void*) 1, (void *) 0, ... };
+#define UNKNOWN_CHUNK &unknown_chunk
+
+chunk_t *
+find_chunk_if_needed (void *ptr, chunk_t* chunk)
+{
+  return chunk == UNKNOWN_CHUNK ? find_chunk (ptr) : chunk;
+}
+
+</pre>
+
+<h1>ABI compatibility</h1>
+
+<p> Because we need to be able to link with libraries and .o files that
+are not compiled with memory-checking enabled, pointers must be regular
+pointer - we cannot use "fat" pointers (aka descriptors).
+
+<h1>Reading uninitialized memory</h1>
+
+<p> We want to catch reading uninitialized memory.  We do this by
+optionally associating a bitmap with each chunk:</p>
+<pre>
+typedef char* initialized_map_t;
+typedef struct chunk {
+  ....
+  initialized_map_t initialized_map;
+} chunk_t;
+
+#define IS_INITIALIZED(MAP, INDEX) (MAP[INDEX/8] & (1 << (INDEX % 8)))
+#define SET_INITIALIZED(MAP, INDEX) ((MAP[INDEX/8]) |= (1 << (INDEX % 8)))
+
+/* Check that SIZE bytes starting at PTR are all initialized.
+   Assume the whole region lies within CHUNK. */
+
+void
+check_initialized (void *ptr, int size, chunk_t* chunk)
+{
+  int index = (char*) ptr - (char*) chunk->start;
+  /* Of course this loop should be optimized. */
+  while (--index >= 0)
+    if (! IS_INITIALIZED (chunk->initialized_map, index)
+      SIGNAL_ERROR():
+}
+
+/* Note that SIZE bytes starting at PTR are all initialized.
+   Assume the whole region lies within CHUNK. */
+
+void
+set_initialized (void *ptr, int size, chunk_t* chunk)
+{
+  int index = (char*) ptr - (char*) chunk->start;
+  /* Of course this loop should be optimized. */
+  while (--index >= 0)
+    SET_INITIALIZED (chunk->initialized_map, index);
+}
+</pre>
+<p>
+We can only catch reads of uninitialized memory if all writes to
+memory we are monitoring has calls to <code>set_initialized</code>;
+otherwise we will get a lot of false errors.  We make the rule
+that if a chunk's <code>initialized_map</code> field is <code>NULL</code>,
+then we should not check for initialization on reads from the chunk.
+We also provide two global variables that the programmer can use
+to control this test:</p>
+<pre>
+/* Control whether an initialized_map is created for new chunks.  A map
+   is only created by add_chunk if alloc_with_initialization_map is true. */
+int alloc_with_initialization_map = 0;
+
+/* set_initialized is only called when do_check_initialization is true. */
+int do_check_initialization = 0;
+</pre>
+
+<h1>Guarding heap memory</h1>
+
+<p> The standard function <code>malloc</code> is replaced by:
+<pre>
+void *
+malloc (size_t size)
+{
+  void *ptr = __primitive_malloc (size);
+  chunk_t *chunk = add_chunk (ptr, (char*) ptr + size);
+  /* Some extra one-bit flag in a chunk. */
+  chunk->allocated_by_malloc = 1;
+  return ptr;
+}
+</pre>
+<p>
+It is useful if <code>malloc</code> would also also save the call stack
+with the chunk;  this is desirable for possible future error messages.</p>
+
+<p>
+The <code>free</code> function is obvious:</p>
+<pre>
+void
+free (void *ptr)
+{
+  chunk_t *chunk = find_chunk (ptr);
+  if (chunk == &missing_chunk || chunk->start != ptr
+      || ! chunk->allocated_by_malloc)
+    SIGNAL_ERROR();
+  __primitive_free(ptr);
+  remove_chunk (chunk);
+}
+</pre>
+<p>
+It would be useful to provide alternative entry-points to these functions,
+but which returned/took a pair of a data pointer and a chunk pointer.</p>
+<p>
+We can optimize <code>calloc</code> since it does not need an
+<code>initialized_map</code>.</p>
+<p>
+We can catch accesses to deleted memory by not actually deleting
+the memory or the chunk, but instead setting a "deleted" flag in the chunk.
+We would want to give the programmer so control over which
+free'd chunks are kept around, and for how long.</p>
+
+<h1>Guarding global variables</h1>
+
+<p>
+The compiler can easily add code that is run at program start-up
+that calls <code>add-chunk</code> for each global variable.
+With some linker support, it does not even have to generate any code.
+Instead, it just has to mark the limits of each variable in the
+object file, and then have the linker set up the initial set of chunks.</p>
+<p>
+A global variable whose address is never taken (and which does not
+contain an component whose address is taken) does not need a chunk.</p>
+<p>
+We do not need to create <code>initialized_map</code>'s for global variables,
+these are by C/C++ language definition initialized (to zero).</p>
+
+<h1>Guarding stack variables</h1>
+<p>
+Guarding stack variables is in principle straight-forward.
+We just do <code>add_chunk</code> when the variable's scope
+is enteered, and <code>remove_chunk</code> when the scope
+is exited.  The tricky part is the later, since we have to
+do <code>remove_chunk</code> also when unwinding the stack
+due to exceptions or <code>longjmp</code>.  If that is impractical,
+we can do <code>remove_chunk</code> lazily:  Remove any chunks
+beyond the stack pointer before we do a stack-related
+<code>add_chunk</code> or signal an error.</p>
+<p>
+We only need chunks for variables whose address is taken,
+or that we want to check for initialization.</p>
+
+<h1>Translated pointer operations</h1>
+
+<p>
+Each local pointer variable <code>P</code> is augmented
+by a second variable <code>P$chunk</code>, which points to a chunk
+pointed to be <code>P</code>.  We maintain this invariant:</p>
+<pre>
+P$chunk == UNKNOWN_CHUNK || P$chunk == find_chunk(P)
+</pre>
+
+<h2>Taking address of pointer</h2>
+<p> If <code>P</code> is a local pointer variable, then `<code>&P</code>'
+is translated into `<code>(P$chunk = &UNKNOWN_CHUNK, &P)</code>'.</p>
+<p> Taking the address of some other pointer-valued lvalue
+is translated as is.</p>
+
+<h2>Assigning to pointer</h2>
+<p> If <code>P1</code> and <code>P2</code> are local pointer variables,
+then `<samp>P1 = P2</samp>' is translated into
+`<samp>P1$chunk = P2$chunk, P1=P2</samp>'.</p>
+<p> In general, if <code>P</code> is a local pointer variable,
+and <code>X</code> is a pointer-valued expression, then `<code>P = X</code>'
+is translated into `<code>P$chunk = UNKNOWN_CHUNK, P = X</code>'.
+However, if we know (or can cheaply compute) the chunk containing
+the value of `<code>X</code>', the we can set <code>P$chunk</code>
+to that known chunk instead.</p>
+<p> Assigning to other pointer-valued lvalues is translated as is.</p>
+
+<h2>Incrementing or decrementing a pointer</h2>
+
+<p> If <code>P</code> is a local pointer variable, then the
+operation `<code>P + NUM</code>' is translated into:</p>
+<pre>
+P$chunk = find_chunk_if_needed (P, P$chunk),
+check_pointer_increment (P, P$chunk, NUM * sizeof(*P))m
+P + NUM;
+</pre>
+<p>where <code>check_pointer_increment</code>
+is <a href="#check_pointer_increment">below</a>.</p>
+
+<p> If <code>X</code> is a pointer-valued expression (with no side-effects),
+then the operation `<code>X + NUM</code>' is translated into:</p>
+<pre>
+(check_pointer_increment (X, find_chunk(X), NUM * sizeof(*X)),
+X + NUM)
+</pre>
+<p> The case where <code>X</code> has side-effects, as well as the
+pre- and post- decrement and increment unary operations,
+are handled in the obvious manner.</p>
+
+<h2>De-referencing a pointer</h2>
+
+<p> If <code>P</code> is a local pointer variable, then the
+operation `<code>*P</code>' (as an rvalue) is translated into:</p>
+<pre>
+(P$chunk = find_chunk_if_needed (P, P$chunk),
+check_pointer_read (P, sizeof(*P), P$chunk),
+*P)
+</pre>
+<p>where <code>check_pointer_read</code>
+is <a href="#check_pointer_read">below</a>.</p>
+
+<p> If <code>X</code> is a pointer-valued lvalue (with no side-effects),
+then the operation `<code>*X</code>' (as an rvalue) is translated into:</p>
+<pre>
+(check_pointer_read (X, sizeof(*X), find_chunk(X)),
+*X)
+</pre>
+
+<p> When <code>X</code> is a pointer-valued expression, but not
+a local variable, the expression `<code>X[N]</code>' can be
+translated into:</p>
+<pre>
+(check_pointer_read (X+N, sizeof(*X), find_chunk(X)),
+X[N])
+</pre>
+	  
+
+<p> If `<code>*P</code>' or `<code>*X</code>' is used as an LHS value,
+the translation uses <code>check_pointer_write</code>
+instead of <code>check_pointer_read</code>.</p>
+
+<h1>Unions and casts</h1>
+
+<h1>Finer-grained checking:  Obstacks</h1>
+
+<h1>Code</h1>
+<pre>
+<a name="check_pointer_increment"></a>
+/* Signal an error if adjusting PTR by DELTA will bring it outside CHUNK. */
+
+void
+check_pointer_increment (void *ptr, chunk_t *chunk, int delta)
+{
+  if (delta == 0)
+    return;
+  if (ptr == NULL)
+    SIGNAL_ERROR();
+  if (chunk != &missing_chunk)
+     {
+       if (ptr < chunk->start || ptr > chunk->end) /* Usually redundant */
+	 SIGNAL_ERROR();
+       if ((char*) ptr + delta < chunk->start
+           || (char*) ptr + delta > chunk->end)
+	 SIGNAL_ERROR();
+     }
+}
+
+void
+check_pointer_write (void *ptr, int size, chunk_t *chunk)
+{
+  if (ptr == NULL)
+    SIGNAL_ERROR();
+  if (chunk != &missing_chunk)
+     {
+       if (ptr < chunk->start || ptr > chunk->end
+           || (char*) ptr + size < chunk->start
+           || (char*) ptr + size > chunk->end)
+	 SIGNAL_ERROR();
+       if (chunk->initialized_map != NULL)
+         set_initialized (ptr, size, chunk);
+     }
+}
+
+void
+check_pointer_read (void *ptr, int size, chunk_t *chunk)
+{
+  if (ptr == NULL)
+    SIGNAL_ERROR();
+  if (chunk != &missing_chunk)
+     {
+       if (ptr < chunk->start || ptr > chunk->end
+           || (char*) ptr + size < chunk->start
+           || (char*) ptr + size > chunk->end)
+	 SIGNAL_ERROR();
+       if (chunk->initialized_map != NULL && do_check_initialization)
+         check_initialized (ptr, size, chunk);
+     }
+}
+</pre>
+    <hr>
+    <address><a href="mailto:bothner@cygnus.com">Per Bothner</a></address>
+<!-- Created: Mon Jan  4 15:36:00 PST 1999 -->
+<!-- hhmts start -->
+Last modified: Mon Apr 26 12:15:39 PDT 1999
+<!-- hhmts end -->
+  </body>
+</html>
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/misc/notes-for-AIX-users/Notes-0 gcc-4.0.2/gcc/bounds/misc/notes-for-AIX-users/Notes-0
--- gcc-4.0.2.org/gcc/bounds/misc/notes-for-AIX-users/Notes-0	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/misc/notes-for-AIX-users/Notes-0	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,14 @@
+
+Problems with AIX:
+
+It appears that the dynamic libraries on AIX are shared between processes
+in memory, in such a way that we could not replace the `malloc' in libc
+with our own version in the checking library. Using static linking
+cured this problem, and Jorg Petersen has written some notes (see next
+file) to help you use bounds checking with AIX.
+
+If someone would care to tell us exactly what's going on here with dynamic
+libraries and how to fix it, then we will patch the program to make it
+work `properly'.
+
+RWMJ, JP, Sept. 1995.
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/misc/notes-for-AIX-users/Notes-3 gcc-4.0.2/gcc/bounds/misc/notes-for-AIX-users/Notes-3
--- gcc-4.0.2.org/gcc/bounds/misc/notes-for-AIX-users/Notes-3	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/misc/notes-for-AIX-users/Notes-3	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,53 @@
+HOWTO USE BOUNDS-CHECKING WITH AIX-3.2.5
+
+Simple programs may be checked by typing:
+
+        gcc -g -fbounds-checking myfile.c -o myprog -lm
+
+Anyhow, there a problems with some libraries like e.g. libX11.a
+By default libX11.a is a shared library, and due to the special
+behaviour of AIX it always uses the unchecked "malloc"-routines
+from libc.a instead of those from ...../libcheck.a
+(this leads to a funny mixture of checked and unchecked mallocs...)
+
+Solution
+
+        gcc -g -c -fbounds-checking myfirst.c
+        gcc -g -c -fbounds-checking mysecond.c
+
+Normally you would type now: (which doesn't work with AIX)
+        gcc -fbounds-checking myfirst.o mysecond.o -o myprog -lX11 -lm
+
+Better link statically:
+        cc myfirst.o mysecond.o -o mystaticprog \
+         -L/usr/local/lib/gcc-lib/rs6000-ibm-aix3.2.5/2.7.0 -lcheck -lgcc \
+         -lIM -liconv -lX11 -lm \
+         -bnso -bloadmap:/tmp/loadmap \
+         -bI:/lib/syscalls.exp -bI:/usr/lpp/X11/bin/smt.exp
+
+  Because linking with 'cc' we have to explicitly say where
+  -lcheck and -lgcc are.
+  "-bnso -bI:/lib/syscalls.exp -bI:/usr/lpp/X11/bin/smt.exp" tell cc to
+  link statically and "-lIM -liconv" is needed by "-lX11" if linked statically.
+
+
+If you have a more recent AIX-3.2.5++ there might be a error message
+about an unresolved symbol 'pthread_yield'. In this case you have to
+add an additional -bI:./foo.imp to the last line
+         -bI:/lib/syscalls.exp -bI:/usr/lpp/X11/bin/smt.exp -bI:./foo.imp
+
+And create the file ./foo.imp containing two lines:
+#!
+pthread_yield
+
+This tells cc to resolve this symbol at runtime, not while statically
+linking. (Thanks to Mr. David L. Crow for this solution)
+
+Due to my lack of understanding AIX corrections, hints and explanations
+are always welcome...
+
+Joerg
+
+P.S.: A last AIX-tip: If you don't have gdb (GNU-debugger) and want
+	to use the dbx, you should say 'gcc -gxcoff3' insead 'gcc -g'
+
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/misc/README gcc-4.0.2/gcc/bounds/misc/README
--- gcc-4.0.2.org/gcc/bounds/misc/README	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/misc/README	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,12 @@
+Miscellaneous stuff here that might be of interest:
+
+tcl-7.4-patches/
+	Patches required to get Tcl 7.4 to built correctly. The changes are
+	mainly for the new rules for 'goto' and some bug fixes.
+tk-4.0-patches/
+	Patches required to get Tk 4.0 to work with bounds checking. I have
+	successfully built a shared library version of Tk 4.0 with bounds
+	checking under Linux.
+notes-for-AIX-users/
+	Contains notes that AIX users should read before starting to use
+	bounds checking.
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/misc/tcl-7.4-patches/tclBasic.c.cdiff gcc-4.0.2/gcc/bounds/misc/tcl-7.4-patches/tclBasic.c.cdiff
--- gcc-4.0.2.org/gcc/bounds/misc/tcl-7.4-patches/tclBasic.c.cdiff	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/misc/tcl-7.4-patches/tclBasic.c.cdiff	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,10 @@
+22a23,24
+> #include "unchecked.h"
+> 
+910c912,915
+< 		    argv[i] = pv.buffer + (argv[i] - oldBuffer);
+---
+> 		    argv[i] =
+> 		      BOUNDS_CHECKING_OFF_IN_EXPR (
+> 			pv.buffer + (argv[i] - oldBuffer)
+> 		      );
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/misc/tcl-7.4-patches/tclCmdMZ.c.cdiff gcc-4.0.2/gcc/bounds/misc/tcl-7.4-patches/tclCmdMZ.c.cdiff
--- gcc-4.0.2.org/gcc/bounds/misc/tcl-7.4-patches/tclCmdMZ.c.cdiff	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/misc/tcl-7.4-patches/tclCmdMZ.c.cdiff	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,16 @@
+830,831c830
+< 	switch (curField->fmt) {
+< 	    char string[TCL_DOUBLE_SPACE];
+---
+>         char string[TCL_DOUBLE_SPACE];
+832a832
+> 	switch (curField->fmt) {
+988d987
+<     register char *p;
+990a990,991
+>     char *trimChars;
+>     register char *p, *checkPtr;
+1159,1161d1159
+< 	char *trimChars;
+< 	register char *p, *checkPtr;
+< 
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/misc/tcl-7.4-patches/tclExpr.c.cdiff gcc-4.0.2/gcc/bounds/misc/tcl-7.4-patches/tclExpr.c.cdiff
--- gcc-4.0.2.org/gcc/bounds/misc/tcl-7.4-patches/tclExpr.c.cdiff	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/misc/tcl-7.4-patches/tclExpr.c.cdiff	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,8 @@
+1110c1110,1114
+< 			goto divideByZero;
+---
+> 			interp->result = "divide by zero";
+> 			Tcl_SetErrorCode(interp, "ARITH", "DIVZERO",
+> 				interp->result, (char *) NULL);
+> 			result = TCL_ERROR;
+> 			goto done;
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/misc/tcl-7.4-patches/tclInt.h.cdiff gcc-4.0.2/gcc/bounds/misc/tcl-7.4-patches/tclInt.h.cdiff
--- gcc-4.0.2.org/gcc/bounds/misc/tcl-7.4-patches/tclInt.h.cdiff	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/misc/tcl-7.4-patches/tclInt.h.cdiff	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,5 @@
+54a55,58
+> #ifdef __BOUNDS_CHECKING_ON
+> #include "fix-args.h"
+> #endif
+> 
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/misc/tcl-7.4-patches/tclParse.c.cdiff gcc-4.0.2/gcc/bounds/misc/tcl-7.4-patches/tclParse.c.cdiff
--- gcc-4.0.2.org/gcc/bounds/misc/tcl-7.4-patches/tclParse.c.cdiff	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/misc/tcl-7.4-patches/tclParse.c.cdiff	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,10 @@
+21a22,23
+> #include "unchecked.h"
+> 
+821c823,826
+< 		argv[i] = pvPtr->buffer + (argv[i] - oldBuffer);
+---
+> 		argv[i]
+> 		  = BOUNDS_CHECKING_OFF_IN_EXPR (
+> 		    pvPtr->buffer + (argv[i] - oldBuffer)
+> 		    );
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/misc/tcl-7.4-patches/Update gcc-4.0.2/gcc/bounds/misc/tcl-7.4-patches/Update
--- gcc-4.0.2.org/gcc/bounds/misc/tcl-7.4-patches/Update	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/misc/tcl-7.4-patches/Update	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,11 @@
+#!/bin/bash -
+
+( cd ~/tcl/tcl7.4 ; \
+mkcom "if cmp ~/tcl/tcl7.4/* ~/c/bc-tests/tcl7.4/* >/dev/null 2>&1 ; \
+	then echo -n; else echo *; fi" *.c *.h | \
+	/bin/bash ) \
+| \
+	( cd ~/gcc-2.7.2/bounds/misc/tcl-7.4-patches; \
+	rm -f *.cdiff; \
+	mkcom "diff ~/tcl/tcl7.4/* ~/c/bc-tests/tcl7.4/* > *.cdiff" | \
+	/bin/bash )
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/misc/tk-4.0-patches/tk3d.c.cdiff gcc-4.0.2/gcc/bounds/misc/tk-4.0-patches/tk3d.c.cdiff
--- gcc-4.0.2.org/gcc/bounds/misc/tk-4.0-patches/tk3d.c.cdiff	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/misc/tk-4.0-patches/tk3d.c.cdiff	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,14 @@
+18a19,20
+> #include <unchecked.h>
+> 
+237a240
+>     int half;
+251,252d253
+< 	int half;
+< 
+830c831,833
+<     for (i = -2, p1Ptr = &pointPtr[numPoints-2], p2Ptr = p1Ptr+1;
+---
+>     for (i = -2,
+> 	   p1Ptr = BOUNDS_CHECKING_OFF_IN_EXPR (&pointPtr[numPoints-2]),
+> 	   p2Ptr = p1Ptr+1;
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/misc/tk-4.0-patches/tkImgFmtGIF.c.cdiff gcc-4.0.2/gcc/bounds/misc/tk-4.0-patches/tkImgFmtGIF.c.cdiff
--- gcc-4.0.2.org/gcc/bounds/misc/tk-4.0-patches/tkImgFmtGIF.c.cdiff	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/misc/tk-4.0-patches/tkImgFmtGIF.c.cdiff	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,19 @@
+675,676c675,689
+< 		buf[0] = buf[last_byte-2];
+< 		buf[1] = buf[last_byte-1];
+---
+> 		/* RWMJ: This fails with bounds checking, since we try to
+> 		 * read element -2 of the array sometimes.
+> 		 */
+> 		if (last_byte >= 2)
+> 		  {
+> 		    buf[0] = buf[last_byte-2];
+> 		    buf[1] = buf[last_byte-1];
+> 		  }
+> 		else if (last_byte >= 1)
+> 		  {
+> 		    buf[0] = 0;
+> 		    buf[1] = buf[last_byte-1];
+> 		  }
+> 		else
+> 		  buf[0] = buf[1] = 0;
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/misc/tk-4.0-patches/tkTextBTree.c.cdiff gcc-4.0.2/gcc/bounds/misc/tk-4.0-patches/tkTextBTree.c.cdiff
--- gcc-4.0.2.org/gcc/bounds/misc/tk-4.0-patches/tkTextBTree.c.cdiff	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/misc/tk-4.0-patches/tkTextBTree.c.cdiff	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,8 @@
+105,108c105,106
+< #define CSEG_SIZE(chars) ((unsigned) (Tk_Offset(TkTextSegment, body) \
+< 	+ 1 + (chars)))
+< #define TSEG_SIZE ((unsigned) (Tk_Offset(TkTextSegment, body) \
+< 	+ sizeof(TkTextToggle)))
+---
+> #define CSEG_SIZE(chars) (sizeof (TkTextSegment) + 1 + (chars))
+> #define TSEG_SIZE sizeof (TkTextSegment)
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/misc/tk-4.0-patches/tkTextMark.c.cdiff gcc-4.0.2/gcc/bounds/misc/tk-4.0-patches/tkTextMark.c.cdiff
--- gcc-4.0.2.org/gcc/bounds/misc/tk-4.0-patches/tkTextMark.c.cdiff	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/misc/tk-4.0-patches/tkTextMark.c.cdiff	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,5 @@
+24,25c24
+< #define MSEG_SIZE ((unsigned) (Tk_Offset(TkTextSegment, body) \
+< 	+ sizeof(TkTextMark)))
+---
+> #define MSEG_SIZE sizeof(TkTextSegment)
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/misc/tk-4.0-patches/Update gcc-4.0.2/gcc/bounds/misc/tk-4.0-patches/Update
--- gcc-4.0.2.org/gcc/bounds/misc/tk-4.0-patches/Update	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/misc/tk-4.0-patches/Update	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,11 @@
+#!/bin/bash -
+
+( cd ~/tcl/tk4.0 ; \
+mkcom "if cmp ~/tcl/tk4.0/* ~/c/bc-tests/tk4.0/* >/dev/null 2>&1 ; \
+	then echo -n; else echo *; fi" *.c *.h | \
+	/bin/bash ) \
+| \
+	( cd ~/gcc-2.7.2/bounds/misc/tk-4.0-patches; \
+	rm -f *.cdiff; \
+	mkcom "diff ~/tcl/tk4.0/* ~/c/bc-tests/tk4.0/* > *.cdiff" | \
+	/bin/bash )
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/README gcc-4.0.2/gcc/bounds/README
--- gcc-4.0.2.org/gcc/bounds/README	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/README	2005-09-29 17:51:15.000000000 +0200
@@ -0,0 +1,159 @@
+Bounds Checking Patches for gcc-4.0.2
+--------------------------------------
+
+By Richard W.M. Jones <rjones@orchestream.com>
+
+What is bounds checking?
+------------------------
+
+These patches give very fine-grained bounds checking, catching errors in
+C programs like this one:
+
+	int i;
+	char array[10];
+
+	for (i = 0; i <= 10; ++i)
+	  array[i] = 0;
+
+(Notice element array[10] is not part of the array). The patches are
+compatible with almost all C constructs. For instance, the following
+programs have been successfully compiled with bounds checking:
+
+	Tcl 7.3 & 7.4
+	Tk 3.6 & 4.0
+	Ghostscript 262
+	uEmacs 3.10
+	xrn
+	GNU Grep 2.0
+	XBoing 1.8
+
+What files do you need?
+-----------------------
+
+You can install GCC with bounds checking either by compiling from the source.
+
+>> To compile from source, you need to retrieve:
+
+	bounds-checking-gcc-4.0.2-x.y.patch.bz2
+
+   *plus* the source for GCC (which you may already have).
+
+	gcc-4.0.2.tar.bz2
+
+   You will need around 500 Mbytes of free disk space.
+
+How to compile GCC with bounds checking from source
+----------------------------------------------------
+
+Let's suppose, for the sake of example, that you've already placed a *fresh*
+GCC source tree in `~/gcc-4.0.2'. Patch the tree as follows:
+
+	cd ~/gcc-4.0.2
+	bzip2 -cd bounds-checking-gcc-4.0.2-x.y.patch.bz2 | patch -p1 -s
+
+Compile GCC as detailed in the file `INSTALL' that comes with GCC. Usually
+you need to type something like:
+
+	cd ~/build_4.0.2_dir
+	~/gcc-4.0.2/configure --srcdir=~/gcc-4.0.2	# Possibly some --options here.
+	make BOOT_CFLAGS="-O2" STAGE1_CFLAGS="-O2" CFLAGS="-O2" bootstrap
+
+This also makes the bounds checking library (in the bounds/lib/ subdir.).
+You'll need `makeinfo' (from the `texinfo' package) to make the info pages.
+
+Compile programs with bounds checking
+-------------------------------------
+
+Once you've got the program compiled, use the `-fbounds-checking' flag
+to add bounds checking to your programs. Eg.
+
+	~/build_4.0.2_dir/gcc/xgcc -B~/build_4.0.2_dir/gcc/ -fbounds-checking -c file1.c -o file1.o
+	~/build_4.0.2_dir/gcc/xgcc -B~/build_4.0.2_dir/gcc/ -fbounds-checking file1.o -o program
+
+Notice that:
+  (1) I've assumed you have compiled/installed GCC in `~/build_4.0.2_dir'.
+  (2) You need to pass the `-B' option to tell GCC which directory you're
+      using. Note that the directory needs a trailing `/'.
+
+For Makefiles, you could add/change the following rules:
+
+	GCC_HOME = $(HOME)/build_4.0.2_dir/gcc
+	CC = $(GCC_HOME)/xgcc
+	CFLAGS = -B$(GCC_HOME)/ -fbounds-checking -g -Wall ..etc..
+
+Looking for information
+-----------------------
+
+The first place to look for information is the GCC info page. The relevant
+files are:
+
+	~/gcc-4.0.2/gcc/doc/gcc.info
+	~/gcc-4.0.2/gcc/doc/gcc.info-*
+
+You will need `emacs', `tkinfo' or similar, to read them. Go to `Bounds
+Checking' node.
+
+There is an old manual in PostScript form in the file:
+
+	~/gcc-4.0.2/gcc/bounds/report/bcrep2.ps.gz
+
+and the source for this (in M$-Word 6 format - yes, I know):
+
+	~/gcc-4.0.2/gcc/bounds/report/bcrep2.doc.gz
+
+Special cases for bounds checking
+---------------------------------
+
+Although bounds checking ought to be automatic, if you use one of the
+following constructs, you may need to change your program:
+
+    .   signal handlers
+        threads
+                Read the user manual. For signal handlers, you will need to
+                move the signal handlers into unchecked code. There are
+                hooks in the checking library for threads.
+    .   Using `-2' as a pointer.
+                You can't use `-2' as a special pointer representation (because
+                I use it). To fix this, either change your code to use, say,
+                -1, or change the definition of ILLEGAL in `bounds/lib/
+                bounds-lib.h'.
+
+Read the gcc.info file for more details.
+
+Bug reports
+-----------
+
+There are a few known bugs: read about them in
+
+	~/gcc-4.0.2/gcc/bounds/BUGS
+
+Please send bug reports & fixes to
+
+	rjones@orchestream.com or Haj.Ten.Brugge@net.HCC.nl
+
+Frequently asked questions
+--------------------------
+
+These are questions I've answered more than a hundred times already ...
+
+1.	No, it doesn't work with C++. But do you feel like giving up ~1-2
+	months of your time to implement it for me? If so, write soon.
+
+2.	When will the patches be integrated into GCC? I have no answer to
+	this. One day soon, when I feel that the software has been widely
+	tested and the bugs have been all but eliminated, I will apply to
+	have this happen. However, the GCC maintainers may have other ideas,
+	in which case the answer will be `never'.
+
+Related documents
+-----------------
+
+http://www-dse.doc.ic.ac.uk/~rj3/bounds-checking.html
+http://www-ala.doc.ic.ac.uk/~phjk/BoundsChecking.html
+http://www.inter.NL.net/hcc/Haj.Ten.Brugge
+
+Platforms
+---------
+
+See the file MACHINES in the distribution to see what machines GCC/BC has been
+ported to. It ought to work on just about any machine that GCC supports.
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/README.103 gcc-4.0.2/gcc/bounds/README.103
--- gcc-4.0.2.org/gcc/bounds/README.103	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/README.103	2005-09-29 17:51:23.000000000 +0200
@@ -0,0 +1,123 @@
+Bounds Checking Patches for GCC 4.0.2
+-------------------------------------
+
+Version: 1.03
+
+16Oct02
+
+I copied the gcc-3.1.1-1.01 bounds checking patches from
+http://www.inter.NL.net/hcc/Haj.Ten.Brugge
+This distribution is all patches made by the script makediffs.sh which runs
+  gdiff -ruN egcs-yyyymmdd/gcc begcs-yyyymmdd/gcc
+where egcs-yyyymmdd is an unmodified built version of gcc and
+begcs-yyyymmdd is a built version with the bounds checking patches.
+(For gcc versions, replace "egcs-yyyymmdd" with "gcc-#.#.#".)
+I have moved the PostScript of Richard Jones's papers from
+gcc/bounds/report to a separate archive "bounds-checking-reports.tar.bz2"
+to reduce the size of the patches.
+I used RedHat Linux 7.1 updated with a 2.4.9 kernel.
+I needed about 719 MB to build bgcc-4.0.2 under RH 7.1 on a Reiser file system:
+171 MB for the unpacked source and 548 MB for the generated objects
+(168 MB for the bgcc-3.1 generated objects with --enable-languages=c).
+The bounds checking patches should work any system that can build a normal gcc.
+
+OS-specific build notes:
+Most ELF platforms:
+  gcc 3.1: gcc 3.1 writes DWARF 2 debugging information and requires
+    gdb 5.1 or higher and binutils 2.10 or higher.
+    See INSTALL/specific.html for GCC Host/Target specific installation notes.
+RedHat Linux 8.0 / RedHat's gcc 4.0.2 20020903
+  bgcc 4.0.2: RedHat's libc is newer than gcc-4.0.2 expects and ctype is different.
+RedHat Linux 7.1 / RedHat's gcc 2.96 20000731
+  bgcc 3.1: When loading executables built with bounds checking,
+    RedHat's gdb 5.0rh-5 gets
+    "Dwarf Error: Cannot handle DW_FORM_strp in DWARF reader".
+    gdb-5.2 built from source works OK.
+RedHat Linux 6.0 / RedHat's egcs-2.91.66 19990314
+  bgcc 3.1: gcc 3.1 requires updating binutils and gdb.
+    I built binutils 2.12.1 and gdb 5.2 from source and forced the build
+    to use them with
+    --with-as=<path-to-GNU-as> --with-gnu-as --with-ld=<path-to-GNU-ld> --with-gnu-ld
+SCO OpenServer 5.0.5 / SCO cc
+  bgcc 4.0.2: The bgcc 4.0.2 patches include a fix for config.gcc
+    for the gcc "machmode.def: undefined symbol: BITS_PER_UNIT" error.
+    See http://gcc.gnu.org/cgi-bin/gnatsweb.pl?cmd=view%20audit-trail&database=gcc&pr=7623
+  The bgcc 4.0.2 build needs 428 MB (132 MB for source + 296 MB for objects).
+Solaris 2.6 / gcc 2.7.2.3 + binutils 2.9.1 from http://www.sunfreeware.com
+  bgcc 3.1: If you get an error about "libgcc.map: file format not recognized",
+    use make.sh with "-with-gnu" to force a ./configure with
+    --with-as=<path-to-GNU-as> --with-gnu-as --with-ld=<path-to-GNU-ld> --with-gnu-ld
+  The sunfreeware bison-1.50 fails on c-parse.y.  bison-1.28 is OK.
+  The bgcc 4.0.2 build needs 484 MB (140 MB for source + 343 MB for the objects).
+
+To build a bounds checking gcc:
+  cd /u/gnu					# go to a work area
+  tar xzf egcs-yyyymmdd.tar.gz			# unpack gcc
+  mv egcs-yyyymmdd begcs-yyyymmdd		# rename the egcs directory
+  cd begcs-yyyymmdd				# go to the begcs directory
+  patch -p1 -T < egcs-yyyymmdd-begcs-yyyymmdd.pat	# apply the patches
+  touch gcc/c-parse.in				# force a rebuild of .y and .c
+  mkdir objdir					# make an object file area
+  cd objdir					# enter the area
+  /u/gnu/begcs-yyyymmdd/configure		# initialize the build
+  make bootstrap				# do the build
+
+The patches change c-parse.in but do not include the generated .y or .c files.
+You must "touch" gcc/c-parse.in after applying the patches, and you will need
+yacc or bison.  gcc snapshots use bison-1.28.  The bison-1.25 on SuSE 6.2
+generates different tables than bison-1.28 and might cause problems.
+
+Many versions of gcc fail to bootstrap unless you set CFLAGS=-O0 to disable
+optimization.  This reflects gcc problems.  The bounds checking patches have
+no effect on the generated code unless you compile with "-fbounds-checking".
+
+The script gcc/bounds/make.sh does the touch command, configures with an
+object directory and does a make bootstrap.  You can run this script from
+the top level directory immediately after applying the patches.
+
+Building a C-only version of gcc takes less time and uses less disk space.
+Also, some gcc snapshots have problems with languages other than C.
+Since the bounds checker mainly does C, you can use
+  /u/gnu/begcs-yyyymmdd/configure --enable-languages=c
+or
+  ./gcc/bounds/make.sh -langc
+
+You can run your new begcs without installing it through the script
+  /u/gnu/begcs-yyyymmdd/gcc/bounds/bgcc
+If you build in a different area or copy the script, you will need
+to edit the initial sequence that locates the root directory.
+
+You can test the bounds checker with
+  cd /u/gnu/begcs-yyyymmdd/gcc/bounds/bgcc/tests
+  chmod +x ../bgcc
+  make CC=../bgcc
+All tests should return OK.
+
+If you want to experiment with changes, you can recompile your changes with
+  cd objdir
+  make bootstrap3
+
+I started with Herman van Brugge's bounds checking patches for gcc-3.1.1 at
+http://www.inter.NL.net/hcc/Haj.Ten.Brugge
+In addition to updating Richard Jones's work for gcc-2.7, he added some lookup
+optimizations and support for threads.  Herman updates the patches only for
+gcc releases.  If the latest gcc release works for you, you should use his
+patches instead of mine since gcc releases are more stable than snapshots.
+
+As I have time, I will put patches into
+ftp://nscs.fast.net/pub/binaries/boundschecking
+
+You may freely mix objects compiled with and without bounds checking.
+I find this convenient because I must link programs to third-party object
+libraries.
+
+These patches are unrelated to the fat pointer bounds checking patches by Greg
+McGary gkm@eng.ascend.com which change the size of pointers and require building
+modified versions of libc and every other library that your program calls.
+I have heard that Greg's patches will eventually be incorporated into gcc.
+If you can use Greg's fat pointer bounds checker, it has the advantage of
+better run-time performance and support for languages other than C.
+
+William Bader
+email: william@nscs.fast.net, williambader@hotmail.com
+www:   http://williambader.com
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/report/bounds-checking.html gcc-4.0.2/gcc/bounds/report/bounds-checking.html
--- gcc-4.0.2.org/gcc/bounds/report/bounds-checking.html	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/report/bounds-checking.html	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,130 @@
+<HTML>
+<HEAD>
+<TITLE>Bounds checking extensions to GCC</TITLE>
+<!-- Changed by: , 15-Dec-1995 -->
+</HEAD>
+
+<BODY>
+<H1>Bounds checking extensions to GCC</H1>
+
+<H2>What is bounds checking?</H2>
+
+<P>A `traditional' feature of C is that the programmer can overwrite memory
+at random by accidentally exceeding the bounds of an array, or using a pointer
+after it has been freed. These extensions add proper, fine grained bounds
+checking and pointer checking to C. For instance, the following types of errors
+(amongst others) will be caught:
+</P>
+
+<P><PRE>
+	char a[10];
+	int i;
+
+	for (i = 1; i &lt;= 10; ++i)
+	  a[i] = 0;			/* can't access a[10] */
+
+	struct linked_list { struct linked_list *next; /* .. */ } *p;
+
+	while (p != NULL)
+	{
+	  free (p);
+	  p = p-&gt;next;			/* used a pointer after free */
+	}
+
+	int *
+	f (void)
+	{
+	  int i;
+
+	  /* .. */
+	  return &amp;i;			/* returned a stale stack pointer */
+	}
+</PRE></P>
+
+<P>The GCC patches are compatible with almost all C constructs. We have
+successfully compiled the following programs with bounds checking:</P>
+
+<LI>	Tcl 7.3 &amp; 7.4
+<LI>	Tk 3.6 &amp; 4.0
+<LI>	Ghostscript 262
+<LI>	uEmacs 3.10
+<LI>	xrn
+<LI>	GNU Grep 2.0
+<LI>	XBoing 1.8
+
+<P>Bounds checking only works with C, not with C++. It may work with Objective
+C, but I have not tested it.</P>
+
+<H2>What machines does bounds checking GCC work on?</H2>
+
+<P>At the time of writing, we have compiled bounds checking GCC on the
+following machines:</P>
+
+<LI>	Linux 1.2.13 (i386)
+<LI>	SunOS 4.1.3 (Sparc)
+<LI>	Solaris 2.4 (Sparc)
+<LI>	HPUX 9.05 (HP-PA)
+<LI>	ESIX SVR 4.0.4 (i386) <A HREF="mailto:herman@htbrug.hobby.nl">Herman ten Brugge</A>
+<LI>	OSF 2.0 (DEC Alpha) <A HREF="mailto:tuppa@iue.tuwien.ac.at">Walter Tuppa</A>
+<LI>	FreeBSD 2.0 (i386) <A HREF="mailto:u27113@kb.be">Danny Backx</A>
+<LI>	Ultrix 4.2A (MIPS) <A HREF="mailto:drochner@zelux6.zel.kfa-juelich.de">Matthias Drochner</A>
+<LI>	OS/2 (i386) <A HREF="mailto:mattes@azu.informatik.uni-stuttgart.de">Eberhard Mattes</A>
+<LI>	DOS port in the works
+
+<H2>Where can I get bounds checking GCC?</H2>
+
+<P>The patches are supplied in source form, to be patched against the current
+GCC source tree, and as binaries for various supported machines. If you
+wish/need to compile from source, you will need around 60 Mbytes of free disk
+space.</P>
+
+<H3>Where can I get the binary distribution for my machine?</H3>
+
+<P>The binary distributions are available for the following machines:</P>
+
+<LI>	Linux (ELF only)
+<LI>	SunOS 4.1.3
+<LI>	Solaris 2.4
+<LI>	HPUX 9.05
+
+<P>You can download one of these binaries from <A HREF="ftp://dse.doc.ic.ac.uk/pub/misc/bcc"> ftp://dse.doc.ic.ac.uk/pub/misc/bcc </A>. (Owing to their size, these binaries are <I>not</I> mirrored elsewhere).</P>
+
+<P>Please read the README file in that directory first. It tells you what you
+need to download.</P>
+
+<P>There is an OS/2 binary by <A HREF="mailto:mattes@azu.informatik.uni-stuttgart.de">Eberhard Mattes</A>.</P>
+
+<P>There is a DOS version in development. Contact me for more details.</P>
+
+<H3>How can I get the patches to GCC source?</H3>
+
+<P>If you can't get a binary for your machine, or if you can't get through
+to the site above, you will need to get the patches and compile GCC from
+source. The patches are much smaller, and should be mirrored at various
+sites around the world.</P>
+
+<P>You need to download both the patches <I>and</I> the corresponding GCC source
+tree.</P>
+
+<LI>UK, Northern Europe:
+<P>	Patches:	<A HREF="ftp://dse.doc.ic.ac.uk/pub/misc/bcc/"> ftp://dse.doc.ic.ac.uk/pub/misc/bcc/ </A></P>
+<P>	GCC:		<A HREF="ftp://sunsite.doc.ic.ac.uk/gnu/"> ftp://sunsite.doc.ic.ac.uk/gnu/ </A></P>
+<LI>US, Canada:
+<P>	Patches:	<A HREF="ftp://sunsite.unc.edu/"> ftp://sunsite.unc.edu/ </A> </P>
+<P>	GCC:		<A HREF="ftp://prep.ai.mit.edu/pub/gnu/"> ftp://prep.ai.mit.edu/pub/gnu/ </A> </P>
+
+<P>Please read the README file. It contains useful information about how to
+apply the patches and compile GCC.</P>
+
+<H2>Where can I find more information about these patches?</H2>
+
+<LI>	The current README file (<A HREF="ftp://dse.doc.ic.ac.uk/pub/misc/bcc/README">ftp://dse.doc.ic.ac.uk/pub/misc/bcc/README</A>).
+<LI>	The <CODE>gcc.info*</CODE> info files supplied with the patches and with the binary distributions. Go to node <CODE>Bounds Checking</CODE>.
+<LI>	The project report supplied with the patches and with the binary distributions. The relevant file is <CODE>gcc-2.x.y/bounds/report/bcrep2.ps.gz</CODE>. [NB. Somewhat out of date].
+<LI>	By mail to the author (see below).
+
+
+<HR>
+<P><I><A HREF="mailto:rjones@orchestream.com">Richard W.M. Jones (rjones@orchestream.com)</A></I></P>
+
+</BODY>
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/report/cred.pdf.uu gcc-4.0.2/gcc/bounds/report/cred.pdf.uu
--- gcc-4.0.2.org/gcc/bounds/report/cred.pdf.uu	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/report/cred.pdf.uu	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,3933 @@
+begin 600 cred.pdf
+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
+M9'1H<R`X."`P(%(*+T)A<V5&;VYT("]16$U!3T@K0TU"6#$P"B]&;VYT1&5S
+M8W)I<'1O<B`U."`P(%(*/CX@96YD;V)J"C4X(#`@;V)J(#P\"B]!<V-E;G0@
+M-CDT"B]#87!(96EG:'0@-C@V"B]$97-C96YT("TQ.30*+T9O;G1.86UE("]1
+M6$U!3T@K0TU"6#$P"B])=&%L:6-!;F=L92`P"B]3=&5M5B`Q,30*+UA(96EG
+M:'0@-#0T"B]&;VYT0D)O>"!;+3,P,2`M,C4P(#$Q-C0@.30V70HO1FQA9W,@
+M-`HO0VAA<E-E="`H+W!E<FEO9"]O;F4O='=O+W1H<F5E+W-I>"]Q=65S=&EO
+M;B]#+THO2R]0+V$O8B]C+V4O9B]H+VDO;"]M+VXO;R]P+W(O<R]T+W<O>2D*
+M+T9O;G1&:6QE(#4Y(#`@4@H^/B!E;F1O8FH*.#@@,"!O8FH*6S,Q.2`P(#`@
+M-3<U(#4W-2`U-S4@,"`P(#4W-2`P(#`@,"`P(#`@,"`P(#`@-30S(#`@,"`P
+M(#@S,2`P(#`@,"`P(#`@,"`U.30@.3`Q(#`@,"`P(#`@-S@V(#`@,"`P(#`@
+M,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@-34Y(#8S.2`U,3$@,"`U,C<@,S4Q
+M(#`@-C,Y(#,Q.2`P(#`@,S$Y(#DU."`V,SD@-3<U(#8S.2`P(#0W-"`T-30@
+M-#0W(#`@,"`X,S$@,"`V,#<@70IE;F1O8FH*.#<@,"!O8FH@/#P*+U1Y<&4@
+M+T5N8V]D:6YG"B]$:69F97)E;F-E<R!;(#`@+RYN;W1D968@-#8O<&5R:6]D
+M(#0W+RYN;W1D968@-#DO;VYE+W1W;R]T:')E92`U,B\N;F]T9&5F(#4T+W-I
+M>"`U-2\N;F]T9&5F(#8S+W%U97-T:6]N(#8T+RYN;W1D968@-C<O0R`V."\N
+M;F]T9&5F(#<T+THO2R`W-B\N;F]T9&5F(#@P+U`@.#$O+FYO=&1E9B`Y-R]A
+M+V(O8R`Q,#`O+FYO=&1E9B`Q,#$O92]F(#$P,R\N;F]T9&5F(#$P-"]H+VD@
+M,3`V+RYN;W1D968@,3`X+VPO;2]N+V\O<"`Q,3,O+FYO=&1E9B`Q,30O<B]S
+M+W0@,3$W+RYN;W1D968@,3$Y+W<@,3(P+RYN;W1D968@,3(Q+WD@,3(R+RYN
+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
+M"B]3=&5M5B`W-`HO6$AE:6=H="`T,S$*+T9O;G1"0F]X(%LM,SD@+3(U,"`Q
+M,#,V(#<U,%T*+T9L86=S(#0*+T-H87)3970@*"]H>7!H96XO<&5R:6]D+WIE
+M<F\O;VYE+W1W;R]T:')E92]F;W5R+V9I=F4O<VEX+W-E=F5N+V5I9VAT+VYI
+M;F4O0R]$+T4O2B]++TTO4B]7+V$O8B]C+V0O92]F+V<O:"]I+VLO;"]M+VXO
+M;R]P+W(O<R]T+W4O=R]Y+WHI"B]&;VYT1FEL92`U,2`P(%(*/CX@96YD;V)J
+M"CDP(#`@;V)J"ELS-#,@,C@V(#`@-3$T(#4Q-"`U,30@-3$T(#4Q-"`U,30@
+M-3$T(#4Q-"`U,30@-3$T(#`@,"`P(#`@,"`P(#`@,"`P(#<T,B`W.#4@-CDY
+M(#`@,"`P(#`@-3(X(#<Y.2`P(#DT,B`P(#`@,"`P(#<U-R`P(#`@,"`P(#$P
+M-38@,"`P(#`@,"`P(#`@,"`P(#`@-3$T(#4W,2`T-3<@-3<Q(#0U-R`S,30@
+M-3$T(#4W,2`R.#8@,"`U-#(@,C@V(#@U-R`U-S$@-3$T(#4W,2`P(#0P,B`T
+M,#4@-#`P(#4W,2`P(#<T,B`P(#4T,B`T-3<@70IE;F1O8FH*.#D@,"!O8FH@
+M/#P*+U1Y<&4@+T5N8V]D:6YG"B]$:69F97)E;F-E<R!;(#`@+RYN;W1D968@
+M-#4O:'EP:&5N+W!E<FEO9"`T-R\N;F]T9&5F(#0X+WIE<F\O;VYE+W1W;R]T
+M:')E92]F;W5R+V9I=F4O<VEX+W-E=F5N+V5I9VAT+VYI;F4@-3@O+FYO=&1E
+M9B`V-R]#+T0O12`W,"\N;F]T9&5F(#<T+THO2R`W-B\N;F]T9&5F(#<W+TT@
+M-S@O+FYO=&1E9B`X,B]2(#@S+RYN;W1D968@.#<O5R`X."\N;F]T9&5F(#DW
+M+V$O8B]C+V0O92]F+V<O:"]I(#$P-B\N;F]T9&5F(#$P-R]K+VPO;2]N+V\O
+M<"`Q,3,O+FYO=&1E9B`Q,30O<B]S+W0O=2`Q,3@O+FYO=&1E9B`Q,3DO=R`Q
+M,C`O+FYO=&1E9B`Q,C$O>2]Z(#$R,R\N;F]T9&5F70H^/B!E;F1O8FH*-#(@
+M,"!O8FH@/#P*+TQE;F=T:#$@,3@U-`HO3&5N9W1H,B`Q,#$P-PHO3&5N9W1H
+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
+M8V]L;VXO;&5S<R]E<75A;"]G<F5A=&5R+T$O12]'+TXO4"]2+U,O5"]5+U8O
+M62]B<F%C:V5T;&5F="]B<F%C:V5T<FEG:'0O=6YD97)S8V]R92]A+V(O8R]D
+M+V4O9B]G+V@O:2]K+VPO;2]N+V\O<"]Q+W(O<R]T+W4O=B]W+W@O>2]Z+V)R
+M86-E;&5F="]B<F%C97)I9VAT*0HO1F]N=$9I;&4@-#(@,"!2"CX^(&5N9&]B
+M:@HY,B`P(&]B:@I;-3(U(#`@,"`P(#4R-2`U,C4@-3(U(#4R-2`U,C4@-3(U
+M(#4R-2`U,C4@-3(U(#4R-2`U,C4@-3(U(#4R-2`U,C4@-3(U(#4R-2`U,C4@
+M-3(U(#4R-2`U,C4@-3(U(#4R-2`U,C4@-3(U(#`@,"`U,C4@,"`P(#`@-3(U
+M(#`@-3(U(#`@,"`P(#`@,"`P(#4R-2`P(#4R-2`P(#4R-2`U,C4@-3(U(#4R
+M-2`U,C4@,"`P(#4R-2`P(#4R-2`P(#4R-2`P(#4R-2`P(#4R-2`U,C4@-3(U
+M(#4R-2`U,C4@-3(U(#4R-2`U,C4@-3(U(#`@-3(U(#4R-2`U,C4@-3(U(#4R
+M-2`U,C4@-3(U(#4R-2`U,C4@-3(U(#4R-2`U,C4@-3(U(#4R-2`U,C4@-3(U
+M(#4R-2`P(#4R-2!="F5N9&]B:@HY,2`P(&]B:B`\/`HO5'EP92`O16YC;V1I
+M;F<*+T1I9F9E<F5N8V5S(%L@,"`O+FYO=&1E9B`S-2]N=6UB97)S:6=N(#,V
+M+RYN;W1D968@,SDO<75O=&5R:6=H="]P87)E;FQE9G0O<&%R96YR:6=H="]A
+M<W1E<FES:R]P;'5S+V-O;6UA+VAY<&AE;B]P97)I;V0O<VQA<V@O>F5R;R]O
+M;F4O='=O+W1H<F5E+V9O=7(O9FEV92]S:7@O<V5V96XO96EG:'0O;FEN92]C
+M;VQO;B]S96UI8V]L;VXO;&5S<R]E<75A;"]G<F5A=&5R(#8S+RYN;W1D968@
+M-C4O02`V-B\N;F]T9&5F(#8Y+T4@-S`O+FYO=&1E9B`W,2]'(#<R+RYN;W1D
+M968@-S@O3B`W.2\N;F]T9&5F(#@P+U`@.#$O+FYO=&1E9B`X,B]2+U,O5"]5
+M+U8@.#<O+FYO=&1E9B`X.2]9(#DP+RYN;W1D968@.3$O8G)A8VME=&QE9G0@
+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
+M2$DK0TU45#$P"B])=&%L:6-!;F=L92`P"B]3=&5M5B`V.0HO6$AE:6=H="`T
+M,S$*+T9O;G1"0F]X(%LM-"`M,C,U(#<S,2`X,#!="B]&;&%G<R`T"B]#:&%R
+M4V5T("@O<&%R96YL969T+W!A<F5N<FEG:'0O8V]M;6$O<&5R:6]D+V$O8R]D
+M+V4O9B]G+VDO;"]M+VXO;R]P+W(O<R]T+W8O=R]Y+WHI"B]&;VYT1FEL92`R
+M-"`P(%(*/CX@96YD;V)J"CDX(#`@;V)J"ELU,C4@-3(U(#`@,"`U,C4@,"`U
+M,C4@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@
+M,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P
+M(#`@,"`P(#`@,"`P(#4R-2`P(#4R-2`U,C4@-3(U(#4R-2`U,C4@,"`U,C4@
+M,"`P(#4R-2`U,C4@-3(U(#4R-2`U,C4@,"`U,C4@-3(U(#4R-2`P(#4R-2`U
+M,C4@,"`U,C4@-3(U(%T*96YD;V)J"CDW(#`@;V)J(#P\"B]4>7!E("]%;F-O
+M9&EN9PHO1&EF9F5R96YC97,@6R`P("\N;F]T9&5F(#0P+W!A<F5N;&5F="]P
+M87)E;G)I9VAT(#0R+RYN;W1D968@-#0O8V]M;6$@-#4O+FYO=&1E9B`T-B]P
+M97)I;V0@-#<O+FYO=&1E9B`Y-R]A(#DX+RYN;W1D968@.3DO8R]D+V4O9B]G
+M(#$P-"\N;F]T9&5F(#$P-2]I(#$P-B\N;F]T9&5F(#$P."]L+VTO;B]O+W`@
+M,3$S+RYN;W1D968@,3$T+W(O<R]T(#$Q-R\N;F]T9&5F(#$Q."]V+W<@,3(P
+M+RYN;W1D968@,3(Q+WDO>B`Q,C,O+FYO=&1E9ET*/CX@96YD;V)J"C$W(#`@
+M;V)J(#P\"B],96YG=&@Q(#(P.#0*+TQE;F=T:#(@,34S-3`*+TQE;F=T:#,@
+M-3,R"B],96YG=&@@,38T.#0@("`@(`HO1FEL=&5R("]&;&%T941E8V]D90H^
+M/@IS=')E86T*>-KMMF-T9MVV<!O;KMBNBBJV;9M/;!L5&Q4[%:=BV[9MV^:7
+M=Y]S=M4^W\][?]UVD[2T]#''FJ.O,=<:3\B(Y!2_\AO9&`!$;*P=OS)\8^`@
+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
+M:>)6QUIZ?&#X?$:@[XU:,HF/B]K>.1`4)PO]?%0M>0_,6YGBF0A6P83GT(>F
+M!@5]FQ]J^XDJN3N&:ET;12]<W+:0AH4R22MA=(-[YP)Y+^_R6.#V5H7&SY8)
+MZX>DDQ?V>`L]W#)5,,H:JHD)/PJ/UF\*V=HT#]";FOUGH_HCOVA-_%%(:Y.?
+M#$Z_`AQ$KGZ'[4RYB%F^J6UD('\QQ250!PQ%06OI70=B\H)R[-70_S_\@OG_
+M-_C_Q`:&E@!]>T<;*WU["YC_`U-(O]YE;F1S=')E86T*96YD;V)J"C$X(#`@
+M;V)J(#P\"B]4>7!E("]&;VYT"B]3=6)T>7!E("]4>7!E,0HO16YC;V1I;F<@
+M.3D@,"!2"B]&:7)S=$-H87(@,3$*+TQA<W1#:&%R(#$R,PHO5VED=&AS(#$P
+M,"`P(%(*+T)A<V5&;VYT("]:3T=)1D4K0TU2,3`*+T9O;G1$97-C<FEP=&]R
+M(#$V(#`@4@H^/B!E;F1O8FH*,38@,"!O8FH@/#P*+T%S8V5N="`V.30*+T-A
+M<$AE:6=H="`V.#,*+T1E<V-E;G0@+3$Y-`HO1F]N=$YA;64@+UI/1TE&12M#
+M35(Q,`HO271A;&EC06YG;&4@,`HO4W1E;58@-CD*+UA(96EG:'0@-#,Q"B]&
+M;VYT0D)O>"!;+3(U,2`M,C4P(#$P,#D@.38Y70HO1FQA9W,@-`HO0VAA<E-E
+M="`H+V9F+V9I+V9L+V9F:2]Q=6]T961B;')I9VAT+W!E<F-E;G0O<75O=&5R
+M:6=H="]P87)E;FQE9G0O<&%R96YR:6=H="]A<W1E<FES:R]P;'5S+V-O;6UA
+M+VAY<&AE;B]P97)I;V0O<VQA<V@O>F5R;R]O;F4O='=O+W1H<F5E+V9O=7(O
+M9FEV92]S:7@O<V5V96XO96EG:'0O;FEN92]C;VQO;B]S96UI8V]L;VXO<75E
+M<W1I;VXO02]"+T,O1"]%+T8O1R](+TDO2B]++TPO32].+T\O4"]2+U,O5"]5
+M+U8O5R]8+UDO8G)A8VME=&QE9G0O<75O=&5D8FQL969T+V)R86-K971R:6=H
+M="]A+V(O8R]D+V4O9B]G+V@O:2]J+VLO;"]M+VXO;R]P+W$O<B]S+W0O=2]V
+M+W<O>"]Y+WHO96YD87-H*0HO1F]N=$9I;&4@,3<@,"!2"CX^(&5N9&]B:@HQ
+M,#`@,"!O8FH*6S4X,R`U-38@-34V(#@S,R`P(#`@,"`P(#`@,"`P(#`@,"`P
+M(#`@,"`P(#`@,"`P(#`@,"`P(#4P,"`P(#`@.#,S(#`@,C<X(#,X.2`S.#D@
+M-3`P(#<W."`R-S@@,S,S(#(W."`U,#`@-3`P(#4P,"`U,#`@-3`P(#4P,"`U
+M,#`@-3`P(#4P,"`U,#`@-3`P(#(W."`R-S@@,"`P(#`@-#<R(#`@-S4P(#<P
+M."`W,C(@-S8T(#8X,2`V-3,@-S@U(#<U,"`S-C$@-3$T(#<W."`V,C4@.3$W
+M(#<U,"`W-S@@-C@Q(#`@-S,V(#4U-B`W,C(@-S4P(#<U,"`Q,#(X(#<U,"`W
+M-3`@,"`R-S@@-3`P(#(W."`P(#`@,"`U,#`@-34V(#0T-"`U-38@-#0T(#,P
+M-B`U,#`@-34V(#(W."`S,#8@-3(X(#(W."`X,S,@-34V(#4P,"`U-38@-3(X
+M(#,Y,B`S.30@,S@Y(#4U-B`U,C@@-S(R(#4R."`U,C@@-#0T(#4P,"!="F5N
+M9&]B:@HY.2`P(&]B:B`\/`HO5'EP92`O16YC;V1I;F<*+T1I9F9E<F5N8V5S
+M(%L@,"`O+FYO=&1E9B`Q,2]F9B]F:2]F;"]F9FD@,34O+FYO=&1E9B`S-"]Q
+M=6]T961B;')I9VAT(#,U+RYN;W1D968@,S<O<&5R8V5N="`S."\N;F]T9&5F
+M(#,Y+W%U;W1E<FEG:'0O<&%R96YL969T+W!A<F5N<FEG:'0O87-T97)I<VLO
+M<&QU<R]C;VUM82]H>7!H96XO<&5R:6]D+W-L87-H+WIE<F\O;VYE+W1W;R]T
+M:')E92]F;W5R+V9I=F4O<VEX+W-E=F5N+V5I9VAT+VYI;F4O8V]L;VXO<V5M
+M:6-O;&]N(#8P+RYN;W1D968@-C,O<75E<W1I;VX@-C0O+FYO=&1E9B`V-2]!
+M+T(O0R]$+T4O1B]'+T@O22]*+TLO3"]-+TXO3R]0(#@Q+RYN;W1D968@.#(O
+M4B]3+U0O52]6+U<O6"]9(#DP+RYN;W1D968@.3$O8G)A8VME=&QE9G0O<75O
+M=&5D8FQL969T+V)R86-K971R:6=H="`Y-"\N;F]T9&5F(#DW+V$O8B]C+V0O
+M92]F+V<O:"]I+VHO:R]L+VTO;B]O+W`O<2]R+W,O="]U+W8O=R]X+WDO>B]E
+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
+M,0HO5VED=&AS(#$P,B`P(%(*+T)A<V5&;VYT("]/6D)+54DK0TU"6#$R"B]&
+M;VYT1&5S8W)I<'1O<B`Q,R`P(%(*/CX@96YD;V)J"C$S(#`@;V)J(#P\"B]!
+M<V-E;G0@-CDT"B]#87!(96EG:'0@-C@V"B]$97-C96YT("TQ.30*+T9O;G1.
+M86UE("]/6D)+54DK0TU"6#$R"B])=&%L:6-!;F=L92`P"B]3=&5M5B`Q,#D*
+M+UA(96EG:'0@-#0T"B]&;VYT0D)O>"!;+34S("TR-3$@,3$S.2`W-3!="B]&
+M;&%G<R`T"B]#:&%R4V5T("@O9F8O<75O=&5R:6=H="]H>7!H96XO<&5R:6]D
+M+V]N92]T=V\O=&AR964O9F]U<B]F:79E+W-I>"]S979E;B]E:6=H="]!+T(O
+M0R]$+T4O2"])+THO2R]/+U`O4B]3+U0O52]7+V$O8B]C+V0O92]F+V<O:"]I
+M+VLO;"]M+VXO;R]P+W$O<B]S+W0O=2]V+W<O>"]Y*0HO1F]N=$9I;&4@,30@
+M,"!2"CX^(&5N9&]B:@HQ,#(@,"!O8FH*6S8U-B`P(#`@,"`P(#`@,"`P(#`@
+M,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`S,3,@,"`P
+M(#`@,"`P(#,W-2`S,3,@,"`P(#4V,R`U-C,@-38S(#4V,R`U-C,@-38S(#4V
+M,R`U-C,@,"`P(#`@,"`P(#`@,"`P(#@U,"`X,#`@.#$S(#@V,B`W,S@@,"`P
+M(#@X,"`T,3D@-3@Q(#@X,2`P(#`@,"`X-#4@-S8Y(#`@.#,Y(#8R-2`W.#(@
+M.#8U(#`@,3$V,B`P(#`@,"`P(#`@,"`P(#`@,"`U-#<@-C(U(#4P,"`V,C4@
+M-3$S(#,T-"`U-C,@-C(U(#,Q,R`P(#4Y-"`S,3,@.3,X(#8R-2`U-C,@-C(U
+M(#4Y-"`T-3D@-#0T(#0S."`V,C4@-3DT(#@Q,R`U.30@-3DT(%T*96YD;V)J
+M"C$P,2`P(&]B:B`\/`HO5'EP92`O16YC;V1I;F<*+T1I9F9E<F5N8V5S(%L@
+M,"`O+FYO=&1E9B`Q,2]F9B`Q,B\N;F]T9&5F(#,Y+W%U;W1E<FEG:'0@-#`O
+M+FYO=&1E9B`T-2]H>7!H96XO<&5R:6]D(#0W+RYN;W1D968@-#DO;VYE+W1W
+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
+M?:59>Z;R"'8F8VVR;T$""+>M*&V)&5B>E!1RTL!<8\:M)=.6HU(;VQ*SM#LO
+MFF5/K/G_\$'^%_A/",B5$*,92H714<B?^[5*G&5N9'-T<F5A;0IE;F1O8FH*
+M,3(@,"!O8FH@/#P*+U1Y<&4@+T9O;G0*+U-U8G1Y<&4@+U1Y<&4Q"B]%;F-O
+M9&EN9R`Q,#,@,"!2"B]&:7)S=$-H87(@,34*+TQA<W1#:&%R(#$P,PHO5VED
+M=&AS(#$P-"`P(%(*+T)A<V5&;VYT("]75E)"3T,K0TU363$P"B]&;VYT1&5S
+M8W)I<'1O<B`Q,"`P(%(*/CX@96YD;V)J"C$P(#`@;V)J(#P\"B]!<V-E;G0@
+M-S4P"B]#87!(96EG:'0@-C@S"B]$97-C96YT("TQ.30*+T9O;G1.86UE("]7
+M5E)"3T,K0TU363$P"B])=&%L:6-!;F=L92`M,30*+U-T96U6(#@U"B]82&5I
+M9VAT(#0S,0HO1F]N=$)";W@@6RTR.2`M.38P(#$Q,38@-S<U70HO1FQA9W,@
+M-`HO0VAA<E-E="`H+V)U;&QE="]B<F%C96QE9G0O8G)A8V5R:6=H="D*+T9O
+M;G1&:6QE(#$Q(#`@4@H^/B!E;F1O8FH*,3`T(#`@;V)J"ELU,#`@,"`P(#`@
+M,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P
+M(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@
+M,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P
+M(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#`@,"`P(#4P,"`U,#`@70IE;F1O
+M8FH*,3`S(#`@;V)J(#P\"B]4>7!E("]%;F-O9&EN9PHO1&EF9F5R96YC97,@
+M6R`P("\N;F]T9&5F(#$U+V)U;&QE="`Q-B\N;F]T9&5F(#$P,B]B<F%C96QE
+M9G0O8G)A8V5R:6=H="`Q,#0O+FYO=&1E9ET*/CX@96YD;V)J"C@@,"!O8FH@
+M/#P*+TQE;F=T:#$@,3(Y,`HO3&5N9W1H,B`V-S0Y"B],96YG=&@S(#4S,@HO
+M3&5N9W1H(#<U-38@("`@("`*+T9I;'1E<B`O1FQA=&5$96-O9&4*/CX*<W1R
+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
+M(#$S+V9L(#$T+RYN;W1D968@-C4O02]"(#8W+RYN;W1D968@-C@O1"`V.2\N
+M;F]T9&5F(#<Y+T\O4"`X,2\N;F]T9&5F(#DW+V$@.3@O+FYO=&1E9B`Y.2]C
+M(#$P,"\N;F]T9&5F(#$P,2]E(#$P,B\N;F]T9&5F(#$P-2]I(#$P-B\N;F]T
+M9&5F(#$P."]L+VTO;B]O(#$Q,B\N;F]T9&5F(#$Q-"]R(#$Q-2\N;F]T9&5F
+M(#$Q-B]T+W4O=B]W(#$R,"\N;F]T9&5F(#$R,2]Y(#$R,B\N;F]T9&5F70H^
+M/B!E;F1O8FH*,3D@,"!O8FH@/#P*+U1Y<&4@+U!A9V5S"B]#;W5N="`V"B]0
+M87)E;G0@,3`Y(#`@4@HO2VED<R!;,B`P(%(@,C$@,"!2(#,P(#`@4B`S,R`P
+M(%(@,SD@,"!2(#0U(#`@4ET*/CX@96YD;V)J"C4S(#`@;V)J(#P\"B]4>7!E
+M("]086=E<PHO0V]U;G0@-@HO4&%R96YT(#$P.2`P(%(*+TMI9',@6S0X(#`@
+M4B`U-B`P(%(@-C(@,"!2(#8U(#`@4B`V."`P(%(@-S$@,"!270H^/B!E;F1O
+M8FH*-S8@,"!O8FH@/#P*+U1Y<&4@+U!A9V5S"B]#;W5N="`R"B]087)E;G0@
+M,3`Y(#`@4@HO2VED<R!;-S0@,"!2(#<X(#`@4ET*/CX@96YD;V)J"C$P.2`P
+M(&]B:B`\/`HO5'EP92`O4&%G97,*+T-O=6YT(#$T"B]+:61S(%LQ.2`P(%(@
+M-3,@,"!2(#<V(#`@4ET*/CX@96YD;V)J"C$Q,"`P(&]B:B`\/`HO5'EP92`O
+M0V%T86QO9PHO4&%G97,@,3`Y(#`@4@HO4%1%6"Y&=6QL8F%N;F5R("A4:&ES
+M(&ES('!D9E1E6"P@5F5R<VEO;B`S+C$T,34Y+3$N,3!A*0H^/B!E;F1O8FH*
+M,3$Q(#`@;V)J(#P\"B]0<F]D=6-E<B`H<&1F5&58+3$N,3!A*0HO0W)E871O
+M<B`H5&58*0HO0W)E871I;VY$871E("A$.C(P,#,P-C(U,3(S.3`P*0H^/B!E
+M;F1O8FH*>')E9@HP(#$Q,@HP,#`P,#`P,#`P(#8U-3,U(&8@"C`P,#`P,#,U
+M.#,@,#`P,#`@;B`*,#`P,#`P,S0W."`P,#`P,"!N(`HP,#`P,#`P,#`Y(#`P
+M,#`P(&X@"C`P,#`Q-S,Q,3$@,#`P,#`@;B`*,#`P,#$V-SDV-R`P,#`P,"!N
+M(`HP,#`P,3<R.34T(#`P,#`P(&X@"C`P,#`Q-C<P,S0@,#`P,#`@;B`*,#`P
+M,#$U.3(P,B`P,#`P,"!N(`HP,#`P,38V.#<W(#`P,#`P(&X@"C`P,#`Q-3@V
+M-3`@,#`P,#`@;B`*,#`P,#$U-C@S-R`P,#`P,"!N(`HP,#`P,34X-#DP(#`P
+M,#`P(&X@"C`P,#`Q-34W-S8@,#`P,#`@;B`*,#`P,#$T-3@R.2`P,#`P,"!N
+M(`HP,#`P,34U-C$V(#`P,#`P(&X@"C`P,#`Q-#0S-S@@,#`P,#`@;B`*,#`P
+M,#$R-S8Q-2`P,#`P,"!N(`HP,#`P,30T,C(P(#`P,#`P(&X@"C`P,#`Q-S,Y
+M,S0@,#`P,#`@;B`*,#`P,#`P.#,T-2`P,#`P,"!N(`HP,#`P,#`X,C,W(#`P
+M,#`P(&X@"C`P,#`P,#,V.3<@,#`P,#`@;B`*,#`P,#$R-C@S,B`P,#`P,"!N
+M(`HP,#`P,3(Q,#(R(#`P,#`P(&X@"C`P,#`Q,C8V-S0@,#`P,#`@;B`*,#`P
+M,#$R,#$R,B`P,#`P,"!N(`HP,#`P,3`W-C0W(#`P,#`P(&X@"C`P,#`Q,3DY
+M-C0@,#`P,#`@;B`*,#`P,#`Q,C@V-R`P,#`P,"!N(`HP,#`P,#$R-S4Y(#`P
+M,#`P(&X@"C`P,#`P,#@T-3`@,#`P,#`@;B`*,#`P,#`Q-S$T.2`P,#`P,"!N
+M(`HP,#`P,#$W,#0Q(#`P,#`P(&X@"C`P,#`P,3(Y-C`@,#`P,#`@;B`*,#`P
+M,#$P-S,T."`P,#`P,"!N(`HP,#`P,3`U-#DR(#`P,#`P(&X@"C`P,#`Q,#<Q
+M.#@@,#`P,#`@;B`*,#`P,#`R,3(R-R`P,#`P,"!N(`HP,#`P,#(Q,3$Y(#`P
+M,#`P(&X@"C`P,#`P,3<R-30@,#`P,#`@;B`*,#`P,#$P-#`Y-"`P,#`P,"!N
+M(`HP,#`P,#DR-C4R(#`P,#`P(&X@"C`P,#`Q,#,Y,S<@,#`P,#`@;B`*,#`P
+M,#`R-34R-R`P,#`P,"!N(`HP,#`P,#(U-#$Y(#`P,#`P(&X@"C`P,#`P,C$S
+M-38@,#`P,#`@;B`*,#`P,#`R.3DP.2`P,#`P,"!N(`HP,#`P,#(Y.#`Q(#`P
+M,#`P(&X@"C`P,#`P,C4V-#0@,#`P,#`@;B`*,#`P,#`Y,3<Q,"`P,#`P,"!N
+M(`HP,#`P,#@R.#$W(#`P,#`P(&X@"C`P,#`P.3$U-30@,#`P,#`@;B`*,#`P
+M,#$W-#`T,R`P,#`P,"!N(`HP,#`P,#4R,3DY(#`P,#`P(&X@"C`P,#`P,S0R
+M,C(@,#`P,#`@;B`*,#`P,#`S-#$Q-"`P,#`P,"!N(`HP,#`P,#,P,#`R(#`P
+M,#`P(&X@"C`P,#`P.#$Y-S`@,#`P,#`@;B`*,#`P,#`W-#DU,2`P,#`P,"!N
+M(`HP,#`P,#@Q.#$R(#`P,#`P(&X@"C`P,#`P,S<Y,S@@,#`P,#`@;B`*,#`P
+M,#`S-S@S,"`P,#`P,"!N(`HP,#`P,#,T,S$U(#`P,#`P(&X@"C`P,#`P-#(Q
+M,#@@,#`P,#`@;B`*,#`P,#`T,C`P,"`P,#`P,"!N(`HP,#`P,#,X,#0S(#`P
+M,#`P(&X@"C`P,#`P-#8T-3$@,#`P,#`@;B`*,#`P,#`T-C,T,R`P,#`P,"!N
+M(`HP,#`P,#0R,3@Y(#`P,#`P(&X@"C`P,#`P-3`V,SD@,#`P,#`@;B`*,#`P
+M,#`U,#4S,2`P,#`P,"!N(`HP,#`P,#0V-30T(#`P,#`P(&X@"C`P,#`P-3$V
+M.#`@,#`P,#`@;B`*,#`P,#`U,34W,B`P,#`P,"!N(`HP,#`P,#4P-S,R(#`P
+M,#`P(&X@"C`P,#`Q-S0Q-3,@,#`P,#`@;B`*,#`P,#`W-#@U-2`P,#`P,"!N
+M(`HP,#`P,#4R,#DQ(#`P,#`P(&X@"C`P,#`P-3$W-C$@,#`P,#`@;B`*,#`P
+M,#`U-#$Y-R`P,#`P,"!N(`HP,#`P,#4T-#$U(#`P,#`P(&X@"C`P,#`P-30X
+M-#4@,#`P,#`@;B`*,#`P,#`U-#DQ-R`P,#`P,"!N(`HP,#`P,#4T.34R(#`P
+M,#`P(&X@"C`P,#`P-34Q-#8@,#`P,#`@;B`*,#`P,#`U-S@R,2`P,#`P,"!N
+M(`HP,#`P,#@R-#8W(#`P,#`P(&X@"C`P,#`P.#(R-#(@,#`P,#`@;B`*,#`P
+M,#`Y,C(X-B`P,#`P,"!N(`HP,#`P,#DR,#(V(#`P,#`P(&X@"C`P,#`Q,#0Y
+M,34@,#`P,#`@;B`*,#`P,#$P-#4X,B`P,#`P,"!N(`HP,#`P,3`W-38T(#`P
+M,#`P(&X@"C`P,#`Q,#<U-#$@,#`P,#`@;B`*,#`P,#$R,#<P,R`P,#`P,"!N
+M(`HP,#`P,3(P-#,R(#`P,#`P(&X@"C`P,#`Q,C<S,C<@,#`P,#`@;B`*,#`P
+M,#$R-S`Y-B`P,#`P,"!N(`HP,#`P,30U,S$P(#`P,#`P(&X@"C`P,#`Q-#0X
+M.3D@,#`P,#`@;B`*,#`P,#$U-C0V-B`P,#`P,"!N(`HP,#`P,34V,3$Y(#`P
+M,#`P(&X@"C`P,#`Q-3DP-S@@,#`P,#`@;B`*,#`P,#$U.#@W-"`P,#`P,"!N
+M(`HP,#`P,38W-3<P(#`P,#`P(&X@"C`P,#`Q-C<S,C(@,#`P,#`@;B`*,#`P
+M,#$W,S8R.2`P,#`P,"!N(`HP,#`P,3<S,S0U(#`P,#`P(&X@"C`P,#`Q-S0R
+M,S4@,#`P,#`@;B`*,#`P,#$W-#,Q,"`P,#`P,"!N(`HP,#`P,3<T-#(P(#`P
+M,#`P(&X@"G1R86EL97(*/#P*+U-I>F4@,3$R"B]2;V]T(#$Q,"`P(%(*+TEN
+E9F\@,3$Q(#`@4@H^/@IS=&%R='AR968*,3<T-3$V"B4E14]&"@``
+`
+end
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/report/homepage.html gcc-4.0.2/gcc/bounds/report/homepage.html
--- gcc-4.0.2.org/gcc/bounds/report/homepage.html	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/report/homepage.html	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,17 @@
+<TITLE>Richard Jones's Homepage</TITLE>
+
+<H1>Richard Jones's Homepage</H1>
+
+<P>
+This page is still under construction. Please click on a subject below.
+</P>
+
+<H>Subjects</H>
+
+<LI>
+<A HREF="bounds-checking.html">
+Extensions to GCC to add bounds checking and pointer checking to C.
+</A>
+</LI>
+
+<P> <I> rjones@orchestream.com </I> </P>
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/report/README gcc-4.0.2/gcc/bounds/report/README
--- gcc-4.0.2.org/gcc/bounds/report/README	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/report/README	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,13 @@
+There files contain various drafts of papers about this project. The files
+of interest are:
+
+bcrep2.doc
+	- Report & manual in M$-Word 6 format.
+
+bcrep2.ps
+	- Same in PostScript format (US sized letter paper, ie. 8.5x11").
+
+cred.pdf
+	- Description of the out of bounds code
+
+To extract the files cred.pdf.uu and reports.uu use the uudecode program.
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/report/reports.uu gcc-4.0.2/gcc/bounds/report/reports.uu
--- gcc-4.0.2.org/gcc/bounds/report/reports.uu	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/report/reports.uu	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,9888 @@
+begin 666 reports.tar.bz2
+M0EIH.3%!62936;SC(;(">W1_____________________________________
+M________Y&@OAO</H/3L^^MUX"^TB2M`%F``&U:)VTZ,`H````````````!(
+M$HI*V(L`$0)L8=YYM=EX>^\^N^?3>L[:VT5K0S5HA*MM=,]JV[<0O0UZ]>NZ
+M:>P>N7:J3VW>JY/>V<XV[5M;$M;MBW=RK=FYVL;94[>E*'5TS>X-;V@%````
+M``('IM`8H5`K0`#+Z``<"`$HM#*BW'!?``+'H!@T6T`#0T``T`ID*!0:`&AH
+M'T``!T```'Q,O)T`#O;KSWP)NW```H``=```8U@`::`*`%`H%44%!N:$/JV!
+M[``````>O9D[L;M54*ZWR`&V-JP`>@`D```````````#0``'T``````Z``#M
+M.;WV[Y[X6S7W6H````Y*4*`"@HD*24(E4`"0A);&HZH`!2FB@``````R&+;B
+M@#H('1T0\^SY[[L'0*`.@`.3.[)[Z^4,ZS>6]ZB'S`#>QP`?=/@"*@-```)4
+M````!]L```*```]!;````H```>M````H```````Z!0;SGV^?'0!Z```'OL`#
+MIH`!X=G9RX`.@*``T#0"@(^PT"(``^V"^",4VP`%]@76Z`'MOKH`=Y]P``!]
+M``!T#O,``2``"@``4D4Y```&0`````\R>^@?=O@```,(!!3OLY]`?>SY?#P?
+M8X```````````````````````/0/H```#/K````````&O/H/NV^3@(Y8%++8
+MM5+K*NK-RP2-V=78S8:[;36J?``,P7;"JKT9[[N4W$X'WT^53JV&0[M-VN"J
+MV9AF[-H941!V.X[;=FK;6[IVTUH7"V<H((.@`RC;<QUJ2N54TVQ`"@"(=VIV
+M;:TI)R3LVW0DW;DYTSDW8PN&`/=8:&]8``'0!?<I4I5"5(W:`F:)L5;-36C*
+M^%T%5(2Y<L.5MJ"UJJEJ`!J^SET>#:A5`5539D'O`SJ0/0(QAHB%#?>^^O:^
+MN6-;;T`KNS>%*/-?/G@``%``>BB@`%````0H^F'V'T+,<;CK:X6Y?>%PXXO.
+M]XQYA>[<`7H8<U8````V>^M[KQ[A[QT-(V`````````-```!'?7O#[*@"JE0
+M=]SPV/1*H"I;.`!WW:E"*%[/`#W.\`HJ2UW@\Y)`HH/.\$[)Z4!0%>\!SJ**
+M``[W@O/*`*4]O`X``U1QP-TZ#5`/N\7N:=Z=`7KN```#D'0`%``"@?0`%`#/
+MKTUPNKX*"S@/GO2/7>.YZ&VXP-%][Q]OGU5NO'MX9KWB;U0GG>%N>M>'O+M>
+M>`NN]GRA#X![)@``````]`H````!707J^X/>^Q[MX`YO1M>>/'/>VF>/<[W=
+M<>%U>O#>!WKQ,X&TXK.`=AVS<)NSUSP9B7QV^^\[;P!Z>;[@`!0```````!U
+M[;@H]T-G`N?08W`X/>.&A7:+MVAW5*KMPG.V;<)IR;<+ET7&]ZF]3PT!NNVQ
+M\WL+NP`>NA0HE54H`"@D!1($@4````[RP[S[&KWAO=KQ.\/.>;."WKW9/#NK
+ML7#-V#BW32[H#M>VKAF]>VN\```YNL^>A:`];VH```````````"]]P\\^VUP
+M\WGFW@`[<UJX`9O7J[>&TCFA@HB=M#><X6X,]4O<+A3G'<<VVX;W;V??5"``
+M>]Z7`````````0@```=[N.]QM7`N["<3#M<=]UEYY[Q>\\O=>*YXV[5>[O#Q
+MG>\;P][O`%[VKX1'AH">^C<``/H````-```"?6/,/93-U`6X5<-I=.-U*[[P
+M<Z]8X7.IC@;G>[/`AO+@NO;UX/;M6^\1`!O8`````#02``-```````````&[
+M#N\+AM*G<.?/>]H#QKMQ=U6<%W-N,X.9P;=O=X=E['`,Y[S[Z%[```'M@```
+M`*H]9UGP````=@+2QYYF@!0)V%[#MJ'.[@,J]`T77<:H&ZP.0!"55WGIW7A9
+M@=[!Z]M[S>=8]-QCI1.P=X]'WSKVK'PG+N'D[WS=/O*ZIFGMO>V>^#=YKULC
+M3$8YJVKG#G,4:AM+#//#R9SJ]:]U;X^)]':]=V<4WW:=XW'K0[ZZG?6<7#GW
+M/7N-6"]>X-VWL.G20`&UY[P*JDB252!(;XO?6UC>+4^UU.>][O=INJW/#X/I
+M3O@<YT"MF0M[FAT4`H"04-:4$*6K&[9*"J,)K6T^^DN)OKTCY*DD/K*&/O->
+MNTI1?<VY!CSM]YKAK?7%&U8>O>:FBDGWOIV[@=[WV<UA70->^W7U4&W'G;M+
+M;;W:,G6DWU;NM$:V4R\YTY[G;N<'NV=Z"DX8``]-`4%IYJSE6@GH[N[.I5HT
+MV+&JWUZU4IIK/>H]RXY`14"Q:IG7=7;X79?>]][+9=WU[HD>SC5+N%7=S$S4
+M;&Z@2:TN[ER^H![YV^B[?'7D[E.EM+KM;:PV]:][6+K`)?09%][G?<T=CH!H
+M!W19)-5I'0``&;QF>\K,R]>.0DFF::(I+8:$5M>XJYNS1MFF)EMK'7N.ZSZ]
+M?/FK:VQOBYP:ZW:79W3UFLX]`2)#D:QTQ0`X9R[;&ZX%")U$9-0"0'@^/0^I
+MXG?=O>BM,L5$U-M-0-F^TV=FM%NOJ7'SZZ]J]:=9DRUM(;@=AU-:I?+GS[OO
+M=IEXVP8B6BB)88-B[U4FEH\]U3PR>98#6VKHE>8>A0.S`]VVK6:W#UN\5;XW
+M5)';;8M8&9B/;WK:]0*V]GN]LP(3.KC./>@/D9-`=74^+YIT`!U[['?6T`#0
+M`!\@`&@``%*H!0!0!T!IH-;?<`:=[Q0N]``H%.@:!Z>[!5`ZVTV```"UT,N-
+M'IKK6C)6]R3DU0HTHK>-B$H0@"`!``!-````":8$&@TT`````1ID8F3(9,$`
+M```&@!H&@`T`F``````"#3$!*1"$)H0:)D4S-3*FQ,T(GJ/4]3(!B``&AH`!
+MZ@&AH`````:``````````````!H!*>BA$031":4\IZ:FU4_4V-)/:C04:?DH
+M\H?I30\H9I-E-E/4>4R'J/*`#:FAIO5`'J`T--#U!H,@-```````````!H``
+MA*)$)`"*;24WD*GY4_5/]13RGHU/49&VE#]3)/:H/4:/4!HT_40>DT&$>D:-
+M-#30T``````-`&AB!B``T`-&@````!"DA"`F@!`4\C0!H@TQ`)M`&D8$(;31
+M/328)M-!4_3%/$](R94_:F3%/4;U)IFIJ-/!H:DVT*?JGZ3U(_$I^HT3]2-/
+M:)ZIZFU/4'Z4VIZ@/4;TDVFH)-2$`00("`33$"--&(9`TFFGI,*,T3-4F]#4
+MS(U,2/3TT4\4VH\IXFU0/4](VIH]3:FF(]3RC1ZFAID/4/4&@-&AHT,TC1D]
+M1H!H]0Q"3_SQ'XX6!/X8D!`FG81$)_*,(@B$KJDHCP2H255ZR05<J94.`F+6
+MD;E4S+M_5^/XCZW6K:=>=S:Y6[`\B@Y\<LM#1SM)G)@A107O:[E;]FX2^4AB
+MV+ZYX*"8O=#("\A/ZQ:6#7);2TGQ1)^X3+BSEMK?1EJOM65[[#G"8I5$1#,!
+MP%`4!"*)S!(%""!-+YJ/\7#CA-Q$2+['I.J;/KSY[N^5554555Q)=8%`5E9'
+MJ9Z^&@@3(FUOOB/B$4G2.$&>@?KGZ(CO^8Y[EN@WO632);6U<J7;L*BY.5EY
+MD@F;<0,O!,]@YV?R-!H=%GL8T>=6<3AI*^@TNFT>GM$VAU&IU6KUFMC3796O
+MV&QV6SVFUVVWT*&XSD,02J(VYXC=<3N]YN+,-[I-]L]_?\#6Z*S92`FK!SC4
+MITKG%QE%&.-41-F(HX=I;##*<_-&/SOQ=MPJBZX/FFH_O>\^WA^BB;\X&!>@
+M^;@[:L`:745'(@3D:YDOI)("1(@/1$W8FRP-7MXTH_\WB+,@AXI^+X4:1JBJ
+M@H?&_15_1\O%_&?;/O??=^*?\("CDJO$>RLJJ*?G<\0++V_.]"%/YOSH?]_3
+M9D12-/_/0:(7]9*@1_LD`<CQ`E'B(O[4#]R#?X507_:EIE_TA_M__5(('_16
+M$B1Z(*H%C_R"/_W"6.-74JZ_@R0B75"O!ZWNPU)`G'`'_.VO(.UCVV_V+X=:
+M?]AH/'106W$Y156<0$,W6^4\R!TVI"9Z)I01-OKI>+UIHESR`;6'@]03[81]
+M<0-9+*)HH@B!"O`K4#U11512BHODVF2/[M&U51'S@T!-$@D3QJD4'!)#7_DA
+M_R5=O=>0./QF]5_`?R3P)?'\GD#J0T_P\BK$R-=;_%E2+@'PL56M);T#-IEU
+MI/XO,UP-ANB<,B9-#634J,^MAE`*8F91DE^]+,V4#:!@!Q##L6F+-9<@O)+Z
+MPC6*D0U-_I[-M-;<U+*N:%K32UV^+4-J:KGP^/_KLB?^$7?FUX239A!9D(4%
+M30Q(E)11%0O%0\A-K3V.&7O65']7Y<33PSG>^TD)#/@0`ZPA^_;[;V;ZJ(A$
+M)'T(;H-V'/A@!SP<Z%X.;#F@Y8-"'S*H9-["!;V$%H,(,$'Q8(7@Z\./#-#K
+MPZH,H)*>1#,#KPT@:8.O#KPZ\.O#FPY,.O#KPZ\.O#KPK87DPYL.P#L`[`.@
+M#L`[`.P#L`[`.P#L`ISC.,\9[M5SC.SM%G\_N7:(-GLM)F0@X'HG">#JQS7L
+M8O*":GBN4I6UL.9U!8@(@7^BLB/_79+-TKA3L=UI8R^(M/I=1#37>/V$@E/_
+MLIW72B6`P7B;%_8J.1.T1A-'M6D,!5]/Z>G/17=%VWX#>"]05F1$<J,E**`_
+M<J"BJL2#`JOLP^34#\_YOW/]_^Y>]_]'<#WQ?CGH;6NZ]L-"/\$.\-:':%3^
+M+Q^HT(_;]GVUI!`/]*B"'2J"(!$B@@&PU&EXGD<;*%`J:%%VQO70Z#.KC1M1
+M$['M[(\A[(;W0<!<0(OB_7Y]<7=T!<@24@!617B1J%D1$!.*X%?A<C%75`C5
+M`VU3$'B6$$02M6K/XJNR3J(@6!%1$1$0-A5W^]BBXNN!D*B>5FLE<1D1*]:M
+MP[,$$1,%%!-]N^-W6_ON/MK(FX%$5=VJKDJ(PXU3"J,R'RM)][ZE]1?>>SU>
+MM03X/7H#]O`/N"P?\T!YV5J@!/5YL0#I(]@?4]W-(=G9@I_%Y8(#\<@51$$0
+MET!(6,'BI\?,Q_53D,9D!$0T:B(65J1C(B"(3TF^=IE`1+Y40#!5`$ZB6T"<
+MP"8!<G%_$T@=<@@\^9RW/K_\GCET!!<E!NP[43`/&0F'^MD0@3X<@CQ*"SS#
+M)A\:YV?2(L<,CO^S@3@BH")V&<#/M1(<,/P&.;'[+S["B9<T'(R'IL=;$KF<
+ME`><K@"(!?18"+-5R]56T.F+^!2BEZE``0)_^J'-"A`L1X2#^2545`Q.;*8N
+M[A&B(`BHEHB[!Q0:1@PJ#`GSH6S#??"<S"._*R"`F`\##FKZ(C@"&B5<0=>V
+MX[-$$03]^?)-G2FL<"3EI!LI40-N*J*)EG%L;@YZ<^"FAVYLK]ED1-OI-B:1
+M]4G_MJ$01+"`B(B%6*L1V7"4&)NQ<\((@CP-."2H_7IJ]RHJ^UC$.D5$VR2L
+M=#ODEF?T2/D3LJB`(B($$21%ZAP")RR>^><BEM$,^!R!JG(XWDID(C.++.'N
+M8<G!(@[_3Z3P,;9N'KF*QBY6FW$!W0:!U199=''(Z#LV#_#YV2:%58LIJ.JG
+MVNXC<O-:UT*TNP>^-O-_):RIEZ]/]WX8R]E4?@M:_][;K1Y?6R.N7LML(:O"
+M+T;:<)PL<(VFB8T31X?$??^(?$71K#]9],P?C@R\1BA?M#XP?'GITY<+YO;.
+M'H!L/(Y=9JNYI5+NR&CDG)D=)"3G>?(KX)R`:#/Y!YM/L[2L<8>Z8(R32FAZ
+MDM=D5-T;'#X_55L_:YHQ03T'GRUCZ?I3.KU/0$:!*=86.44]"<*(1/1'HRYZ
+M0A@5;'):#:<*IZ/TV'QVTY7D(X^XTJ(;#855TVMVHF,_G3$],3V<00Z(].<E
+MZJ<@AZDV[L]ZH@!@ZA+[><=K]<4DGJQ3O[[UAQAZT@!`5#UPH)Z\7V!^H:/D
+MCV0Y.1/9FF\X9.#Y4C]H=L,"(GM3M2+VIK?;'DCQ#F)3N2MT!YHY8]N1":X/
+M<&R\L=MTOESDN^.>[#W*]DGNN^1"J)[L\`Z`<(>\/>F^]\+[].-SZ>C)!PM<
+M.I$8-WP?%.S/@'P2(^$*AU`J_#,)/B"O$\P>,5:OQ3XQV_QSY!\DF$^4:?Y:
+M.^84"?-/G'CD/GGT#$^B>O/I$2("?3*/J'U/-J?5.8_^3!/K&@]^?7/L'V2J
+M(?:,'PS[9]P^2?)C$^[]YA/O_@8/P?A_%^/\GY>L_-^?XWRYQ#\_Z/T.1/T^
+M+^K?'R>QY6/]7??:_7D'[(XQ/V>R_;^[Z7@_O^7+/_#[?CPQ/XU41`_DJ?S_
+MI_7^WT_[Q?WK'^/?_Y@'^>T_SB+_#]TG[_(?D7]7Z:!/\\#_+@`_;Z'\OZ?O
+M_Y[I!/\R_F3`_8@WM/M._T541/]_P8_Y_TP$$!.J_E3_)#A?[8_]]G^?]J0Y
+M__6Q=_YO\?]\T`A_OA@!_[3V?("")_WT?_?_:)!,$D)O4_4\U%\KBC^15_]^
+M&7S7]]?8,PPAA6)_8_>H_]8^_4_3:L_\_U_K_&YR/JX69AX'X\*O4_STW0Y"
+MU[[\UK_=Z]\OXOP?>&0@%\@(J""B*J$$G_0^L?ZZ)<FUK7O"S`_^FY<N?::2
+MV<(>Z,'9WM_['&MQ?[0'']'WK9$EAP;FRH\9RP<E?V/ZN0!`,MKF?_NVJ^6>
+M9G>H2?;?^HPD^VSW2LS,0^9'/E=L=75OK?]-I4^;*GN2J?N?[F"_UI]0J'M_
+M7MZ540\YX2,(>:5`1-\J(9^7.U&R^9O,32\+^<XB&$)[!\='2'L\]M68/T?I
+M?^C39G^Y#TA1>?/`3[V0#Z??@+P2O]R'XWQ?JNE_JW^G'^7[C^HT@_R84^7'
+MY_[_!7]K*H'?"@IY)?FGC_^]ON_6;A]QQKC>-;%66)##4_\HA.*JH)/K,',=
+MAP$5F!`9[<7L,\9Z++$$BSE$$\5!?P+QGR&("HG<LF6[3*"2D^UV>BAME*ZA
+MK2/\X0B0(D!F$XQF%&Q^V312$/JD,D1/)Y\0P@R$#L$=D>@]-2;9F:_EU4<<
+M=ETR8+#&E5$/\*('X5`$+BDDH\"PT+X0][&I3KA3=(R.[_JPV[\!#\B`\\!W
+MR`__E*?B2'_L^L3!I?WD@_P(`'ZZ23^O_E40AX(>#V25VHO[X?BM[4A`/_'"
+MAXKV_^#%_UX^R"`]B%5/9)>R>Z$[Y%.Y1CX8_!+TRJ'W_]/^E_I;'^[*/^\,
+M]\=I^GSOTA@;7>"Z+`#[^#\>$/JPH'*0$_IR"1*1J&US,+2:>$JHB`B::1@A
+M5Q)ILZ)$1"A0$;(:143)\SW/^.8[.VW,R`65446Q4<#*'/_B^YGL>`DEZ1E<
+M)*J"$7Q/%=U*I'0W2.:QSG^/W?\N?\CD4K*"5E01"M\-@./4(*1,JQ9[$XCB
+M.,`3^?%[V:::;8;IFHHHBDD%%56966/7?.J^C]$P2+C*B[)D=AX;G44.J66L
+MZ)@/I^.WI53C%(3N-/:@94*E1YPJ6^-M6\WQ[)*B*(HBBF'B883,ZYBQU%J0
+MCJ<9V.NCP>6&7AZ_PGE@IHQ,#8SQ_C_!RLJ#T14SF1)[:L^W=N8AQNXC0W%Z
+M3<[__?(?D_&GX_6>:H0M*A:4`1`,FWEMAY6@XOG\;GYL.^9/\J<76'`@&"9[
+MY^9/AMB@"&R<_L_K/C>]2^][WCL6)["A_94/!\PP5JZUZ[T-+8L5=+4Z3)D#
+MB?ZLAILCSG0]\G%1`EJTUI41`$P5T:\QQVP<AZ[03N">>?`P-!4R50DP.:OW
+M:;7W.H>5!:K`2IEEWE\W^W'1)$J)I!-(,##)$DJ7=G:F%/H29MSS%@0L3D]2
+MI51^>O2?O_7Z;YLL$0HEHU%ZM%J/V[G\G1=#R?S^U^;,E9*HR(()?J'W.\DW
+MOI(!;4251`_^;U'IGHXA1H\M!+_[%2IV6YG$1$$T"I11J=Q/`X'7]QVV^O1!
+M,LMAA#9X;`0WV4VBOGMT#[,8RHE_.@UE110.040]JJ3JDDCJNLFF"/_BIG_Q
+M8?K:+D^VY#C*>;U^IV&JO^3V';[7P/^]SY'SODNB[#>=?W'=\OF9`F(,V"HF
+M<HD2D.(78N!H\(W_E$_?P_PYZ275\FP;(17T,B`B`BY65QS^-XUN!\WVK@FF
+MTNNU:`D\0D_8;1-_Y/DZ(T6B<G$$U#XU(XT91!$$CIDQ^BEY7^L@'X>W]Y33
+M!$3`5JE3;TO_EC_-N?BJ'UX\%:4OT\H,,PR#JM[;]96T$:!RD@QY%41J^3W*
+M65Y/@_6Y#J>IG3#6A;7!.EXNYFW;MTS=93U'^ZAUMWE5T7X.?R=!()=NVL_;
+MKU_==?5Z+W]`=-24WW)E&QSHO2YYOP+]:@$!!E0!!`%G;(N48SQ,:I<JZBI1
+M^+TS2H`*H(E2I11RW0?FOM#WDR$\Z9^WC*9_F[I=NU>]H^1XW;.3B!*K(A6;
+M7UJERK=WTH'><+]NGTOD]K&)6K:4S+-_?]%(B(;3\WE7"$\^-?/!$0)T2>9P
+M@>O7?_9^7M^1@4JB4TTN"QTW(:WMTO(1(G-%K%72LK#KBK`1$W/^.*P4_-C1
+M(6[=JU2B(.W@I")X@H5JEC">(<[_MN3W/E/)[[Z42%2KKG`5*E3">@70J5')
+M-,T<;"0[9B$2V1)N)@=KX)?_>W,!)IK\QWATN/ZDX[[G;1!---?Y_9XW#Z#2
+MSSHA///M-)TW<5)._R;U3[L$I*:9?>_WFFN>6VOA)0E%%&UUT,K$IX.3`V'@
+ML:%:::<9X;BI32'7P26663IN^T_U(Y#DI99=ES&WV=]J;.>ZO8'U/CUDKUJU
+M6VV?+,=BO7J[S!B(4TSZ?ASZRW+(J!-WS&AEL5U6.`)333L:E3CMKY+`F_MH
+M6*5II:5?,PB<,+%7JU*GR(CLU))*)9.[B0.1ZO:>)U,">>K5Q><X,^;*2DLN
+M?YC"FY:0.BF9)II&-=F\KR>ND`(I+%/$\.&FC&CLU,CCIX_)*<I+++Y<UDM6
+MU\>?UO#Z3C?75A$JU;.MV6J]!W_%RG<+D<O^EQ33SFFSW1X%;8FUF0"GF4],
+MX#?GZZ_W]C`L6*U-/J(I4G77^_TWU^UC*.!?8N_O7V_Y[7ZKU^[];:\KWMHX
+M[_ZT6M_:=:_]AV7F&JJ)T/6^:LUN>^[[;<_9Y"<LZOF\:Q6K?X[GIN!OZ$TE
+M/,\Q4Y/0:_D38:/$T5/PMVQQVA_9D/0XG8,6[=JM6X,6_][5<?P\GW?4U.WB
+M*M7"K:3?Q`$7\/67WX.<B(D)Y\CF9]M-V'L=G[#44GU0J5+5,*/J=9P/:0)9
+M97<USVXTO2P2924EZ;JK[4V)_8/FT?4%!11%-'TWZ(R..CG.3M%JMU<H'C*3
+M337-C,397$:GX'/>DI0]-\]BK5IU]G;T;?UW8\IJ:`2IV+%2I@7*M2G=3]O-
+MZM2=2>?KAW2R=WGL+H['/R)11C6DM!?XO2I]_^_NN_L>LZ"J6:U:K3TD23S_
+M_.))-2']^IX$>VD)$7(S<G^_D9OS1DFR]WZ[:]U<C.(DG_,\=NX?T\UZJ)(K
+M^KUNEJ^Y:,CC=C>0@B")[=>,4B,K@:.F3:^;Y;YO<SDXLTI5K>3Z5HA8XJ>K
+MA'>R/630)IN.L[^FI3Z64EEP999-SS?E_YSSI//.<.HLNDZ^0K\\Q--V#H35
+MLB4^O[#7R$Y/-P9NI$59]UZ/A?ZJ?]]MUWFZQ6K4T<!T_DO,=;]GR/[*"B7X
+M9B];ZG_$O`E)9=1H;$T0DU>;C]5`2>?IY\^OG\W1_%IFI4GGTTLN9R'0<A\/
+MIISHM[4[CA0*U;6.NUJWX339[$2SY^I4G*E2F;70]DL+ZKU:]5?U>+":MRG(
+M^8_-43@*6:V77JU=U4ZSN^_]S^JK4!*5N8>^O4?&/#]GH:W)SHE%$\^!\3FO
+M3[G#F)ILDRKT7;1F+(PAGL.MZGF>^M]OR?Y:9RFG6Z&I3>^+J>'ZGEN+I*:;
+MZG1\Y/X?H?83(33</G99:TTV_TDY//-V/=R_?^=($8*@"@BAS$H#M1LPW=C[
+M/U*<GW---")?"BLMZR;+;GBX'52$MJ::67YG$32DIU7)5-AR;X^A[^4E]H33
+M%2;"Z3RW63$QT^/-'Y5/*^V\?0><G"<F..XCIB'&8%NV/0T:H3%F>>::::Y9
+M[#)\2D2DI:J2=#\)Z'2R^B<2DO-+L#FBW=XNX9^[8KV[';:SX'Q^9X_N<VZ7
+M2S9L6,"L=)(>5['H\KJZYLHRJ4W]_K:J8%:GY^7WGCTF*)41LG(U*)DV+%B7
+MEMQO*:"DUE/5W+D]S9G$]3S-!03SG"M\9TE3SV-]GOZ"@PJ:*)Y=Q\/23">^
+MZMBA5HFO8NRT7R/8T4<U0E%F\ZBS11V5'J8P)IINAA`A-6Z.CGN(RN7X?,]A
+M049U-,\W53\=O*-304+K2N:BW?=3WM'ZI28F+-XHLTZ:GZIV=3\6BJ%0J+IN
+M(V%8ZOIZN_^AY2]Y^HFKSU%Z?\4N;+I-).32Y@7/N>AZ>?X'#IHZ6DP==J.=
+MU'$<1&B`GD=K['45NGB*>CUU2FFFG'E"6:5W?7^_\MK8$E61=KGO_>:ZVKQ^
+MXG)YN6Z!_N)62*I#0O/`[>/E/-9M,:3]%14TFXQ>OJTT3D\I7XJ;G??V/1>W
+MF)IM>DGG.._ITB>WPYYR>OZV9X]]BASQ#VWV\71/(&@;#WDW/<NG?Q$@:F,X
+MGF*VA.3YOC-EW%!043SSVIL362DI:K2VIMIO.+\GX^5E)24E-FI9JU:G75/G
+M9GL.=Q*M4J5#1IS4!.[L_;X^:$Q+:M%K=\??Z'D-)/+*1N$R_EML\/4Z:K=^
+M9\?F*^GW66F@K5JU\5JNHK7UJON90^E5ZK1^AA4)L_RW/[KCNNR*::>-T56K
+M52YD\YOKVLOK5CK?-VN8KUZWZ*]6K4Z2^K4T=/PZE-%O2Z/5]#3BWN1SZ9_<
+MTTF'1>O<"I31OM%W%!1H:9J_(:'L9_%_'\6BBU9GFY#?XFRXCH)YTY_B:,#?
+M<#6[GJ3?][MSI-CAUJQ5HHSNSX@[7O)93+")PAO.P]OSTLNLCF-YJM-[?K_6
+M33<C--+I>S-K/[?_4DF#''D15=!(B<-95Z3D=/G_U<#;\I)+)"&+Y3W\:1_@
+MZI[WJ=MQK#FO#G&XXWF'O@Q\.*#H+FY/[_)<E!$B6[R#MAJ>!X%&-H*.9M5Z
+ME!Q--'8?1H^O1--,:W,]F27N>FFEE)33\E&8/0QD9N80U<442]"M:?7Z&C4[
+M70U98XM%N_G$G%[3@^%-8VVUF>\HAJXM!8IDL>%]]VG6@GLS5)]WS?FNUM3H
+MB!2M!P>!D[:M<+EC1UKM>GWWL6^Y\MBN5LFM6O4T_FW>-/.;"U+%LXHKU6.W
+M3S'4>%Q'DYYYRI-5XOM9^\EEK1U;?"W_!]KN9IM5JJ'\;ETT30E4U4N>DX&#
+MEZ^24JRRXE\:2/G*)W3$UBI+++++VDP:12IGI]'^B/*XB1)+_HI*\<<=F*'M
+M,V**+)DV#R[!=9FWLO+WM?L.]G2>S>GEETWL^IEEDT>RQNLW31QYZW5M58\"
+M1$]WH<]%/6Q:)X<;K)^?IXYT^]TN;Q-2^1+=2INZM``?X.M^_6?6JU**-'^?
+MH\Q&_3U5-!1<IL;+IJ/12227U@XG18F`E/L::><T]2I7J:.I3QOG=7W<TQ-M
+MK6RY^U/U7,8E'F*4$I)R>O?V.:-/]>GVT\YQY1,XDC][P_P?2F",6]7KFLL<
+M9-W.>_9@5JW[J@GTJQ<KUL_7X%C0;&<L^H]CDV[7&1UR^FSMM\'G\S4\[,3%
+M]/Q<WG(D1.*Q>BUE,--BX%J^#DED[Z2/%Y,EKWUC\^'/E<'LJ4ORB>Q1--[^
+M?9_4:C;TE(HB`EVUA:BK:YOXW6RS+HIR6_E"Z76]>?<_#330B4T5Z*($,OO(
+MBR5HZV!GIIMA(1QPQ(VCY74<O1'%$<SNXHCA:S-D#S?D>SG>*3-'':=%WK1B
+MTI'R-G0;WO99+=GF)9/T=C&@(815CAK).8O21H*`'5Y*JEK"NZ_[&9I>UZ#D
+M_0ZRIGU!$2BY8YFUEUZU7K:VLK];BM5IS-;4^CLZN)//-AJW46;'A:*+T'W=
+MSY_JM%\#J-5L,RWU]I`Y3`XV^Z;4<E1;025053`49R4S+)#*)/H88$:#(<+T
+M^[U?P_]7^G_K_['W'4=:!#:Q3`?LK^;.#X8AW-O8&1B?2\6O_#]YQ+VW>XM>
+MUJ<9M+["KZWZWC^N^;T_N\GP\[A5-W@8NX,7<<5L][<Z`_1<N>4\"UN.?N>!
+M5S]34\M@S[CW/Z?T^-F4XN''''I1(+5-=HM]B:/1[KZWN^J-/I]#GY\"7+FU
+M>!@6K4]O1:*IHM%J[^363@*B%DE$<,HJH"HY`1E!#1QX]_S-76WM'J;_/W^L
+MO]5IM+G:S+RLO+QLO,S=5K<?4:K,TFLRL[3:K5:S0:;3ZC4ZO6Z?4ZS6:S6:
+MW6VZN%8UE.ATN?S]FI@ZC08EC(L96IR\#0ZK3YF#E:+#T.9H,[.UFKS=!J]#
+MI]#H=)I=5J-7IM/J]5J]7K-;=HUF=>O9U]8J9IFYN;J;-S`T^MU%VD2V(EP$
+M#"9B@I:`H/:CY\'TQ\N^DH#Z'T/7P^]\;W.0#M(\Z@B3^XNA[O_EW#['1P,P
+M_V`+Y6_8^(3`C$LLR$&9,!XC&,YE7/O09EF`;9^[_=]RH%^@4H_&P/P![!^X
+M\!V'AD>WS]+%7\SF#P/CQ=@?]4_3]G[6,Q/J=W8/*!(_HPG6$)M[XVM?R8=,
+M`&JF*Z6-(O@.!BBK12(=I>J$5Z@>K0Y!Z'K>&#@@@'%?0")R(?F3K4E0<)75
+M`[84/LH/[,`>['/_]&0P\!D7_A][]#K+9ZZAYO,3=>X?U__[)#<!]#X7[:]_
+M_3_QQD\G\?OZ/B&?5\BOR@54@Y80B0_?$"@H8(/Y^,0\OA$P.",9:'(:U$Z^
+MM6PA(8:8TV0EA">I4'!]P*"@G#"[Z=`\D$B.`TAN!Y,5^?T_\W5YO1BG"Z$T
+M.LYG[1#="#Q@BS$>@R)`ED83[SV1,Q;PD;#D]6E#T040NWP.-Z)1F6WUM)#[
+M$"Q9?F1:,JM:2D12U/_CJ*,@RPLI"BJ+L_S_'L_G_`=.W8/]N>+R]1Y?\4^,
+M."O"M:Y"':\D;`SGU">V=XD+H34&I'K5#IL:M'7)H%4ZWGQUAL/ZR\YV#HT7
+MMZ=C$^#W3?+K]'PF>S+5#>Q*U2EC]:KC-_\;`0L;<F>08/3#>5,&L.:-$O(7
+MDH"=07IP)D5ZX%-+Z6"EA=.I80%)2&!H(@G_(EXMH>=B(]G9@O*0I":`PJB(
+MLI]]9W(@B!5"H#Q--&$#^'MC^*-@8`8`7:#Y3229\B=&T:K-;2C'RT:75_.:
+M&B5$C`LC9"B9L2%U"-EK+"?0Y[!EA$I$J(2U--)A,@1`P);1/T"4"64)E^/&
+M,.0EJ5L=GFZ$41$VBV%Z\ZKGW&EWW$;3APV>YZWF^HXOC>BY?BMYUYPNJZCI
+MNJ)]]UIA=7TYU!SA@8?6G*=+SY1SO.9)U.5C]3U.7UV1'+T^@ZO(R,?H\CJL
+MF3J\KK.O,CJ^KZOKSKS$T^JR<F_R,#3ZK(R,C4WJFDJYE,6-E5<R.#]3J<NK
+MH<W+ZXR^O-79S,O66Q+T67H]+@X=;/9>LT]G07=5H\]G\31Z;6:C+PM+JLK+
+MQ=-IM#J=;F:C0Z31:/3Z74:S6::C%T6DL3:#-T\V=E9[0:'5Z+27+Z[H=2:W
+M5:W+T.AU.CTN=G:K,TVMT6IU.BTVMU&ITFLTFFU.JU.IU>LUEG28N-G:W593
+MKF'=MB1HB%W^`EGG=AK1(D#'40)!-4)\$1A*U433Q/0CJ/0<GFD<@Q<61;*G
+ML6:`C:T29L\LZ(JEH5(C#P/)]/_WX7_:/NJ?C]CL<C5JA]<(\`B_9-X601Y!
+MWP/4&L,-OM!W0<0>)0\L/XX2?,UB>YK$/2,`=GW>"'.7J\/H:UA:=1]]AA+O
+M$<A<?R7\YQ=H5/TWU;]K^J8Z=`YD3F3FTZ/H4.E/)SI8C:9!!S@1.?J(5551
+M.5.4&$1$<H""<SS+`/E!49!$00N<1HW&9C<&)37<GOM]R.3J<LUUK+S>!HM%
+MKMUM-AR/&[WD>0GJ7]>K7J\COM]:BX?#W<NRXK9\9N^.X?"Q'7;?'Y[E-UR6
+MZY'D^2X?)XV)>1`O[V'>X>JPXZF;:M:#-Q+6FOM!H,;E,70Y&AQ<W"R,K0Z;
+M*UFKT.KX&HS^LSM5J-/IM1IM9JM5JK=ZU'+?9V9'-JM7K-9?YU715]!;OLW3
+M8&@R\[5Z'%SLO'TF/=TM[.OHM#JM/J]3H=/I-9D:K6:?4:S4:S6:K6:S1ZW/
+M6*;PCSAHOHW(R4(T/[^?^F/M-A^D(P_,&38GNCX(/LM<I-Q^B79?US]Z/^,J
+M&CI(G.43G!A!DLGZC)"][OWO5\_YE572UJJK6TJC!+(C%CDC_"R&(B"G'\>P
+MG/\<<'C@XT.-X\3?\$X'!%03@@A1QO&,(\8;(7585I<'@:_$T^`0RH2;F3B)
+MZ$-3GJLF[U^7OMULMEL.!L=S=LW]VUM+_>8&STL>XW^QV7%;;B-EB\5K=?N]
+MWO=WNH\_M.,X&EWW&<5P-1J>,XOB^,RM7K:1%X""JI04>-03!P/JX8U?L?@P
+MUMF$'.,OEW=HRN697ZS-OF\ND?+0,48B)&"1&EIB$`Y#[XZD1?=_5?J_[&PO
+MUW"YR@>G>CV!";\;@+NCV"R,;@\*AH,,#`,0Y:L0!@TU'L?4-?;UZ;CKE5S,
+M,[`G[+_0:;G]AW!Y,B9$3OOZM,(A0['[B.L/1I4R%+D)8&QS7GT8U.:\^C_7
+M90,L.>,8E\.=L8J!2+)IFABCP.@41$4;X*)!XA#H%;;N-M\0,B&E:T%,4YGL
+MD[=FV5[P^@;[@<0,#"8?F?B(X1S"(+ABB@;%4/?VYX.QM(0C8:-HWP"^A]Q3
+M\OOZ*MB,9<N7,K,YT5NG:_Q_^$H\;^A_4G%/$+RBA+JZO,]'4/DKJ`JI!*A-
+MIK0D;L($''Y:N@UQ9-ZFN8Q>0($AR31IP_4?YQ,_`-_Q#][H71'7!]:'L=-S
+M^)`B=\#2]R>C%1%45R*,S*,"","B`[^3HJM?>:K2ZS7ZC;;38;',TE]MM)J=
+MAJL'>:_9;O$^U[7$1,4,04`LJ<JYA!/X"*`80@J!Y/BV#C^&AR9T'0<JG*<I
+MRAPTY01)P1,_J]#<TO'[W37M-+F\EPM?R&JX'%Z;/\+BN/L\AR-?1:/4W=/J
+M]1@8.!R.QUW"WNNV_#U/"X&[Y+<\EN.'H=QH^'N]OR?$[O?FKWNMND?YQ/J3
+MDKY&19V--<K$OFV7%LK*M[%&$L9F(@?],$35Z""+$!B9<R=DB:F:JC08FIWL
+MW'=125+K92Y;M7#I#>\KF:I4)FEJP(&X3*AS>G,=2R74A(TAR>O.^=8]C#AY
+M'P.\N\%'_"A/)$-*8*`+A',R^-\D[\;-[EWDQC6\PZ!>TC1/F(60+.>3DTN=
+M6'2_MTAP$.")3>.SYO7N[>7W^W;?Q8IRE7_NC*)M*TE"]PQQ`.#"IJ#QC/X'
+MGLI#X_O^C[,=E#H,@@FL!1!*3<;;=#&X=MT3;B1H(A8P<*:C26\'3X6WGB1$
+M/;'#E."P^\N+[HA'=&^_E,P.V%W24^W_<9J1VE%#["#VX/(/CP'\#\#$Y%>C
+MM^_/=[B\]L,\V"?>J&]J/9V]GEV]OLT]VWN^R3CVD39D][&D0JB@*&E&A4H*
+M2BDB@C%(B*5`4!8+!V-.2DUYRO';QAR.BA_?3[0QTMNQ9[H$/Q.>(N@D2PQ,
+ME'H,!`2`Y5H+T_?^<\Z<.YRK6WTV+5%NS:GV(FG$RA-$(^X(H)IU`-S88//`
+MEF<.[S6/"$&;0_;8![@B9?I_#]C/JS^F@'ZS[(\)4A2-(^D(;,"2'4+Z1D&&
+M4)<0!$@1$GC>Q8N2BC_#Q]7RY_=F89RR*J,*HBX_%8XYX**$&0Q<:^A4OZDE
+MVOT0X1<&B_$E`QV/R>*&"@DM&#&ZI[(A<``ZVSJS7%4F912,I@!`V?T62&!+
+MH'Q_QOO['D'?\;Z>WR-G$GO&7P`'Q?_3I/?MTX"3"1\@^3\C9\)?)&PQB7*]
+M0W_+Y7VT=[G[G&T5G8.))2!V#LAY>I#MX.<!V0\$+)9\-[\8_$AQS_?Y5J87
+MTHH.L,%@_6/4&R"Q9,0VXL28*>_^II1[OAX^XS;Q?JL=_']SOL*&SW\L_$&B
+M@05VG;9*B:10W(D05T'8BF7%;0MB/B0#"$USDXZ?/(M*/7@[^0\1_`N*F#HG
+M+#>*^9G?\S8*?H<KUC"/P6T@_42@GKL'T)U18',34HIB*H_H<D[/FFTL>4\T
+M18NZ;`!)`!RP,'Z*0CMFC0`4HB&P>?$#[&0.($#:%57<(4'2?ZO^3MH[CLSD
+M]V?('0Y$_]8>09O'<]__/I>20^G&@Q>04'*3`$5U#3[W1]5H]5@?MWDZ"<Y5
+MJWL;29G!UG!ON1T/#XGB=/IMGL^'Q]P,S'&2XK*,MUF#'W8C/04<&F&,O3N>
+M@D,P3,=&$T&8=A]M[6_8?YMY?^;<]S?2H5[Z)9D^!ON%=&9^%P'*AI++CE^3
+MX?(O"FAF5$*RC,QC;"#A%+BP9SA:04^-AZFXI^^U@#,C#M;\C"$@&'#PJ&CZ
+M!M;8D6Y[D9%$H'0+@(ZX.)-R,0GX?>3,Z&#Z$)(0-]:B)'[VQ8FP)=_H?1SF
+MYXSA.>-27AAD7!+5_]K4'=:J82?37N;154)F'OH+-H3;QM/R)"!+Z[6E5ZBW
+M['\6UEHAVCD$?!RS2/7[^O0%^JA>+L*S#KZT^[C3U!'Q;6D8>OX-E,&13MA/
+MC#!TX'.022/'M#\;9.SMDP#X1OYP;&=4]74&.T8CT'KT)[%U7*>6%G.-0R\P
+M].G$<Z]"(Y@)FR9"9L]EZO5JL:!I4QS_U<0EOX<$AMI+E@H1!,!H5*A/GN3^
+M7<,[5FS[[(7TO4$\.,Z<.B(P,?/\/36P,*@T#[@WU(/+.^NUFR/]$E6+CXM6
+MM:6+5J";O%H3F2T,9:ZCNAVU_T@=>(<57XW0,T?`29)05I'_:BT+]1@">D$<
+ME"A348@J(Y40G4TJ!O1N>U?/,@.418&-BTMS1-`01[`GNJ$SM,T+^V@XO10<
+MJ*J5>03[G+'0'J@_.N#;^O\.`=)ZA(M'VH%&2,^:J4=`\Z,KWA/S+P-+XX+G
+M?IJJ"8]A\'#^H=W0I#V.'^]GXE!0G[NU`F+YW58P1_@T"QJ-0C]281$`-*I0
+M?KU2C9P'%'SVA*_`APR$TSM['68IFN0<]'6[6R.OL951YSRX,0O)AF55CP$K
+M^=ZM(\;?%D]TNG.UOML53-$5=$]CL/BY`SW("O^#_?RJHJ"QA"1+JWX?WJ#=
+MFKN@6N%%>%72#^WB6LBP4F@<3.KAC#]XD<^$..8PY)<)GD&`?N>P@,(GZ4_'
+M_`'Y+62?R;A:6+_\.X2S>@94Q55;^K+<)K=P/RPYGVW<.)[_>9WT1%=P8$!2
+M>%,I"&3^U]0S[[O=:/ZL@J69T%S[\PR&8*H=O=L.]RG[N;W>;$5]]KGL./QE
+M/[R.ALBM7/'/?P.>X8_??IO>]_='?G)TJ'(R":+\R%1$P'<H^-L'="B,'3'W
+MB6D.PAL9U"CKM8#^@!D5JWNU%-@THW+0GB3BY-.D/W2:VN<C!(GIVJ0I!$F/
+MEA13N';B8C]7Z)[.P*)U=>&,=4I,E'23F$04$,G<'U:TK^%ZMYR,C)S,S,@\
+M!Y=7=ARM6&;84@8/ZH?T9F8T'T!V[ETO=,DH0W/9P]`^263!V#N#T:,"D/7X
+M>1XXFR`'QZT*OJ18B3IBHM,"]J]O6K(]D146@%),:V\!ZADH"Y&8X,H'563`
+MM\GAOF%D'0/AEB\AXO=6GND66HHC.@<?C\<%X1]6W0Z$=,0W8;F]".H5*&@I
+M@:>Z2?N2_\=`S,ZE0KP/@2%Y9%1U#W4?'8*8'I?_7)>:H=*&C8)L#3#X*)N*
+M[`]?BO8O"/<D\N-T>W<<ZR.RU0'U>K%_5.W]G/W)F)^["#']VS_&G]]+EY<H
+MT`T.%^;FY+LT8?ZUYD-C"C)_8)EU(D8@?9N9WO[W'F_WCFDSJ!SK6ORS=J"O
+MV*/TS\[^8GTA],F`W36M:"WQP;"+/WF&$F&Z$O^Y3E8>I'X;/G31?]Z,7]S@
+M\@IQ@?RWM8[^HG\!/P.1#)(?[!&2<.T$-:*JF#F456`7_R"BX(80GKZ!<3'@
+MDB)$D1`4_A'^)GS!SS0\[-IWL%3\/^E1A"[DI&K)0@HG^7)U`J[-MK@:_D%"
+MXCF+N$-X5UF:T.-2%1#,L=,=N-,@4?^,/Z@*'Z9G_.AF!H_<]S.H2*+B'=F%
+M??5-:G\F$A,T4F&DB*H*`6,*@_UHS25"+/YM%_LR?<_L!\*_-:5_/^FW[F61
+M[<[%U3X@M:U`L:SC`TD(D$U^$V5?ZI-F<UW?Z6;"IN9-SN%UHGN?'RF3Z3!^
+MN36::8!`0GZ!D/IO*K<WL]F1_MKP.P.N*HJ0R`]R-A^"C".U!3(9-:F9:75@
+MJG]DW870/E/VJ_Q_6?7L9L%V&#M6L:01!&"HHED=ZE+_2O8*>S]NM+3$55_`
+M_W5CP_TY*E.T,U:*/Y&=H`C$82QI1;^P_K?W>.W\&?_^:%`L]/G%%(GO7\O[
+MR_K7QAA]0@%=VI"D*5OE8JLK6I'@CE1-B'[`DXE1(Y.)GC#%X4U"@\5P.S7A
+M,K)GL@)C%3@ZE<,62&[V!,P[&]2S*G$VH+>DZ#[V!])@ID15/O24:220?M85
+M/X"9M<-$-,5`A;'^2*:(I_T@)@:39GUK8+OS$KQ9,KTI]D[S[75LTSO]N6GT
+MC@PE2@G.2]D5U5?'CK(:F*-H,VP,E990_;ZU8BZ+\J:S45$?Q,,2LR"XQRJ0
+M\O#B$:?D&DR:-LP^->'H\;8YCZ33ES^I@:UDS(#GZ-*FV!)`.'I[L'R1QPI_
+MAGZ(X=FY@=QW>Y^)T-C-\33@__X+.5>/,LFFBB(GZO_(F_/OP3U,UIV2T\YF
+MBO%\$R(@Y^[9UH8V=.114^ZR?^O!"Y2P_C:'/TAY/5KDUSL+M`*',L4.LQ#1
+M[JQV)QE&8GQD`U`0A!%"AQ0>;.5<8FFO7W6.%,D`[)V.<?1N1Y.*/XU3=CS"
+M#;B\#22*N/_^,@\\S,_D_V2[.>#'IF:B:DO=PU26U^QLW,+TX>L&'B*)<7JT
+M>/J__$TDN83-II&#[:IVI/#!83*C7I50-J*F\$%%&!DWH9F>7#W2)B8\:!$B
+MDJ+AJ*IL,J446,?J7FN>S^@4II-'[1UGEYU7C7FP%5&5%9AD4QT%%]'<N(GQ
+M][K?X1Q2$U\S4,4#(,RKF44B*SXI$ZXRP6M<4^`N4T"D_VY/*]@O%S_(#D[D
+MZ/Q#"DU#%+R8'[@]S\?^:T=O;A,D5[F*3]E#7O")O^'"N5#T8)]]/3];TS-:
+M),W..9$?XJ,_]:ISG2.1,ZJ*^XB2^**27&U4P2?YHG\]A>,PS.9%!^#Z:),D
+MF6+6$Q_;XO[LQU\P>$'^AAZ7>N@AR\#*9.M9[4:I)H=1&8T4'R4^(GM#Y7#1
+M]<+%BX%R)@U$SJ4^]]KL7P@@R6JBC."8I-WO.#US$#PD@@RP#_G%@.F\W7H^
+M`;;:`BIG2O)ABT<)C_40_L_[(F:=O"05I$<%:]4TFIFL*+GXP&N71,%@HK@M
+M2V`CBT0?(^@_WAXC#YING.0YP\QID,M2::E^WM$3;&8[1EGL!:-)DP2GW4N\
+M&H-C,F*&E@I:C"'(]D/1ANQ[,OH/5LU4+79&X<)X!<S',&_+%'2S"*$$S20R
+MY`/WW\>;4Q'DFX*L!3N?RPZ_>#\(7P&8S=K766O10L)>J(BD-W&7EL!+H-V,
+MO;LPUWM:HJB+/5MTH_"GEYSUXZ?\$ZGT;ATZ4=&U6+%+14Z#A:*.7%CG##1I
+M3D9XY5'*Y9"5$@HH?D&ZAFFA!8+BBJ:S][>GQX:_F7"]I2C*N?,4I>\HI!GP
+M+D#6:#_1<UFM9"ZYK2:290FRE3P>J'W?=L$B.@H<16W]38DX1#V/]%SC>]4/
+MZ]%FT*EF4R\]=0P7"D51/^)U\CZ!X.A^/\AGCM1K-N:IJN"Q1&1L4/-O[V]8
+M*:J3XB)_2_W'^+_/HRQFE)M4=FQ=8W@A3%C:EW,4W>CSK!L](N4I;8YVW?W^
+M'(+J8KO'"4$?\EE[<.[AQR4AQ(KD+%"#$56"EEM:65%9T/">L]@^=Y))_V4F
+M:QPTXKBC0OV3_7?YDYPU`Y++#\J0KW4!AB6E%+BIM$RQN''-4/012T*MR"H*
+M0VVGG#444P[/)LFX0T!A:FG/#;41>%A]AO@<;&+)5_%?6Z^)@Q!-M*L,5@(Y
+MO_L,M>E*8NM4"+3Y'7U&'OC:FJ7A#1N1K:UC)-'EGANR<I@HB\X;MH*NZDB'
+M1S8OMNTQ+=G,;N-/"@BOT&6998Q!^TDQ!O>U6"J+64C-:#^L$GX-^-/%FC1H
+MJNLOX/\ML'C@)+C5"5%B(JF0D!123VIIS49FGW/M)IWN$7UQ_SQ__9!_G3%L
+M2;\M<;%F??A"1*(:,E<S^K5EVJ51,%D+$J'/_5E?8_>@3-#B,S8:%,K(M!0V
+MJ5+T],RH61O''M&CU0$\]'K!W)']7+C_3=3>;J\@GVD<U\^=,7_+ZJL%U5<]
+MY1G?%"'X@M+L$59%CV,..ZZ=>%!!5Z'^ACRZ>L5B(GM#3FH:*HCG`$(E)!$_
+M"C[8'Z@.C]AP\:*:>=!`:+1>W;1HDV+%F_C8Z,]_+F?!._9CI<EZ18S!=".G
+M+,D';C4`E4\V;8:#E))PK'*A1FX0S1KZ.JHJ&K"4I8+ZX?Q#I5H7U#]O_C'_
+MHI2%YL,9,MDLBK$8?UZT?/I3F5#)55Q)VHT0QBE$+U3C-D/G-X?Y)_3P#VN2
+M]?7AG5D%T!G)]9OF^1FT14U"D@20KM3'-*FG`T+J>D/PF?CU=3>Y1<HUH-U9
+MN2?]$@52\@UFR<OV'..;+JY2BZ8**NER"DF1(YJ(6Q1;+O?UFF:^#HG_#IG^
+M=:9Y"4L*D17_@.0<<-*8C(3^M$ND/UD_M3'6V656AI@=J+-HC%+TQMFK"XIB
+M?S)N^>M71AT^;-;MO9E'XA5"78+F(2;VTE55&Q0G3_+#S%L<3\6=60&"-'$L
+M0"F*:$_S:J!M$J9;YVL+F6C8!&8#^M5!G",Z?%YXFF@)148_^'U_G>(ZNOQX
+MY'\CIB!Y9)A]OW.\]W.%[X/(-XB:13YM>.:I3%`3MXVFJ:57[.Q:\O%3+QHT
+MV0=X%\4"&H`_K^OZ/FY#V=%[-&$D<Q<%D#\MDK#6V#1E!$%H2D0[>_0<H//R
+MV"B#TG]]@P/)<I\)<JJJA_S_*B84\_CO57/6A-'1C%6#F%(62?R_<5;/I:[A
+M926N,JHS8CAP+%\%@G1XJ"JE7XGNJXR@KE-A#/L4`4BHOR)7P=?^`]CO*P9&
+ME&J2UFAES"&EB^_3BI.3_>U^[EOQ4W;,-A6,9\/P^_[1Y(1LREUF59$55$55
+M4UIN>3+!7]VWJEA`C`03;:A-J-V4HL<_3W]:;PPP,W.)+#(\><+3$+NS8RJY
+M3,2?7?3L6S.>"?1Z5U]W_&MZGUN[XMU0HE9`*$JUV!5%5:[.1<+5^$[<Y!8B
+M0^!OH@G$47>MR)Z060ZH'[OJ/3SQ[KP_'I#;:%)M/MI9"3M_I6DZ,2?</\:P
+M::T5*!*1-%G!J\/Q8ALIF5H52JZ22DX(/T?&[?\'P_-=#9ANQA6\LI<`X1MP
+M7XALP!@^/4^-YTK?[-0GDD-I3IOI.*-#U2]4#M`=8DCJ3T?;UI]/`$-$.]%(
+M7H04AV9*TALX0LDFQ)#B(?3@-N9\&G5$%6_!D8IDQ(ZV?OEZ?,&<9,[!B"8*
+M)?(7DJ&0FA0J0'I`C,OUQ`/*7?Q@:S]1"G2$H1ZSAQR-2[D&V0Y&=S\1F$-L
+M^70,*)FL$G$K65>BXR79*>6V+OX+A2.$:OB\_TK%Y+$GTL(%F0T224@^I-"L
+M0IR0H0ZG/!$I$:`!3/1.-<(J9D<"H2P#B!VF'HD':V]CV%VY(;;C=NLC;/G9
+MA!J8)?J*ABB_.V,=A]_**HPT/\H^4;+N,AMTKR\G4_[$@;TT^]A_-#0<)PX8
+MFPP_'T1+J,BC;![!-`>?K'%-#"/7-RY#HH`^K"+^I@1_I2)UP.XT$,Q0-23"
+M$H=<)AR)>,@OH"1!])#^F/_5_9^OZ#P\#_"_N?J-`=0P(?BWKF(.;&P'T@&K
+MA#!S^O@0<55U(`:0/[O3GT1E5686_8A8%0:)IK;(EM3L%03PHSQEYQ7ABL?C
+M*<'^OX?)4/W;*L,S20LA`+$ASZ#]+B,:`B=U=LOIP,R^_'_WB=9YC"K_BY'[
+M6*\37_VQN6R*;P)@>MWFEU/K_2^SY3UW2]/QW-6N)\[Z&]G]3TGIN5UOL]=$
+M;=>ES9_$5Z^(OL>P8[_S#':^VO^\>G4YNM<VSW75>7Z'T/V_2^F]3Y/U/M-W
+MWG=^;ZGE\]YC9>W]VW@'G/4_0/W?!-]'WO]O;?M[#WWH_020YT]TIX/L3_[]
+MWE?0=1_'[_B^X]C\P]QK/9^_\[Q^>]U[7V7[N@]T>L]O[_Y?N?:>[_IM_X_B
+M][^O^E\B=4)Y=/D>+D?M^6?\/A'YS$/^'\CXB?1/Z']C_)K_T?0_U_SY)]PO
+M>I^7^W]_Y_'_YZC[/L?W>/^X_V5#^Q_<^$?W/YGMCY!^HH];^'_I_?V/^2K_
+M,^X?R/@_`^G_3\OU/Y?#^]_G^'\/T?[/S'_#^)_KZ?_#]Y_D_6?Z/D?K_S]S
+M]7^3_I]G_O^K[\G^OY<I_+_G[OX_QT7Z3_9_7['\S^A_4_:?R/;'V/Z?S_G]
+MS^1TO]#^IA?V0_[_?XH']3ZO^O]_[_Q_T_\?^/^G_C_J_XG_%'^%_F'D:=(?
+M_P!!_U`2A_ZBC^Z5&@T*B*@*"N<JA[,%1Y[[ONVYC<^^F$D7U@'Q%4;^WZ?>
+M>#W//\?P-Q*A\Y3^W^?'SV7B1)?B(@N$HAT'-L?<Z?I>>Y3@V/82(GW/,^8Y
+M77QQ:)!!?V?"MYW>\E$B7D$Z+_'T5TY!/V_*^+Y!X:U0D_U=PG@'R?CZ].\[
+M/J=HD>B_5M/E?&^)N-&[WO^K/?>8\I>H^;\+Q9+_L;F@N!K?KS?.NB>Q\#/@
+MDOSKGM/9^OOHO]?L^I]'C)/11Q_,=5ON6V7"35K)]KZ7SN3FFY2:4A\QORZ;
+MZK_&V/FII(?)^-R/NKK^DA/S,)KVA$DB\2Y<C]1N]WI.!FPDX>SO3:;3.\U_
+MDT&!K?43>GGO"9UKI<CL=A_G4?6]A/V>'A5GU<Y/X\3A6X^[P/B:Z_H[?7FX
+MA11%`T&RFCFDP:OK.IG_EQ&VVVQHY[5>O[?N\7_>?T4TWQ>PL5(0NV^PT_HK
+M>?TLNP?)?YO7V(^.^=M/AX61/_KDI8^)N;W$SWA]/5DK]0WL[GE=8"?CA?U<
+M"[[27L8XHHM)[2/6XIU5ZWB^!WOF>3?=CY3:]3LD/R;SJ$PD_/F\=+XEOOX?
+M1XW@^?[";>YB;WMNDYJME9,KFDM()@:?T>EDB@=AHN3T6ABXG!TF_S^L\G4X
+M7W>QH]MW2(C_NUN!5_IFX?<7.?[7=^Y2;&O__)]]VDM^^T&CD_G9(L&MU&M(
+M^>MZ5+^CEHO]>8^[17UG.\O@?^]3D:CS?8X\E;_F#R67=^5A>VP?P_+I]UXA
+ML_U:3[^@_5M7_@K^Z?Q+J<>S"]_2*+)CK?SM_1T>B#P$\^MOP\SB+-OC/V=S
+M?>4UMSE?9_*F]_+Y798'8]#[GCN4ZG37-]^"=VCY:YPV\#H/I5,7A_2H=JN^
+M=6W'G.S]17AE77;S>;+2<#GN8CW?L.MY/B\7@[+$FZ_F>_QNGZ?028E?)Q-!
+MX>7/C[WF.!^/PYL[>5/*=Y_V!TW=YQKO6^;/+<KI>;.>XF+"LU)99;%%%<#F
+M?Z3S:RMU^K3?>PWO%ZC?<OA8^';X$?'`)@0U'H,;>6=-R]3^E]H<CO/M9_E-
+M++F>9CO<IP=&[W7'131G$OMZ6WQW?/GAN-%Q_GIZM$ON*=+'V/Y8\;VL=^>R
+M\UL?3-NG9>MRH>+1OOYYW<QR9GO<O.XKJ/+R8N@VIN>@\7+?:C]CX'D.=U'X
+MN8W<3_Q;+[O34^;M]7-QV5\S?]]S'S,_<V<VBJRPY7/10WZ)QAM+/7W_LT2G
+MYUJKI/4G9R\]"EW98<];>[+W7GMSH,B3=>SQ,'UW+0GV.#O>3^EX]]?Q\38Y
+M3B_1=7WEJ6KR&>T,+[A@ZC'X9\'C<D$Y*:WZ.K)5Y?NOW=Y\3Y6L]7UO1T]3
+MZGKKQ5M<CA>'4N_?BV][^O$7-OU^QB]KLO,D4.#XDCCP^K/+?[Y&.+PN^YWT
+M3S"4L<7Z?W>\V'57/9^FAS4/D3>NV/2WS<7Y[T_0;78DWK^ZV$G+>1\:;\/9
+M>4@;2G1ZG(\'7^<YCR,QF:GEY8M7Y7"YQ_3:EV+QTWW>]TN1\VG99<FSZ#,S
+M'M'_+2WVVIN1]S\GE/1[W6;;IK_L/(&WNU,.+\T=C"[F/(,3;?&PJL=2/6^=
+MY?!Y?F!'XDN/^QWDK[;[%CP_@:WEM`:BUW7LO):+:^EZ+K]=ZR./^&SZ9V4[
+M%TVMVT>PYW$S_!Z?/YOPO+ZZ+MN1C\KCU)\SZM2;<^+X$.*3.IH23OM)A5*G
+M/7SME;]%NO'JZ36R\?-[CJ>>XGY?)/\_ZR+L"^V_;:.YVV'G6SJ/$Y?>>3BB
+MYG<?SX>QDU?GJWOJQ>XCX$U_J?U<QY+M89/0Z75ZM.?Y3ROEN8V'GO)'O(>V
+M\QZV@).-BQN,HKXOW^1^]\FSYS_V;Z26*_CXKX>'D;8_9T^AUO:9,^31H*+Z
+MJG:>FDU=@ZCBO&Q=!\+M^>J2.P]SZAN3JF:[]TOI9NNX7H-AO_662223AU(O
+MH:H/8RWJMN+5[GZ\+[QXM?QO2<9S.UYE^YU=]]79:)-%I=SM^4^U5[OR?1\1
+MO/J;/73^XD=Q>_JQ?&J9T'NV'@>]>ZQTSO-G$\1L32;*B4W_G/+V/3PY@\X[
+MIL?YNP]_AV>WM3YE'82ZV:]:EY+FN#P<&S/@V<;:=;1S?,228WMO:/=B?0U_
+M10N>]]_@;#6>].FBZ'`S?G,W1=%LOK^4GUDDE>/<>XW/;HGU>RYC?\AX/P-%
+MS&_P]EE2R?_=0=1[^+@;+'IZF_LT[.+?]!\#D.WET$N^ZK0W;E]\3H^#[C=>
+MBQ(J_`W/KMQY'Z?4:7E]W]63T\5',_#RH=/>BK]'6MQ159<2+$L>G=N\3K-A
+M+B2O=_7X/9Z;XMST66_E9^2G_MT4ATT7@]8\Z*:7O-_N-'B>CX3W1\K/)-Q_
+M91=ORM,5BIY:?9[/X=.9K+%7B]YV.CQJ\6CQ87M'V7([N7G,GI_7]-6]_T7M
+MI?E69.5$36V)]YG?-B\1511%45:)^MS.)$@>Q`5$C4$.$8HBLAN%4-A_S@3_
+MSJA)(:(*3_Y+^?_M#L@?6@P`?Y2!?^R0H/X^8_%E>I13H*DG\?$_=?L1^=\H
+MY"G[R3_O12`KZ`[B(/ZNGNOTT']F.N/^C<P7]R>`*I2E8^F-&@5*!"(:!"")
+MH8H(K/"7^Z#_V@VW$0I5""$)J3ZNX>*[W?=`9@0*09$",!51_P?\WG\?!:K>
+M6LS#0@`L"!$JP'\S7_0,[#L,)0@D+$S8O9/'Y&.KKOV*@E_Y($XE_^[\O!/N
+M1A.7I\>E#`>Q(2`(UX>1CO_"4'*EHG2!<&,DG>3^Y!$@DDM]$"'__%BQC7I9
+MM1_H_46Z=LNM\Y\B*I;X*.^*(E`/IVBAP^9A/,P<XC@W3X@C.6RS:GY?R4_#
+M"$5H8&+0S*X9O<I=<Y_9/>]18VP0B>"N1DT"_+7BE3-5!/0KBKSBB4H$RHV>
+MHZ>#D0?]M?>8+(100&T:H@:N#=\HDHOWXP:S2@C&C4WBITR^*IOU`0YBEO9,
+MR?/43,!%!/3=;#Y.SVGKT00?G7_TYD[OD&/A0[O_`GE8;B?6>+]R`F:*>4Y6
+M/E>YA+]]A#U/5MF^G\IT'CT?9`]#ZJ7ZZ)[__4?3?.;\'52>N]=#_3Q!(M8`
+M,)V'IW!TET&DB#TZIRW>>JA\_G(@B[#[GD>R^Q%[^;?^3_UL-3'$*@=4LH>\
+MO[Y=C2$?X*X@82?^Z,OT95?^J%#ZW;]>:`'V6%'7^"8`>$:Y()_S:4U`HH':
+MLF$M^1C^LU@#^KCA-8K^QL[;;1FN3A^X5.84B5ZHR[=T2Q"1/C5]4DT+I!%$
+M3..S^'O'">&$$$C&M?0W5X!>4@^:']>I)!/AV;IW=_`AM`G@)R_X=^9N(;/M
+MC+RG!_FG^\*@Q`ZR:*DHH;^:&&`'[)/U,1(_U!^JZ0E0D8$4C:"P9'0R@GQP
+M4!`4W\'/0%$NI$*AW2QH0]^PGIC^?YO8^XC0#@>L`?_",()^#_X,/%(^,:!"
+M_0L/'\Z]1^A;<_RGP7#F(U9T@C,?_'<G!_&],<_)JG>W/_,RSK].HPZ\"HBH
+M,?R4$54%7J,GJ'ZQB,3MV\NOF'[)0\Q7B<CL/#PI>ZQ/"^+N<><3P,3(_7UV
+M>0`R.][_+S,4V5(FJ4RN)/_MYT.+H*DZ?5Q:FCT/W:VC\U_[9_E^?WG@^#QW
+M@[HR_!Z+P?!Q[_?XG@^#4\'0>#X/@^#X/@^#X.Q\'P?!UG@\WX/@^#X/.>#X
+M/@\EX/@^#X/@^#X/@[?P>K\'P?!]IX/@>!X'1]IT'@=[X'@>!X'@>!Z/P?!\
+M'P?!\'P?!]#]3YWQ?B^Y_]\CMP\AT*(JI]?WWG.]^YB2'EW?9[S5P\_Z;[/H
+MN^]G$5Q3_[GV1`]2=H)U6YE1/^\/\A0_OSA0V2`_B?GX#^I_B?E:?$H$P"^Z
+MR'E]JECE3$@1H@+@>7[KM:D"W^]B0`.]KVN[""S"UF9555555555;?XM_\JW
+M;;^XZ_UOXC+$/XOY_G\N/7SU\+/E.P=YWMUE$O^WA3Z'L,]VD)$2KA9::/JW
+M]T_RWEL[H2;M</RWT!^%U9A453J[&&9/8^V'9F7HSSL[59!=,HD>FS>Q[&&!
+M"[VCS&5(K+"XOE\\SZ5FM8"6Q-1Y"-70[W873$OGNPAV5W?E+>P\E>Q\'#\L
+MZ>IW&0S7_G8)@^9T?>X7F?,ZS4>8;59&R))=CY9^MW5F$UU<NTLAYS010T,T
+MVAZS,OLN%6Y;Q"70:O29&N<ZQH2+TK9%]455BW?GH;S7&%OW[S%A#=7,;R"7
+M,#S7%7=+H</4$?>8WES8\3K]ME:#9\#B2OD-*WI<C54P;`VE>IJXYAEBR!ES
+M(O#=%I;.EP.(P)*^C54TPCZNUL*3ZK*<[7NTNGM5+7)\"A'9NBI54PJ^I':-
+M[G&GVK>'\S1^'AIO<BF3*7664XEG.T8UMF&V,>H'XSHGOP=U%$\HTWG]Z\L&
+M_,CBFP-4[%-C6O.=O7XV$:\U7?U(M&_$39:NIKV;.V3UJ1Z+5:[(.!ML5SM;
+M8EJZ==3N3<:@V6VJVDF?:U^(L^YDUKM:[.TL-O%GH[%76)@;[=C]-<'9^XF6
+M_,?F:LTJ4YNNP,>IN[.5D3-;VBMOUT9HM_W]725-62%]5<YM.E8KKI=C>,S/
+MLJZU+[6"J\GV:E_1:.!7.#J=`ZHY=&-I<A,6_S][S1H.07'H,S3%U;.ENW;.
+MC*%70ZV715/:&HTR\69V5O-%F[.IEZ^6P;T[P2+=8G'P-V!!$X:*",((HBIV
+MWN/K=+]N`@(G4^E;]DA^K)4_5]WY?Q-A_0/\WV/R=D']=^E]FJJJJJJJJJJJ
+MJJ_=_!L>H?UQ_'!PYG</_<Z_H?:>U^E^;WE86]5-.<C_WKE^']=+'VO_*KO;
+M?]$L"?/*U:J9!T%7W-6L'H_-?7BAV[G=Y+9.$YBF5,S)-95-W=S,W:S,FJD3
+M?_VN>4%B@]\D&X[X;1OC=&Z-S+>Q[%@7'Q\.T1O?<'`%PO\#!KI"G8&R\SDA
+M6KYV='`R5`[Y211!*I4GI^6"J6K6@+9V/5%XBBY__SR:Y<CCF.-(L`XZ^OJQ
+MY#7:_*T._[!E+&QY.]U*(A6+=O*+QC>OY#%7+E+]$#$MW,(@9)06L27U#.%E
+MED,/#T8FP$D`($PBFZ@5-"L\\E&.5289B<''^3["N)\3CXB0L6(WGI(KD@*U
+M2IY.,4D*'&Q*Q5))%5Q%$<&^E5F[_X=DNDGT9C;F"M2I&*PL"]*452]>E+^_
+M^&:@II5192<I*)97%PG(B(C%QM`H9?+>97T'J,!^XWE>O=NVRW7*ZELQ!%+1
+MHM%'(JX$@TDJM//`Y:]BT45##JCWU2@55%C>_!(C?UA))!:M7LMI7*::<ZDB
+M;%(R**N28)>O351!$B)B8O3SV$P:#:=RVRE*M6W;P_06J]PE&,`M$\]LOB.1
+M5LB7Z5Y8*ONRAE5,$L6''Q1%**1:20I`)R$0PI[ET8KB:9X\P-LAJ$E)"NB(
+M1`E)1`<2EO+]9A8'\RO7EEHMBU2BDOKYXS/>60GGC*^6"+HD5;Q//=HI)2DS
+M0CCD($!2&1D63Q%%>_?@\3<TTOLNYW`^)DS+&_"JJJNNMK*/%^,;GMZ9Z*JK
+MX:9X#8_STZFFF>?CN8PJJN15<\Z:>/CXATY-S@RRP>!@Y.1570JEZ:F#--=:
+M.G3(_D>&FYNHJB.^^_!P>"?\O6C-*A-=55555BJJKY%5H8.O7.0_@_Y@[>!+
+MIZW_Q']OTZOHU5')GD+/^=[O#P5555BJJJJK(6"64I<3G#DDD+-F(I*BA;F(
+MR[=_E$%!01E4CCXN.I48*DTPN/,6">=B@>*?,A"]6(B69:E32F:B)C8T48LT
+MI8*IBH`7*A`>3321H!:'OJU=K*92(D44OA8&!>*".-Q4)BJ5*D<<A?1D9"$A
+M7@1EZ]%'"1%)!2**>?.F+<8>ODDJS*L`G&+MY5%>0*:7%^I8N3$P\_B6G#QY
+M)*^M)$.*1!$4=Y^P5`CDEKUY)D!$G*"M.4N))(AY.1#&L+H3"")6J35)YR@S
+MXHQ06IGE(PYCCQ]Z^M`XBCA"I3$0`.B)B@DD8MN=7FFB(HHHR8<YP^!7KQ15
+M"04FFRGDDDU\\H+`PPI%%7KBR7'""(Y8BBC,)9;%@C*2:;@/)7O<5",C'%(B
+M0!(%CGGN%C,T/@EC70+F7*:Z_9XX6+_T-MSPQA1\>3Q\?UL9#V,C4M=$41UT
+MTS.G3KJNNJJJK)(\F*?`H<4$<=DD)IE55IIH$@3WKTIE%0J$(1CRCA<8T-@^
+MCGG<UU5555[FVVQXYWO1OP>W,HZ&^Z*JO2J515515551555_GM%>_MVZ=/+R
+MW+WO?KONJJJJJJJ\FAY(Q''7'BJ*I117BBDB+)*3$\Y`E@,1J?S%***9?1_N
+MJ$-EO^02\.%0(""%L?0P*A[W=!H8+%(I(7((!.332%:M(1$<Y0EJT224D9-<
+M68>/01$,86..I4C.*`J5)!Y=NU[4<=49HRJ6B65X\DD))($<=-,1$*1D44G%
+M3%!"%-!11"$M!0JJ"T$Q%%_>@G+--4>/)!UBQ--)C2%`I7KL2RSD100)2*)[
+MU5(B(HTTH_8U"C,3(HHRR^X&7?P$T+>*&@P^1)L>.*,B\AA7??+KUQ"3]LFY
+MH6[&Y<SSL:90S$*A4%<Z0E&`M4TT45"(128GF)BDB0?"(B($"=V2>7EIISSJ
+M;FA#33Y#!N8A#;:QY`7DE[J-)(PA24/HA!!S8HEF646<9A:"<DDJQD"2BB..
+MO7J4TJM).3QQQ1$&6@9RJJN(SR_Z+=S1YY\%$%>(\'(X\,9/C(1ZID'(!&14
+M"")30JU:M<K^6:.Q&7+DLN`9YJJYAYG!>]PXWQC"C1F9&"7(28H#Y\40.&#`
+M[P'18H5`BJ))!!H6)``&[?',W%Y'7U^E#9%`ZS<Q##GSKVN?/CRR+2J4KZ(`
+M.0BW;V]I[`C[P>'<=G9L=)%^$1A0&4+/^O"H9^-^#_*-A_>_G&SI&W?RYX6"
+MP0$1.M4<H>ADCCD.[-C?]3S\_/K4I\Z(*%B<<I`!`3NZ/`Z(\*`EL0\M98C^
+M'C-X'>5G1;I01RH**BQ9NZ[_\$!-RF,N,N"]"RJ)!1$O+>ONBV_$00XSP.BV
+M#[:@OLL+K'9:7RF#E=9Y7,SJ-!-E_P\,\G];./&\#P.QVW>^-YRMZ'T?H_2>
+M'ZOR')[/W<S>BKIU_M]53X<GK[_,U']75^-[<7I<3N'V?Z&S=\>:J)GE011%
+M1`S[#`"B(B),#-4>X!_&O]/^M_"V^VW^+CCD1(Q!%$TQ^_`X@*B*I2(2HFJ$
+MHH2)B4HI:*8E(D*B*I2)"8B!B0F**$HH"(B4HH"(B$HH:HB2BEB(DHH"B)**
+M6(HIHH"@B&F@B&F@B6BAB$HHI**"(::"(::"(::"B@*"B@*"B@*"(8@HB6B@
+MB&F@B&F@B&(H(EHH**`H(AIH(AIH**`H**`H(A*"):*"B@IH(AIH(A*"B@*"
+M):*"(::"(::"BDHH**2B@B&F@B0B")"((AI*(AIH(AIH(AIH(AIH/AZ:"AHC
+M2LB$#C&-T'$O=%M8)Z=XP>7DV5#YA.O(S7U(G`(G#5#Q?)'TU3[6E9#*ZR-$
+MXI437^ZZ_VFRYZ($U,F7T;P-("@&N54!$OAG^V//#*OGV&9S,J[49E5[E]5Z
+M-[XH>#]SR/!XE4.NVFNF6[GH4M6&AYD"20]J3IW[;[W_E:_9Y/*X,_K>2X?)
+M'('0'ER0Y0Y<Y\YDBY_?V>:LS\[S>VU>TJVK_"X3<JNV1%,3%R@<EY[W%7?,
+M()D*82MHD&95U<VR=?I&^)F7U^'EWT1W0*@#B*7H#E&AU(Q"XW4H'YL>W)X*
+MX!*T8"DGQYG.55LD3"`.5-P==\@#WIM(XR->D<PXS0'=\[:=TWG#QJTMZTJM
+M:0"=F$6(JUSE)8_%(V7W%/T'-Z(\NY1Q%F9;O7&1IR661WB.2HKY$0]TN\<^
+M"O51?LN6#D[+929N3=+KHR<2N5\[#P#`,F%B001)45<%T]5;T(B#,LHS9;N9
+MOK\P3V$<BBZX`^\H.=@KDY+W!_6JI4XF$$/?""J"66`&3/*)[Z>]LHA]:K*&
+MI!2'[1'\_0_1^W_61QU_3Z?9\[[?"]LK`,SYNE`_,/#`47OD6(B1I!?UY_@9
+M62I^']>?];7[V>4010^C[#-OVF(/BXQ^3;\OFZ`7=(%3A,\)-*">$I>76W\_
+M<0#+05.K]>Q$H^J+SF!SE$Y6=(/^5L&V3=S_L//][G.VYF:-[46RH+1&5^E>
+MUXK'.EZ?#1&9&$;<\QB@_"JFVT&%'7/X<0RAT@-_Y>M(GN?@?X/XNP@]EUA%
+M'\^'QC))";1T"`ZR/>M>?!`\T?U(%7;?%R44@`N7T4+8$`D\_Y_XCU/O?[+Z
+M0]Q^_K)`2TJJ)/HF^FJ59[,,318<9VN=\_D^HE^?Z%_C<YGLZU^OCO2?>\6]
+M^NTB9HBC_"&7!\C@'Q@4I42]N,!68*1:7]F<=TL`AH8^.<-'Y*+'BCC1MH*X
+M<;56*9G2*;94"H*PJ&I4&5`54%5$%`'^)SOAN,2[BF-W+?W\G_&01!#EQ>/^
+MY:<86%I8S=["(ZGJTZI1G(E8%(R(3UB_`E5M(S+@_^^8FT47XT<4(I9)%6JM
+M>I4"RK"%?I7+H&<*X5E=9J6!K'G#^I@W4,1)F0*:U!15@F%G+^;*N>/W;F52
+M#OH8@RND\N[ATR2$9VDT=`KYIX=M^G8);1$`T^L[-M;K&91SF>KG,YRJA`1$
+M[%+O&#"L.%7!6L=1^E1=@/(18O"-=!("W##&O"B<Z+B&.R\L,B(DCF64H,A8
+M<\;",3L0-\QH%XR22)`,P;,%!2)KXOKY1=+?:GDVW,H2"@F?%291>V_VU8V.
+MC<E)T#0D\XNG5VD+)9578Y(VF(V%840<3'NX"(7R(1E;/QI#2(QYDBUR.)T0
+M/;1CH#%XDK%9E9GY\CU1E-.6A1$U0Z/UFM&'8!?1B&)!8>>S;`Z%4<5["X)$
+M3'1C)W$UO!$_ZAQ4+"?'\1\7X_(^+-S/:(2P!Z&Q'(#C.&03_9A#(#U5403&
+M[!<4GL;E;9;25:!4`28P5@71HF,@<B8D;$%\/G7:8LT#HD87%+1B8M]'%0(:
+M0:QETE++RD)%0Y0*H>W^_X*.#ZKGJ\0O&96_S./*V%C8RXCJP1XPPAZ]AD0[
+MO4\&@?AFWZQ.\55*3SK.\Z//;,;1^I_Y4_]W'#N2:T9Z5/R_DC]]I`#]XDBA
+M]EI][?O.(4-TH@@),=9G1/$..0>H*C]V0*67JED$D$$1")RJ*R"(;]`4%44]
+MIRF_Y3VGI>MZ_=V;3^%S447)T8&;4J7]2B;3:6MV5>*O7DK]E+@3-?%)PH0P
+M</LL2:^LUL:W<[/E\#)JW;>/S&);B+]<B_P5&@]Q7MWT.GP,'<6;M_A>2Q+-
+MOMK[!P\7*PN9PL+%QL?*R<C+R<O+R,C(R,C(R,C(R,C(Q\?'Q\?'Q\?'Q\DL
+MY66X4AA7:LN'?=I+3FX+J+359<AV7<QL')CN7,M:MO-<_&K865+E$YA8&3BX
+MURM<KP?1D5LJ222F6YA4XEZI:IIFM6)9Y[$^;/AX:U!5+^_6A[PP79F9-'(L
+M9EK:J-6R;>;=JVLW,+M:.UDWU]"S9KUL6:::F^R\NO<M6<FQ8K8EZ*U'`M9=
+MNK5J7:M-,]2U2@RH1X^#6B%&6#EM.<L5R`/?>R7/6*Y<L46J\L=J>6KFW<:_
+MQ+V'C6\3+S,/(S,3+R<;)QLO)R<O(R,C(R,K)R<G)R<G)R<G)R<G)R<G)):;
+M5BQE59,3/T23Q8=>?)N85C`J8][&OLS"R\/'PL;*QLK&R,S&R,O*R\W-S<S+
+MR\O+R\O+R\O+R\O+R\O+A:A>J5&J1WHS$HL8&39R+-[%LUZ<NMA9%S`QKV#C
+M96'BY.)C9.)C9.5DY&1D9&1D9&3DY.3DY.3DY.3DY.3DY.;+!<S(ADU\B6.C
+M+J7)I,+`M8[URU&455416;,Q,3!S<#)PXXZ+$,&M%%9S!JCL1<S+'6UV][]:
+MSRZ_1VS]VE[H^#UTZ%L'UGXM2E>//ROOI6N34KY-:B]4O54,=<I\)[=K!C@J
+M5Y:'/5<!KRU\N9K]K18P<W(?+>HS:+%RK=O\*]C8%NY?8N-@Y&;DX^3CYN7F
+M8^9;MV[=O)MV[=NW;MV[=NW;MV[=N3-LY-C!GO\>SC4WV5A6\6WB9N5@Y5]C
+M7V%DX>/EX^9EY&7DY>7F5Z]>O7KUZ]>O6K5JU:M6=3?Y,]O%M8DMC`R*^!CV
+M+V+E7L;*O\3)O\/(S,7)R\?(R[=NW;MV[>3;MV[=NW;MV[=NW;MPS<7*P+52
+M7'P[UFKDXV#>M5,C$R\C$P,R>K9OLK'Q,+&LW+ZQD8^-B9-_@X>+CY>7EXV/
+MD9.7F6[=NW;MV[=NW;MV[=NW;MV[=NWENNVZ'8-W+FS<]@4XE4ST5%6H3X<D
+MCHL\XRG8C*R-GEBO7,J#[UW)Q"^Q%BNY=_BV<&W<GFNY=Y\+Y6MQLJLRJRX&
+M1798XUOW/45Q@=N;+=5K&=OG'7KMVSQK7?Z^OCKC3P^!\4QQN:]<?1;;PVJ+
+M+BQ9\$K\UF.954EON*2(K*;_O3Z[TTEFI9[.7S6LW&@^GXWGOX_N_;^NW_K/
+M?H_?R4^^_E@F"6Q,#3H#",*@JIBH"(#(C`,@MD0V!+@TJ>U#A]E@FT*GBJ1`
+MV@`/CP(4HY`@+!_2(#]GG_S:03M_M?7<!UG\E%[KT[Q,1:M+)OOD_?\AWZ?!
+M^@W*][[I\(/A)')K\*@OT467L1R`#A4[$?Z8<GU.!+])HH_K21.9SE(>'*B?
+M&^,;AQVJZK[7+\L\4&&0)S^W`X_=UB)$N8[((PJ5Q43Z*B):%K*B'9%QD/M9
+M3()G5SWPY`[P5$#\2`*)YM=DI@!\MRJ_J2)[,_,S'K/G]M6O>+R3_N_.,_ED
+MKY8/B&3Y_NE?E*?\5*:BBX@YTJO96ANX)SRB(:=4[I:IBY9[)O[0`-**7A;_
+M(9//_M5<WY97@"ERU;5Z5C*QG!1//[A;=3O+^1+^@:NHUW/_C6^+Z$D?(J@B
+M92@8V,WH%P50UHI?X%B'M<0B0_7;Q3%9?>P1+8I`4WB<)%]<N+O'AVZ*B'XA
+MPP@YWKR3.P6RI58=C+C-)IB&=C__*.XU40U2B(AM#L4UKAZ.1ND;D4ZKRT(U
+MV_':WTO:]1HOAR?%^S=EW/I_G_:_'^#^G^-W]#_7#ZW"L"B*B*(I$PPA[B"O
+MMX8(,H?[)9$4[%4RHJ?@4-(*'T.@Z/V7I/RZKX$AQOI/>?->B?IKFTP?9.V8
+MQ[%S?.^S.J@J*=,O6GRV>M5D9%4QYI9IJ:9)%5#4B%2.2M#+/YN':##,8DD<
+M-6^3XW^3H1]1O*P^MK_&H^%-S$G[\^_X6U/1[6]YM[/5PKGN<=9:+PY"(`W:
+M:5UI<%CC!4^^[7P^J+]47;BF+\,S-.^KI%9O<>I=45$`JBB)_\*(AE'7,(&4
+M*@ARM/J[7)<Z=9EF6@'V3VU(*3ZDDGP,P/@U7XOY=S[8F$T^[^*_W!\O?ZI%
+MV'Y\B?Q,E+!JS/FF(D#*7%%O]0OZ&P3U^=8LHLFL2H5"Y"(58CT[.L#,K0E6
+MI&:PUYK2T4F+4%U)<>/):E5?UNQMO[`0Q?<EF(]G0=B4DT"3'UTL*(@RU_23
+M8"9NV(4??K;C!&?4B:C1CL`TF*9E?<K8(1@&*9%%*J_*(#7=6,"E[U-C_BPP
+MA<,7'R,/*+_"6SKI"S0P-(E!0;XX5M$QY),"^P&=*3$0IK?HW=9P(R,$U2B2
+MJB<AJ>00<&X\QAL.1$`3:=[[?VFTUW0NV$3N*Z.;U]6M[#80#P%>IQRN6TRT
+M^D]MQ=KS?M?$I\3U]>K[C`]SO/<^);2ES(5XFOZNR=5YC#OX['N(6ZFE[+W/
+MD<V_JE_68OE1)/HHV5GL:OBKES6X5+V<)*^3%6LM%:*)]2A2ZXQG(A3"E[RE
+M3084]E^5)Y;[C[U>Q4^I4X6+Y?OO*8>X^5[#L>\V%O[U[\WTN2_A4Z[O/L>/
+MUF_ZGB^%O_\[SW?[/N9W^_.=QV'[/P?YS]X/G*'V`4"@1(A`51'S/K\T)[/_
+M)[G[G^KY_1$:'<*(?\7ZO9\T.1$\;KF0]/Y[;?;<<7(W&^NY:E?`55W[,+')
+M)')/-/*DJ+5\:H38GC?N%UGN?T\8L9W1R*;+O>?4'$7\>M/K^HA'\!_W*9>=
+MYHZ6]"A32?U:EU9`@J'Z?*POKWT2.[:]9;BM75X5R$(WCW>\<YT\:+/2ZE92
+M"V(V_F0EH09:A15K]M[9S4U;455@*Z@6?YS\EZ/5\6#N:<?ZE>WC2Q2LLG&R
+MJK[;;7O;X3)\QEM,F(R"'FGKO-8_,Z0T!U!T1$3B(?T_@OT>Y,V8=Y3E+_W$
+ML))8R9?.:*.;:?EL[.CN8YY?U5[=3P(6*G%6"WW-:-W->LKVH4K1'-6LU>7J
+M1W<\8)AH`711P<VPQUN3.-UHO7;DE\E:,]YT\O%G[AMZFXZ*Q^DQ@888PRM%
+MH:OM*Y!+NAVOP-^G5!7MPV&V7;ZZ^JOVVY@;[XK%_#9;FV82GKCI=69\>B)E
+M;+!5=LF[A4(FI`XA6D#4EHDAP%XG6*4`Y:=Z<!R/*$DOVW[QJ"/Z#48S)?13
+M.*JR>=@ZB<'T$\B&QRFY2P/T&&_G><]U>^'W/WYUU^A*DC*3"Z"6K`.-@40:
+MG$JD;XJU$^5=B*C2QX1L"_+8"*.-P739[&OBSWUNLNSXHPN+7/-H'8VBI_@J
+M(9A3I&+YW76*D>>*9\6O1P:Q0V0_"$JXV-F966RR.(Q-<*46$"X9DM2"+39U
+M?$DA@S6DEQ>),F'P23-5<TN5K&!<FFJ6(TMN%H-41[LNQY.'&:#6Y&95B+!8
+M&L)?9!E1\I31C^P=OBO1I<S*T-".?=-H8QC%!K^VO@2"F7G&@*?XKG*D%0#<
+M%9B*LYVP&><:BO0X0HHI%BFTVBBZ@^ZE@N&A$E/-]FL27Q@XF$8.8:"9,+`8
+M>J:5=`HRC*.70*@FVQC@F*8'&E3"DGWI7U^R()GL*PVPLH5'2C?8VY(:#"R<
+ME6<YSL@ABBUKI?$#(`$O')\4:>ON#4.=;XI2LE8GI%%9:ALCA$VDCR"9D+Q4
+M<3\@4#J!Y:-$>;O/%1X\IYVK:=-5<[2FFPRA*%7AET<5!PP/.4'EPFW&X,'!
+M^)?REII,?(55N<N6JI6,CN5R3F/R_&Q6C)##0&&,.QI!:;#ZW)FQV,IGC#*#
+M$S,Q5S!Y&8-53FBHZT6CRV?*2DYHAB8N>SU@R",P2_P*W#Y=RLUFHS1F'2?A
+MP2R:PW)@G&&$:'S*?D1.J!41?LJC(.1Z,B3$BBJ520R2[8X1=MKAF&+#5FE&
+MN$MS0:32+F.PM@5;2<;F#A3+,XR`3L%OE$#]0BH)\(Y@`9!->B@'01B,B(=]
+MP6\^K-5DY#)8%@W@NJ.D5\C/5(.ATRTHB(J""@A01.Y]=-Z+C+%CYG4]/Z+Y
+MOA5K?&:;"H\;G+7AZJWR^MUGU/I?);R.O\Q\3UZ_<Y'I=MWWM?K^;\/[7X?O
+MZ*\AHT%4014%$$]AXPB.30C.P"^WAB*Q$/\/Z_%UG\K1I;:-O]]GJ/5[*P,-
+MZY3/YB?;S(Q,/[3!!%"]O8:]XB!\A%F1$`^98=_;]7_<H_>P[=(FH.5[B5-1
+MV$6J_IX)[<]+Y6P[Z"?-^3$]_:="2Q1PBBDEFE3MO<422^G,C@EH/4&5/QIH
+MV;W_O>.Y+2B<=.5JWHJJBG\NRAY?E?R$/@.WWB['`5SZ7-)(M0Z,@,)L-2W+
+M>[-_QT9[K:E[<KC.F>]SWAJO?]<ZK$S"O5SWN,E1.<G8+XK#"8K#(B<Y0P:!
+M0TQ@D_O1X:*48/E>J.);X6,840>]%!">LP%\5V"\H-!@P51$*PH;T]]7'`>8
+M!0,90I%#QQ0-\6<%P<LH5&8$=6&#U-A@]*G7LJH4%D9,/[4!U\>1H^'5OKXN
+MDA@*,8GJ30/$D\SRJBQ.F]61&CU".-,;1-01%\2RN`T&4:!^"O[(BO379F9P
+M0F:\^"JL\4O'D=P8*Y>*Y28Q9D->;;DYS[,-Y4:KD<1;CX$I2=*;R8+ZJ?VD
+MFQL>*Q;Q0S"_*$4PL-56I4K5C>OEK:#!%OZ3<&MUNG]2NH-=",0T6.4Z`>99
+MC#!N3C"R9DF*JT1I@8.(S+.9*9XEEU^C-&RYG<RD"E#9&87<2C'9V'AK6*:"
+MK<XJH(:54#$4#.5`R501-HL:HGS5K9AD[C]4=OB.HR/0?=[?IU['N/->WP_+
+M:_O-3S/\I_^G^/"]A[?YOL^N\W^/53><T_T?A>B\Y]WWWT_\>!];Y&E00T"(
+M@*@@B:D!11%WB(P*P"BJ*@JIWGT<KZ#T@B*(@(F^5/W]1[+V4<#IOL_/ROVP
+M$YO65/MO1$0OUZS9].JN_M_GR=4Z/M[*?_+A<+P:]B**$4DGAU(OKI,@AY!0
+M1Z@86\]^=A]=VM\8RSG#?'R(DH*!J"=$_:?;>0%4'KP'.'**JJ*HJTQ.%J;K
+M"EDJ2HTC*=O9[GT`XS/5]9?R?*+[)-=F,(JA$J#*D^R9-/TGF3W!AB(?<=[0
+M^GOG%?XF'9\CY9O".R9A1_C]VY-!]!SOF;%F9%5%9(YY2=GAB_-'1/UOM&67
+MT,(X"C\&9GOL!?1&R&.&+,7GZI`S?-^'C:*<Y@^6GC_*^=L(S_Y7_Z%814JU
+M4_^-'+(5U:;_YES5=5>GWAU1SFC54NF9;&><][W^Q_TE5D(?`3?T/H>67\2R
+MI^F:WZ54?'/"?+K3R<%A>6=)V^EXYWWC>ES8(9$L)1GK&^:!*PPL844/Z6>[
+M),!+,B>5A<]=0AL%O%H4J'B]+J!VP%*2VM9;=EU%+7MF\>J)MF8MJRI.B)N%
+M$?&2AJ5=2)2I2I]D0.1_]G]D^)H!-H!6E&E7D?])'Z?H/M7F/9'[/7`>'QO&
+M!/&FR.?3D+^_RFG".A>EF=>%%7C]3PK.VF,?_"BL.C@9SS$/EY`G"!]KYJB>
+M'S6/K)Z)\^*R^*MA-6SDWMKG=N.>2M_U?P5,.S"NAE["6KIL3>Y5_W:..NV5
+MYE:$'###-\@7DW/)0DIB3M7,GW_-K(5%4E(%*TK6%QEWHI$J1(2,J+I"NSI6
+MJZ!C[)0-?$ZSA(@.O@M60G'^O_F_S%)*Q69SE#P_/B?]<LT:^TZODSE4ZYX*
+MUO%+_\(62]==83"_5XERZJK.3']6VP\D,'NS4MQDI]W/R_UVIQ[?1N4^MBB\
+MBL<9GL&O7-B:VS9+5U56MA<UYS"315<8OL'NIB_MG['5*M$ODBS\7*MB_#\2
+M=/>)]9!Z';O9]2HNSQ*<;'6P;$GO[=WPQ^1YM64`51$%$SN!UKGJ@B)O>S&7
+MMOG<QJH_<^A;C^AWNSY/<5:O$6^!6R-IR^@W'1]!1W:U\KL5TQW>NWW<GUK6
+M>\#X7)^5_YW7X?8<5_/Z7K;FE1,D1+)J%&4/),A\9$%33J`>T6Q]1LY?%Z7$
+M"_9G(VG2"'R>K$^"=UV2K#K%7S?QSJNH^D\ZP[?XL;U])X5;OO\1R221R7J*
+M:?WSF6+[SY;.V-Q5ILU=?<^KY.-5O_![\.!'XGSE%C/,6NC\RG7'_T0O%'UO
+ML7+?N#ZD@L;>D55/`7VJ^^4Y6_;CET=3TCL9?MK7\^V0O<KR*W5M+\=>U7[J
+M\FN&O+JEE?/KWJ_G7HUK:)JRU%>MA=$O=+?K>7`4Q5OU]8O-JR_L6A?\K77,
+MMM<6HOP5^"LZ^B6)=SQ5UPO5^EZT_YKQ`UJ*J*:4_)N<].+L$CJ'"RHA6/<*
+M0F#$(AO17!Q*+BB]C+*PK>79RQ.5I='R+H8>\"2GTY"!/G87'W7S]BU^:#_E
+MU42J_YYG[L(B1C_4J083^MD6@ZTTF)K^R['/@*Z#,RHP,/9AF&&:TFY[;,\E
+MY"A_XZ,22AG>DT8)`_\Y^_^G^S_M?_G?_/?V?K]N[N[N[N[N[N[N[N[N[NW=
+MW=[Z`1#Q@1"QQDAN,$73.P].`VQQAB,_'_EMD+JCAX68/&+'P?DLGPI\C1C\
+MJJJ^MI555555555:N>UV^GZUOUD^+CXW]7Y?D^:_8`(;"$4`@BHR`E#^-(4!
+MD`M*K$*%"A^>R('("#$2&4&%@47AMAB(DK;,1%2'-F*-:)C@1MMMHH(M8"Y!
+MDB(FT8B&)YMLY3;!$0JBY:IA*4"@>3;EQ'D`&H(!B6FD"D*B(F5@HJFD1+--
+M0U%8`+$K2C@L`F$FN[.P]CEM?)V,.SFO,(>9"62>+RXL10D!,B"2*H**$_9D
+M;\58?GA(7K^QJ^+U:E6PGY7.%"E$HLIQXB6+;D*BA!4W]Z^M/#=&$6T!*BB!
+M^S`00D%D4&B$HAHH*B250!/W\-%^>OS0X_/AE<T;)H2D2E-"&E:0.S,.J0H#
+MP+L`]C3C8:4I>D)1H<U*4.ERA!0!H'0!<(R%FL:5#21"<EX020%(M(E.@I#2
+ME#<;:`Y(UI")Y"4D%$H')TJTKR#$`?SXW&L`4(=D-#2'!@H4.6A2B6&D+90W
+M&L+0I%&Q0S1#1R<2.D,,@TJ4%&C6@T(ZW-&LE"ADL0:$II7B1)`E"T:$I0H"
+MD:5Y!R'G&LAH():QS+R2@*6E-+@20*0W]C!R`I0I#D.2.R[&M833!*4F)'24
+M!R"BD*1H-PM2A0#0FA'9K`:T)F:0,3R'DE`A0ND#2)<R)R>+S1K"%`4#I"E0
+MK>OW8_?;[BU2!2\0&I=0!,1+1$."X0)B$.32)2%(E#H`TJ;5DDB1J$Y&XUA&
+M(730\E-*TJXY@Y*4M,%R#1XP#NM9&EI=-*T@%(Z1UV!Q!-3*04B7&LM#0&N1
+MR>2IR:#,')0T4L550*8(Q"XA8V"FA$Y-L!R!<0P5`4H-L1K"4%)I"@I0-#I#
+MD.EFF1*5#2:XZP4.G0FFD*5=(:!H2**E:1I%-5$Z&J<0AI:`=(&A_AC)-<M;
+M*Z%I1;-9*"@#0!0[N5H-<)@@*!I0#1MHML4.E:T`&ADA:$Y%.A:$"D'A;:+;
+M`Z&V!-*2$M(M*TJQ#B4*VT6J8LE'YGY?,\\SVNCQ>K<_^5[M*2U<0.&9)3)%
+M6"I$I1H`I1H0--IMH:'0-#[V$@DK2%"&@6&*0H-*:0*0>3%B'!&A::&:A6@2
+MA"G2B<D=%&G7,U@TA00SB0#0`4)2@<D>04-`<QJUHT4,$TH-*L2E"AH:!T&V
+M:0@F(=3(:6E2D6FA:`#0+I-+F(M!JAHW(U`<E&@"EI*0H+Y0.-55Q$T`=E>R
+MS1S*4')YMN:-9-(M+"FP+I:4-5$1)$+2AFBT#0FE+&M8-S(\E3DHTH4@:$#0
+M3RP<@:Y/(&XV-:`2A&D*!TH&AF"D'<P:0.28(TQ"E+R#2H44G)%Q!!(ND?Y=
+MN3V%TW&V@=')'2#0O)=*4!)X?B/!0[`T!V4:8V=`-`>2M+S8Y#0@0NPAR&E*
+M!`R0I&D72P.2+2*?'\?I]/TO2?_Z=`$4?-T44.H:2FD:2JIJJ:$B*($*44AA
+M'2"';#B*PGNL&2I?VXI6>RJI**2E9H-+V:..73B&BF*E(B)B2):2J%[+JGU`
+MZGUA-/-J2EV=2TT)41I[!RH.0:$['8>2-"TG=E-.B)8AH(F@)@H:H*B729[A
+MU01%+I=%4!45,R48;8#)B5UJ)8BAF:';*5125211#2)04,2D6@H30E`$0N@T
+MF(331IU0Q(4$0TT.PX7_9+"0LI*3!4%1R`T),Q)3354D1,:#-$-!5"4C5+24
+MT]@T%%-)03#2E14%#3$U$L0E4%S&JB(L-,BQ89DJ!05(G3M_J:=?G';4A-=0
+MH7UML:1K;8VX,*'4^T:"0/**HI)*AHB(7"48SI0DD$#&<)4G/I`4"&@!U)0:
+MD43)J::##H2M(6RF@:%I5T@&E$T(XD-+$K31!W"AZH@#^237M(T#2.&Q^!.(
+MF2*"JJ4FIJ)JF:)JBFIJ*"BJH("D"J:%:&J#BVEB"FJBH4P\SSCM::*1-121
+M1[0ET_]E'$*(.0L%%5(5F#%2]_'-6P?/AGQAJB:*(I:0Q%5,4U,)H':`TPLX
+M`XA0%'H]GQ>'9QA]+Q%S1-E^LZ"^M&QH/PEI#D'8HI2A(J2J**&BJ"AIII1H
+M2BD"D"J2@I*:8IF^[(8FF@:2AJDHH6@*"AI*"@II*1IHI$I%Y*GD!2&DKF5R
+M.C2M%&DWST.]'&L:S$=RK#)3R$TKH2A*3C"4<GUS*<@YBVJ'0]"$Y!H=%UK+
+MR3D@T:PLFC2!H>2%"4\:DII6N5!0?K+R.12;K6+EOHP=2-!0;3U?1Z_T=DY3
+MQ*Y+0>Q@I2@>0!2E*:"XVUH#DX)^-NR=CD:4HY"E'&C93E3Q@?X[D`\@ZU&J
+M*H;F*<-]MN2T]E-!7Y]'4%3=@.D&AY$D4TH*')="QS$:YP.`D%)^4Y8$H3L+
+ML60DA[-S.GFL$SE@Y(#)%"0I/P>_V%ML%%QD:P^Z(>0\CDB4<20.2Z-')'A!
+MZE7D\M":Q&.M8.2FCD'(0PT'VP!H[`]DW!QR`Q(.D(EV,-.N-0:H-<D.2AH,
+MD)R!"@*%TA0#8L)R`P24%)MGFFYSD(<CD&M#@D-%.9BE.H*`-%T_;^WH#>>(
+M7B1I6YA.<XUQY!R"JML4H2_?+H#Z?&([U!Q#0N]2E*4`4:E34\DMHUDP$A#"
+ME".@H7$+0A?67D#R[`\.&MHVUR#C1+0TBZ`IY4FN$:30#H>1QD-219`0Z:P<
+MD'T>-#[WQ_'\"X!Z0_$+\D@:*TAR!H#2G)>6@DFKFC6330C_#9'LI0=AI#D,
+M0O*A>0+R`*&"H2ELU@TB\D-`<-DT!2:!CF!_;84[*'9DAY.(0HN-8.0)0CEE
+MK-:7PC8A#4*9`3,2=OB[]&PL-[L!H*QZ;:430%&('24AH5PP-`T(46;&EY"T
+MA2&DUI'AL\E'\+AW!W#F2Y)I0H3D:6X:VT@9(H'DIPG0!PN2+DYAT!$4AI#2
+M"Z&D&U"4T`68%F$+#`4K;,_L_X>@_-OF`<"AUTC/XFZ+V9B$#L22PY5L6P1!
+MQDO%X(Q%-MW"_F'XN2W"B%:OI-M`727NV(S[AR7]/K]6GT!$1!!-0JJ*HJG\
+M,JAH$$I%G6@HE2@"B4$%400$5"3PM^"(4*XJ\J+KW<^[C!75;S1/Y87F,]N8
+MARORA>(@PKX.%;C>@55H@*_;N%U6BUY1Q&9L<O,U>!JJFS?M!T'Z7'UK7XG3
+MMO*^UQ-#GZK:._OM77DCVMD][<K0EHCE,>.SB5182#UH=LYCA01\2.=94`(!
+M#%<B'Z>HP]*(`FP4$0I!B14JE`H8E5@210B&@:1B189W]=D0_:7H;CP="43`
+MVVF*(*H-(G\L4)3<L/.AD>R-*Q(-`<$XL&("R."W!"D($:BR@8N,H8$4B-#P
+MW"D.%$<X9..)#BFJ6DF%RP+`P4R%Q$J&0ER9/Y!]#]Y_T5J*=*/),.ORV)?1
+M1*O2C%.^RM!A-P01`#7H@*B(JH)+*20)`D20B2,"2D`A!`D,J,D*D*`#`+-`
+MH22L0U*$$)#0P200)2P$D@04,I!($H0P$*A)#)(T$RRE%"Q$0,(BPRTBD$,M
+M`A)"$B@4JK"T-*,P@_0[CZ]ZOJUS_O#1]_X?)[_R81*OHO^JLM>HN18@2&!J
+M86**F\Q@1#&T6<"?UXI@Z(_G:K<)5:\5M35?L]HHNL)3SANU55BVX4<0/EXI
+M9G.9SN+SY/97FMC3GN1Y)Q4)L^2G($?5H[H11561A5X"HK-$JL<ZYZJZ.T?*
+M1'%4B*)1]<W]6N1CX1N-Z*;,Z?QG<\JQMQ8LG+M.JP;FE7(<[EE7'L'O^0QC
+ME"3XEOCR=']8-S`H[LNZ8ZP>FY5:<,<FC5>=-#HE?HE5=>J^3HP?)M^N_O_2
+MKY>I?=:4FH%.C.UT#N,%TB)5;H%7KF57=9UFFTQMS;PL1R:U59&Z-5;6CL=5
+M=KW&&#QC+%-:O"5>C95<=0,;)>859QN65<?'R&A#E%6MD_B`1_#5=GFCM@*Q
+MH])?:_3$1)4&V@N&;UL)5UHQ%VEAVJW;-VO,=;Q%[<$>^55WJK2!@;I+8FZ'
+MD6?%VOVQ'[X>CQ7*Y5CPG<V+#[_=NF57H((VR561L15X_`0-^I;\/E9?Y8G<
+M?$_5J/X'M<7<_,XWC\CZ7>XV7RN+R^G^/^K[7C_IDT'N=!QV^\?X.[_E^K^7
+M.>0_.N'_[1(B!GE!.W]9ZGGKV=Y!_<<USJ\[P-YV>QZ3)_-^WV]SVUC\WIN-
+M^5_N&`=ENOX>'@7<_ZW6<#]7I]5_[VO\*QK14/W;_\^T_'S*%.7]N,_4PJJL
+M"$<;XCT"ISGL>G^.=YK*^+$CF]E&5?]'9?H]4GLT56_AX_R^WY;E[FA?,R$(
+MXW2*>'\FV)]>O#_9<UY[](?[VAS$R"&;@((6?):M#./G^0RZQVW=*+1H?QXV
+M;D21*Q9+@ZU=/@_DD[B>,P:,G/J_J+_X&-H^S<L;:U:CE:7Z3XY7Y!<+1;K=
+M@WI<;\9W)KZM?-?K/0E6DV^ICD-D?(8-7";ZY;\ME_456T)H="M]^\S%5</V
+MQ3)_"V/U'(?L6N2T6_.^5;KE92I7L*+6OQRN9F:6+%7Y(FQ&%_V<1G&7KZ)M
+MO^"KC7"YE+GIZE0=6MTUB>?TRYTRYQ"6G93+AX=`^*_,`61[.NZ$JUEO2?5T
+M.29++1@9Q_$U6)M0^_T\1IL3$Q%LEB^0S=CQ0&*\0>NOY3:9.RZ?8;'@<7M?
+M%XO<=/OOU6N.SOU<"^\+;[WS/%_SY'CONXO]N#N-^_X_?ZW,RLO+RLO+R\O+
+MR\O*R\O*R[2"'9)T)^K"_1[";07.S^?\;>^M]UZ_XOO^V\+[WON-V_:<5/[+
+MOOZ==_#I/<<;Y3*R1$^6"H&5OQ!OS*B;X1?GHK"1JB"H!G.T>LXGVV9M(O59
+M?R7Y7Q_A=-YOS-OA^^_9-WY5XE>V\MU?J'ATZB',+=[SKNK55U@W)>U9^ZZ+
+M]D_GT4[*262626>CUL_L:*NBK449_TW0'3?]47H-+.K>F,3QB'/T4N]R<<)R
+MJD/@6(X^=X?Y3\],D1K[Y:')E+LK!;'&`L)1IBI4=^CR&(P"7C%@(@?@*)ON
+ME,):SG<<;,D^H7OJZ&^A=N;Q9_J*5S*RE577U4KXQ1]DMY*:J42!ZQ)26Q:B
+MB*:BBS,,RLT-68$;HSG2B@HN&!)[1VCS,0GU7\=&863/%_+#'7$OJTO*X]_@
+M+C7QD^;JTJ_`U2ZF[VQ6DQ))S-,"2C0KYY<]-$M07!OS%?87R$0F89EGFLO/
+M8R1Z'"PWUL6+<E-)GV70F5F)7MF[$#*BQ\&W4#M<IA!005#HNP80(L7_6BUB
+MQR<?Y*20[W9\CP]'\_S_J_'X7ROD'?;_ZN]\3@_I_SIM%_]U?5Z'J\SJ^G]$
+MOY/O^2ZS5?.^E\W:_HC]YT?\_VFJ`-8B`@H$J_U7SGB9F/XW0YOV?@_WY__7
+MNECVM0B[#+XCDD$2)4$B]?Z$,XS-;LW75^_W>C^FHOZ(HHI9)8Y%_44*X5:9
+M>SZ_B//\NW8==W/GN0]Q$Z_Y&)A[IL&BBB%%-6QR.!X<4%Y$;U5;WJ?$<>Y9
+M_G^Q@8ON?/)Y9_ZF%^2Y)YCBE"W\ID1511D6*")/M5IK_[96Z6_X%!9.QMGI
+MCX<A0RT_2=+&P1D\4OV(0EC5PXB]CRGTX0^LQ]B5SO&6%>>.<98T2(B_@FF_
+M\74PN'(CG'SU^"O])R%?]M]_KQ[>.^X>C.6?3$;.('%TF^_>YCIJ6]7'$LQR
+M*GDV/Z6;)1IE3OT.__+UR-6LZB&5"(%K;^7?KIG_]SH%4>:5"IG$T;-$/JL]
+M*U+%=LN0*()-48E5F)5<'0W(2#R155DD)*@^4UC7EC%(*18"UT;4TC^<MQ/I
+M496BC>LAG8OQE^*V?PO^%CP+!](AN.S_S6+89A.N,SWWV?[WI6M4:FM&F*/+
+MZK9?;_$S_780_&Z?*^2I\-Z]S[I*3`H_RH#(?-`/K@.-GQ89]EY/W>;<#;V8
+M,Q_2](GU'$V:\N`N;'-.:DRL_6APW#[G.J:3-XK!8NC?_G7O=CI1AAZ:UATJ
+M@^!"?*_)M1/]YX_WEC3!K;ZPFV*#[KU89_6T^_^9C0<T^6U&E!2BP\4_5;L6
+MVOE;*.:3U9T![F&B%DB^MDIGP1M4>Y:Z&'_?D/[<'[?;%>Z?G3U5\K,@^7OG
+MM;#ASF'9]M/*1"X#WM6=&I$RBJ'N3M<^IG=:<1NAB\]UK7JUY)<5$08*J,C_
+MA]G_#^V3_>:T?ESL[?-]R+)*:=<@:F;WE$!S.^6;?\*BW<++RS&T>88HIKUR
+M)3+7*TT]["OY[^NW>&?![?A?95AL--OC/^GD'#)^MU/IM^BOJ]OM17AFKSRZ
+MH^3:R^[/@?3.,/!KUIRLHJZ/(-$[1+CQ*YRJJ@[3\3].V62K_<OV]];!B]12
+MF?H-,_Z9^E\C_@X[9=+4V_1WI?"NI&%9D98+VFAKR/3BF9;#(RJHM+,I*S7Q
+M]#P"5+KA?^C13/Q"4Z"4_:0W2[=\/US_E>/NQY?DUM_)VH=OR_\WG%\_5;W_
+M'E;]M/?;/?VN%4V&_:I9A%N_=_%;/PP?5[0WUUQ-X-57\;^@-K#O2KZ?NU/<
+M?8/.V[.!$0/^D;>=_<6,<>C4BX8:V\K!2>2?J^6MG;[YG>[,SR\[<;GK)1Z6
+M,"NZ9%59U;@WGOI7%<PJG**RV%2(VHE7<V>[U4'1\2]`I9(Y43SJCH:(5HSX
+M4-IVU[38XN<>[#/AZ0FY@=JDD(XE>ILJV:8:H+,,UXJ:I]U#1T2<?!4_//D_
+MFZOA\>;KB-LU[?,]S^)C@S-PH331QQQPF=)%$Z*.*)[R665[WOCS.[=W>[N[
+MN[=W,S-F9WN[MW=[N[N[MW>DSF95-KMU.^W=N:FT>[LSM[NX71MWUM#7PC:2
+M6$L3,T44LDHM?,T-8*%R[YCD3/-%%269H3*A;_:?WV)ZO1D^IP5E)EJ/RW,N
+M[W:U7/C,JVROM:JS'(EV2-10I5(I[E+,S=+T%B^UYTG?;DG]KOFZ"U6SZJNE
+M9E55515T!D955-UT>.=#NZE^7D+WWW^%M*7>@K44*;T\5Y8>7_(9FA-"^[=J
+MU<+CM]H]*JZ6&@_O7,]G&?%RYN8*@U"U<<QN_EF?QQC\@7-&7N.QS';WUDU"
+M"?,S<J4L_F;]=2N+?'<*AS(H;U><J^>WF>?S<%D55@<^SE6-[WO%?(]A[U]@
+M[D&EZ^*$3*L_SH?.I<Y:5H<HJM4?T<CZLY0E*TN!IHI=E%"(9\M,D]$48IZ-
+MI(RK3-4?`J<;4AZ;J:'(69]M'5JBVO(K)3-$1-+R4=>,FD)&AY&MGG1R1D@L
+MT+LT=F=G]K\YJ8CYRTK123DY=A`@+ENFWT52B2994A(][U:3"A[N]8GOJ.@Q
+M-,O#.>RWCS7;.VYGCJ=AL9U;EK/V.UMNMM,Q.<K*_WN57W_T,_7PH;<L?R,E
+MZ/`O*F2F9^"J!GV'\N@IX\44<3HA8JU>6>>67"G(%A\I'`JNF>^DH25EFHI>
+M0.RDDK6HXQ2M3'?84Y'&JRQ+'4&<.J%:K-7A++!?),^*!.+=DKF&U$A:D)&A
+M8FJ0B%(3$M22$0I+-%-)'6K14=I'8IBRS^.VWP=M.PF.F]K]EQU=;7''7I3>
+MCM;%Q--_F\OSN;_N/K[;U*OGX_%8#?V)BN'\Z_%BUN=LV#^?]-U6DW+Q6KY=
+M&^]\:XS\'QS=+WW$^O?QQQX=C0TQWP[8[.1T[?%^NJP8/,X?8L^J/O]?\+P/
+MRPBF&O]?OG[T+!S_)3"-\L:K&XIIHJ29:UJ'N@V78RX2PJ%05SWK2K*^`MJH
+M,Y55\56]%"(4CBR[5:M)39R\E_J/#KJ[#KYNFX74Z!OF^-J/&^?P.Y[GIN;H
+M^UQE/3_"_OX7:?,_CN?4>)Y_Q/5<+\<?JO5=;;T:(AGEZD-2R;3?.<3?MYTQ
+M&?K5Z/KNV]?Z_^OL/7?]E_["N"'A#_8:3H#,YE[U6+W#.W'9</MB*.*.*.67
+MW]29B2B5U)5^8G65'KH=C)-!/N'_A_U6]8_J*K/53YW[]J[YK,NP:GX%<HJ^
+MC.EYC]IX\.**XQ^@I,JR,5SR]_B>?NDQZ;*1<7S,Y:YHIX1RQ-T=1B!E]SE8
+MY!.V^XV:>GL(V&:!B#TLC6[B*U4QO5IFCC<'H))%59A65IB;/"W%IM'XS28I
+MC'O:B>:AQAFX]HRY92IB5%6YT*U"I325RT?<N%#C1X!J".';K^N,P<*:8]?<
+MV-TT^22RJJWKXU`>EUI=X-G5&'AK^%Y<%U:H@*H"G%,RJH*O$G>]U\([W@?[
+MPO(]U1PNQ]IX'@_*^]YCVWN='U'QN-]E][7?1Z?7:?YGY,/W7.?[^]S7[-MK
+M<Y$$07W?T,5$^(D@4J+]*0!7^9_,OZ/Z_P_U-?[O];PS]I'\GNO9ZBIT$O97
+M;7(ZS`U5/Z9/T5AM.5/(_$YODO9$#(/DYN'T_RG'#WS5*G1>\A%%"*626MN\
+M]B81Z#/PL[OB+8KJR^"0^*<8_P(OGR^KML9_;M!7DW7ZQ\/S,RD4;1O^`KOA
+M+%\2ET/3,=IY]DC7C(OM*Y5B@YUK"#VQ[_TU8_Q&>T]][#UOKGSCF=E&4+"I
+MF,O?Y'-'A)V3,S>TZ_%/S>`HLY:**:ZM_D>:'!,=/>>^DZM^,9AQ$AC=4>,<
+MQ]`JS'P@8/"SC,<><0KIK/#/J%8B(?T6\:_0Z<7B+6XVN])R^4O'U<O+5YB%
+M48K"/@HO4:TQ$^5,1B:XN]/TU)\S%*HZ>K55G.<Z6!6.`X_@\J';68%;9G'N
+M/<2&+O'BF+SYRI_WS$A8,5BQP!CK[5FH;X^/33TZ_-[C_DF"FE*@8N/Q7+KA
+MF'#NOEC7YH>.,!QH(J^+C\B<7;,.TG(E_@+G&?%^5PB,<^WA58&2I1BZK4&G
+M9<@R#F;1)V6LT#T^A63(S%S&^M8-`7](F\$Y:D/3"/#-4Z]3AJ'Z!%$`<K@#
+M`Z`4P2'Y__7T(Z24?^7]U_C_\WY/"_QCDG]>-(PDH0_V)!P?N/L,'_;W+%3<
+MBFE_'ZOV'^)\[0_W_'<[_VOHK'_?>&78_A3Z:T)M-U^'[/P_Z>JY+R^3MO6>
+MK_MW_G+)[G?8?P^ZVVEZ+]WKOY7Y+JQ$UB]D)]9$_+Z7\C0$B6^/!(PVZ!*(
+MR()`!)>J9$0@)JQ$YWM$$->?-[B.(2)!4/=_S]=TWSNLZ7S^Q^;HI4T5Z[[6
+M_[BS>07UOFL(B%$3NT+F[$Y>81X!\[0'J<K*_PHS?U9R^Y_65H0A"/>>HZ=&
+M"WV@)R*HGO0>I!"::I@=MGSR+,,1IIT0$]`@H()Z$034[L^)8]`+)C,KOL*(
+M*(HB#W]+D%0"Q99$",KH(1\L8G,<>9DZL]3V3-0_"6__W%K'QJ.:XKG*PW\6
+M=\UGN_HS>L:W]>S4^U@"7K^@TW0HE@1)=W]Q)A/F9[[@3I7%$DTE5E;U*`E4
+M?JC&CNBI^MAD-\9YB-:!7&@I^X\\YT%0E/@3$2K[,0@-ZLR1K0E8@>&?$(\L
+M^L27]!GZN"LYS49N*OXX@X_<)^^%DF-$5"T2HG8'4?7P3DYL[(R%%^)6-/NZ
+MW>Q57R4/9F9(R<B[5O=.+)X>Z-E_G:'@#XB!%V9Z><)IXQI,$[/BG"N*]A57
+M"PM!H!UTC,\5].MBW4+9"P87..D6Y<X@B"[JO9SU@[KQ+R7UNDW!9LE+R8V&
+M.NP9;^_/<;LQJQ6%DE7RJ!I_.:3<ELP^1LFV**>)^?=$P5'*2[YO\/5?P^4^
+M#'L^0E\+5\*^]C^'I^[/E.^+FXVRZKSO4!_MF/9K],Z+F3UWK?OXL9H?F?9_
+MM^#NN9_U_W^/S.E^!N>[T@B'FB48_7OOCZ'L$ZX\SU_5\#+B^E]3TW0:7\A_
+M#/?@R?;<EY[Y.&>>\]^7]+\/=>3_&=)QG)]UQ&(_KUO^Z=&FM_1QOX>4\4\K
+M_ECS/U_Z/A!\)9)9?I^9D_=7TW(6AS.T&%`D/NX/LL&$2M0X_F]N9U@YMAIE
+MT2\OEMU?HV-IW7A._%6G<0YSR;C]V$U<LG-J>+*>E.BP%%A6/L8::8&;QX8X
+MO?F!R#_.F7F9.]]=J>_PK28I5\RM8I.*YZ^2&P7$/0'X?`>99^ZV[&&:P+]H
+M.YU6HN92U2//C'IN_DT1%EIB((2S*+Z7V>WCTI^?[RU0TY`PYYU9D9&^=RT/
+M5E3ZY[_&/=7\<R;4]GWYDE@R8T&/EGU!*[[9MRQB9'RB>-$7$N7,E<_R%<UQ
+MN31>S7",*KN_QREWW%G+RVQ[%E<HRQ8'`4RDWAQ'H*I')%^$!"3?&G\VZ+3F
+MAT*XI"HL?:G)<WL0.,SJ/AY64MPHOC;2HCD0W[(GO..(D\'F/0<E_O?^<][^
+MDU'8A^GY_!\/[GS#G8?RV'\?DS1<#\MZLOV\C:^O^M[WY7VO$[?[7S.[\U>W
+M?Z=":!$43UGJ3U'-/=VBO7KE>&E4RETOK_KN(_8_5_A\;COB?FB_OD-,AJ+G
+MV#58W\OF2?W^8:7UFL]CK3S_R^/]=J?6_ETUK"O=)W'I][O_,87;]U-XZ%]<
+M5?B&B\IQ;.YQ>N\W-W$(0CDM]H31?+Y?>B>](_*B_[ZI5UYV1\#UQ1&;;^OI
+M?<[[P/G.T7EOI-[;]O73^YSUJU^_]_G8O7^<YW5Y'QOU\7A>WY?WV5ZWN/'W
+M&']_J>1_KV.?YWX75[/9ZS4S:G4_.^'X_JKE?(P_]][^G"TGENR\YAQ;_9KI
+M1MJ@X&[_3&G%Z=^X%^ZJ'_Q]MO[THI@F";H@GC81PW<E896V)L3%3&%ZT])'
+M;4X>]]D[C_;1[@W!\$D*^XW"KH2B&L+?3GZ/2!F2'C91N3B#B#PC=;I5R#2F
+MN/1W34G(:+7"ZTTVF476D9U6\WBKMBJ4Z,WAL]V?RTL6Q/?8[MN+A"A:M*+P
+M3^]_L#Z[=ORI+P.*XMF:+E!:4XPY4Y`X)QO!Q69LQ.ZG.5'3Z=;SG,YW+0%M
+M28YRQ$<7Q:\BRZ<SV_5?/G&G<G::DM&Y,S@BU4-J:+FSE^8%SW*'^MKT7*RB
+M[6A5D\[RQ9'<:;>:?+,P5^X.89=L<Z?5+4?4XF)N5=6PSF#]O+<GR@ND)*%N
+MG)D^W-N^X;,V\4IH=UT`XX[CQ>/,]QYD&*:0HTQL#9UU6ON2+0?TX)P3)REB
+MMZ"II(M>+;K;=;3+T7'#MRJT8AE;@S_0FW/YH`J(BB"H(J!L/$,;0\'7FHRE
+M7!R.B8%Y=AM"P=5Z%GZ?G]KO(^?CYY??J3*,J="JKZ3O>PTU/&=]P.:^K9N?
+MO[?FO&YF'R/Q]CLNS^'_[N]=F>CWOZ]!_WI_DZ7F_K<O\+<>FXSQ^J[[ZN^]
+M-I`0Z5=(NN7E.J];#I((![3M>U_;IO(])_V0$3]:H@`!@J-#M^0.F/M=NW-'
+M$8+.7N<O;0BA%"*22>V1Q_*^X5O:EKY<4<#>]TU3LCYC*[SW\%7PX^)_=ZGO
+M<?9\C7^]XONO@4];;XSDO\?'Z/&[?K\;#PL/\U_P/E_VYWEO-]WZ'"_CK>AU
+M'S]OSGN_O^T_AA?E[OG=CY',]I][-V<N__%GJ-I^O8>BV7$ZWJOK3;?>ZOX_
+M(>'[7ZWI^MQM#YCZ7S]5V>![/Z_HN9Y7X.DY]I/<<[PMQN!:IE_A]ABBZ:15
+M55]N-Y0U8QGCQ,]G"OP3\OVQ,T!`[A`$&V_=[TD-S7&$5556&WN]5=Z?>/IJ
+M05-4`@>*9R>79F;1F1JRT:HU17U1Q7%'%,NT_RJ"`=7NXZAL#",]@\8+TU\)
+MQFK%XG]GBJ+B&H%R=F-P1NIX/''$,N[T7%;07]!\78D"E-"<2=-Q/$BR'Z^)
+M,`4J&@X1PF7@%0SQR/(G"97I<QU7A'3G3G3GR>G.+^T];.V5>G.7UJKQW+<N
+MS-QYIM,HJLS,S>ZZ4PS='G#FN$J\AR(N'9.>\V;B@VYWNK,LTVZU1TQ9.*XO
+MGF9L`KG3#<:<$!.?H5;9RUOB]NS-_K;1'2G.'0F'O,(HX"KPS>:;?JIY[*L]
+M:N?X:Z,T@M;<&7GA=2<:<P<5@]&S-;MG`.!1ZM>+XP7C.,.D9<)W2,S=D7;R
+M\R<T;O=\L;#@<5TK,W4'+'8RJN3V/!5=X9_C56&GZH:U;VG+G,'9<F;0[(V>
+MO.H9>RXQ5X'']DS-L;BN.<.;...;-KM5ZX[*"K5+1SAK-8O")\`Z+C^0.R9<
+MA.05(E0`Z87K5$ZU55!WWV/&BZ+K'ZM1/A>UWM?L?B\GT'6>@7*P[KP^UM&Z
+M'C=)^G:2]MV&-T/U<[_'T6]9ZU?('Z?MG;XX)GE1$\58F0;0"*(A_O<;-R"'
+M/J`G(BB(`!R,R?F=[?ZW!U[8R?5_,S-\>?\FK?")FDE?+Y2CT:.-B:^\;PDC
+MQN'PO;S17KG%;[[=&I]S:]-6$.M0RF\,XACEA9A3V1[YDJ$HV=CM5.2!Z`GG
+MM?9'`'CJB<6S(`?\%NYZRA0<J'I(O=G'"9I7+DAT&<4.3>>9472:9<FPJZ;[
+M$@Y;9534YR44*+U)Y6)[U9F;RYY?.)?R?_9XZ?3G)&ZX9I\06L><TAB;;U6D
+MUXK>.!A!ZL0800V)/T"T7V?Q.N.I].['MZ$MEN%W9&*9)6%R4RCYCGOPS+>]
+M;P8L"#+>B7`],"866:`STNWRQ9-)S!Y?]7R5_**"BJ*((&K]MII03P-^FOQG
+M_[_]Z3L)>,B[]==^?7<CVG[_0GU=_^>G>?[RLSRF>[ST;N4_H:GJ^(ZOINX.
+M*_2O.?IY#9=YT/\*OE4%7^Z]Q\WZ7WO%Z70`G3KG*VP9`8^-Z)WEK'J/;8'Q
+M/N1ZKW3&K5"QT'V+/PNE2'=,Q_)S.='%''UGBS2R_UZ=_IC!"NZ*/BW-^Y5[
+M#?<6)S0"!)^^C;?`F]#8I1.=Y(T@ZMY-!3#\[Y%.)MUNS485SOX]>J]^_KW7
+M/[,JD3B6*#WP>T(0CKHJ<N]>Z#EZKLS)ZMQE_^V'Z$?\\"/^D_E_X/_#^*)_
+MR!<5!">JM!8C'F&>!"S@=H9GK?Q*+0>;J\R*GI'KU[L\)`1`*W`/C02(GG45
+MQ\%?AU,UNO\/EE7[D5N0LK6.1Z]7!I"M"LS,VI/:J(C.7F;>IQ1?S![7?WB]
+MK-4\O3%]9N8V-ACI)#!Q)B8A<`0,&^,'!JGI<1J@N!@R7<(]9`@*YRW2\;FM
+M-LC^GF,Q&!&5$411`>&U%1'J)QB*=9(-N>0VGZ=M`[[^*!VOK_7=KINN[8XC
+M9=UWN^Z\^QU'A?8_Y_WOSC?2?ZY_Z'X/E>7ZO\_^-;T/G/KT];Z.]F!_5$4#
+M1*W^G./L*?[X/BWM;`Z;Z7UMKNO]?%K]YT7IO>_B^U-E+]RL+Z:HY$0!-#[M
+M?$5<+S#O9\[,^$'PCE\C+%NL9M\]NM]$I5/Y_84;ZG6\:KF6@WHN0<T]XI%]
+ME5;Q:A\%PIPQO'/76A/![1%AS9QLGX$[8_M]CG5^K!)9IT5N,6E;_$1B$4:J
+MS-UI0?MB[==9C=1+,M;%.92DET>>\<_SXJ7U@L8&']`DPAO+JXFQ,2/$,$KB
+M>WNWK>1D$4(*JM=[2O765(>0\QDN#0BACKOOG^^U%7,^?T7/=]\7N>Z\?I?7
+M=SZ/N_)]#X^CXO7>8Q._]&?._%P/0>%X_KN'I.8\UO/3]-GT$S50.:P_\>I?
+M]?/AN]IQWR.U5.@\?W>9]?V&>X&/_6O\9OX]>G':GS'\G'CI_QF[IS.=%"+W
+MGB4QR-9@U^A\0^K''Y09HCGU07U'0@X55Z5^\>_S;'F#-8S.`+$./8Q'M_-F
+M+^T^&WB21^VU\:Q3\'TIA^^Q#$RD@4URNW._=46M_0?(BGXHHE%_;6+39,D5
+M*QN<SG?9FLGO\H<L4:JOYI8-*6RCU-_@X&`8+ZQ:M&+/.6S-BL65OK[[Q;?"
+MY;?PJN$83+B@)#32#1]"=SS[P]7MSH`<<2NS'>3=VZ_,O_U4TKY#UG\M/O*G
+MK.>Z'V/RO"_%]K]OO>,Z#\'*_A]Y]KV'H-!^#W7L^=W'^/'^+X_G>D^MGP31
+MJB:9!VU(4,5!40T%47[O\3*IP)15$XAH;7.S>?[7[,9AE;WQ%Y?GD;E/[.])
+M[OIO^PBBA%(Z3F_NC%-2'SCW7%1/@)X%SG_-?=@E^*)@(L>E9)NM^#SBB^>/
+MA]*'&W8\)O;XF*5:G('ERK547^Y"ND@T&@S,PJ]SZXW#?GQY/)W#X\[Z]B>?
+M/K101YH?R!#`XI:A4N?Z6]<)J:BV[EJ+/&B9;\B(A;)@B!/=BC*MFRM=WL@^
+M6HHI-J)P^YFL&7\+9.Y!^L\]X3])ZSYVPX14_UW/"[KY6GV&QX/H?E:_<?%T
+M?'_EX[Y>5\OTGH/@Y"(ACYB`@WEU[TL\B(.7X>\=XK/_TI\?S>#/\7?/]*G3
+M_Z<Y?M:E\(0?"6266M13+-V!75*U=RBK\!GC#/9O1D<:K<#^/&7VJZ^7EWD&
+M%9CD4?R8J6)ACQ142M<Y!,7%47ZL2<\2IUKG*D:1QJ+J#^V5%WJ^36YA--,3
+M,K-Y?_/JU7)Q2"1$8M+Z#%/;E'B?\5;.8^T>FK5NM7E+.:7QTI;NB%FS7KE4
+MJPL7VY+];ZB_]?:M6V<\TR8/YS%S<$.?7UB>H9()7;IOJX>R?U?NJ?A==GNZ
+M_GW?6<AZS,_9[/CZO6Y'1>L^^O:5.U]W\[\WO?"][YCA\/2>DZCO.-^M\.OH
+M,T-&BAF(?O78H".#K%54$TONMZ./3?WV'R_?P[3W>\Y,Y0@K:OF?:!:B[[K3
+M3)Y&?'\PCO^-]&9SG0B_6^.X<VN+X*]`_?1^YVQSFR)X:T_/E7HUS&7[+EG_
+M0CMLI:YY16TAOCC!!'6J0&1Y'&HOFFF2!8PS>.U-8OXT>LDZSN<SG*RJMH\:
+M+^N:MF4>9NH9*TUAQ#GQNE4LGT+!ZJK5JC<6DGF1$JS$V+:+1"F^3P559E+P
+MUN]>?O`$.Y+JJ4$<:Y!@GK.JNWZX4(5/KHF+C6[*&U%53)ZZ"(FV4.ZCYO/_
+MHZKVON9"7K/G^MW'-?&WG:^=N>D\AV?P/:?7]/[7Q_:?(\US_8>U^_QFVZC]
+M?B?0]YH0O(J(9""*>2XS^&7WWS?L?SP.@_=L^Q]GUDW*\OH^6L<O]%,7Z]U>
+M[\V;UYV3MKV',JG`Q8Q`]N>^9$!#6?I3J.@APA1=IY%G9?DMI6P(Y(Y(Y)IL
+M6Y''[OWBF'T?G7]AB[WD5%'%^\6:=M(4CWODX&!Z!&:/+9146#.0^_CK0YZX
+M7PQTX^=WAK0O_%#I#\O7C.+GV#_ZX9MQ1>YSU<3VY\NT4%0!3'<?'=[D^*<"
+M!46HS,T2LJK$6Q]99M#UW]!]2Z7K_U$"O9+[R=QPXOZ/WY-LN"VR[3T;?QA$
+M[#P_.D4E@PF6E[K[":X31D,"'[,5@Q%X"*)TISCS9>2GO*+V.E_)YCRE7>Y,
+MU=?%NZKQWZ)>B7SOE__?`^;D]][OD?1ATOP(PT7P/\?!_M[?Q?.\?[[0!H44
+M+R*&?Q6<JKL6\JY!#,*C1\H?T7\)Z#HOK'&&C_N[HU^/7<YW/PB8?'JCQN1?
+M<]-R%I6D@\V9^N"[E@^U\!.G3"1`=\SY2B\V%6A'O47P?7#P_WT7O4T9VE@]
+MC'`)YU9F966,>2\,S+G.$=4]''.F3^:/$)JU:GZ:O?5".IPUQ_M+.218)_JS
+M96P7BFBZ_\".'"RRWZLUFRKW+AS7+]KDUQ;EQ:=&$M]A3!Z%0IOF?EYG#^U%
+M@]IXO\_@?JXGW^[[#B^I[OW_/?3L?0Z7`#[=^@ASBFNPM)TGS^;K?&UF^]G;
+MHW'O55OW?Z[WU/;\/.Z;P$WG*-W&P^&^$'PEDE_;-1YS9V488U5E:A48E9_[
+M&8]HHB*+H5_X<F[[3]>+""B]VZVS4.917"NX)+K]L\<SG!!,^<1M!QB^M]/9
+M=?XRG_8_*'\2<_HQ<6XS,PJJO^B-/]$#[I+1`L3D\N<5C'$*U;<+&U-)N*:U
+M<L"V)I5<]]);K2DE*M<4+*Q=K?8SP\JN]%_9]KR_E^@=E>@V7>;#V_]O$]-[
+M;]'B;+S7)X?Y/91>^]^U\!W8D_Z(RJ#[,C@/^@/\P?Z`[#\L=QW&'!V!,S>"
+M1B0$"-1%^4H0$[<1CK/?R=(GXE2'4>M5>4Y9S.X72,_(YN>$4(H123OA+JTG
+MXQN)\FHC]2RR2+(T'"IJ_EJ***?"D>K.<>_'LO$F>,OM:(A%JM=XQ%F1P>0/
+MMV?#**LG]OP&S\L/#E#U9NE0J?"*N$\FDL"J+8959NA`"7XQ\=OF$$K&?\M6
+M3Y,?8VZE19(4TX:NP"F*_X]<`DA8P"4KUUHC5]I/@M;2Q8:"%_?EDP"XL<BJ
+MLMJTK6U]%IF#]3S'7.'AKE\AU_+='"?/^;U/T]KVFUM?>]-Y35>A-#YG7L7`
+M,^(J(75+7(;GWO'>SBY[[7]'<OQ6^SWIN"=*A];L/@XB;=<:I0][XXH_FS1+
+M5BI3:(*L"$#?)4%*>P[#LM`.9W9'%RQ*J[ANR<S.M]-!ZM6:*NRBJYG,-Y`Z
+M'EU%P(H:QE_KUZ>S/CQ5SYY0[;'W?NGJ?,N(\W-Q[5I1<U]`%=+&JJ_N,HA,
+MLS,MES.<YSI40H)NZC'L7)ZY7H_,O+DDYQ0A-,7UZ]9585NBFA!6KEFTUIPX
+M5DL7RW[+:M*YZ_&I*GR4P<ZK?J');\1N<4+/!*V)RK,I`T*AE*@9"YYS#H,"
+M;)3[;5?T)[]%.^GC)$X\$1E!501$C!@1N'_7/<[S_+N.AD3MO*\F[^^7\-1:
+M@C[F$YVL^,JK(K*'VNN9RG]?4TD\4<4<4<GP3]=`41T2\F;V&$NA\,$)3[QZ
+M\>1;J,BHG]QQB'^.+Z:2O)(Y.`*A-HM,KF5O,/4<,*F9Y@!P"`Y431Y/6:/E
+MO8Y&F_AZ>6.5999566267.[>WM[.W.SNCN.[U>Z=]U^[.7NZ^G>&[W<CI=.G
+M/E^7V=BI0C?:XH?I]'X_S"]KV-N!%/GN80!^?Q_'X_/Y_C^/X_CN[N[N[N[N
+M[N[N[N[N[N[N[N[N[N[N[N[N[N[N[N[N_R"/G_RP8@"(C_L/_-F#_U[]&(,#
+M_&?TA\?*QIM5;&*B*VTLU5HT5?_C^<>^]>0"&JH@G@[551%5E_*Z"[#H:JHB
+MHJJJHBE17RYS\=?'Q\NIH@5BMY_I540\14.#D7_F'?+51(,%4=PB(J**H(J_
+MX"8N))3$,U533-[49>ORYJ:JJIHJFBBJJJIF&"/D$DPD+]O/,@:'95\)<,_8
+M6!ACU@@X1PH**#!A%^=$1'[;-/^3$!$*+M1F9KH1EVS@X,@XK%DI0]V,?A+2
+M((HI1@^"N_M]6O?GQ^?K5O*_R?(WO,7QXOMTSSK%BUX("D0(,0!5(S%QVA95
+M")O;@9'$H:A?'L%U4E!]><.+[B3HF$M<`WA)D$:DRIR>B!/68`%!!`$P`#<\
+M*JL==U&T$4V--NH8RJKJ=R&.U]P]4#PZAG^9X-S'G_W/Z_>9^"9]/M=6MZK*
+MJ44:);`8Z6W+X,<S:WD9[?\(%\'9P(>JT%_?6%1(UC%D7\-6J5:U9UBM$CJU
+MQ60@CQ$(@(VK`_A=(MWSX=`!B`T#`L?U`L,-!)!4<&>*OB.VJDN;_TGOX`T>
+M,1&`>`C8F`Y(OJ6F<ESC*YE;,,H>&)F93&9"?7\J,.$Z9NU;FQ7W0H(?3@18
+MN?CR40A=@1)GB*#VT(B20#F4WO>\-$F'*2IEX37$W<(0F$&9"[%;9T<KB57G
+MR9\K9/HCD*"9*2!2A`<")<KLB;\'B$(>IYIK)(;M+\TMF,8>96DF0B"%-@,)
+M?!\#A1;L0(_:1V^(9V^JQ+%!3(,<[*6Y"0A"8XG6=7QHX7-YO9HF`1N5K[D&
+M.LB222"B$#H.1$B.$CHB!_9.YR&)Q'$1&3HEN&A`'59BP8%W#-B`-IB8D4&H
+M`$WB<P8`&/W\=E5FL>?#^DBP8CQC`:L0/G?PH]\$7$=PF-;O1/8-D:"?4#67
+MV8`+2Z-[CZJ>>$;V@4G#AD$=3K,&Y=T)N9]*K.&C!$/8B+!$#_%X`4-$9<0P
+M!*W@&5-S0V9R!7D;UJ6*(],K,SG<:..57S_7KM@;G:35&U\OY;$OX`\P9E&K
+M[I,$A"(WOB\!UC)]X%P`"`1$>GKP:`KBMB#8(UAYH]NPHF<['60H@`4#4-X*
+MZM.-`1U/,DP(`OS&5Z=BY6"`-[#O\N$UFP@.!SOA0^3L&2T!4CXYO]AZ^],W
+MDV?>\*QTQD:/*@E,#^Z?#%`"J$-:M<)3H?%E@FA\Q;-4O`?4YDUQ\_25@QTV
+M`)`[!9W%H8$[BC5D-B];N$8]MU7)?7\O=E#TO![WF<,`AXBELT[G(^JF^[+V
+MA];EQ`FO\;WO49WX@3,<3DY61;<J?>>H\`X$F2.W@L"B($!$GK3UR)K3RJ`'
+M`BJX`-4%49(`C+RGEEP)*`W`!8>HS8GJ"KCLD8B%0LCD'T@0`S)WIFA@@7UV
+M)J=K;3%@9(U70L9%<4#&$!SN$=U5>6YUJR.DY6!WVWH"$(5ML&A?(4HPL$#!
+M5@L;VN#-L"N!G(T;UB9`="X8@,]6YA4A2\T[Q6C+O0:U4LS>@R%&0S0/"HQ:
+M$7+8Z3IF5ESPZ8&UVQ-P@+YCFJD!RWR&V*$R+'7K;N(P#8`V9$Z-.UEY@Q:A
+M*[+.,&(N^AF$!$`Q$6Q_K#_E@Y%UFGQ?RZ7JTV%2&72J76T7M6+[XJL.6LD)
+M!*F0!I@U"O(^+8LZZ)#,G2Q+.L+\!EM(F5MTSG%[.A@SO-`B$3:1T#%`0B.L
+MC]_8XH7"@!+W38Y"!_BC%=KX/F1I0KTQ``PRQ8\,Q01`"^G$T!0'=#$Z:PP2
+M;`6(Y[&FE'KUAC0$D#:8-LY(!%?\O@S,\LJH$0IB.47<!#A,B$'`.3\F*%>R
+MC9$B`(%:^$!P8N1_);(S1%UD#<%5'3:0<IZ\&F@.G3/@)#_D7#7AQIN&+S$P
+M8URVP0"/Q5BQ_O@`(H9%1"W?DR!FB/PZF?D3;Q=_D((8X5&W'CWLB(@#H&1]
+M(#,&7$"Z8@%I"12[YPN8`O84`W+##R%^VQ0<!1G:.&K#D``3PMX'*^`W5)X]
+MRV853$=L8/^V,5$",8-`D/+OQ8CC:%MCR+;21X"8L&^9,::2`G%Q$!F1E"K$
+M?9I4-$)"/H#IKK&2E6B.J>`"@2!,8AG\#^59U])%?+-Q$W`A&(`O^9#B[@"!
+MWR!HB$/JA>?6WB*PW$1&&`?0)$!L2/QUUHWA0KK0&[09WU"!TB!P$.^]$2*@
+M9HV!GN"W.[G^_@Q9[?=*'O1'C_0A89X8#)@8)%M[#&>J%X**@7&C+L,&H1'#
+M7*B!.Y`U`#(P84)T]]2(P>.,QX<X%$^'LRLJE'!3@FZ&OZ'S8ZC9`\/"A5=(
+M4`_0T6/1T!;S4X]SXP'OG%940@8J.A]I(=I1%GNT'H<")N[`&_X_1QX1T1HE
+M?H50FHKWRK\O@#H9%Q2ZK@?`)>C_E>J!'SK^5(>6O@]>P74N:CUZ]*ZG>MR9
+M:ZAJ;5TJ`\/-5T-<&F<@1E5">XXN@0!FJX[!FE3$A4P&(^_>N*J#?AY09LQ[
+M;`8W1D>D=9W>LIR-@8.#P4.W0,&X*V[V`)G:S<=18GHB>$)]PC_UL<Q]9%>.
+MZUBCK#)$B1\D.1\\`/M>AF>\N0&M\-8J``8#&SB$+0T#``STL(:`(CIZ9^1.
+MGJ[VGAVW[]P.;$OMWVR52'7KVQWSK%2K68T*KU&?+V,1$?Y^JAV;X5$0!-<O
+M0/0!>@``B,QQ5'5HT$<`90$(Z@&+#%B*CIL0Y$=.`9QW)';^OUD]?>&_)N)B
+MG(6`CUP-&\(:X"Q`$<=1F8%[F#;/+34M,&CC.LD"]_"2>9:\FVGA]/KFO&=9
+MZ<7=>.K+SOM<(9YY26SV`U$2!76.C\Z:C-Q5E5\$D1`$#]3]0?\U_UGT1'C>
+MQX>?U\O[?P"AHP-4?L!=8C)(MU(J!4#PN:[<#!A#8V)0`%V),RQE_M&`FI-7
+M/+P455=Q$X/)?O]0/JOJ$1&=R!TWU`5O_S/V70D.FX1#??>;%&^4`"99XH#,
+M,;YPA-<__K.8\!R]`9V)G\#TB#=Y*^9O@Z8'Y>#)<#"<(!>B!HZ/O?8!U](,
+MS"C[^,?):&C1@#-/97#Q#;,M`F6Q+.IG8-[D/2WAMH;7>9#RS[5_T=L<[:PX
+MT\[NYW)SIVR9-Y8RN-\,;LZ[G:%N4/7X1;\`/L58C(H!NA0C(AU=#-ABQ8HA
+MS`%>R(41DPO@0`,&5<`4,L4-`:&6;D-M"K^WQTWT@3>;U8->^YD&..#/37,`
+MB8U),`?6H1V*Y#A0-X7$+,D9E5NS,7':,CA#$=L1#8<!UF]P/`*1`S];MX.\
+MS0GT]Z']?9^A<#BA\`%@?)T1\]<"]TV`U8S?@@'>`'#H!@4.-<'^*C!^/``0
+M*^>PV3@"KHCL&DVP8(3.@RDOO`)GF,AA`M@XZY:FIN;HR$"78%;[[XRK3*$H
+MR*#<P:WOK-,O>;8(!@TC)EGB.AQ`GNHR@'UN-+<)LS0"^82BJ$#Y>`>!QE&[
+M4U&U>;.P(@?8_`_F=@:!D+OQT>F0(L%J`)$!2ZRQ,_0^MA[%N+.V(M1XLT'O
+MR[AF4!0KD>Q#>UC?>YSEH<EMS@?F?QS<!4X=V+$B1WHZ@*@$C>NHC\5-PA4"
+MTM+:R_SYUOOTV;'!P&K8-\&6-\PTZ:8"`??Q_/J9Z-/8/I<Y.B@:<0"5$5^3
+M-BZABT.H3LQ#SWWPX8!$38V(J1\'A$.8Q30E!34Y@AL-`LU`L"?7:8UT/;D'
+M1^?0!41@$WFB)&X!;ZA``]N":$7G0%#',0!L.!@Y"UP$C_>?7OD=]C>^N^HW
+M!_3^<[`N-^_D>AV._`>#-J!7[9O"!H^AH<OP\,H7D@Y);\*PG"[WTWN\-%R*
+ME3,E6K<;$W,SP0:#J*#1C9&V#$Q(F)Z`9@F%(NOQ5Z"#[1/;H6"!@&0/39]]
+M@:.L(9N#$.Z(%/^*`OX0!0BKA'H%P*`->OA&BJ\A0CJ%]]X(^U.OZ_M7]GX'
+M#\?$']-B?0*^U^/IT-$!#\3V`5@,78`L3$B\$B3_(^K3`O1'J!OHB/O140[V
+M8@9_K_O8&=;@<%::R96U<I`/+'R:FI[3*UB%>7?/CBP;YVG&58OH.9;(H\=<
+M$)D;?$;[!OB0+9>%4!6+MP&T_(C:GX($&??[?W-_/@0([8!'!_(N/D@SG-J(
+MGNA3_'5W]=$91&P0>CTZ0GL2BC+O[;B(\_GK5<)""F<U2.A1Z?HP)(RXX"YD
+M,.8Z@.!@;4Y40-$_EX(D9X"]2DU6W/A+"OT+%2&C)"`[YW"QE```X]+9;+QK
+MG>VF3QQS?`0FL#4)Q<-`EI#*LK@3&N07`/7MK?>`0W]'?MK#>2W&.TCMAV`Q
+ME>&+7(#)543%L]]P`@=L%7@&A15&C!U8WVL!?0,GS$B``[&1$/$%6@&,J1?H
+MC@T%$A"\F(A(@%.'F%Y-P`/Z:XDQZLB?:*EQCD7,VM#6!MBK:%W$RRT,=,.L
+MD_S[`&#?)W:A0%_=<+37%K3@JA"\G&TTO!."TABV@8SAH7L7[C@_.`,3&P`-
+M6[?7F<0%8`N7$1X=%T#`N^;V3O#O.P$)M,#NZ<`WH\=#T2!;N>[KY6UUS,YM
+M.*ML20RYS+Y8"$O[<3G!<TR-!#+60N%7G38@#1J`F+XR//#:9%X3;4RJV6E7
+M(0<0>O(>NL[>RBO#MX`_3A?4G-:V.\%_/P_Q+O\W4;%5_=_GGN=XY=51>?BA
+M/R7TH?GES?BMO@K)X]^9KTZ[]'_BN7;/>];X77FP\IEO??6Y:KOW]R,SY._7
+M8'-?4N9)G\T/O_-Y7$_$GB)TA[]U.JO]*;/5[I^"?Q>_U<C]IUR?X/[L?R?O
+MW/[YK_8N][XZ^U0Q#Z_/SY(^?6!-RO(JPI?ZW^)O+CI'<:^_^%'11"Q)!)7P
+MQWPHW"Q5XZ5CGD:-]62.$(1QQ1V84/\LU3*EM+GOKY];]A_5&G^N1OX?[BR,
+MQ6?Q]?M\?UI-_MG])OY/2,K+?K1,T4;22NBG(H5".>=H[RM:A;>26+K1UU6#
+M55?(UB"_I?[/OVW?UUC?RA.?L&OP>>]^WX?4/?F:_&AYOW7:O#*^LP7;U?QE
+M_@2OJ4/HZFOQ/]3]@FOH_R]-#/*[_E5W5Y4K]?7>6=_/LW?QY;]9_YM2?N:/
+MW]%_V%?RI>_"?I^V,A>63]_D>LF_S\_"G?^$0VM6_7??W\'UWW(GOG\OGI]]
+M/XOZFNI_Q]U7X??ZV;-_>_!]?QED_)N7^>Z?KM>?K?J?KS!_=;]WXT?`W/;\
+M%./O->/BN0R5^'9/EW_1*3'X_],Q7X^7M+\I?2']?VS/Z_G]3G#Z2Q'3[:\1
+M>GMN?WENV+G[I4/E*#]+BZBP712E?)_@"_NY:A8G_9KJWZ1\P3ZJK(K$<^I_
+M8AD]]]W?T^?B>KXV^]GZ=3=A+R<_SZS**D(_CSC3^QH_C4'ZCD\ZDVZ_8_KO
+M[OWF[]G^JOQ=_$B/A5;*FH?X,S'[E>/X+_EOMK\OTT/U3?[R/WT>'XQ$3.8E
+MW-FR4B/SUT9XV;7PS-*?.['RA\.@=[RHKQORPYY+U->?VOGSZ]X_VP(^U_EW
+MZ^2A],SY_Y*9'UV:?]%"%N*,FQ*EJ=SY'7EJ+/;J3V6:F.-SR.5F>RM;61S%
+MMM!&V5<ZE2-=+N?O^B0N=M"R%(OYC7*Q-ZP7@XHFC0.%HT+IER;%)[^^/`OU
+MHG_9KI^?Q?U_-A]$*QCR1$U-:M3/.Z=9)92VTPT)*D*K43.DF51706>IWOX^
+M]^JHS[WV\^/.VQG[[<QXAU:(9KG9`_N(HX8'ZU?7?Z/GWOS(L_G\(=]?/SC?
+M[&]?X<(B1=S7]D]KI\E^73YL;WK3IXM]JXRY2DSM3:N,ZX0]\F^.V7&1\_9/
+MR^_L^T23=+\]4W1_%%,:?[[O;_)]GH/O=9,?6%7NA?O-G[&JHE'QQ+VVP9/X
+M<O^I19.Q_B.LGZ_[Q^OU]\]W9NJ?]%]NMR&#\06G\M$ZEYO7&*,'6][_#6;H
+MMX4M-=;A;7%3`J._6U[7I!L'OUM_#=@R)6?2HBZ7XSOHJLLA_3K?JKJA\_LJ
+MB:J@^H+R^F/7F;3*?Z^I)/W7C)"/F]E_)^>?WM9EKZ#&RII'3,_`K=;TU2Z=
+M/59%MDNG[\:R=_B]VRVOMYZ86FC#'OO;W^,$BZ6"S)%/PE2$]53^/F[QZ?QB
+M-I&W_?Z_#MOZGO$S6_V`![DFS]ZCHM*K^IK\?BKW7[\[UT*P?N;O;2^?4]^5
+M3O?<*OZZZ)!G=?]B#^`GC3\YKM0N?ZG^7NH_K^W\9\\OK[F5]RW1''P-2*7X
+ME_FI:[WW/S-_CYWT,"7+Y]#5EOZW/?AT?T?O3O7OP+TGX']L,C\?*'M-(I?/
+MQL^CZ^)_)^;2!Y:,^9\*^/\9WO/FAH7/NP5F_>5WWERMNR/7E_5?I#ODA^(U
+MCG-2&R%/6Q7%FT8]]N1?U^%=?BOL^/;OV?>^_GIV@L/:]_LFFKZ1B0^Q_*!\
+M]-IH//UE[<)I%'[O*-%;*DV1B?PT_FC#OX=4#^;7K73+\6=']G[2`Q]&-!MY
+M\^C.>I5N_OAS5/T='(K6,VO2-O&NK*)5^J=(09W)3K)?[[6$R4,[SIG;"\9B
+M_GR>F=VG<W5X\M@5R.4CYYQ,T1N;9NWCP)T[]DV3>J?GXE3.YO5A_F>^MWY\
+ML%T2#(6_XK1'OM`<'K^)ZONKJOPY+2_!"^C.C7IJ[%2L]MG;24S?X/'ZNIGP
+MKB[ENVA=3K?M\M^NJU0_JGWC?P2/63]T_S,D3M3?U_?_,;\'1OY_'Q?8?G\N
+MKS]F*'LJXGF.4R\IJG[V.^W=N<(O[*->5<9T+1^'Q+.7)NN\JQKOVV1,GQQQ
+M1_9R#\5<A\KIN2Z<JU5[GT7B)D_6SLM7FWIRDE-M$/"D;=_Q:H(S1W^<V")*
+M*)_DG^E]TL_ESF<OZ_OL/*P93^CH82I)M_G=LU!,"@B!I>4VA=_G+[";6M3O
+M[-5JK)K[,[_<AD_7\'<D$@V+F3,)H!#]4A\_&/]OYA"=MV21^@OECG\HW^2J
+MJGI_69=Y#FTY4>-0M=/,,]10%$)HT@G0?[VF1)=3:J97[;D@Q8Z<\X55S:.$
+MB24&&@+D/#)E<;-5-JCR4C\^T3]/+VAY_?TGS^?W'Z<\ASQMJ7:VI-+[DFR?
+MW5V;AG[_$]UA^DE;NX9D^W%.OEDQOZ,=JUODK!!2\C+8IK3AJ5QM[^ROOYRJ
+M)R\C.?'"W"%3!N?SW\3]85\^<6[J;K]\GXJ^AN"Z^FI*%_EWKK\7\^?O[V#Z
+M?WM+>H_.S;[H?N(_N_R_/N1^.9_7OU.4+'Z2_#<?>HF:4FJ9_4KYZW*V[9JD
+MQ;%L26"/R</834)JC2+ORH&M[XZ-+KTS/M?I_V?Z2,]>/NX>.AZW!G%^%TV2
+M_NY(]?\AG7-IORX5,4PY^2_S4^N]7W->V]'4NNN]FGM4_S7^B\Z_'<YY^?EY
+MB(,&KU)X%V$UQU:?H85:M2%2=ZJT241V(*9U;/9^TN@O:!^''))&^*.M.M2X
+MU>XYSVKJ0O5+#[UUV%,YT5UGTL^1IFFB'.ENW:CP8_Y@_6?FF?PX^Z^%_]FL
+M_%^*OO69F_N?%FWN"<5J5>UZF<_V+7ZGN_*WA^C^?^+(?PCOMO]S]B[L(DM>
+M:'6_K^6._RPO^CGS[\97Z'H^C7TOE^R<4_M\5(E/E<IFW815SA_^W/^^HL:5
+M11`5?)"D6*06G^\>/GWRUTJACEM]_0^C+)17++3C7@SSLE)Z\&I"S)="F%50
+M3IL4$GVF`>K_7\>MS1#Y&?;5^5);GPS_K<^SY]%GZ/ST%OGJ3R87ZE&FB4'*
+M+=,3_E7^QYXOU\:E75_SW<=YG^Q-OK[.UIZVCX?9CZQ@DFFEA.MFO.2U536R
+M\)[]>T'.4IJQQ#UD4B<%QWBO;&?O[U#,'SJL5S;.U7=KUT<95#=+)J-2FCWF
+MG[NZ\C`8,Q<\O[?\4'W>?MB+I);<O4-:\2UQ32>ZZFF?E,ZD#25Y9K4-)E5T
+M)]B?UZ<3>YE0B8V+C/:F%U,/Q.QCE<6%DH>Z?\1#9#`@I^'(M82JIBZ)V41,
+M_8L&.YXI'%U7E9$6:+E=P@.F'3)'<HKWV3FH9U8V$3X$B[AIA"!"6QC5ZD+X
+MI+#=H7)N%(PKJD)+J01T3!<DGC<O[#E*IQ(CFV>'-:FL<DRTN=ZCK^P\FM_G
+M<7I0F35CEZMJY""XDAJ3+J74*EU'\]UK1N:RM=:-9?76BCJ-MKB1W,A8DUW^
+M?S6?=Y&,KT6)I+*1H^JRUVTEL^3]?B>3?1+UH30K*ZU=>'+HFR,VP=#GIJ+I
+MU96%KM+HD@E#[,?D@?5KZ/L@$%`G0M0RLZ;R"):+=PK34A8FI;)&21-4G7K=
+MN<^_>KT;I#421$HMQJ>76DF@;N$4K))I9-?F:T&LFME;//I>/-V\E4JUL5J,
+M5;&US6HO)[_==<Q&\W-:)0>72ZT]:T75(*76CFB<W5*0EY"^]Z^S?PG>NH<R
+MR,%2%,LS+"]_S1_M,[B^BM_WBGA0+!!$^E@S2+AD+[659O$).-!6K,-6Y-)V
+M42E..3/ZV]J+:O3:,J94TB$9$DMT5]N301JPRYXA`SMCXZ/?Q?8+61_M/I'^
+M.O9QPC"O*O(5\;LT0_762G)_!L4OVJ]DT1/C\=7=;7RE8E!NRCI'\S_I(G,'
+MR0QYH5OW?S9>XI>?)D4/="#1/%&(XDH;"CCNQNFHO/2FFBF29T<:/A(XER9*
+MV517Z[X>,$;]TQ8_25X[_F9=G\M#/P@'_H0[]?'6TB]0^E(ZA\,_V+^1F*]V
+M?Y$%8\?`B;I_748_V%\VV57[57JFPS=JTA6UDH'+3(/XQ)XJ7[_*-NG>U]4X
+M3C/%6X=D?HQ;1PVSH^8?N^OMP=,#MK5OM?''[X,<*12S)K^[5@)LJE"))&_8
+M45QNS/Z-U^CO_$H43L(D"31'\53'X;^%WE_BJ-`C,LMX[_I]Y_BG6A^!C'J]
+MS9(_&_6?\U-C?Y:[$Z?S\OVO9PYCE4"D,:5*2'9BZ(0,(>OSSL!NS#HA2$V2
+M=76]0V8H+/BM1PAX.$"NE65A=#=,)#S0.[)HF;('1#WJR69MI>Q/BWVL29IJ
+MW;)I5+%(Z96+6H)2A>H,1,TI<P&M&OOV#I(4=DHY')-+>8]78.P^YP5IPT&S
+MA.S,)FJFJFXS*CM@SR\]!HGBR5LG9!?J2X/W65-O2P;MUB=4T260':J9RTJI
+M!31%E.[27$U99%1%/I])N]4#]5OV3Z(9QYN'8J<X?K\ND/:=O1J0[RU]4]*2
+M/'.DXB=<H9'%",8F]P!F*@A&C1CIR<I8II?P1ITV0";FV(_XF*$T'(Z5@^$I
+M(\A,MB!!4CB@[9R0=^_BFM*1P9I&0HGA:_;+*X<8\+9/L873KH=+UKVRLZ>&
+M+71==[%[F3I$F+^JX2)7QCQ%`_.?X3^J&%:/V,,GZ^-LT''P_&/MP)KG%EVL
+M?Q.90)E8Q]D515W\FC\L*/+')XSODF4`00B%]+X2UBUMV_B;@D',#G?I]/]S
+MB\KP[+1`._ZP$0/N(<D'[MA@D(_A."CYS#4(`6OS\^MDWG4G1%_AJ1U2;5]_
+M/6][]K<.^0KK=VZ26**TTT3?V0OY^V/=%PPOIST_+-)DE*OPA+E!-T9<)H.?
+M4Z*'[FKF%IF5:J0A]R&/6;;S)9DDIB_30PH:HPY)!",EQE*A*8?['X:HG^JJ
+M:RZD8PFYF2+H,&I#8%-ML1_F+9!&5,@D!+XFSC7=0()^OQ75AO77D*DN:F@0
+MV_LLU<;_>AI$FT6KG%_#'9.8F?S\QQEX\7TYIS3G-YN$*C.<US-3>:=+3[)=
+MNOU&)=*M3-+\?F8_'P(6;3*/ZGS_O8^?)0K!IF_)?9TBM_#N9U3)`21_Y?\?
+MC/JK^?*8E>_4A?)I,(=0?W(VU*7O\)R8)YH##,B5^,2I&]1L)3)?V?K[D!_U
+MK/":+*"09^$+$*)DKR1X_,F;T.R#B$_UQ5(-]]-[<E[^ZV/\Y&X%(:'SJ=5P
+MD,_?SZO/B")_@@7]7LV2N^30I.I#FDC_/+G"2/^5+$W^/M`9^*G:9/W\?T1?
+MN7XUW]?4Z:*!BD%)74?KY^+NS]-EE<_RYH*0_GJD#]5=&4ZG"R?HW_$_RF7X
+M_G:=(%6?U\);BOO_/7W5[GXEPY9=<^MLY9;%@6:>BI1+3/!H\EI(HH,RRP?2
+M/M/:=I'-0^HOMKY4>OS^ZNUXK/V^>G?]GP=?H_<_.VH_X.^'X,R4#5;--^_P
+MJ<WP_'J==<B>U?F6+^+\^QYZ/?TE?V6_E_/J7R?I_M_WN,__3-W\]\P#]_O:
+M^U]G.7]'=;?S=3S].1A]\37\G^TPKWZ65_!%PY^2W>?[53G]GXW\R/Q\^9(_
+M;]?AXE^OL_7?7W*_.34?S-=/R?Q*?UU7GU(VS7A:_WXW:^\0^]%L"R6DN^O\
+M1JC0^DN'U^K^K5+V0^^4BY5K]F!Y_=<^L4_7^+W!?\I"?P&CQ_L(^P?V(6(?
+M7TSZ8_!N4,^?AA#OKWWROM/^TY^O-E8_VK]I<K_IV?C/];YZBCWZF??;#%D!
+M3RC52%3^BT=9.[+#M3GE/Z^]P]](?KOL]VSG\_D\K^UZJ)WZ+CC\I9J_@R"/
+M?Y_NW/X8OK-3]?G?E_F?UM>8[SNQN2ZXA0)*'Y!^7^;,G'D]-R^,V\^_ZY\^
+MZ=?,:(^_>?S[FJ=!S]S0K/9\=?BY_CZS^W\_G/JE1^?$?X_-_3RZ\#IMG5Q+
+MIKFX_&]MM+9CMTJW6\SO?>J[I]YZI?%73/KM;7U]K:I^9IK;IWJ??T*[]M.+
+MS1<N;8K+;KCJG-X9'K9ORNW7OQ^LR%YV-)DAW3$UGA=/^GU]&?F\P_I;])?R
+MG+K#?4*^3]39_2%&Y1(_QQ_Q_\0_T;PD>&19P1QGQ+_=D;Z`&LBJR"+716>^
+M]65SHIUKVY!WIHV%A5%@]V;&YXL23M).RSD[J)F**2<"$;"40?YLT(W#1`F$
+M(80^Z(B,&,5_2NR\N6!IJJP5'*]3VC\WS`9$L4;V%!\=2Q+MM,@(X32:(F9"
+M""@@*J`F(Y`K:)92JV^K8&8^02NS9]U`17Y!<NO$7%?!XCJFS,QZ(_72,7UF
+M5TL[G#C0KGUECV&GPR0T=+'D6610G6O*OO0HRYRF:'Z6@`>4+!+ROO%MIC6?
+M?,C(FA<F\N7N:34P].7,T<WAY*:0W0Z`\B.%(65@&")6"F)B*?1*&,-D)2`B
+M2"6"(J2HK.(.:$"<CGQQTZ72)&T,VA,J=)JFVI-[M2IQYN(8YR^G,)TV-/:U
+MV4-<[T`<21P`LP`.@`$-Z>G&Q3-SXN6I0SU8&0-+)T=T.8G/J!P'7`PC(PQ#
+MO0]A[L>N(R!VP'M)@;NSHKMNJJ*&4-/;0(%1,=`L0.B!P,`Q&QT0.$=`X1PX
+M6!5@8W@S!@X<!H&CA4KDNT5&UMC!DB9RA47P$[&3H`B!\!@!B`1%[`J9/I82
+M3Z$X@<$XK*2\5A)3B)I$#WXUSG#D4U'$XBR%L0M+20DV-+6`#:7OI>&3HD31
+M"@/A@5LF&A$-(4*$0#E@1@1Y4EVFZ-RP([)&$0(,8!.S4O-UT)V+B[V,&CAW
+M`=VQPR,BW,1&D"!1B*@8-<XDTFD,I-9KIH:3[<VT0-F"EHR%:]I8P*(R%G0%
+MD@HVVP`-(1EQ(HYL4=GC(4*(S6E_@WRLT8\D1`D$=&2/$"44`+<]&%G([)Q\
+M_BXDE]),Z_P6AX0GUDA^[X60--/4'Y<9PGH/?X]XJ@$TH?EZ6_SU*HO^?[_L
+MW5_G)JP3H`0!B+%$:-"PL4HU1]/+Q5U"=`1ZSGTJ(J%#$H)#%7`8MJ*2JJHV
+M,5HZ?$*!\L4T,35%+3%3%$'`#3`)HI22B)*1(58@4L)L!5+2A4UK2:(Q!5,1
+M55:QM6C:+-K8Q&-LQ$;!J"J0]I1?,(G11A4#W%'VA05^=[&`I^`?6^'Q#Z9_
+M;-CXGQ3TF[*$`+)"4H"#Z42'/NKU>>3R^KTQ&U&R`F^X(^D94'.A@FA1$],"
+M/`"!P<*.XO((=>F]G\PY<RAC@@<[EQ#HD<!#$P<Q<)J-"&6)+A0A9"9;25<M
+M(,;.'9Q9),,S'#F.$5&P<<<>1MSCRV>EUZ;'54,8:R]=%*H;B\#(CSAV/A87
+MPJ8JB8H[EP20421/B1K*C:")RJ6FBH=M4Q$P;)`H)Q$$YA2#AN/3O$1>*H#S
+MG%0/ICN.7HGJCT!`P$0?4>>S!@SU1YZ8.G5\XWH7QX'G@X>*7DW-UP)GT+>@
+M](=]=]/$DESX>(;R#JQP&,6)Y/&/'>!#STF=)U)2@A(I/5[YP:FZL!S,R1`)
+MO7=E=>#\,?)T<!U%4'":DN<@?`04QI!@U77,0*SM,V"][YMMB92<S8Q!Z5?Q
+M-!!,$P0%5A)$A5$]U`BI\P(('L]?'>&VSHVG;.V;&M.V;&M$EI:DD*RY-0B7
+M5R.63&`I),D21F2S)2:AJZI&3%)$DA)"1QC%S26I)JELR1)(5ER28N20DDR)
+M(Y$C$D)+<ER:F73,YMLN>)K6KE5KA<FK<U-27)+("R0%B%Y)I)JT&V2Y'4H;
+M=V83>0D*V2I&QJ1%CD;9ANY-.J5LE8EC4VE:X*&@EJW+8N6V+EW,--QC,9J-
+M"RJ$W".+BX*:QFB7);&Y+)06R`L;DE;DMC<ELN33K4!UN4-.LL;+ECJA*Z@1
+M6.1)<ELN6+E9M#3*-!A0$00"YJV2_R2N8>$9<,9Q@7;LR)2MD4$84H2F223R
+M\?4?)->S7`Z:`(F_A\4G74PC[<'R9N$J%'$)4,9!Z2@@5Q:\E-ZZLJH2@(2I
+M(&3>4U%5@FN-(5]+6PKKZMNMGZPU3%QS&:$ZH8,$1##'/B@.!UHD6?QC_R?Y
+M^#FK`;;D"9<[HJIH0VVI%555:$RCU.KM7-5.7=PKF%,SDW..W<Y=W=TA,JJW
+M!=VA54'55-"JJC8F7-6[%V[EY(HU*$B9=TJ%*I5D3,M38I.J%BJR[MV+JJG!
+M550P3,S<2HDLBJ2R;N[K,N[N)F9D9=55-MWAER1)``)@88'$`;&JS"(H@!W$
+MY,ER99,U;K;=W(JJHV)E!SB=4ZJG5*C555U:#H31J<H555CJE54Z1IU4NZIY
+M>9F7EJ<HY-WE39JE#:9AEN=.XLBCCBB="#05`0Q\BQ?:N,K>@??V\;!;+GRB
+M<KX=I@%"XU6*;'ETV%/E8^2J(LE8MDD%N*05!JEY+U9YCO+%G`B<.%'8D`31
+MHF!56R7#'%T-_$M?&I9J4JN%QG-CM$BCH%5T2V9RU4_YTGM*1=#&HO6P\01N
+M@J-5^]2/]/[A$0)*2R3TS0=,SG4T4PIP;\G&L%.Z1($U>6BA[/G5Q7U]SBEU
+M^9>3FTVGLS2:-WCW\BA(`[.4C]!>S:NMW.V1IC:%CWT)X^)SKVB18<T;]F"W
+M7OV^A$`"?7?U$CCUFND8+G?512W!Q8G?@MSE=)\;[]+TI?`<D7TCX/'9KRR]
+MI5E5794?5NKNQF_3"];.;E3"O4/@G=R6"'E/GDCI%KPRLRC'2:DRDML(F;<W
+M1F6P3MAX@KF0#'@($!`;ZD>JW[#B],SB"L2[XE55<X!6NOS_#?=555<]-5VQ
+MO:W!C.]995F7`N3\NP[49H2D-LZ)4RE2QGZHD73Q0-().*4J-T8M@+D,(1<X
+M4_Q'W$1`%6?F>\/AXV/!]V#YU_(@`=D<%\4?'A\:^*_$4WB&3ZF]5"ZU3)^=
+MM;9FB0\'3@<H<*DW;NT^C%DI!29(9<@E(@,:=%>@"(_@50U4Q?SI^*_;-ZG\
+MKJOX>SV^AKPCUDDDV>RM[JL['B"FTPMZVJ4E,V.E#OS@'HB(B5-.^JE\GU7X
+MDDDW7SF.F>2S35SZ=B\B=RV,:RP_7>IURVQ3<>\/+BLUD3I?>*OUHRUB9V\I
+M0QF*I0=/:.7*?^K?D1`C]_G76]XOW#)O8S?FBE*[#;N\^C-*\=<\GE@MIW0<
+MRA>]VS/#\W=>^#A1?GXYT^$BSS#7PLD9;#(NL0ZZ[MKJ[P@")BY]JV6,>JZR
+M`(\_<<P],G@D!*;YW,]U/@EAW%(Y5,N)6R'*GF,SID68P_CY$`0O?#7IRGY/
+MFGB5'Y+#KX$X&F<KN]&SF/Q8T<8)#VJ-!^J:*`UR+JLF137I1(JZ6>&CKYGH
+M;)5OBO4+V1Y0J'34^+?J]PKW=UJUF91%7-F0,%>$0(RZ.ZJR6%0\D.O:\+"]
+M3K#UX31]7[C^XDAL3X+Z7T4PO37/X1.#*;9_6+0N-LL&K?:C.VU:%55;&J14
+M&()&*06(Q5)!D$D/M!`VQC/7:^C=E[F6N1;;32P9"T'#I\ADSHMSU&ENHBDZ
+M,P*IL&N+5+.*R<#65H97*,O#<(&4`G60\PK//DW^OI5=,%H+[^FOM!=G8*(0
+M*9UJ3Q6A`TK!1#_;Z$1`G*"H7Z'OQ"?/M[I73/2-V_EM57O1HM#-5KWO%HLU
+M*W6=0MY/>L$S*96RZ(VLR0$HMC`0R/GH$`369OQ.3ZU'SUR]O?ESZ[[4"5[W
+MN?MV[010.^U2JR<[LA=)O3I))@D;E4ZVN?C69(G0R"22?9Z>*RA.@HV+T<:M
+M`+C9#PMTQ^2-E)#='OE"X5TRNK*-3]?0@0!1[Y]&4@&>:F2]G]XCU;2/K$U/
+M6L#>#Z>SB-3(I+#]$(XKF15%VY4H7G`"!+N2+GP^>9.=D[;CQB(GQ'$5UJ3-
+M=[J.7@Z9A=Z3M[>=?=2-<93PQ,SRD9:OPF9G#[UUQ#\?-RNKE@(+BR%A""MB
+MYK@YLC2R"02%7"TK>:L&TI-`XT+.M.[9(-I-!F20PK2"IO<RDY&WC347LL&.
+MM?6_!``'N'C\+HSWO2_:,O5NW.W+=BRQ?:?DWA8XW,^@M4280C08\3528R0A
+MMJ<46Y9T>>D42/H#X(B`+].$ZWSKX[?RE;U2,?RX5_%N]5KV[//VG9W=K.V]
+MX44<KG5F>J;U870-ZVR%]?!`B&,"S"#E>:'5\WUHF1N:?C%/B<\/:;WIS&U2
+M'3EI])-^;VM[>?=W=S[GN[W<^[N[GNUF4\Q]N]W/N[N]OM\_/WGS?G[GW/M?
+M:^;Y]S[IN9=<[Y]KYOL[GZ0L]8T3<S&OV;X8>@1`KW2*F[Q3UM:\GTV)5)<L
+M[$7\7$?(`$9WN]ZDOB"*^"[/#3HU2=(^OKZ^NK']>@)_4^`I_.42U]8I(PQ9
+MNVO">B!$5R?I?202"3V=N5M<5Z<L\:/.B-2!(Y+>I<*PW>"0VT5FX9S)R?9<
+MWT[[WCYJYDY5]PN[6]A*G975PTX>:D\T2#,E'G+(LHE+ZCX(@0L]WL\773=9
+M=(WZ<0M/944V)?S)KJFU+=R;[<'MDDDDUOP`1OM&C>&6+2-=,JJM<8:..5#7
+M+.4X[O6JQ,I+.L`.S(;2$V@!O[NYY4?5]C,ZCY<\VZX[]BU\7$EHS4_PR[&6
+ME_`MS^A$0"._@;?3W6;]?C0&=KS<5U5*NXC^7`0$+/SW`?N("'PGZ&4R@G/T
+MJ8XRS\?I&:ID?6!9R!F^UB[@U3>6\I$]F#.O?KZB!`6*0O'X-*TU1^,I!K/H
+M?7I[Z3]T`R_.>_?:(,8<^OI5ZC4*9T``9U3YQ8I[\J=[1Y/*K+J#WH]=E[=Z
+M'*9ZE<TZ5T)Q+#5D;384'*MX?95"JL>B(A)"J'#`Q@L>%"AHD#P$@>#]-^E;
+MWJVAQ*DSER/;9DBGV.QS=*69.DBTY3J2);FCA$@CP``93VL]7'WKFY'$TW[L
+M-%%DWZQ$=0&!3*L@>U&T#B9BB*Q72LN_=`$#>[4DB@B+GWA20]I^ASU6,GY/
+M6A.E($^RI7C5"4%+Y*9-J)'2C)%%$29Y,V-IM:+G=K2,%"2!\G1X0($K1QFU
+M>V*D#-NL]O5=IXJ\GA6SC&2\NB8[$TKD&=ZL.4T/Q>?M]`"!WH^<6QZF'[Y(
+M0])OPW"T:K:ZC4W40N@0(41/]8B(``L54Q]RBNH2C'R5/Q(S/P.L?SXLUJ:Z
+M?!8'*)3"%'B'M=.$.5Q%ZK-9[T`"/:),^,CJ)F2*H][VEI;65Z2M>X26=):8
+M5^%=J"T0B1`BN/.>F7WCB85(YFE[NRI)[&NIBN&J;9-;)G2<6J1,L24)3S>!
+M!$?RL?S4`6!`V@#P$#OWXZ=,^-=:OCF]W.UY0S)4LX'&3E5C:`@7.&Z6/=^S
+M(O\2;R[[BLU',[=MSZ4&D,'SWQRJ6Y?9V"ICY2@HB2"58X7K:OYZAE/9(S7K
+M7=D=6[RT,K.0#!575[N*K3$\@-Y1,H:8P(WS,]3;E$$%X&90)X@(PIQP"87&
+M4S63X`1$GC,XE7MBCW/TU1IC%/5`[P]ZSC?3:'>W9R_@@#T]2Z\0#"-KP[=N
+M3(.&D"%!RF,:8^"($,7HSX^E.QLX'CRP63W>Z9-OO4@KU@'MRIBF/>\R8SIQ
+M;(ZGL"!&=>[ON[V9G=-WW=-WW=F9W3=]R2[,SNF[[NS,[LJZJ4D\4+UBK>Y<
+M,'S-O,G;-5QD5)MC@U6,U:L7JP9ZM:DA$)(+2M.5)/2#*C+565%REZ!$0:ZS
+M87$C)\@NO!Y%Y)W5)O;(J:=;7O$W[W<L75Y.\]F@4D+X'7C->`$1?10?7(=T
+M/)"A0#Z7AP'R^!X.G>P(B3!(Z;J>,TD?4I.-$A7GRY51G0!`GP\_.RK0XJ<A
+M+WA)J/;?K<WMCM@29JE;P;9+8ZIK:8;>[.5.$[F]N;N:N047US."RHK%-U=&
+M@VI6U3U/;63F]E3Q"$D.T4",/@!$5X13Q).ILDUN^F8$]@/.<S0)YO<(USI)
+M))"^@Z*12!GZ^L^MJX*T./HS,H6E.=]```??4_5*^'MKWSOF;-]NR[WMS%@;
+M"V^$F9]!Y-.6O6G+&^E][1+=4*RK1XPJJT-VMXL[5-$<)33N\-^@"!<6XJO>
+M,M4Y]A-TFF*<SY;=A9ANYZID#CD=,"=WTBA59K3N#8ZA:ZA5YUPWY=:Y=FPH
+MX>_8!N20[3,+;;\%K<.W!>]K9Y)=1<[%6IXL;$`!^C)I($N^0TW9\I'M/GXC
+M2!=Z)"Z<KW+-S`TA6@(;Y"8Y4B9YDF6SDS-4A(X>`@11E>OKT4:<+I(<FQOF
+M/#Q))))))'N+UJUH?1=.NZ:0R@E&@'CM^!;4GQ&B6>!LG#;`0,<8$Z%X"`%+
+MU9W%UX=E!CU^(7=NE`=@'LO!W#`S5GF+,29)G8$0#[0LU@]FU,4)ZV,;(.`F
+MO7FC6,6RIM>FN/N]+7>96`@=OB47@JS<W=)^_>,^?(%_&6#[?D@9GPLFS`ST
+M1`%?*'7[*VEFN*.!CD,Y"DWM=>UYCQ#T+NR<HI@ST]F;-WM4V,<#)!*VTM"1
+M9BCI?**N^"!\`(#%$XD22205'GC'AU^KR#8!C-<C5$^O$W.NJY(T;!*[T1$+
+MW3'MWTS+OVRG>*A*0I=6=7=0G#U9-K)[O8-=:`>+FND,H>4RLSLFEPE(JMJI
+ME4-N0Y#I4<+R-?L1I,PR&8Y+N%OJMC3)O9,H/T0`'%)6:U=ZA4GQOE(1756A
+MQI1QI/UYRLYV$6J[T"!%/#+]Z7E$,C?4#:\DNJ0;H#:54I75?9AH*ZUU55NV
+M*U390ZN9O.11-5+M1I%G>N"TFYEB<6M\,V4!IC4V1-;,<EC*@VESPQ$>$`1A
+M_0@/;^:F_BUQ<A%.2?@<S-*;G$7@OQW`Y^3OS]0.NQYH%*YWY+>\93SYU=LF
+M>%3M6+V6Z^8)]+&'HJ=;JII8223!!)!.C.WU25^9$?(B`/O=^,G9>>*YQ;@<
+MN,K<YEL7+)*M27W)"6M1?''Z\N<RO93OQXZG@<CQ:OI8PW=^E2A0I43''9G%
+M(Z96L&QMR'B#!%H(@T>,M6#1(,L0*]$`0<#GMJ'YN7/(3/FQCOR6<^SKT(AK
+MRA"=.3YWX4?$3Y85*D/5YR/$D4PAP@1%;YH*4R+(8MORP&I2"&<^_BV#:T\9
+MS/0`(Q9WRRWMCG\#]:+]5SRO"Q7/W$^.\_X?C@VI=[[V3+$Z-7IO=K:*=&A>
+M([HJ94HWN20E,+,SL/:,[LV<LBE4N<ZK)AVWSRA-4N5&D*H?($`.CE;<]3UP
+MZ#Z7;D%"S[3P8S<'+M-FZI[@G)?`Y=X'D@TZTU8FIED3VL##X@:2*1/=QT+R
+MJO.?,DS-XM.=KV32FYHM(N6P0ZS5,E6+CP`@7G>$[^T"$_V`%5\^>P[$7.]D
+MSE1P&O8BZ!/11))@F/GP]*KZROKZI3D$WN(-$$I&TB00_KZ@1`^?,D!+`E\\
+MA\PN^'QU\)P&M4JJWJ*JSW/1C[@)(K5*N78:W:D]7#/D"($\O8NDEYY/ZRF?
+MGS<^%/#=A0B);2?'YGP`0.D5*MI[FU;YS-`J50J[?NVZ[63PJIG3/<S[T]S\
+MW?>JS(LE^[IGO=O5N<1&&@>V!Z5+NA5`A\ATH[]0?``1X+NQGY?S*Y48V32>
+MZ19TX-D^N1ND-?+Q;X5I%D>/I4&PJ.I5QWO5M#*_UG^^5U1!]((&5%`LXS9Y
+M;MG&<]7.DBA%E\%@SB7+B;53LXG+>#_3+FE_Q^V9/^O?I'V?O[UB;0^+SB2_
+M\Z#=%PZ5FF+U59V+)26<M_?[7V^^J*6O7[O5\'P97M4S:*U_XYIP<YM)'BCP
+M_O`@#I(5]=T>4XE[JED(;;"V@PG8Z>H@DDFMGLF3?#)Y4*%%A^I$9UK986$:
+MWB2LP..$5%`WGH@")WRD@DDGI/KE9>X2223KJ9)()9A-:6>K?;O5ZYH*;4D%
+M"7GIX=[-R=I2K*K'*15VL"9PS$Y7:7BMKK,N-&WS&774RK.'\'X(B.GUXNOO
+MB!AS+B5\M*!A)\9.)5WI+#Q"B6L.2/.,+2U+H@0/#*0.;PKF)Y9R4[YA]IV^
+MNJDVY6\#,YPD2>V[X912NK,?UF2YR;R9L7Z?`QZID$]5#&[Z*E34[\@`1[4Q
+MQ)[;W7Z>P>+1Z8D26NY]=Q<\*HO!]`?`!`F23!(T'"SRZK)/+S]OP:,2"I1)
+M:"A`^.Q$17NG9]VELUWG6<<ONR]F;NL;KIY]UZGTMXW.=S[54]E1Q`G<PCI%
+M,IDD.$ASW%3-,BB+Q2!Z!$;=#.UF:XTK6A2#F#WIRQ)02W*S"K?C/@9K%W7[
+M!SZ5['(XC3&W.P!`DS[V^Q,(O9L+S5<U2]08[N7;EWR7;<V:'*:V\.7N7<T[
+M6SA[6S2W,<3ZZ,::Y6\#+3.M3QX"`+Y5VA4<N2O7XTA67UN_)[VC;NG=WPGG
+M.],^_/[G]3]"UOU]S5.J^B?JU1.6Z5K)E4/JINZVT=FMRA]]PH=5PSAMW0U*
+MB'U]=(LBB7*>W:/+5310=E6-[,Q*NNT$F9D]>OH4E6E/7M=M1DY>)976=XW?
+M7B-.*LVUJA<SX*)F="3W=+G&^NR[/.,7<<7JW..*X;>)#>W*-BZSZ@"%U;/I
+M-^K7H1%#2!+D3B'@=E98QV165#)*):A3<S2CQ#D8/"(`4+UE[#SRW*E9[/=Z
+M=GM]N^F9IXQLUOK&'@M6+S'ZB(BI'OC%2/<"/`DP;1.$*;]\-S0^0``[C,K>
+M,JG[F1)JD1B2H4-#.3I9P94HJJ0:XR;^`""+]GS4<%D254,?&!T^)=OJ7S>@
+M0!\`@=X;\]U/Y+-3Z_//G7B=7M%&WF_.JO/!+O4G9K9F9Y!^<[>E'=*O>%E9
+M6F3%:?`"/9HH=:U]'E[;".(*:[27JR%E[=FA)=R;TXUPQ11RAKX77H@`')D3
+M148Q[6&2]';>6?&X=%UO.YFFH0$G/+PK1$0SLY1%>\/.K([W.\M<),N=N9X@
+ME7S3F9&W/^!T6:BLKY`$-:OERSGF>H5\P^&9SMDQ@XDDF4B<0WRP-'U,=@\C
+M=51\KF($<!`,0(F^KIG5)"/AG4%4OTWAOD)*JY)RF;2TX839O3RZS2%QZ(@:
+M)E;OLDB^H3B#]+Q[1:\G,UJJMZMVC[PCNWQ2]U/POFSLM2VV?OYWCFV2DO!F
+MIYEXJ.6PZKTNJ,HR<VW=S8G)&5Z5LR9K&9N:[!<C:[:[,T8^QBG/<=Q%4,5O
+M-[+I*I*9;$[TT*U_DCT0OH0/@GL.?'0@W$0/XR1U?+$?2(X$WTW]5:N:OYF'
+MR]V:L)[IH*\P)+JP7TGF]Z[I(@D##)`9#!XTN8LFNRJQC\@?`(&])X_!.KXR
+M/EV`O3CKY=]>77)<*(.9+?9.R=S31[90V>$G;78IH2/`0',\R>&8^<K/:7Y9
+MUF:Q=>O:KE0PK3%]LR%6;(M8*RMF7DLT94;PE5Q,A=,HQZ`!_K9`'8L[X]L,
+M6_7\0>(S3W)MW(;RIO/FU1UXJF(=5V)V,(>3(V7<H$@F63SRNZWQX#Y$0!X#
+MQ'B9X^UFK$GR3PU"?"L2J\7KS-B^;[8RZ$AUE[G"\T%/GC'%;W*:)=G)LO"2
+M>O&JVO`0-[").VY&;WIX2\.4.O)637&^K.-6IG=%RUIWK5OM&Y1$]U:$+![;
+MS,<[NK*"+/"D)N>CP`C55V.Q-3Q?M>SMS[<+N9SI$F,-]4ZIVQFU72,F-#FQ
+MX`16>\M6+JW.5^E:MM"<>:VYJWUC.3`P4GW7DG2>&E1KV9<FC+`-X$8ZTK5^
+M``7>VKH9U3?A*]-;JG7I,]JP:EM<<6R]K>BA3[L2[EM%"TVS&R\05"J)L.A2
+MJV#G8JU!BK]$1<X:N>W]?!E#*0OX-![XW9M7"@L:0"2218IH.85(\NQG"F,N
+M\D4*R\?*=ZJ6]-I+,R@=26S/^$0/U]P`/=X%?0]]'UDOXAC^,8M+$QM]$*OK
+MSVUKH^%&I(F>QI!R#GDIMM7Z!&U7O3WNN)M%GUFSBV_5MN5<\&DG-ZUVVUX=
+M=!OO9R0Z$7#P=@(>3`@&Y[S.<:/N=@4I$E2]]G"NS9NS>:IKIQ35SEI]OA`&
+M>D%+:P[HYAY(M.C[0Y>]VZ3G2Z0F*WCQ`N2W:58@^F>"+-=@FM\(`:O1A>@S
+MY^3!RBP^5V-JZJ7X:YYB585UFY=V:S3D]<Y'8LO$))L0/1$4_8CCU\O/Q.Y[
+M:G@A1YCG)I=4:;SOR('R!'O'?B=K/.O/IHOGJ7K7IVE%74BJJJKBYW,YP/:2
+M153#7XD/R`O6+ZA9GX(!MS\/OCZTINO8"U^TN<[A@J=$G.W7(E!'YI!O=J8G
+M(^0`?":W3),[U90Z7?OT';5?Z]"OATN2*J=:]C?RYOR2-4DQ4H70LOU#\B#]
+MB(Z[M,8?OYX5GS)_WL?8[\_0+C_`A`WGS.9]]4/LU]JV>J=,*JJJJJJJH*JJ
+MY6KY>#Z/D?)\G[7W?A[,]._5TW7M63M2!/&0^,C"3P2?*P`;$+Y1A-DD8(0?
+M5**.N?FXUDEY*M741D(ZC460BHV+71MNM,8R=V222223,UM(KA$%-I)`9/+6
+MC<3X2'V,O%A\&'Y]]#@`8I20YK+RV\J:3DD"<@2#GO6!S!2(5`25$"01@)`,
+M6I<6_Q3$L1:S'9V"M.6^-+U`_"CQ"V(.PZQH%P@0A>FQA,'&0,HN1VL"_P,-
+MKS\$5YA8<>=2^H$?O\?4?V7?5#XQ\8PDCY/TZ[A4$K.VZKNF0<H'HM#:TM#Z
+M`AH[1\<8DRA([;D,M7<S::XY/I<]3-TZ&4Y9)))))@DDU-`3,Q$WEFJUJFJJ
+MJ*)),M!->$1>4,2!`@!@A\T+G*"L]:M]XXL%S=VW=]&D2",NYZL)'(-GP$//
+M4+*P.3-"B&<9ZV^R]PYN+5ZIOL?=;,P!Z!"OWJ[>?O;J[7V/NSNU]F=VOKMW
+M=N\SNU]C[L[KNGN\+GL-VN(`VL7;7)Z<.3@GXQ+G-[F^8UK)7O@`'H"?;>/:
+MFO2-V?,HW623O<-MY<O"+Y9'HASIKSO/-N?//*M>$E7M]0=\Q6XZMUV(\L';
+MS@B!A9&3`1B+!-<D]KN*BP.#(+`G,-C%E,;Z3":@:;0@9FG%,VZWJX>0,>NC
+MJ03#"%<RJX]RN=P6<H>%76"C-EW4TM%,G:PKLVI%8OKY`W+1\_>\R4I;J97K
+M7KFJN;J[H?`K#J]T,IMRMT7:95,*7CS*DX0@K[!IXW0LUN':B]$UURDEVG=S
+MMQUPNL+&1IFEO%UNS89!W7F4XW,E2>&2'TS,UBJ:4UE"_@%J*G?5ZPU50>!>
+M=.MG#I2:&2/=S!(T4=$[;(Z9WDY[G-=55S^1$$/!.3I`DZ*M^K@W67XU2R20
+M_X'O#PFY7>01!!#2:;1I*E3[O62](^@0H(9C]&0`1)'V($"D.]4A?%]7Y?#)
+M(J.B);^MS?(^6%W)NZBI2\,PG;V>ZIF6]Y"AVR:=<[G1>:,)QJIU=>[V75T:
+M[<-_X2)J58<H-^.T$Z892]U"G.X+K?D!<\3P_")RUI'CFX4HWH@5(\D!M*^\
+M4/4"KK+\CQ*'HQL+0P*86Y/<YO-5>W:NX.6)*W;I#P>3C7F]HI2V)29-9[S\
+M2;(I1%N>L]G7SQ.MT:^VEM/2;X3EC@N7@/0B_:#[RMKV>?LD&,WJFN[+ZEL^
+MB)IH;H<S,O@S3I!MTSJ%X(K)2.K.SU/UX/4QV;6WMT,'H!TL%9GO7ZU<7-9T
+ML"?34#T9FB4B/6:[:]4G3N7Y)Y&(VM=TIX5O/%77)'+5PQ/#Q#H5M/+M*E?;
+MU7>E/-1-5UKK--WI7='QCHX:FFM$G=IPF(JB:*&4G`$[>)[.,N.>N^&=]B=N
+M.U;;5VUWV6K7LW=+:8O!)^)&]MDB=W*VYZEG5*R4E4JG0[4`F%J\(<YK!WV]
+MS6^&"[Z>NT*8JDJ';IG:RYY.5I%Q9%WX1=CN2(O$O!;PV0Y,YZM"QC>N9YB\
+MQ;P\(!GV;*[.KPI14V76FU,Q6^1:?;?6),0:!VAWH%WF-$H=LZ=&6+*ZE.[4
+MTMTN_3O5)MI$T+M7Q=$>$1D;=4FN]7JS#%"KD,4,NRSVB@.@`R2)JY5FAQ%;
+M(NLEO+>/',C.J9]Z(Z:WIRO=E^N=3M`;N"9FW)\G0ZTU@7@!('-#GR/35#B:
+M]XB\E7Z\6Y+N]08[/"*D<*M="&Q),U,FE=:.]O9G`5.C2CM\+J>E0\FYD@`'
+MJ52C!;J9,1':K,";MLQ`)@S,ZTF8FH9-:M0&S)JZNL"R8:NM:,'6I<@`RH"E
+M"+++';6B24A+J6W5G=P\%-*PC=I.6(`>4Z-$!4IV#'Y,>@>)!B"#&(LF6X$`
+M/5U[9[&?'-I?6W.P3/'.@.5C^!-%'%7WB]JJR,QV5,Z4U5YK$^U2ZM.<Q[W2
+MMQR,(S:VJZ^X#PC4:'KY@Y0]S\Y>\,&9V:U9X$2ZIRUU7C:K"ML4==2;:F`C
+M.DJ],S,NP;G:>W>]J\(7MS/9-7S1[S[I>:V.1:O-TKC<OT"*[5HHC3%8ZZ>V
+M;J:]J%O,Z:<S6[DH7@1NYD&:*\`J.Z2E4E!B+59L=;9?=YCQ6)RX\M]-D6PA
+MQ;%"JL7)O-=B3/MM8<LZ[DG/`7.5R:T+R=][,N=7M[J55EE7M9.*CB)Y-T]F
+M&89&-/PCV`,C$18:-]0V>.[N>!SK,W0:.='A`4A\LEMX'ZOWOWQ*2<1V?A=S
+M9)NA-1<W?*YE=-+6?+JK+!R\SNRKY4`(^1!B($D>,Z=(6!*[:GQG.EWNV?:3
+M#L3:O;ZJ1D+55]MUE9$1`'[P`?U]``?D?<::BJJJJFJ:JJ*HIJFJ"JJJIJJ8
+MB)**IJJ0HJ2*II***JJ:JJ*2FJII)J*:H(BOG9JM:*HK%57DBJJS)%1555Q7
+M8>QOVYZ)&;K']/!GUM_831J1P3HO:E!=-1^WP10ZEWAJ^/UB?@>,LTU6T'\;
+MQ9ECNE\MQ.43%BRBJJJJJL6*NP&VIE"L#GKY?*JJNV*J*HJJJK&*J*HJJJJJ
+MJJJJBD8BJH(556M%-55555553555%!-5%4Q4145Z;55154JJJOC)%55545\`
+M>-;-&R1Z[Y/42C=O)[5AP5=GPISF;2L$8WF@U)U]([169M7MTUEMDJ)F\7:/
+M#O4<./.KJLL]/D^12%92E"K;;V:<]BG9S-=J5DK.ISK=YA=7@NL=3EO?`</>
+M',8<]XV>7LD8JQO=1D>B*XQG6\7MJKIOA15Y.K959:!R9#4@#A&/:H7H=CSY
+MNAF4K.S+]OSY%BB,%!(][P]\HN=O1D@E(OY>OIO'"PI#4.5Z<6=.SSR9H'C5
+M#9/HK:PL-^7A.EN3ZS0P8"G:55U"1>W[I&UV$4M2&SF2IO<[5R,S85]-G5PH
+MV4';&23;Y_G?5XDP*CD@?5+M43!+*UN2B#&2Q-#!ZEHGT2P=9,BH=;P"<D(?
+M/5L7QQA+ZW+:M]KUE3?ZN3?VL1G[ZN9$[LOBS$)]?'%D\/`=&DS*/3U;Z0IE
+M5WCN[S0R[=5>E=PL7F\*P\-S:(NB$3=O!LY>)`W=$=ZXISRV55$J9;-36VEZ
+MKK$[%F<><Z6YK@1PB-]T^P/.BWPP2=I/#)&^G&)F<W8="Q84(]6)WG+LF162
+MSPSL%WWHAS//%>=<S9KPD3?C82>C<UT$^VY$X>@]0.&;=7P5(U68*HI%@I(9
+MUM)[;PL,$0)G5:;:%G;+:^2`E(6QAJ@\GY>RY&WLG/][_B!$0(B!$?N.X=WX
+M9.KXBPJ?P3']?NKZBVH_(7JZV;JHY*L_%?PO7K^N2*^/5DY)OX"*^/M6-K*6
+MLX%+O)D\E!(8D)&MLW,B]>&WG*LNSAW5IDCI;#SM)DM+%9Y''PI5B(P2Q@D8
+M*MSUCBL1H4$@7ZYR<\.MSM^=#RU(4&]$LJDJ,,BS)X\>QB;(1(8X$"[Y1_``
+M<>C]ZC[$"`<D_7SZ>U\^L>Y:/TE,CIUD9UARKRS@Q5>07B]N,K'7F7ZKM=.2
+MU-I!WU704Y.>HV.LFGM'=?KN!ADT)?OML6+M-V),L:G\/S/DDSTE2^FZ:P,Y
+M/'<Y]=U4\2[[C*J\$]NF6+)PS'RME9FXV:VNRC2;'U0QS2GNGJP3??,/9JR?
+MD#!8H>"12:R7GIW?4Z.=:ILW;@$F<9Y+B.(XX#@+AA),$&+8DQ`%@AM^"P8A
+M;R_`^,D6?7M2+Y)33]*J-/GR5V&ZY=DEZ9<GD">E(VFP+=S(,A@])LEH4[>I
+M#519[O#:H@KLL=X2PK,MWSW+%5A=9>7N^ZZ[.$HI:*ZW@JC,S7=5558KTJL&
+M35O:>V$'<S&\2<<\>;Q'#W917A(H<K<OV%!8#KC;7MI<VSJ[MD8,XZ<P#*`0
+M0&@*(<:P!`4"/D1`XCT#MGXEZ:F?3/%'YJVJKZH";E@:8FKYJE=K5F-YTSV=
+MI'H[=6G>$^L:!H(QT>FT/5+MZ*=KL3%-^"[*-:\-5$,3G"I]$5U5IL'E=\W<
+MW@LP($]PB!R#Z[[P]M6[+@*O#"RTZ,R,-I9655/B1UJIN>RE)J9TYTK`-,"K
+MJRG.;5&R7>78IY-6%E4\8T@.3G70G2'X1&-O)>7F>H55AUEYGL\8/>A@)!<#
+MO<\&LE$$ACV>EVPTW=-KT;DA-D`G"0.($//?/G7?;F_&>7.WI$"2=3^^JG6:
+M*>N^M];$M+D[F0J-9S[.W>UR^G(L`/M#NT`-'9RQB^M=P[;U8[BSEVI'6J,<
+MWE8\WINW-[(VY-#.G`\FXT5@GMF;33W&\T$[TW.FJE#Y"':/94>O+V^ZA575
+MYF9?O(`,^C?7^@)%`?#$&4"1\),8D2262YGY8&PX'PA[A<^O=G&!L<L<*S#@
+M?#'9^,`B/E7Z?LB>424""QO?83$.6\U3.M*LUI>N=+/-<9B95K(>GD_*>?N\
+MNF+Y?/X?%[O,QZL\BY?[G>0[2>O+GP15%BJ(P1B@B`J`S$,_M8ZV^6>[OS[?
+MTLY\/?[-OCG&G%]^D(P%PT0P;!B8ES$C@S-%&S6'0@D$@0B)!;C*Z5XYY(18
+M)&':5$O2XTX#J6`\44M>$-R\*!2O1)Q3<K3U+%5J!3MN\/26I-M53G'2DJ\E
+MXK9M"S53,Y<H.1(3G:FA*@SG'*@2W,U:"I7(LXY)>QM"($?V'_*(@?L$AG"0
+MWD`R`4!"!5[U83:T+6*E<8VOX"Q]5(:M:-)2%$_=>W/2-^RB>T[3FBC`^H!'
+MP$U862/:>%ADQE\/O8$0/H"`!.]RR?`9,N(LB(JEZRR!H&3=>F9"SM5F;V)R
+MG!AB1]$^#]2H4"CTZMGJ\:GIF`M]R$A2;EYY6+[S$X$3P:B3`0.8-8%!UG1>
+M;;GI=-2>Q^D$`UH-6Q8R32JY!%/9F)Q6EO7KQKP0@>9Y=OC^QE(<=JIARAUZ
+M+N=CHRV(RY$J2LAMB\MUC;3N3%S7#LIJ9C8:5C&)K$LFF5[&-(=M9(!<)+5(
+M33>I;P)5-5TB1,*1X,92!59/,CY^^2.D/Z?PFQ5AAD"XB!'UP@"%I"XBABBE
+M4#TQ5RQ\%DFG`&4OI>>.;7Q!X]2A\Y^FS9HR2?:AI6($C@8`H@&U1AE&0,/$
+M)+.FE(ZVR"FGC[9>&Q)G>9#2R7HM`F3V72)N9>7AN(B!]?(@1`_9P/L12$VA
+M(>MA^^2&,IQ\&Z*2%EU"1))PS]7,_6DU"/OMN9P\W,B7YJ:N1;H9G*J5X$QQ
+MH:4*HA:1SW<O0<%U8.=F<+JLO?5WAWIZJX@&T(ZEZ]@6#$_?HB`&(=8A\/R@
+M2UKJ_A&RI^./DL@D^7HY=>C+WR)I\+"D:K,0K.[>\>J1TWO)^@N`A-[(\&,\
+M;K>&#U&J*'#":&57)3=@PR?1>X%#R!WJ;1]LYPZ5P`.NTK*=`T<`U%G5)ZLU
+M%URR;$D01ZG$56'Y\`@"OHB_KS!"\;%&OKXQ@,J*$#/J3<G;%4[?K.'-71RS
+M?C.>=AK`4$YH@G9B()UL`URUSXQEP4<-G!9%%511J0,K=9]/B9=?C\?D?9D$
+MEJTR4#Y?C#F/"/N:U5=ZEBH,+<LRJ&56:+;T:U34G#?WC)&!3ENCJ#YKIPB5
+MDF:O)'9>RL,ZV,%I$.DS<VKB6;(DTTB2S:FKF1-3_@M('$@\=,#V=DCM2/GD
+MG51PNI%F;T1`_7U`B*.0/<@'$,L`55[+#2]:F6N;CL2&/7ZSY./;ECX5FP?J
+M]JB`!^,!^>R'YPTNY@.0%`4.M"4!R#D'("EY#2Z`TAI=#I:`H"@*&AT!I2D-
+M#H=+0&@**=-)H=+0&CDN@*6AUH"@*`VRG(=(:Y`60%`4V0I`NR"D6&OM]_3Y
+M?G'I:?3G[6=[ZR/MB_6K^"_/M[>[Q;GN*%,3W3$],O<$)KH99T7S?=<[$M+;
+M[Y>JM:Q?>VKZ\$QH8JC_CMD55OI2`9Y_3EZR,'$:J$T:V_5,M3U`9/;L[*O'
+M/*9P)V5;?5=IO9G9W>R=[9&31NLJKXXGF.95?V^[8TC?)I,_XSN4_C3*#_'Z
+M07Y!(';IIRB"JUE9KC8<^MF8064=)B\Q(!]4^LRN>'190-CD'FJ\YG!HL?:]
+M[D\UUP[Q/H`L@1%Z2@+D%Q1P^%F+QA!2Q[NWD6W8V\WEYP\\V/5](B^E4!^_
+M*P"<A`X(0F&V3KKJUPX<4FQG-\M+;;9)8#>O![ZWE\?R8B/FYZ['=\.W8^3\
+M&>'E9+TYXY?7I&&`E93XD%ZC6Z>%VDN?/:JG,'KF;+(9=6N<RJ$R'5]*SEN6
+MSPR3N#,>V$*JY2%9=57=CVL1=R.012<D7EUKL6+-7/-;ML3C1IO.D6G8FFYQ
+MC'D.L.*09F:Q.@423-7+H@NN#H3AV36KLT,(RW.H9)4D6>(/(JBJ$LY5,/,F
+MG(+,S0DP%*;N(@`;@^OD0!#WJ9?I^"=4?,>PQY1THC02`<#B,U3L(#O@95EC
+MEZ<;DT+(U!`M,C*I]7E650:=49V:J4^#=NIF1M@[SIDF#:HY-\*K#&"F%QKJ
+M5RTB-Z@Q)':A/#;F[7$F4!S&I:693;(=(9AEDS;878W6EE7572W=O,(8M#_#
+M!GW]VH>9($<]*WI555:P&.;[F_&KE5,L:)Q555$V4]M]!H\DYK=EYXYH13UG
+MBYGBQAGKG7T4+.K&^MWH79*<(A5>2-I"[#2P2;BK%U$RPXXW-BJN[%--TBM3
+MLH@Y73+2I)I,((X$@3)$SMW)WLJ2D8/:F*;+DC,N_KX!`@!/6:^F/KC\J8D/
+M'#WX!\6B4A76%]4<0GTKWKLS3\+Q'VWD7\0PBI78^YSV1KK><V9"\PB#`OS<
+M`F&W<+$A7"N5Q5(Q()%18D9"&C06U;6-;;;6UHG&U5,40B*J*KTV^%\W>MN1
+MQ'-<A-WF]DVM+9**NI'3YTUJEIE(HT:/$S2T.:)OU=&]];-ML[V;:&4-9":`
+M0!`@&Y(0`N0#B8`RA-:&/F7Z1=><>LI#A/9=H]+S,K)&5W@AU>\L.T=$WV>X
+MU)[PEA4\P5?>QRKF^-"SV+;?250'FW%"K?!&A90]99)("3;*T]SF;.BK6V$A
+MCPA-.5[9H39)`1X<Y0^I'?`(``3B`,'F*7Q*>]WG/A\NJOSAP;8QD)VK:\'3
+M7&PAW2*J[SWQ0-\//(&F&U1$BA$1$3Y^"5GTY97Q1R#LUJ6JABE7ID,3GSB_
+M-J8$J`Z0E!1J&3>W'V*$@8.KOEGJ](*,_$DOA=+QS#3<U@D28&;+&)618+W4
+MX)^SF+%\*8DD\NKIQT[N:N3UV0])!YBRG,600.@O.TL3H,@&ER2B2'($)09Z
+MZN^=[XQL/&IG5JTQQ4CO3&O`UJR?+3F5G+X0%\VO#^W]?RO`,5\.>*E$LV,"
+M]<G-,Y,HQQQNJN6HFH);5\F!=5EKW[TH?WT+/]]0:2>6A(K^]"[6'%";0)QQ
+M`C!`T&X(;`;"I*^P@CYCV.I\IY2\GO=!>/*`_N]]BH204?EC]B9D?LS/W1?[
+M)_M@@7>7V?M?N!(X"R#/8ANKH7L.8QBY^W$G-,@F<T=667:&BKW)]$HQ/F=#
+M`%0!$!1XXK4`2-I^YYZE)G>VL<RR;4X=5"L]DH5+N]U=DMG^5=[QUG#[L#?#
+M=I9-834I4;M>>9M]MCYE[3$H[+(HCS5DN<JH9DZ89#LT&,M>,^QV&HQLM7TW
+MU];?.+*;)>R')E!&)E'%&&`X-V2+8D94"/0!``F5M-2MN?9?[^9:)Y>O*'6X
+M^?.VD\^JP?1SOA^7+^L?OB6&?F@<PX'!B*,28C6R7!!`4>EBLICAFN>+&>>C
+M&^EC!:[2FF*S^_\/!)EFD-PW#9\AZ'/(:>O356L(MBR3BU%D(KD=;2[U$ZLD
+MDDDS-&Y,(XNT4%PVQUO;[7)U?C'I7W2!/PO/E/0GH$]]]M=$`#@,B/H0(`]4
+M,Y."31SO3..+JY,VK6@\JG6WOK57D;)NZ=;/<ZL<JG":Z[GWN%)B@9$Y<A^P
+M*D5>GBK3-M19\NK42;O22SAC$1.X@.$0`-Q[,,(`.Z"N<I9S.Y("(FOL,7M_
+M`)CES#&RQ-VKOY\L-[?S`XR.```W1/R(FN\KYDDF"4OG4%XRL'P<!ISN))@D
+MDSMKX)$TA@J('R(]-[X[ZO,PFNLI5NY4.MM.680\+&*!$"1M:'\6E3Z['E[)
+M"K=J?;5):-N>K!:?/DAV9FSP3'P"D)NK&<_@&U0+1_$U(H;'ULW7U,OY\O0Z
+M]U#QNUX@-]Y*?26)QT-];';DZ`3&=E3]]]"`(\@!';=?#2%GD/N!`J(?K&?$
+MDD*[(!>X;XU29GZ9ZO6L^.<FLQ]@:NL!V2G=(2MVIRP,+.@L&<4RV\!%EM-R
+MDM2)=O"RITELF#,DG!$4(CY`$!.=I.>.A7/D,3GS]?5)39VQ,.M#HT#W763?
+M=MV^P>K""039S>GM[;SU;>[3GJM2B_"3X+B"03B[($7#I`T5:7A1FS[E1>!#
+MC+G"IXH@I!&:3,(RK8\:R@^<F9GT`"#H]7G(@!^5KS]CP?(7SL()MG5[6_E+
+M:B].D;*GW?(`4[P]:3TJB]:W_%_J_V@2((_1<V6+.1XE")BSEJ:&(,)?-A$E
+M>O:M+4MN>]'NMQP@EV)1SN=O\Q`$?V:QQ7T+8$5?K&>SV$;6K:-'VBDX#[X"
+M1?=-&S01].2/&7IW=!-JMJ!$1JSR[U7=\O'5<DJ5Z=L7<XO;.:A@V::N\.6M
+ML/87JH=/7T[69$#<R9L$Y68WGLG>_$YX?-^3OS`4?;;D>P63A-?"2-0-`78Q
+M[2F4\-9<^N=0]`$`6O8$>TW$5XUU#'J60KWQWS68+3[VG/7UT:]@P5J\?:7[
+MK]'9IGSFYY^X=ZO&A*0]/15BI=`EF%?>*F31!6LEG)!1Q1Q5CQ[$K9L##.J'
+MS82$[+!BNN93XG!=R[NND&>(S*;E"1.RA,E8KTJ^MS.[,D.;5SH-8G6.^5LT
+M'<VT<H.9?(3R&T)#V@:M4.1JX#%J,S6)N3,TI=,<7+165Q;N;XTZJ>(NS)H*
+M<.H3M=92AT6QCV5-K<DDHA.A35=N5(Q!W3IS-V&^.<Q3FL9)OETO`C-7(LBB
+MZ1O+E$6*23;N=F\M@;8)6%2X>%D.J1[JBR3-*W-2VP75T9NGB`DY2Z=U&6+X
+MDLZ2[F1T(HNGBZ9V]B=(<>(XCQ0OIG"9H,BYM6U-=S1F:-9,6K"L.9D&7I!3
+MV0PX%%5@T3(6(U`]``CUZ,REMV_6-&XS;\4X-WMZLH3ZIP&;[AW6Z(P4`WW.
+M?:_5UIRUMV\VCZLZED[C]$OUMGN\*]`RQ+JO;K_7OFGSUA)*$;PH7(^-&R`0
+MU&/VN0!;A2I:H*RIIX*O?@B(B#[C?Q'??0=JJJFJHJJJJJFA4SRXUI-\9W<[
+M7MKM:VDSST%BJ+%%5148JQ558JJWX"K*;.VTOIQK28`,[YG$DDDDE,<#<ZOD
+MR?:X.TQ4@>O`9KUT45C;91,,9CUZDI;<AG"JDZ)4W_F<*?>ULC:7B(6!>('P
+M`1`'^A#OJ]#2,_,!KUD@DDDDSUL/\]F?`<F=F?(\P_>$Y7;<U880O$*5-VWF
+M3:[4%53="M5_1NMC+8]1!H&T@I!;5Z;GJ=]-29.QOH$1`'O4MO4D\YMCVBS(
+MIYFWC5UNG?+TKUYJGG?2Z:?3XKJSEZL`\X'O#:/1V<$_))TPB-66Y&U.U8)X
+M"``/9C5YF^69=<QOI2`ZJ.FBJ\K[=S![=$[[WXC+#W>V)/O'"&?=3`GXO:A)
+MFO2NHVHO>*`I<PZZN85`2[)ONU4/1`B!_L/VGE\.R7Z7US)PA=GMTFUNT@\0
+M[D40;Q@3W!_.L>!.L$4"!8V7#JUCYY.(O`!0(QQ-MIM%V$5D>`B!"P%`9UOI
+M%,\3LS<T229,TJRVH!9*J.=O3U;<%OAX.3C3C;<M:V1JPIAD'KZ2'J]3X@GU
+M<>&F_%D4Z/&*E)DEL=&4V/58.9`#&:_?]3ZN&%5E54=X)(#W3E7?E1-_#*F_
+M#Y0-X:#FITBZNM^6=0Y8NGR[QDQH2]*WTA9=\\#->E<AKH$Q>6WJU<YW5,]M
+MTY#((:!SP$0!//"[#W>!YY#:%^)U($M*]R9Q(F@E:")K&RZ3VVR;OD-6F3E'
+MT5M!76]9D>:]CO`/YB`"/:=_'SX_EACT1OU1+)^MN?JU;M[-<@96HRXTG4)^
+MOU(C[@0(%WBF0L3D_1'7[1?SZV`;6GVUDT0#3Y[W52L$3QBTIUC->VC-VPNQ
+MR0+W,D8.QA'E"".I=4C-H&LV:.<[9FZ*IU*RI2&<J0(2-M$Q=DW<SJPRV)>5
+MQFJ3,\W_95F>JPX)$@T$]K9REQ.Z7*FZ%8CMJ4'[<O;TXL(&S,I*WQRL3&US
+MWDJ33E"0"1AG>PY2(NE%U+(HA(CD,J48'P0`!4]N;[U.E:\9DT]5!$8$'NQ[
+MT,<![M48:*/INY\#WNO:MD*/50?7L@M]H,R?;X9<VF^VYF;F\/7(?$ZJL2F$
+M@622>K.6&55)<O3=:Q:K99%KYY]=X2$ZXZR/'/.3H;WWY-+TZ#5L9?U0'V@A
+M"+"UCB)(]<L7XD-%@U`\`/`0!`T(:KF*<RY0Q-VP)[-%%#(%#)3,'.\1@RER
+MDX11\:Z7X6:->`K,$FR8/*N="D52'!@D)FEB=$/L*NJE;>S5.]%3M6F6\:AO
+M"P2ME54YCQS"PA3ES@K,$PHRR')!_"^$32BRB$;5+UU6RS//1)EFB[JHEE`R
+M*;PH>,428Y4YI2#1>*17P`"!5O=K,]M$ZZ9\9V,\KMXSZM$U-FSK6:\<8S>W
+MZ;OUE/UYU,&[O775`%<TEA[.[./CU$7VNB97G?35SN9=85NJ&E9PQL&$+0TA
+M&"SZ<N5O:RK#Z;.$<3:DM8P3EQ2JZPP&PI()LIK129>(#'^,^`0`!*\[,B1$
+M0+&;,"PPJ/;C#!*3G,E^W@G46FP[VA("-$_$.<O`:SVR*?M!4AR4N@>@`1'L
+M/6.F9GSZJETBC[".T','MW)?;.,B:\!PS2PO27F29-W-07+J9RN]4S=30/M7
+M19ZT@0&8T%2@,$KP$``(H.I[><U@PJ\KMH@;XO1/\L_<?SO^[8^A-Q.N.C?P
+MOUN8W>M9E6>V!H>NV=6K*J;FNMH;D]F@TM)+.F$"&E`H/F>4RV$9*Q!-<=/8
+MJM2J>G23)'&B2RC:1*Q28ER36!Z=SCYWT]'Q\$.W?MVZKT[5BYW:ROC`IVQC
+MNG8A(.N1B]-XQUVMJ855<ZVUJI'/`I8%EUQ%K,-5XVE;,75E&^;@GV:GXNEA
+MZ49S7DB6+[M)6(<5YO9+*-'>UX03P2<A(B]1DQ'1$0!VREFUT=LPZU)FL\C%
+M\8URUUQU-"KF^U&57P&!3<5545523Q1)))))))*[Y6H_-NQ@W@I-2@E;&NS6
+M5A)B1IN>Z;,T5/9)OMSA)S)E$6'76KX3>BW;=PY>77V>AF&'-JJHJHJO@&*J
+MJJJ+UYOGTL\=^=SCWJ'H"3KVU/9WKQ*]2D]*PB7T]0X^DA.;+9%$^6]`@`>&
+M*YZ1[*8WU<_=E+D%QO3?##SJ<=W$XNVZ=T*]TUE7$[RY/:#N3QA5(\>?7,T[
+MGA87$$X1GF)FV3NS)4ZQ.`J#=N\2.VSA$Z!Z(B(LO@MYK-Y^FMT2[[R>@35+
+MM^GK*DL:8(;\ZX7\/IJ+:6T6B:03T/5)-$$^Q'?@``'W>D/=2\:^%&*O9'%4
+M/ANE)$Y=XE@?Q*DQ,\Y4WM/'&*KD3M4MX&B:%LT7RLM$$SLZ?1@Z[C7/O7Z8
+M"+()%FB)L.I`>%8I<I-YZI.*P#,W$IE&D3))$UYCBI9(73)V)=C:1&"@K^H^
+M`1`%#-W1\IBBKI:YJUV7/Q5MVYMCY<[9PFCM+@^?CQ(OR<E>IWC;HA,CTN_4
+M+#)X78F@MH,3=;U3$[6S1):DC7X0(`95];S*#\/#WO"90K`*+EOLSC&\]\A/
+MO;8RY!D/I&*]FZF5+KQ>DJ2W#0PB3C)BO3TCDRD+5+>HI[=2=+F\EUW&66^F
+M@:#%3<@+:=VHTARV/"(@"2%3$WN>P5V.5U*22+R33]6DD<$)2%#(AB9&B:3'
+M9O5%>9VYK,0#(78Y>,`K)G=4.N@0!#EFCAO>K:/G[KF^YQN2+O2QHL;+RM;2
+MUG+(^#SXW-M?B&0X-LC<H9&9N_`90R//J=">7E;GV\&G*<<W;73J6*O6*ZUE
+MC*]#X5=S[5IE0>R@I4I;=.X,Y3_1XCL?YB!`&'[B([YY6/D_.J2_GQ2PYVL]
+M,[LQ\[W+AF0655S54#T].W=$^)KMJKF>5K*4](U7HLA*JFB#%NA)!(HMDP[_
+MU0!\B!`$N_E]Y/O3W?+J[L9>X[S)DI7.]OA:-SJ03G.KIRN/O+E1>C="][UG
+M>W$CVW6]>[L=?'*YBLS.IGM#?*MS:`OK!T]=,7.3Q-:U5J>X.K**U/+#FJ!-
+M`B3@FY#=419&ERD,(1'$8[/P1`^1$0`AT_)&E>XP3'9\NZ0;:))/R>B)[AU4
+M[/<[RDI?&@Q)=)#^YCY\64C(,^0GJWY```8VLD?%5;CFJJMFFE(KDP.>U\HF
+M5-^%<9(EI"2)!O8T-&5I8,]?>=TZ>Y]^@0`-^"[!\A(EK$I&][=$Z2+*<UD+
+M/DGK-=I>3ZZF_4YK'H[V'W41K><R)5M64=.-T^$UPB`!E'W;?=CH6:$]W?!*
+MSYY,M+?BW0,NO=/*C7O3PWVH?/4AL>H=ASW:M]IG791%`B[Q[2.+-3H]M=KN
+M17)F.X*;R3U0@T&*2=5="L4(Z;!"M$]3+4RT8TA\N@]HN^R/`1`\-)))))))
+M)))))())))-4TM5>&Z/7Y'I]-@F)>((DDSWGH$V>V[M'AMU)()!),I$I(F3"
+M,80C!).)07:RE1/%&3O*2)"6,+/!U/D$22:VZ^`)[4`Y\SY0[34X/AWY*38D
+M^,TK-&^.8)TBB'2RD&1`UJ-:#(O?/C5\[+,28$FL*$S3N9X2&Z0!%21DTI$Z
+M4SBT;,J[G2B+(O>>G&FD0V^:$H'9Z=_I\@1$56;?SW>S)FM*DE=W(W/?)L;0
+MP79JXW7[D*I^E%M6695+)*.9*\I2GN08D)!%L7:EO*F1+-"8OT0(`:I#W/O.
+M2WZ_'9K;J^%>)))))))CPKMIDDDDDDFKR1B0689G%@EA>)E1X@TE..,4E%I9
+M`B,@B.`@",#CAZO&W0[FJX8)M,W4T\%T.WCONH>T[>VO!;LYI>]V[:G,S96U
+MT6^>5D]V%M4@>'89DSNXO7L=ZU[/8KII,C;%(DYSV6&&*:M#;"H9178)U2")
+M$*,88P6UP#2X)CC])`$1GBRB9X5-0JJ.45;!0/?%'KS./LZ[?#G6R82@#R/(
+MJ9WTTM[+?=RR51['K^T6-YJ/;XB:2BYU+489N506S,O`,S!4L:HIF:21$0T]
+MMB")*6@8+PI09\5@(9*>6$W9JT"3"RV(S-EP-=]4$FT6^>INXK!24&)A&4R"
+M(,C,JJ*"HJ:#9-;^6K$0%8X9J8)FA*7D$1)$152E)!3,LT16OC&/;3O-PDVV
+MAQ!O.;AY#RI=NG-=\N\KM6C0ZTH',08L;FR\BC5!K;.BN\\.*!XI5)%,31-1
+M5%-55(E$PD5`)L1$452:4"=%#$U0.@TT$Q51)W:HW.'".;,3,4T!2"C(:2I"
+MQ1F9JD4S23"N5/C]A^E:OPN++-A]R\3H(:8831<%K8HHIJ!-H-E6=*.#EEQS
+M3G\=>HQ;0UJBUM8BU;;$ZU._@A_P/U/_!H?XC_H1VU+_N!O<V>S>[>[N[=W=
+MJSV9F7=WW554VWNU555;W;N[LS,SN[O=W#N[N[N'=W=5$U4]W=N[O=W`M&6#
+M,R3*)S,R\R[N[02L$WG=NS,]NC;N[W<&9F"AW9F9@X=W=W#AP[K%W=V+XGN;
+M9!'#A(F:JN&#`,!!S`PV\S.[N[A,S,]W=W=W#1N[MB^&EO61N[O=P`Z.CAPM
+M==T+I5UCLUZ-!J1@=1T$1G2*#!<R*`H/APW%*!D&LJIDF9;;G;27;W=,S/=W
+M=N[O'N[N[NWN2)7=W55I7<S,SE55-MUE5556=V5EG&]J^;S,SN[N[=W=NR>P
+MG,S.XH[N[NU5"1.SG573>Y556]MW=[N[NYS>[NI"DGLWEW:2N[[N[5R[NZ\R
+MM6RENN&&+F9F9WKWAR+'):QV,=,M]EYN]W3TWW`6>S)RW67BY]TC#43-J5*:
+ME4MM[IW=222V])Z]ZGN[.]O=O`]W=-&E9;25W,S,WW=E8=DS.UM]E:MT3N]G
+M$.Z8=H;=OM4U9%;>;M=)'9BVZ[I&KKL2N['!HHDJIOK[2>N[ONZIFW<B;NIF
+MD%221KN[N[>/=W=W=O<D2N[NN[N[N9F9[NJJJJS3F=),]5=W=W=W5553;==5
+M555W=N[N[N[W;VK9DE\359F9F9G=W=V[N[U555W3,S/=W4@=J(!(B&U$`,@(
+MMJ"(())!D1`3"Z\8ZXNEG%S?,-I+JTG,[<S,S,[>[N[N[NXDG=V9ZKF925I4
+M[[E=5W=77>=W=V9F9,S,XDCO_+_Y?Z_N/E^.4WC?;<I@V204XP5-4B@89R&C
+MPA5#1"Y;C@ZW%"!QF<XF?J9TJZ!8B%"D5,HQ!]1=@1M5H86=J!:'#X$Q46<C
+M%>2Q4M">J1;$B!B.6,D?4H54S(X:Z2H1%$]#51][#RL3)R<G)BRH,V/))"1\
+M%A"!)))$^-LIB6..-XRD3,-S'MPH<T6[,C15"^0@$A&R`.R;W#F1`@3*PN\J
+M7SPT'QF7/575/<NKNY]M[Q@==YEN[>9*GIZNW(9M$$T%15*%2$TW+54I:>H-
+M;FJMI,P!4`$0""(!MB1:27*[SIIQH[!L$1M:T-N<K@Q.B8C=JI"UNBANQMU"
+MY'.'1W#HT=O'N[N[NWN)!@]W=5$U3``88<7,RDINZJJJN[LW5A"8.R^#0MA7
+M=7W`<([NS!D8,K#W4O\_^;Z)A151-)L]$_$5M\86T4W\1><EW98#8Y#'AE$>
+M?%1^J0RG)DE0Q78E-4!'1X"U9=!<GED%RQBA0WR*8*NA*CHBX^Z4'+B7\80(
+MUEB0'H/$Q00`0"[B6\!VK,+%Q>0QG+0(556H35,;"B0$(/KY;P</>9HRRR-C
+M$0YG0'9\)+Y^<.&3#26..$C4SP6%"D)49M"MPG)DG6:IES4R4RR+_TW]_S^/
+MKZ@9J'X^5]_@/KCV5=+A^-[OQG8"$J9$R]X,G'DDD)ID<*M&,X"NJ!B@(&0B
+M3EK<%`FBK4PM;#)S(HDB)`$%1(Q124I&$B+!'KY(HGO'Q25XJBE!W,OT/"7G
+M#E(B$D)UU^5HY]NX>!/Q?B^;^V%."?<0FR!#0_.;<FW]B95@[/W"-Y"9Q`J%
+MDZ-Y4B(L$&&)77FT$=C',01LY=5G!?WU,:U!$5)AK1<A"`N@32X^BU#V-0RB
+MV4>$%U+1Z=SH1/TKW.&D=&T808D\#"VQ5:;U<^?!&0>'2\PL<REVRL!-7CUC
+M@:[JJ1(!4Z*`Z&&X`B-!`YCL&YQS0A%Y\#T'9XZ"+T#H]'2;G1Y\-'`33N[`
+M+J,H".`Z$,$"(H;$#+/#($!;5[`P;'0-CH@=`'1T1T&YEC8&[MT-%B]%Q<;@
+MP9`P#-T9@S)'9MB$"+6Z,'+J%"J&;0D2G$Z21&,Q;F1`;H]4;VZ`+4Z[N('`
+MH7.`"*3L1">C7>H8P(N=Z(""PVH$A7H$)V>K@6MJQD=5:HR(F+ZX%<0*)41@
+M!=2*?!\*G%43$B.L@M%`N+SRSB:Q4_/8#G2**J***&8EQ:Q%BW1<3-DO=BQ7
+M30:OHX;ZZWH1I6*"@Z16+4F%ES"3J]#-C&DE25*@E.5!RF)G+N\>;5XU(D.=
+M%5%M!`@+)(C80D$<IBBE<B0<AE)5ML;""3(6YD&DR0$D1@RI4:0B&X<,*$08
+M8(:A16RZ2VF:O%&2.'4066$0I"ZRHJ%&HL85KCN1;%U;"9J5-?8:S6<^K?PL
+M6HW0DST6IKT)Q^@P(+A@M0BO#ALUM"J0)B(LK<T)-,CB<8=BK$+$;+:DBPXP
+M6G<Y3($L;!HP5"7$:OGC-Q2&G<K.70Y41.3C75LT`/%0.0L%.J0!#228;\-:
+MM;!1``,^HE"4M`4)2%(4A2E(4)2%`4M`4A0E`4M`4A2%(4M+2%`T)2TM`4A2
+M%-!04-+0%(4I2%`4A2%(4)0-+0E*4A2%`4A2TC0?%14`WW^T^WUR^?Y?=_0\
+M_CCR^UO[&6XB->,$1B&786TN89MS#U@2I429PE(\JL0')J2NT9$;>_D+O$'C
+M@B&S*+Y26\,AHEU.#15'JF0;<CVM;!OU+[4)A*VNU&&YVN<B#R/5.DA'(Z**
+M.#I8$@A+`D)80@][ABE]V<-[<E4T[WLIG1M;BZA+.<\[G+H,X=I7KNQ=;T+)
+M%WKQSU4Z5]9.)8)N'C!UT<NT]3>/%?6;LZ<,)MUR%AD$*KFY/#6Z7<+K=MSI
+MVU3R-EC$NG`[*JBP\ZLG#*N<:BL>575)P4>8$UA$T-/!9TGC%57=V3O=C&&E
+MF/4\[!@>N5HZ1O;V2$4*QTU==-9A!L7=]F8*L;FA%*9=\*UNMRD;H.^0;NN&
+MCLGAUZP]FKLITF;>L'+D6APWMB3,M!=-CJYU36XEM)OIM,*]%!4<JT^E<+4O
+M$Y69RO2')V>RK4\&[$WM9:29V2)PJB9QXD5:0[,J29U54RNY]2[KS)3;8MSI
+M5AD74T.X5B"&I]=LW;MI7(IT$N$NPK/'AEWW;E!:B-ISJ/"CIL=G;VBVNJKV
+M9VY,TADS.&RU+5XY.HUPI`RJMH]5"J=#7E30ZC?5/7NV9=DJ4NT5+DRAI=N=
+MW6)H/;,V-$U/((W0EFD)<W6:;F[-418J9N<3>;77>-;==VX);N;E2NY35:Q5
+M2\OJVYPVI%/7+F1>Y%;;1DR=GK>U.,=NZ*.86HNN.[6$/MHA"AVCD^JS&RYR
+ME8=/73FLJ1,I9TRH/%T;">59Z0\N=<Y./5,=7=T<EB[3PNC(JW53U'#0SKS-
+MXU-W9[*5;4[M#1W7(VGU6+JT-.3B20Q8HX9:-WQ(K<J1O8[Q=1H79I+7L$LS
+MT&E74.J<I,[V:%Q!"NZ#.LD&E@QI&F#ML=1J=X6QSV1-9LT@EV4,R3F=TDGD
+M7<V>4\5NY;#D.>Q*YB\(53O'AQZ<Q!J23L<"&!(-Y;JI=U9>,9FY,Y6E:XZ5
+M(D=R0:1RZD9LR<%"UMHH32F16UN6+K5+"UU.W<BV.?)VC-BR=O,.L86#Q0Q"
+MZ8O')VI&OJ'/./5HE/IR23N[LCMK7DC>:[<S#V9UY45VH9>=;S*N]$LC'F8-
+M4V[R1EH%'G1<V4[-VZZS/%G*WNK$,S-RI%]C)UL:PT>K,*GB&NX%[AX3+6)F
+MSSX7STSIO=T&PMC*Q`K<JCV6AQ0E@G@L3!(.]O4A0UY6"M+>\1JNP=P&MZDQ
+M.=G%X<N26@RN:>B>JFJLTIQJ91;%X:[<6W.KB0A2*I9E\Q621HPZ`>F@7254
+M,7'GG<:2KD=..W.:>S+&N4D^G#12U$U+ET)T[NY*O7!NKG;MXYQ%7-!9V+#7
+M96Z57/0L<O3?'2<O*DG@'U5IWFQF;6B[F6=Y9W;FZ[L;5!3QQ4[&O'I76+%F
+MG74WNGME'L1V<[,R]E#J&=H[.R6)Q]5Z>R>.+C.8EF;!J]>596KB<:6)7)L'
+M#84Y)RJNSUG+U@QFUT#0ITS:"P\9XO%W#I7!<<T3=<<'5QT:6+.CNK*GAW4Q
+MU%Z+*VLZ0ILB0JWFEN99*8W9K!>R`R1M8NMG>5':`K+=9RRI.6]ZT,Z=!WGF
+M,40P^Q],JZLN[T<KFIV3I1+VKDTUR&6.G>N^$\A+8ML50P6N3G9/8R2+FJG6
+M)LYQ6\+ZV:J^:=.EU5.=JAD`EFB;K;/8@\R1FFT7U:\W>6H[*D6+=RQ;TUV7
+M=T=J]MBI[-XG%(O3=';4SUI4%5BW839*&FM?2;R>5)&[SDZ,&;J7+,6*T2*D
+MI;.<*+;D;QOM8-W8K->9/'@47W,Q8[>XTZVU,OK;X-NZU.6=M'@UF0E9H[FR
+M3:#G-&WUAM&7BT;FSG'.G:[D$P[/:^HA=>!R^"Z6\K7K9D;F-@;F7,ONQK!-
+M3,]F<$Q=#+%WE4^2%YSJ[O%T\3U3:YJMZ;2)1V9.76SW7M)L*[MM7ST7RV6J
+M4ZQB"S;FR'#JLO6=0RA4\.(P:FFS=(*<JMH8DQ2JS8H]9X\U3;&65>C1.,A3
+MQ[CM82360LWG,ZT-XU%M*=Z4APFKO::+G;&;6SMOI.5HTZ)QQJRYS2LU;>C<
+MF[YKIQHT<ZF^$Y1&5I%GM-CI$].6=M(5UKC-9>:IRL[INL0T(J+7.^K)RIE=
+M64Y<W9IZUVY;V<+R0R.8I4SF;0.7W!GJJ]=9S6X$N!W7+O.:R>M=>O>%ZNA[
+M:FCLXZXS6'6Z>.*9'=1ZIV3JM/@^5J[=U(M;L2GA3UBLS(K;IU>WF3FX.RUW
+M138.V:#I]*1L5:IUD[W:.'':U.^O:L<1M9+LSU!M"^Y<M;M5#$HE5)=!3A,@
+MO=25A7$T[MF,'=0U$RNT]=;DW,]KI4;H<LWEE#M:RCG*LONOJF[0YWR[1V7+
+M0;-5QJGJ)2Q;FSU-7/5JWK==-\1U*S3:C>T5>S:4J6,5V\W`<,V`^<]G"]%K
+M6Z@W./NQ*>;PG)N,G<[>X3-]FWF.SMK%FBSE=M&Z)<]M[<[BQG<[-E9F8:+8
+MSF1-72L4-5=(D4KUK)<YM[>9.Y3KMNYY7".+I2W3QF>Z[$SE)[CKAI[<0Q[6
+MT#"VGNI=1.Z5>/6-5.V+S9K12G;NITUQ<MC.D;G8A,(L[76KQ<V@5&`NAIVN
+MWA,[9[IP*W2$[,ZKRC,XU%RAAJ[N\F+[JR0=D.\J9)I3E&73N25=98X46]6'
+MGCX;'3?7>(6Q*%9TF1+?8U;64KW&*FLF9[=RH*=BE;NIO!,YF;LVNG"33[.@
+M[LOK"I&RM<B>MNC@3-G*[EW)!I2U1ZJO4#R/467>=>I4-Z>Q#3QW,TSLH;HV
+MNW32&I38DBVDC-3./;[->VTV3CR;!HLUU';RLM:1UYES0?$P*S3JN7!O7TS*
+MZN-2WG5)J6^-RL0IZUES>2[G50M=QRZ(G.ZMGII`;.R<*M/)>O:,]G=HJK&4
+M^WKW*=F:8/5=U-358+)"REC!HL:;TT+JU69-<]FS)M;MBEIXC)[D[6:GN3MT
+M=*JYH9EU0K)(Y2L&C9A\D;N)JN[K9-%TCO%7=+:3>]=#;S=VV1/('2R$>2H+
+ML(6TQ=X)GABG.Z@N?8+:=SPS:%3$W4WG=@ZM[AJ-DIN:DT;E(8KY"\D353:Y
+MGGF3L5M,;?*0^ZN64JFY4UTI*ZRK[GS6938K-LRNFEO.::>%201.:]0=OKX.
+M1-]MY;PU@P=-II;-B\[A54NZ<S.R;DWV`R.5H.IH]>[+5SDG78GD,=EM%F>5
+MH]M'+&6VY"YQ0-=@T55NZ)JKZPM["I4A&<S$)T34T-)TXE4]Q!*KC5;(?8;T
+M8-F]JR09.==:-(Y[,P*N=S$#6BSVB:'*6WFU1O!0FKTWI,NYT=J)NJ-M76*3
+M>O*SJ!JM?9,G0+2@;=O#<[9K#*$BMFUEW>R\(7,YVUAP,&AO8LQ6+I[FNF-6
+M:IYO$`G<TQ3,F1VU+O9[,.+NR1FH23UOMJZ0WC0,Y3VN;KI%PW-4NW!N:3%=
+M8X=3U/B]Z\%]9H@O!M+L4X7K!(G.NAM3ID$Y43>V:WA774[8I9=;-/%6.GA[
+M&HIJ1JSLO*G9-Q>[;RH6OMJ]=4>ZC6);8K=7"UTB11WM5Z"+9VN[)=.F<!O-
+M#?5O2L%;4;5U(IZ:O652W<K+G,RBLYI3B,;-9FNS(UUQ4LI(3"L]B!6S=U+H
+M8ZMUH5ZZ$K-$@UU#DF[JK+EWJU3:T$2+N9FC.<7DQ1HU(N9RMO.>:U:5)3A:
+MW9@V1QRMC69;DSRUVI<X[--\#TW-6:.,C.DS/<:E9P+VMFVIHN[-$5E3?(6Y
+M&OL0<I6:L928:B)J1BOKVIU/C=S@O:XU*#/6UO8C3O<4H=JW->RKI[,U-8AC
+M-\)M3R3?#J6;5]VSDWDV,:@CFCV.:EY5G;;=BG>';-:5.W><@51-\+S,O"C7
+M"1<3Q-3-$45LW5XI,HJY=F>L]1Z;6+G0X[QM7A64NXA-;NSU&QJO5NUV#%DS
+M63U554;//&+5QMW3FC?5F%"EV2MVI6MA#EI'96=:LE,U,B>.,)RYS>5Y?'K[
+MHK>RJRYPY4N18Q-:<=298L)-&6S9VT`:7"JD7M`JU4:A6GJM8B3U=HTZLW'L
+MHT#G*]S3CN]80[3F*Z&2$.6!(8&YZNO7;)W-*20<L9F.JJIX'G-&4>SD3>&[
+MMYDS(XJ51-N^K4[U:L5%W(I\;2L3"<JC.FP3,%@S.S>WAO&C+ZTE6%ZV)G1>
+M3VB^W+UG@8JW(RV[NDDME2MG4NV6JJ[UO=6X\OIUH+IV=.<,/=0I574JYACD
+M>FKH83RH7)P8Q6O!T0),1NB.$,#AH&C8CH[N&V]M-55'A)Z]%U4W@+J34[((
+MW.=BE$T*_O.91\B%-C)D4XCE,YC5R[:\`*B-]&Z+`&0E`K::H:"\+95\E%[`
+ML`#H((JR19#S'O$66EG32<SN).7%6WHFD*+3EL9KLD$BQD]4ET!9>BC8I=*R
+MLJZE9HDR.:![9G"*EUW.=8..5O<APR]['M=)/3T[>[S`3,`=PV]31G-.5FIO
+MFGD1\,HWC>9M[,K)HTY%+@I3,UFG<=':ZI>:Z5(&L6]-5.<.JJL4C>9E-"F(
+MLC='6YZA)TNUJ-5)(,7M49I!/LFFQ2I<C;M<KG7$Z-4\`#3F\VYGIM]FZPC9
+M<SDSG.:[<Z>U2[3=54@!!PP.@98W1PX=&`:1HC1D`:-!C0*.$`XCN6+I-<<G
+M6GNL/JDF82\,@-3*3.&L-=""JH%)55J"7@E$'HZ*[@.43.'@-[@+RR+S@8RH
+MF*&DD2-`T0]'"^@<2-.'N-]?.`HXW`V.(PK!9,9BZ^SC(8P$W@.G'N-(]=%7
+MQR^U*+81Z-#Z-G1QY=#FLG+@W;X28N9H$[#`S<!MY:%2)UW1C;)5J9)76#RJ
+MJP2JG)DV1M%]A67765NS.VQH12JEI/-RSMN0R)+L7=5.E=-+!G!C=:9LZ&J5
+MVLQ8JW+QT)%,;BM7V9G.QTR9G5V=2G3VJGG$K,VUO;*!WN697$:E/!IT;U<)
+M6S4NB176].SUX:JL5TN;I"<>;0L,B^8F8L[L-R<-2`YEG"*+':#9X(9@?!&*
+MF=A#`[0HN'71R$N]5R+YW>"^,MYT48S;64.@G*/75QVYRK*<9A''C=:[:EY&
+M#L>4[X;3WLHTG$DU2?;5L7IVUK>N<5Z#.\,)&Y:ZFB9THZ\Y#)7'CEV-VN8O
+M)&'KFJP-<</!N7N'J'27FCLP6';XF[VAM.<T\:9<SESCK.`=+ECFTR-W%I-T
+M]6LC#6U+W';-FNQ-2\$XLNMN,33/+*Z;ZN-U9RHS5M3LZ+=K"[&\:>P=(TB:
+M/=3GL[9/56Z=NYPV9/.Q=;0&:W-:#73VR+'/C+Z=8XU+*V51>4A(.<MQ*6>N
+MUU35153=WG+<*(5PNVU8SIG+Y.YV3PEZY[A?=M3USLXLP],O`WQZ67SN].*A
+MP?!'5/:%>U>7>3B[LR=R\<UJM6\IWE;4M3T]U[.2.!):6I!\V##6.$GTQ)`)
+M*+J0%\3EPG(*$<4=0(B@HB*(BIN9`TX>+,;"&F>&'B$-.T#U+V"BE*$*"GDG
+MOUWA'=B2@1%Q05>T(E[E'$TDQU(L8SOI)\MQ!WAU<ZF]X<KZT$,3)NJJ](>[
+MF=NXN%8NVK#?9=:[9<WN+)R"V9&*<M3F(\^N01:JU$S=!#M&Y95AJ[1%&(`.
+MU77/4C96:>G+W&=:&--SLRW@O+R@=QXYWF-<(8R+3D7>-=H3;GI3DU;RX[I)
+MSLR4<Y7?=T]2,]:FF7FJY.MG-K=U;>(KJ4E3Q&I+:F=%38K0B*ZLFQ0R[Z^K
+M)F=U7RE9MK&+')O%9>8;IU.2\6WPQU19/=G9L\]SD=S*W.=]E83O)=V6UU[T
+MEJJT;>D.\F[4SEGLT5.IFR[Z;&&U3S+Y7N;(UZ0+`E5JL/1?=I)"=%36KMR9
+M#&ZPMY1(0MN^K47LS-([=K`S0DVM..E-C=*JCM3.5=Z^FU75<[:=\6A1[J?/
+MMLZ=."=[0;>7*R4"WF=HKD@A,YU-5M3CN:[*KJ3.3)4UNMST]DJ5R3WI![:$
+MDK#O4\>:[M=N7QDXC:D;BLJG>*<MSO2&9G:.Z+3BUJO9&[E&;JJ8IHFM["<H
+M9-RW-15`V=)LW-FL>,]<[N.IK:3G<>!G;6S3M@YFU73,WVK)R:OETF]NZBGH
+M[,Z:L3,OJN=O9Q/.W"3B,NK["^529KG?(<4;*R\R>?4ZK+6N;JCP1Z:MYI#Z
+M0Q=*IPG#9E*5+TZIRN*KMTVA52*%99I,V&*OCL;*9SLE'J70>QWU,3*E2;-+
+M>I+;Q2IO$-U3;HD.WLJQTW'=.3/.MM+.D]?+8N@SEWM+'V%4>K1U<UK67=T-
+MK2NF:3FVE1!J:M67FD;CV]<\>:1A51Y[3FJ29YO*BZ1KFRJF=LYCU6U-+)GK
+MV1B,&WE'G1=#NS%C85C()W2L;L.=PWV=K%.:[%A&$U5;D@[0O%W;)L9V;/3K
+MP<,OMM]PFN#G<[NHBNQ\,Q@W)?=NU,]RJCO7SQ-<G>)ZY(D3K(R.RZZ\5].T
+M]52[ITQTD3Q!#PRY-&9WLG*W5U)KII4NJB^TRU<7+T\EIR0Z>XM>:&1G&S7,
+MBF,V6K2R>:Z:NNF1N'#*;[N[I!(W+&.JU]F3@ZM>VQ=;NB=1H9>W2G>[D20B
+MUSMO2N-Z^OEE9PUZ*&(]HYUE57#M,32I*>?+-=<3KJ9%VQL]FV*(P8[I7>NJ
+MW<RD=L];GNF]HYN2^;ID<R$G/;TY:6*MHXMR[E7PZP0G,HB7IZLE)/C.<NUF
+M:LFE@O:UAL=AR\<R<;Y]QT6.&F9"W*W#&UNUFMW?;(%SVK0\<3&=HO,GM.VJ
+MIW1<T&33*MCKRJL[6/GV2IR91"XJKP6,+.+)U7:S=UUEEXWE5.7LR&\=C(X\
+M[Z8F^'.=S4KT\>.+KFYV;F^%"MR>F.Q#ANUG/L[1NY-7)1I4;?+MR^.O9S&N
+M!$G:%M76STG;Q!UAZ5(IGF-EC0#1E5=]H.@97-9D$O#6]CUT+>"Z`FI:W:XO
+M`#)"6IEYM3HXQ`9FU%JK(Z6)5==\,"W().19+(1YK(VC:DD<4.04&6)(H]LN
+M1.[9X4WS?;A2=WAN6*:,;T<!(D8#>W80DW7.;5&>-\IT[.FY&D$$R*B!H)-P
+M0@8C>Q^!8GK%+/S/QS%8/1OCV\]^][9Y2\6VQB)"I#+&M5H<,=!S_2/^!_R?
+M^!_J^X$0/DRAC/0ON(N%Z"B(EL3-OPD>06_U;0%#1:IDIO1:P?0BIH;!D`%7
+M0"2,4F49.3I-2Z\["SZLD3MDAJ&':P,"U:XO#YWBV3UPGT21^O@`PD->Z:-"
+M!]>0B&AW"HN`"`7\ZB+/?ACR(&3Z#+'::.8NX&>7,N!()%&*2%B$$AIFZKJE
+M%?FEIK(JVE,+`'DNPCC`R<G(,9=#<'7ID!,%4$"[QQ>NUX0"HD-;IBE-7AKQ
+M!/%$:8U,B1F=/(E(B8>&JK3O<%`%4%XO3;?6+6CR-?9LQMKKJQS4NDCL+>DP
+M$IRP6\;6"7!(RP$;9[CY=T1YU5F1*\^;%/K"%$48NQ,DX.NFT4SN?M:5@[3<
+ML&\TMB9YEAS,O/3&QY97O)8(QB$@D.)+E$?.KY^*=_L9S_DUZY&8B?AO]HYW
+MNQK-1MJ0$C9U22$^W9ECI@^6!6E>D%UTL'1)8E;,FK1==RL^#\.+9]L[9;)C
+M['?Q]7/XB'U*JJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJOY
+M?U9_)=[!T0G/0<?#$DL3T2CT*#'&1I7MEV;'IY8,3*^!W+GE[=#V7K(V+/OJ
+M&EPFG5?S`(^JK;?C8T5>+*`)T6*AQHMN]%E-ZAM%4CGU2%#5\^OJO"N&VA^`
+MY_M_`5&,W[@C&%\D2S\A?C_4$IB,>\G.O[8H?\(L_D55]]_6',SY^G6BLCUJ
+MXW+^C!`/4$!V?FZ)(*(R1^;&(U*EDY]K[L4Z7VA_+?NA6[FC!]H1?U^OZ^XG
+M=CWP^CB)KV3!VA]S.$($8#3H]1=3A"^I8R#<A>#%7FV=$(6@]'[?VWGXX9)D
+M:MS5MM:"L'@X-..>N,@^/7Z;^@\G)J,1.P>K+0.V*G/4J62]J"P>JCIX9-/G
+MF9G'2:7JSZ7/+U5,E<):C,MZ&7KM0YW+6]=_*P=2L7[YZKR;ZD@L<80D<20*
+M[/5(GD&)#)HJ3D:#J&W[44SD%9GO>55-Q>2(JI&IQC20X"8Y9+1)DSM0M!NM
+M%/H"#4C3BJIZJ+VFCYU##!L53VN>-KSUH%&(7O15@#]B&*7X#I_Z0?FXV,EX
+M,8L?2]_CO@B+R8,488/^)#/L'SUZ#Q_D^%C^[[Z,N-Z?K_EO!B3^,>_/GQ_1
+M_'8QD7(/X@@A</?@"I!#_4BOSD7[UV+ZP4T$%B!R'57]7]2+-@[^")^ZV7DY
+M/]X7Y/V1I%-"AH'U0MJO?<H'_+4BA*_`^C/S5(,`V+&2'.1(!P**7Q5I,?Y!
+M6[D4/V>N&5_B.&/VE6*-L[AI]6.Q=HR,JJ7GR^14.;YY7%1LO8Q>008/X$V;
+MJD*'9_IN''W^5_P)'L30]^AOU/T:PR?P/]9.U^!_:4,9'U,(5WV_WG^G\ZL:
+MQ2E9^,_+XU>#3FYRF9M*\^-RU]Y6YUM#9WSP94:+Q0[Y88HZ*2$;X$!T1.I4
+M)@LD;#I@&LU]'A<KC:2)C'XF,CM8[<F;VX4FXJB8-DNEJ+%?`W=HV>K2Y/*F
+M7=!V@OT9(B?,(98C7JZ?*V^G:LZOYE&PWJ]W,<8W]MJ./EQ=,GZUM&/N51FC
+M_@8V@*^(_T']8]0_K5#\PC,+D'GUT_S]F/&9I1:Z6:\H^=AJ&*";"@8[AHII
+MJSRI8I5Q6E&K10*E$!A2HBI'11)20C*U:B8PXL>.#DL@J#B+(=32^E'WZD:$
+MI9&<5D+L\'2Q6R-JUHH,Q(48$5>:"E=B:@*'PC^AO0=#C2,&,(N(UV-_08\8
+MKXL[\-C@RH+"'=,T]$[1UYG?K?=-'JD=RK/8M*RUG[$0%/Q34H2++@"2/$"O
+M(!#YH9^A)P$NAHD*ET?&EL^?EEF;3S.V`M@W*R-+]C0^_TO)C!^!7S!Z^(^?
+MMY>/OV]^V_N?H#('.,T*%*ROOE>QP.2799]A:\MB6K'G6-MLRBWP?/;R_DSG
+MU"HYF%>VI3:@^?^*@Y/77LUJ:?H4>F90CN8:F9G^E?7\5;4+WQ)K;()8C%C$
+MJ)8$D?7\V'$S;G&.=(<?7<=D%ST0F.4GIUK6NDR@@Y1'&/YD?!2H*`L(P'X:
+M(H&%JAP#^KSEV6/;\%SDR-(;Z;:A4OL5./9EK+GN]G&Q)="+EQV\+WX]677V
+MES<Z%B_;//0SQUMJ<S>JQ$9F92V)26X;3B:_7K'Y&#;6K:#_.2'5"X;X_@'V
+M=>?6^AQ[S0I<\6S%+ZU:7,]:#Y.;Y?!SGUQPN9Y[E;S/J!'W8_/QS_7^O!C?
+MW?S??L`L1'XPZOQWT+8D)+Q:H]4)5CHFAGR%")59-#4B=*Z^IOY&L5TELS6G
+MP*K/*].C\Q7]H?T/#^O]`CA&Z?V#=_-L3>?ZA'\Y&&^O^^=8R)$3P:<HC)7C
+MVL,ZJK18%@*7T323!6;%LO=<MH%0.B^&6Y<%!6QF%I-\I/:%K9<5^O]/;[WK
+MW->=J/-I3H;VG3V4%S?V:ER:;>&1>;WG>:U45>[6LS"$HES]!B6G0JJ#`0+I
+MAM;5"KHP5-R7(CG!T,9K430NII7%SV!YO9OC'8NR:#<W-7-XZ]+.))JT.4D2
+MG)5-2!L$5LX)IH9=,C2)%7<JZ++99%@BBV6GIC&6,/D;Y8T,5F,IELS??I@^
+M%U>@T,-DFPPN%,HL(F+%CVXRU$]>7):H9E39DD%,F2Y'MO>X>K,V9G;!CQ^#
+M3Q\#OXQ;9AA/(WQQGTO866.E333L&*O3>UJKI,VL,QELY_W7T0^`SI-.%K7:
+M_SFOIC+GZQ4L:H[%J'QV]CL&8E9Y'U*C]Q/Z_<?*^S/A=2A(W?A\<.6@DF1$
+MCL]7[_V9WPCR3&*?O[<1\0%PXH?00</Z!BIK[&9/VL8E!SDTW,GB2L;SC%W(
+M9@G-_+W!J=>07'00WUHP;VW]O')I?3U=B10\D(>B2E2"P)]_G5"[J)FW>-BO
+M*M_ER.QF3,#7SQWO?*M7!JJ1?=(GB07T3=TO4UW!F9]]"6&[,/#K$CT,YX1/
+M%9@MJ5:&(XWT9I<L6Y$T>YLA($5(I5,RZNM?5VS#$TO\9K<P'JIHI'3S-MU:
+MJ_ABKE-,%,/%RX9-P5MXC1;U&WIKKUSFQK7K94$P_IPR_?CO]Q7\Q8%-CY^+
+MO#^+V5.4OA#=_#=SIK[-KUE>GBQX;UOHAHV;_`RB_:L/T:9%[EJ`LA'2`):H
+MD?W_IR"08/X45(\\X<Q\P4Q701\S2^QZ?+SUM]8?FDC<\DZIQS:;AJFB%4+I
+M4PS!H>5I.VM8;66BYIXMO,;YOB:6+7^^[;\=^<)=,2VC\A;%IRBF+:;WA:Z]
+M,?(,S]65S+4TO2<=L%YNCD4!@<K#B9%LC<ZG'ZIQ0FR&^,CA\4=!P"9_+<?N
+M?H)9*P8;YW4_3_*@C.D(7=-B/G.(Z4#$1\,*U$?N"R*4*".V9BR8'=#E)/,E
+M,B.*X>DF"'JY^.T9.W%:F*D[)40RW[6OQ732K[T8%8`I=IE[5+51\%\<ERW7
+MITVMVXN49&ENO)?##),NB9S<N>"?Q;]\'0.F37'*WOX*U8;6JUOK6N,YHUQ0
+M5_.;XACZC*UE12[2-CW#"R;50B-S8,`?&I_6IB]#BBC-U_1L$TN"N;KKJXF+
+M(O1N*VVME<OH49H97R$M$3[?GKCR3DZ\=+1P+`J$E4AP5?*Q5=:,2M!9X+.X
+MKT$4#.C>0Q(#"DSJ_W-F4.'\S@_GI0-I,7_!$3\*_B?7$9_<@_Y(9MDW1WH\
+M&78T4%(;MC%=:*#>_2OX]]LRBF.XZ9F@JJ(RI/10.JQPV0][IB=P\N1ZZ5]#
+MVC12Q8MSMC=%[M=/`P>&]O3B;Y&O7PKW;4,?A;'B])IM68B<T?6FE!UZ]'ZN
+MW<OF5K/I0Y<>+Y@CE6<X+0O^>,3@/WB%BG!DC_:^Q_U<6JWP[A=2/W^G?XE\
+MFD*Y-;2O"BA#&OR=O%PIYF8L_H(?FO'6O5F;N5B^8LE_AL14NC)G/=*PRDAL
+MS2%$>DO)70)),/4R7S_OOQ^[KJ<XN-5:FZG?%N!E[5SG\>#,\\H3SB;[_.[E
+MW05(J>(TB<#0UR1I-543#367%6W+9R;\LRPG%>CTS1K!+IL7ALF9,KOL.R;[
+MXXHS2W?&+8$^O\Q070LOU]2Q!>5/A/"BQIP5@JO7]?Y;_+;\[*UG]!5%1C5(
+MD1253$M414U3$#%2D250U0512I5(505$%4Q52$U4!$14B1%4L15`T%%50415
+M0%55#5510T554E55#442U0Q%+142U10T4E5$%51$E45253%15#435"T+54,1
+M5)$50Q-4,15+$HHK0K2@$2M%`%4%%-4E%!54E$2M4A$JU5*4B4%4E4U12,05
+M30Q!5)$U0#40E4L5%4M$5+-10%5$E!%32U$`4TU$TE#5$2E4D20!6?K'6'EQ
+M2RJ1&*D52R6JV*:2_JSM.S+!UFS#7J1<&97/9JDEAT8UUKTS93\,BKRU9!@>
+MPRELE'):P9HA[E'#9M\/U[YFI;`8Q*1,93W9Z&6OS?'@1S!)$911'YIV26[B
+M+@P46-/#GL?(SU=-$3";6[>*=S'7,IXA0T=RR:5;B5?!:Q9!/?K:6N?ASS,:
+M^A[O>?F>[M5+\N>ATB^7%O$P//M/?@PIY964UJIV?$=W+/J<9XU!A^89RM9M
+MY6W#\)56,/LYP-B:=HKL17L4VFOA;;BR^O:(06-%M$0^5]R$[RIHU*Y1"L:^
+MK_D"+J\D1:3-P8=@?Z\=DB??X&/1GZN1\_R!TGP)MCW?#Y\>67/OTM8%!$U/
+M9:WAY5:AHZ7]O3GJSNA@%MZ5KERM4P"I8B'ST223KDE29:\9`V]-Y[UIC<MV
+M8R"HT\0MDDC:I"6ZV?,*]O]%<=+3**U?*+^E1T!5+`Z5;=V5T988:$\!P2WZ
+MC#XH2#H(ZPHR7T6A5H7^>M8%V[ED^+8BM5[E66$JWFFSJ]_J])6NU8K$=>23
+M<,UB.L5"S<:Y:?E68C9&C77LXA\BO+\4R]_5O);V^>'!;&9\GJK[69A+YX+6
+M7'V,X7*&L"RL&B'5%6B+'6DV*2E19,DO5GOEF!$&*:D]=RB6%^%RX+Y#=RS&
+MK62L/MQ1Z5^C]N_;0G'55SE9;"I0JY%AT43$@N47"8H:>*H1BFGS+ZZTB4:.
+M]LGNY]`]/'SZ3I?W#X'GUK2]96X/BMK35\6L65J62*1PXB>Z`\9=-BI($MIH
+M#S9BHE\L6CK(Q',2Z$C3O7OZ?@]YHX7L=8^%?PF][.&I-G&#?2'),I864<"B
+M#*X<10CE1^?A<T>CO<FQB.BKJC-'@(Y*N?DBKM)+)8*45IU6Q$U34$Z%VA+1
+M@93-:TZU(J`B6L0+I5<YT\'7YIVF(H.<LPBA-(S/J,Q&\I8DN18&/.12#WZI
+MTAURRT[%&`F6"K.S._P:K@M5_BZ=>^66V>1Q2YWFMBK"6E@*JI\.QM6#ZLS7
+M;4]WSSWB_H-(Q*G]LC@=_8$QWG=<,57+6XCPYK*<V1T.E"D*!&@2FD?AZ'LU
+MX?89UBY!40=5LV+F`UJR],"`T:@^TJX35"H^[GC&LT6"@7@:"7XOP7.@2&<N
+M9%'B:'\>K%C9S?554-Z'Q],L%,]0+:]IIZ/G8SQZK&ITV^\\YF7(+E4!2X,^
+M:V%M]$52IJ7O>$M5)"A$G5%76;D=$JVI$M.'5GH5XB86Y1L9&^F4NP#Q90PN
+MP_(Z&,;51>TJO,O;2KB^31F)4M3Y)L8/BZ'73V\;W+G410D$E&A3LZ':8)[_
+MQ-(H<A)4*5$IH6FB@2DIHH:::"@*`JF8B"($*6)*JAI2@JIB9JB(H`5H:$"E
+MH`I`I`I`#U(/VTP45%$%%(1$T24I04C2#2)S.OF?:7F]A7-1#%*JA/+%6@+E
+M*5!9$)83,_3F83:US1%!$U%(T!U$5HCO9=2"2ISVMNT0(-@X3W$R5(ATUL<Y
+M()Q"H9:F)MV59(J\@CL7!(4L/IBBMW:\LVR9J%P)7NTL]\.NQ5G,D%(U![(U
+M09($'D=2G2OQ"EJZRUYR2#)0J(L>URGH)44-21LA%68A/0X-0/9S,S-9%M6)
+M924HRB&F,>.26BI![F%N#R[9(HR"$D5%+J,.,:4P:TLTH313)2?1TC#XNOZ:
+M\$+^6+$W^&_K_*F;V`E#T6$)!'Y'3GKUKY>.9/TK0^^/D_`CT6TW'[LUX^)?
+M@ILUH/7D^R/\LNYY9E_XW8N-421Q(U15J3])`$L`J*V?Y@2*!82!!]9GY-(_
+M11",B;\.H2"/!*.:VEG+U7R$[Z^%5:[4,VM\6L7HZ=.VE?J9S(5Z:FQKSU,C
+M(Q7';&=5Q@Z][VLW3?I?.W.XFY;4"T*U%#R\SRLS7>9)/6@H_R<'_O/L(?G.
+M8/^YIQMEF4>5MX;&'K8NV#G%0M5%,.PWYUR2IE]II`;THQ@NQ\P3Q7>JM_6R
+M9C/(1IY]\_P%7RSXU,PL5>PGF=-C*)Y^^Q-C>M,#11?;G)E0RR_!D5CJ,T2V
+M1MC3<Q"QEM>NA6!'LFY\)MN]5R*Q'7,]1'5J4<=MM8@9PE/)B1599QB^9GT*
+MY&%!ZQN6JO&V1;PAYH5Z9F1\&NE\_4Z4-ZH89_#:E_-9D=/(^+#(B=7K>5(4
+M0L.=?0(.<4020NU(42DTTLT<N!GOX7^,9:)D82!WLG]_8Q.3O?C1][GP>_8\
+M!)@[Z%C;1YL7N4\9AD7\<?4-N/USX,L82>J;G6U<XLF;P]!EY:4(CSY7Y\;8
+MQXY6I+;=,O/*WEV.%-N7IQU,9]J^)+.9;+3H9.67V,MI<K>O5G]HD_>$W@)\
+MIC+*M0/I,_NCDGM3#0CY-`F:4"B71K593:YUJ`B)Y`D+-"BE_<*]!@X-^Z,B
+M4?*:`4NLVD,^E5U2X*7IAVHI2!$4NK%<D)E(J\T(V13$F9\RXCHC`E_NEM;N
+M>=]I_&[F9-D.0P9&EPU3@RDZ&H0TAI=*PF,T]5C'1=;'SE%&N/<:'%M+.18<
+MGG`5E"WYN-<&;[*-;3/%RK/C=HN?131<MX^-YG=^[S?,;UCA*+N)3;#8W+W^
+MIK'CH9T(;V-37AM.A(/:$A8-W-)HASJ]%F/;C`T)R1/W_B\'A7<VVGX?[10H
+M$4_3/S_F%_A_)?%;CX:KZ"JB>=^G7XC%^]=+*_5WFUC&$^"CPQ3^'M/@EKYO
+MP-$C^7SOBF/J;9T8'$?@R1+_/^CX;IH:-<9DZ+&,?/B@\F"ZJQ(F9_O4)TPT
+MJZDR*VI%'CP2%<J-V;OY?CKON/?$A&.;I/8U!<Y28<$&'$@MN*BA^$I+/-0X
+MJE-PED*RQW(ZLLXI8/\C_C,3[6NC/LZW0QL$<3[^H)_E-/`JNAA&%)86G*S7
+MMDVHT^#9EB9[E)XA[ID*DM;&P56:O%6*Q?2.M6R]Q?36KY-9#'9O]HWMD9';
+M@1M:\2KT3Z1O'?FKC=N?*:3CVS':[6VA>P9GP:&?KSR$1$NG1@[T5E3V<AZD
+M]M5_!G].N>70,TD)L8Q<U_FI5WQ,'U^OV#Q8,9)X#(=3[?V_EIL=7/[EBC+&
+M2WU+%BY>L]ZOR8.=#W6/4;XRNRP^3W,_68R/7Q=*A(9:I,*KE,G*<2P(4/<.
+MJY(P62$HY*TV`2O6*?7."YXWHQHZY74Q)X2P[U26$V!*%*RL20E@DM2U)Q!:
+MG">I&LI6%R888JQL1F&ZM8)*2*$<4\ONOUWSVT,6?"W6]QE\4;&>+M?P#4.B
+M9/.P8N-`_S]G]V8/]!%=OV%IC[2!*^8-'-_L,&-#S!8R1[ZJ428!3/+"U)'6
+MV=8<^H2.E*2#PL[IX^J,VZ&FCD4K,,54KC4J8$\[]S![T*ZR/2BXPR/&)&=&
+M5G4X*7AK<R,]*ZUU+X+)Z7M;+T^+K;'@<6S=F8.+VX]5SAR/1#7.:-DHY.M7
+MW2KIMK1KBNSQMK3^Q[L]=FY^OUYZN^OCE^_@T:_$_F?](_PR_?.`P;^]Y4G^
+MH-2/[,X9^OR!_9ECHL+]L0_S:/V%4,V%_6MASB^Y0_@:_$3NH:+NE^?IS_H:
+M?7V&7^:0:\ZR4*!/G0F0Q)'\2A(DD_Y'/P?Q[$_#61X:E6#Y@_-!?`.,![UK
+M%DBEQZE\^F0IA6:N*XHH2%Q]#UFR^4H,^.13-=;&*31F,:DI2.!5KU":*PJC
+M[#V2)&<,*C1J/</4KM8+1,LM9W,'M<CUGLM[4QTROG?D3TXZXWV%7)F0-4MG
+MLYGD</EXX'>N09G)%7V@R..A>1-$@2SK%+EL-@,\A55K$P-"`@MBFHPN+C3O
+MGCHHFK4J.2@+)3(D:*1"HU326;+#0%*:4:C&="E%I+F6DO_9:Y5GFTXL=QG4
+M\JOY=RCQ-AZ&V1?&8M4S7=S?\\<Y=!33,<Q71"V"^4TF\NC\P]/'!Y6H4Q#P
+M,X6N4+SC%FLR6G@X!.,!^?[9OWON&HA0S8M1'QM/3SRPBW,K3KI;HS&GXO"Q
+M=/>+6Q8Z%_(NJ6JYL4/A;,NJT8`;E!1=E[I4!$N6]Y-T10QMT-"K&0Z=];#Y
+M2L]YAFHC<N4YF:TX66J24R`JO,5XP1SVY9)&@X4<A8LO'`DL8T(K.%:)8G%D
+M<13Q2AAS1#GUKI43`I,R;5HQ(S&91J]7OD'Q"6+506E79--34L/K4PE<\2)E
+MK1$*U#1QQCS7F<XJ;-721P216*V-":LQY,L?%6MJ+-,,)U9W+U+]X6RN;WUX
+MK5D^;2VFGCYX^?YKZE99T4[5CU<_/IOE?3WXU7(RAD,/!%$PM*=%\M.M[M9]
+MS:^>=8ODVECP;6]G\!^7X<'+U^4]LE1^!"EV2R)"ZK+!C!J7UQ]Q9APT2Q$S
+M7S)<(YX43"OB2`L^@?)321#$M$0^>W,TL("I&21[`!EHOHBM!ZBI6J+OW$4T
+M!UAS/>3[1XNO#&=&05S36S"7"C@L=#3P;'U#,N:-3RRV#%'AQG8U[[6OT:%8
+M_9*B?9OLWK%?=H]9WQBR:GPS2_30\<PHS[-9YIEX%>.6EFL9V+(6+VL%1*S*
+M^`98R3@N=_8E\!UFE>9C7`8+8LF#L5+[4'M:$4R]]5BOLIZ[:8-<7)C%H5XZ
+M\'&FN9?&+3!=!.74;Y>'K+2JW+89Q@QMXX+'P@?R-#^HD"[[YD??XR0:-3]A
+MDN0&IT8I4<T#%CH)`MJ4BW:C)32QA69Y]^J5*]=B529TB1WV,C,Z6@E%O*DY
+MG"LE"CASB(8?:?&Z%UM:T=8T-[`NT12W?1Z4D@7Y''&H%5\,M5A%7CTCY)2P
+M."4DGD+^NCYSFR#[.74(OWO-_"71UQA-['B1.)!<_#JT8KT32%4E:;X^W?W6
+M+:FCO63C36WQ0O1-C/OW,]L[Y]2WX;&23Q&0\)/YK74YZS[C)QBDPC6M)TH0
+ML%>RW8RO.E4.91:%CNHZ$?F\/"XY>G'=ZL_LGZ!J?+A]!0)!`H"M0_4BX,(Q
+M8L6/IR9?%@]XN^@C68TF2/0]5I=[W8N8%\SYL3[.),!;-JFIF,*:U"J88927
+M'@88,<P/E?+W)X:/VF1RK2?^,$.G^X+B/G^HC749D1(.MPSZA:%1!^Z910K1
+MIAYR6;QGR-K/*!=CADRUN]ZO^#V%K8?HE%^I>Q,'"8+>K8;/PZFZ6,M1+C+3
+MUU1,Y4I`\D*SVP&^-<JQ;>Z-S-EU%D>!BVQHF)&.Y"Q1920DQ^T"/J92EGJ,
+MK?0WS.<7;/.Y>C?C<W,&G$L9Y0TMJYGW^A5@7WYQQ\L?YQ?C"J-FLE9@\*&=
+M_DU_6\)'OPA\^]K(I=CMSUY"*BK7@T"B#$TS[,I%&T9$1/@P7[0K*\A>S5LG
+MI:<9'71&=LNQ8\-R^1Q;RE]#/PT*?K^$ZF2TB*'"C7([(DM.H<?H[-6A.9%(
+M2*#L%9DG1O:5B3QTK$M6EZ3*K#;NN9FEC#QD[>]\=1RNIGFP5>E@#%*`G"D:
+M*=F4CE4@10>N*4P<$X;$E+T0TQ]K.0FB%+W-'T.F7DV9NYH9?W5?JG*4PJX3
+M/]XD,?XX`^0Z0#$D2)`<@_-PWFC<M%\P;J^CLDCHGL%"3G\V=>YSHIEIT0:W
+MU-G]CUK<(AIRE)^4EZ@Z;9H6MX6MA+STOQ+O)DWY[E9.5+.[+@G:ZZ0=P"OP
+M6)^$.[<S0D?M_MY7AK(,I3_J""-@9T;R'Q2V1\7B;-LST<<?7CL*=J]GW_9>
+M2P4C^M"/(`*0_P.D,Z%5Q(R&QHD/X1.3'ULT&I!TH^(0I02CB:)7)'_3_MK\
+M&^%N'7$M\AK+7GB&7Z!:=M#VH6JQWR]^MLCGMB9G&>GQ+0*ZQ(_C]./AG[*_
+M>;^>F>L+E_5_YGI^$#!2D_7Z[DU]GI*>F,W)>NX>L,]_B#2\T>IUIVZI^>UK
+M_,C^A^P3^&$@N!<9VR%'S!0^!CN^C%'AH?]4YTNF#Q%364HK[%"3]R-))_E@
+M_'Y'S0$)P((_9_*[JU6P<`'"NE2^0O:6X?]L[U)4S(A1]`Q6?UL#_#]IV1@X
+M)&?GVY$_&?XD8$/Y&WO#F4?J#L^*GR]++WQ^>J9M\VG!KAQ-ST_+(UA*^V0O
+MS3"FN0?"!=)'I,M!3@P@\:VCI8Z\#$=%'&P.)7$1<DC*-[=BM65GVTZ2S,-0
+M[`J89FJ5I":F27"5ZRUW(ZPSA9$"VK#[2,5ECG+!49[WX+T1Q%Q2[F\^":8P
+M[KWWL086U<BB+,;.JDDL!H6Y&=%!Y,]1:Q(1D:1GBGG!Z^V4V3(O($[<X'Y'
+MT$OAY[3>C7U#?X'V'`((7U])7;87W:&D1\\10_S8[B_8!L?X`&1FRXZ:4<A%
+M+5KBUI(I94'N&%-&;`&'4*J[#*T@@HJ;N(HF"E4SX\MP+`I%6KX&`BO4%=>G
+M9K;:Z0ANF=>XSS#X:N>_3%Z]I:P\>\V66/LDX<[,+3X,<C6E'7<N:;CN6K!M
+M:3O;+3HEFV9P44_9^?>W&Q6R)BA2FU6M%5GU:(V8FS(RHM2-:LI8F(AU1P%A
+MQ!5&6*J:-IP]][FM97_#5&07.M%A1RZT<>A4F^E=:VT\,%\KX2/H5URJ:>A0
+MB&AHT:_J?'W^-1$I^5\?'I\QT].S;.\,CA)<29UEG]C4/`UN>-&T\-\6R]6N
+M6FK4SFT=JN;,\"^`LQ\JE#QK)I:"8:$Q+,Z9;[Y^E^UH'W]@/0RJ2[9VM14Z
+M^V%QXD=YJ\8#$J,58R@6Y>O%YS5D*MJ1\Q+!K3J=(3DP/*;L3B<F2:J_#'16
+M!K!"2%QP\@2;>P5"B!'2V"S6'D%I1ST<5B)SGUA]-]I="^,J+*E=\9@/T4U2
+M*3")9:L4(JTPL<,JF&2343SA)4KV:DD5PL4Q#.=(14I-.T]6<B?*YB.*V7V!
+M4(BBM=+C(P+CP$NL]\2EY6I6H,*P3&JV^_L6N_(4Z>8F[<==0*,%O*WCBUBQ
+M15<>_&I[C+V!KS?::#L5#41RVU#+(J[9,5T,K2=-O':^1HZ2WUSGCV3&=Z,C
+M8YMGR8S!,G"8-[&*3?"F7:]K]MS_:7.(XQ9KOMJ96VOR98+.Y\U:\4+S8I3S
+MYQK><MZ*]"_P+;(9Q50E="I-DT'H.%3\Q#V$A"=O2O8G!/DTUHM<\-32-:6F
+MM*-29,,ATU[9GR[5$Y\<_+FW?/8T#&VE[SK:_.MRVO4^7/<ZES;*KSJX-3BA
+M5"J)7:Q:TZ<5N)SZ\EX[FI;-K0QTMTQL<#ARSQ?)S-3/N]W+!D6YGM/=5:Z9
+M7.&W2O;[<CP[$#WY\IW.NPV;]DQ$Z%['B:?4?H:E4OCC70T:Z,\&S+WZ0MPB
+M8JC\:9MWJV<^2C'8N8L8V')^,F>[O/5G;=VQMLU1E8_,MRF`S]+>RQ?S[4;9
+M<<=K&EMC/HZF4K5X+&>FM-*UT'3CY_'X=^?P?'H6L[=^F89"@G;*CEOC-JV7
+MA<MC$Z^7<W,M18;[FEI+L_.K2P5\)Q:9<?6XS-/AK=T&3Z,_]]:X([[RRG2,
+MDX^,QBA%&1G,N<Z=\7GGE5XFM);!1DJ%GHEBC8?;<*'MB$1%?E;,U$9C&K5`
+M-4*XKB*)/K[K(ZP<:L2.*MS!KD6;%88:XN-*23$KG);&<]R@CKS$>-/0X>A)
+M$^]&:2JNXM[#:^/6/US/W;?=['OYY.6$-$.$)6EPIP[9*15:'A9,MA)'P:B<
+MP3`1P6UJJJUV&<HBB[AD:Y9)1JI&/KHTK-4D@$3*,^J;-)(/1*PY6CGEH6Q%
+M0-&!HE"54&U&N)TB%1;\6B?*&*A-6I'6(-#4[/*:/>#R$&[E$^GY-KJ?F^WD
+MU#U\E-'T&T/&7UZ-1GYR7@I+#K5K&764>SYI/Q&.\^MXXMG4%JII:`EN"HQ!
+M;%21P9)-6BBG6M'$N1H)7QS212I36J8P5_36M'^T@&/B'YS0I$_K^H_H^&'\
+MZ1*AU,8]JR/\8K)'P<M,W.WU?,&N4&1^8`P@?WF3P(X"9L->E3+4MK8K3Z\"
+MT+^ZKJ,(X=@K%`B+\"JK?;'\KY?L\;<FG:URT^)V[7Q^K@J79Z]9:K9LMS5Y
+MTF>&%QL,!!]]^2V/;X>XT+'2L'OSHUKF(:<HR>Q)03=[)Y^P^GR.*=:.O!UK
+MAI7MT-'-/9J99F9[*RX?D,LW!?096L3BPX*MOQ7YD18Y0B&3.!CA27^P'E^_
+MG$]H\*%C[^;-B:B$+CV2UY0:,A@8$H813@I+6\ALV+]N?M@O^__&*%TG=A_0
+M)()-?99_@_#TPZ0D3:)1:^D(W]?=8J6R9*^G,'_<SVX#^V%Q^)EQXWMA,[49
+M&*MG4,[ZY],'W5\*W$OS[.#;R,A-J-Z-/S"YUFWC;5#KN58L7VY,>./4G4WF
+MB6R3/J$Z@B=_(OW]?YBA0P7@_Q_B:L?)>>!"?[V_Q@T1(6<;5+]!-=KF=%9)
+MV[?5>7*TK2O`Q<VVJS[2[1;(U)6'BJ4OMRVH$MPU@H-++3$*\9;;"DB4SBP:
+M>57QLUJU%?QAB%ZX8N8#M/H2NT3+(9!6<PN`.2FMB^%8,")[O!#/>^?C76Y7
+MILNV5:>JU>HR1SI,NU3283XGQ2#X0@Z-G-?"-/5#/5)F26"F*2UXYRP*^6>S
+MBPVQB(]1-GL.,3+9%,GL.3/D^DSOYQ=>J)]AI(!,5D1Q&7U\R#A9&&5IHAY4
+M>,.%3%+>DO]3$7$&MCMIUL'4?'#<JF8L^SP/#<[MN_KXOC'0K8Y%@Y.6GRWM
+ME_YIG:^7)8>F^6BCZ&6A[+\>R]M]"@*N_O?TO?QM$[Q("!_J0VC^RAB?]EQ1
+MN[C1*'!M<WL:=LO"U]Q.N?OMGA*WKBQ\#(59SJNDKITXOF:F7P"6',JA<^$J
+MTRISZU-88,`^TL9GKVH?(021JPKQ[LZ@(A22*V.,Z"5*D<35)V<M2,:HJ$A>
+M/S]KL6?S@\%F>N"1F?![S(/\(9[PYS%M5D,R[%RC;/?0SRH3HRPS%7HX2F7[
+MV-#H=)B:+1TM.69WU]1^/\GJSS%U9QG6YB];<VP8?"Q47M?-PS7E[Y]L)F)6
+M67'ASWVK6M/`UQ?RS.-]#4.([AX-K\]]5.?[7V.@E_7X/Q1]U^J_%?*T_;=]
+MD_:F/A0F4J%`QH?XB2WP_"BMY7D_ZWIJ1WT?WG[&?%J^,?=`P>8S(D>W[%BB
+M/S/X,H3!!EZ=/@8_L](F?P0/&.WZSWW8P?6A,$K$&<$PCW5=Q\]31RE8TCXE
+M8]^'\^RA]6E!78U'C=!A@K]G(O^/"<WZ^OR?P*^C3#[X!?WPX*?H?)L.#[\L
+MKX"UI*8>"LQ;*/PW0'Z'O??UGUUF(E(D?1@50HW^X]]_!M=/7WQL"10^Q]]^
+M;8]^&/P>]/@Y^A]3?QO1E"R'EBN9^G#`T#MR01\VP9NQHL>?!TNP(BX85P*(
+MD3]9PGQCV<+86Q\O?@\<9&#H[VG0URMU><Z5:XX<-LBL<XO:R[:]-J`?TO"@
+MAS&L(<PX?X:\KKWPQ\JM&]G"1Q"T4.KI&`S,@DP]F-@'\W;XC&_=ZP>0%GTH
+M-_1"]00H@OWGJ=1VNPJ@?B;,!3=>Y_[2$@_.A?CX!\GQ/:?N_ES5U';;%P1_
+M980P[L0%X&!C"@<?+6&_Q$U^/H'X-8[XOU&#%ES0\]X3D[/XCA]C`.I4$<^Q
+M7A7OM[0(6AJ.^B@NWA^B,COQ_"]^.]\!^AS^OPN"0_+J;'W^1(9K`K_EEW:%
+MPPR21/L?TN_/S,([@V/QHKY\J+`0D>'V/P/MS:+^8$<T\/JPKR([-^L#\K!#
+M67[>6^O37G4.Y;&U<';MR6U\N"_>A*H1'@M7:_&CD(VZ3'?,RR,YMDYIC(9,
+MDX:6,R+T:;7PKUUMAW-,IK-,]3PZ=;G.V5/GSQ;KT+Y)W+&&/=L2'(?W*672
+M'YC"-(6V18DJ#]'$%1I%?`8%BD-I1"OWV!5#\G=OZ^R/GW5"QA'VP]D3DY5?
+M;^VZ>1/2"%"(3*]/O"C+NYNC]34V&=0G^^V#\I?-V)!CX.8FZ&$?@\V_O^[5
+M'+VILOV_>U<),P4PX[\7(7S.[J'5*[?5^W>/(PBJUY7M4(XRJK+=($*)B%R5
+MQ2CRA\TKQZP($37)/ZTV-E_=_0[OP,%'[G8((_`DB9#"^#'%R1(IR*I=A4*M
+MH<@5A8J:L=61T4C#YB-B$8\@B1OJ_G\7=L#U70P6AYK:51Z[#$G!1#+_L'T/
+MDH(17OG:/E9\#'R?KXE[@?DY)!)08(/SU^E?F:+:EO#0IUY=*L:\N"O5X]\N
+M$9CIG:^[.S+ES(6RR/2[$ZA96<SI(H,A2MB8@U>J^2PA6DKVY9R>#FDI?710
+MCR9J)):H6EH616O&ECG"$HR+2]RV:##I(XB%6T]"'#W4)H.18R78_L_"E;TB
+M0"FF2?D_[P,GTG-C1P[P]"W.-=<^IICR\:HL:&O:*31GZ^YMQ<&=%)GH7UBP
+MY`J!2S1E+*UYX][W.OF'JZ(:=9GUZ;S,;FMX,&I?JF!1,6O<>+6QM13D_&AH
+MX.DP&10E6&@I0D&05!K^A'OXWAN?04DW+\)=_%7`V0^NU@YQ+Z<5:Y1T[:%L
+M>#G:IE1KEK_(R,=D^^-IE2>+F6Z6H1Z7X,\6S+WF7<SMC.K!O]KJ*H('F`KS
+MI(+$803@!(G[Q?I1.3*N98VKU]*R=(<M%G-'U52SP2<XJYT>;2UJ%+HU170L
+M6<'2^.-\>K3!HX`3*^FOCVN:,XW47P^HFQ7/`[K6W\J0'P_Y^9FS7QT:K/B0
+M/\3\-S^WTX\9!Y9&+]O.R9E?3F*""PAQ]*&:,M?XK4X&HJ9VIT[;7/I-==#)
+MZ<8K>773$0QX,ERQ?B5*-;X+7Q;G%Q3'#1AETK(JXS7XY4.'*-DSET5TW.B=
+MTGO`9"#@G.6C9^2FS6DA20\RG2>^]=Z_0(8>B'S3\M^G/4'=$H^#/2?">@J9
+M)-8\SM54?M?I>]+VOZ6\M(>/J]/9QXY5D=J/EH-L&Z*L,@JD%C%9\Z6:0M"_
+M8GO8HAISS?V2:T=4BX-I2B(+)D@KMBI<Q]FF_'&?8=8'E-SKK67GVM\J:'#1
+MG"JC9C9-](DA.6!6,ZX5,I5JM"NL)(7+$9:^"QEM[64>EO>FQJ9RLX5IH;V]
+MGVC4V]G?:9]9[2T[<6K&AQD%^U'6K6#;\)QO'N8MES5^-LR;$TI+]\UF:.`D
+MAUT%-)H?<:^,J?,GE.GG2#$LE=\)Y82N'O89T"HH^AB6-I-,JP'**LF%T+S'
+MQY>YQJ<[)IXWZ\'A1M1UUIUEL\CL</AQFV330TRL5IJ_S8O)M`U.?X"AE$3^
+M;KK%(O9"QH5\N1ABOJ+E?F'4PAE.E8;7]I;'7>V5VP9-2YT`Q4VUR-%:>6U4
+M0IED-$*!NF5_"]]>GCGXFGI1M;IJ'.G.2[UTT--,:6;E)][%[:-CSS*U[3I-
+MSDMIJ4F8[:&=Y?*5/$0RV!8=7'?DP'75T;B#']W\T&*H9<Q^)"<&[&3,4/P/
+M:<)K;E+2+*H_J/J8\03^0/I9XJK'P.);[O\38X5PF\#\CMF?A-R9&AWK6AFL
+M[F+XVM1_N_#PMJ6M8JS3ATMBU"6'2C4^QC<<LI^IG/KD[<8]LWU.3E+92P;E
+M6(IJ5QS2$EV]"DG;-6*VTYGVJ:/`G=.5BO&/14*JD]2^TT*$+LOXM[R[^AP^
+MXGPYO-^=3G3OWYTD7MF4MG8MR6#S^]B%^N+&V=K==2BRLP.N]R^LF5P^5$3,
+M)@@%AB4\-?R*C$/WT9DW_,BOTA\8O,@20)FG]A-PJ5BP/C9#_J@+WZ<7(0SL
+M7O?I>6WV,`^]O9S+5*9G3<[F)RZF5BO'C&,3!:GLSQ+2IZRCXK3FQFG`NM%U
+M;4];VC]85B.)]IH#X"K1I7DF?BG)"JI%-*T(EF'X.$5":_EG128>KUC+TQ(_
+M!E(HPT1OR3`2?'DO42%9&ICBRZL[B_:HXZ''N9J]I\]&S3]OH0UW85WEJWWM
+M/KW?#WK8IGC<G8COKQ$[`,.@+A-)884:.DE@^.#LX2-SK++:9"(4M(6XQ\<'
+MDI3'8@U7)&*%*Q:D*76YIJLE)/+B1[=,YX9R'7<RB:>^V?<<]TR)F=]G:Q7R
+M^/3/8L:ZWOX7*YH<CXZ,[.-^7,Z;>KPSAER%RQ3DSC7%N@_M^R28&Q^O*?Y9
+M/ZUNR"#.#]I_N%7]S#2^OX%5XX+!QTB/U^OOX/K/K(8\48$L*_M3W@_R)4'X
+M/B\G;?8;6*SG)QIB8M;,N9X]Q1:Q6Q;+=+Q.>QS1UMB6,&O"UGB3(]*EGJ]R
+MN#PL:37;?+/H3+64JZ2Y<L5IJ)(ZE17%LKRSX<4\R,1S79H5"Q,XKK'*T<PJ
+MI\9\6X^TZ.>'GQN_*<O?J.IZW#3WR&@N+4\:QX-.8FI^C'+VZ[EC:T-[V/D+
+MB/R%>[I8_2$P<_`?(63HG^AT]^#W%NQ_+\SN_%G:IHY7>A^MXTL8JHF?7MUT
+M-WZ]_@\M,>./A$5HHL6^BY:>.'WVOIG5BW8'D;[X(I7*94$<X9(HA07)A(0P
+MU)83QSDS11$U3",.LN@TZY6KOK_4:FHY[BKA1S%1UV&6#*E9*IR2XT[$0]K"
+MI&$D':990@]P&T!!:^P%;-_N2'+*"#FY=E9R&`8EFBT5C&*Q()%R&Q-.RL:+
+M.72'?\Z45JC#:096,RNS]D[_:^G&?X:VS+_9=_LR].UQ<RU-<6OC%OM%\JFZ
+M.UH6_\E!?"OQM^JG;V^N*NIQ?\;VW^_A8GD_`(CZ2GX+^A*!Y!_;7W="=]Y2
+M"49GJ0VL(N6S^EAFOQ:_!D7\R+^OJ=_WQ%6#]<.0FNH_:G"OFY(J4=3_7Y76
+MD29(+^MHKY_H^/E]>_ZY^R^'[)^RHB:>5A6:6B%=)B+14KJ8A))R*EHZV9`D
+M@]R4#1OM/EJ/B45T1IZLA"(A2SI%F5KD"$\XZ,6VQ8N1S3"QNZDYD>"%E2B#
+M7L'5K%]W<JOO)XJZO?_U>.CSL^L9D%C6+?&5\#/]PG==Y]#MRA-7S!5K:E.(
+MZH\HTB7;RSE"URW;7HY/+@H*>M8Z]?@^9?J?,=A$#*@8O7RN.,JC.9!L55`\
+MY^;=R=JD2F@]UHN:36KJXN<59F:$(/CDD='75A8[G;*ZBL`@6^ZW/=*YG0E@
+M:AG.11+/;I2#,I1""M]IU"?&/G;9^Q*FJ%S(*JF6;;=3^Z139'Q8CATQT"')
+M^G?FG&C&;FWU0(=)D1O%K5E%NCZ;E6L5K(2RJS,TR=^>_:<Z966"6-`[E(I)
+M!GRS*JV2`\O7O=KA\4MPA$`"/\D)#QRG^@=G;Y'90/>XP$`&D3MX.9F/3J\=
+M>KK(!;9%55555556JJJJJJKXEGY]E55GPXGTH/I7OS]B>A^)[IXB/5.05.XQ
+M9/7#_?]#Z7X>PT'\K6I]?-]_0]#G_M7OV8'MN8^8*:SXSG+XDOW810BA%'(^
+M%67`;H2$.H1F>B06WKUV^1N#.BXQEZK7J+-$1(G"W?/\"95AQ0`F()93JN^-
+MZW2:7@4]1#A"B.'<5XLAV(I2LZS23RS'[DXKDC/^%&=,3JPYD=@7$Y(%1.U!
+M55014COB;V?I:0__T3Y/D1HDV20]QWE`?$^P^'317)C5SG,YTRIGC_I057?<
+M'[D\F`GR!/&$X(FI$A1\2L7'>8*+7\EMW_O%CC]CCLN/T_U,1M#(86&HMC#D
+MHH65T'V#`*Q9LKR%2@Q*)ELM"\I9^2R&O-2@R;%=F:S$.+'H(Y4A[*QE^'Y[
+MV6JU7<3?/]KS78\Y^7Q_@UD@=4OKOZMWWU\9\(/A%)N.=BF^.-L%[`M&.BAM
+M13'/\K]-^,"OXGXORQ_:B'WHPK_D'@(?]N%?X,#GX=K#^F_11T70D5_>V%5M
+MA5D(C:4J-M+T$(^.`#8%)`_ER`_:&Q[WY7MZW.,/V:$R(H"A^<^)5JJ+7,4]
+MA^L\U%!8F5I_W"CSVS/@JK7M]1!UIGWF*E2MJ5KOA25<?'X/<6V6W#`E0A!6
+MVUNY=FB6[4J"U;%A<;KYN'5NU:JV>QL41B9PJ&'(-RF^W'>)%Q\2"1J(D2E*
+M\_YCKZV3ZKWD.O_GZ.8$$0$K+JUZYEYSE-JGL4[=6V?./<]\(NI_6HL44QZ%
+MG*KBCJ^X-BYXI>-PBHJ^8/10Z.TT:LW;_/1,.Y^)/UG,\Z2:(W@:0?^`KRIR
+MQC2]PS"^N,C%Q55<(B0YCNC+\L@FA2.11:C#,K,F#*F`1["ZQ:A)*M7`-O!I
+M5=>O%PO8OH%K52J0?!;H4U:UD'63":D<XPFO%JTJ1NG:XH:T5#4F\D]=YU0^
+M<AD1@DJA[#]>%WL$@?IZCC/=>3^CKON?[JXGBY6ZY7TT$Y[Y#GO<^*.-;$6P
+MY%3S.=Z5\47TF/!*'S/0$SQM$`0VKD3"^F5`3H;G7=GU_(G?'2=%+*T#TS*/
+M554%%!S"GHEC(\VQ6U#+8$$$H5!`$6?!P&J%%17#8&"L9L1!!'ZXB_;\$]=$
+MB%=43U?^%%\*4>""(8O$59*%EE47K1-L5CKU%M"*'\#][R2K*S,S3`9X^"<G
+M"):T459I^:6BS_[14TWE6]5O9-,42UXK";1(JU)6;ZI8E)18V%M8&A^:/1+R
+MQB@FZ6H(S!H_L>^Y+[/O=#V/3'L3BOZ_R7NE4>K0'*HSG/?%&\=%%4ASVG1Q
+MQFL18HXQFY#SH+Y60039^1U[NB3SZBX;/?534D!8AS,$#K!515^/\:,"O*O*
+MCI05-K.YO<G*DGT3FPXY,_O@N1&1XI(T6%AH]ND_[[4L&7PF68MSV>`406!6
+MOAVF(&#Q1K$&/-J$DJR#,U'QCBJ#7O[[C(QWF:Y4"R_)MX3LY::5;B"]?%C`
+M6RUJVLAWPGO!S[<(I%GT*T_M(GO6Y(D>HK1H9*FJ5!?,8P>?]$>`1()@B1YF
+MA?D5!HO*>F':VI_+DGH@B"><UG<^>\E\GI!SMNGZ@5!F8E91>9T+E9SM'%[7
+MHSW*^I9%>K/55)3;R=X?6PE:"!]M^2;D^9F]!MB]XGDSE2,;IBMF*5%G_A9<
+M@?1_T-^4L@0WDY@#<2N99\AK45@5SOG,B!HI2F^J-W`/L#NQ%+('+"!H`JO/
+MH6FQ)2B@'E"D,$P66WH*(HS`9$!5/JV\W-W'*^6C`]NH;!37">X\GR<('WNV
+M8PN[;^`?S#,\A_Y4G5J8[O.I#@^>U8C#'E39("A)[TY_4RY,"A(T5SW^S-C4
+MC*E/-:^(_PY+5JU7E9:X@$`_J,"4AL_VW^:4$L@%_J<-%--%--`'_&.<I$,$
+M4U^JA<2/E0>*-$?:_F:-*@TB$0"?ZT"&7LR@4(G&L%`*6(@@_\^V")S8^I`.
+M2B0<R?V-D5.0&@`_T9"NIU()DJU[DZE3]:?X6*[^+'>1-29*.0#J`#V_/Z_[
+MP)383B!/X$BA\<PHM")0A\2A_G9%/(0![+2+2K^SD%-I74()2/L_.Q!U"-`]
+M@4`_;F04^(=`*T2$S!$TK$`M(4E4I0$RM")2J5,H!],?M@A#$]JV20'>%$<5
+M*E(B%50(E`*@4*E`H4@H%``T*A$*1(HE`@-"(^N`,D5"J4")17^TV52J$2"B
+M10>R":5!F`$DE47N"4`R4!B0&@IHI`F2E%6)C8U04"T"O^!()J@0B&A$4[`!
+MB5:$2D5H$B*"F)%1]R"+I4\V!4I*!1=L``%4JA2)0'NRJ?U(5=32HG$N2L0$
+MLD$LL55Z?J8:&"04H">5@C2(M"`A0U2E*!2`/X;*)K,5#B7[W^)^-I[9)S@-
+M(J3#14RB-`A$(M%(E(K2HE`+04*%%(@T`@T`@!544`4@#0#0M(@T_S[(05*5
+M!*#KZACO@V1V14H:!52H@JBE07E"+U'TX^<:%R2O/K1\^?XOG"DV/ZE538/C
+M8?>9_/_'_JGR7"?L_/1#1A*18B@*K"E<3K)'$2+_S:<]YGT/JN''_][Y/U+9
+M.46D87I#6!ME'^SLM)]FANCY0-<T_D2F73^>A]Q\G<U9AMMEP7-.WDE]K046
+M3;Q:72;2SMMIM<H+(`D]*\Z%G86G,*6>3&N[EQ":":F-UV!!_W_>O"=5=!PM
+M?![_9HQ+T-S98,F!@)?I@0P8XY,#`XDV3`F&<7#K_@JO:;9!$*E.)U6-C'`C
+M6(8RD\FB[E$$/<83I&9Z()FF(R(CE`3/PT'V'B":*,[I?.100$1E1!'*"(-M
+M*"A@^[IHD1!T94'"(%+JC@"7JV$""H(.XW3YKT0)'13ODIU0Y$03[UB4<")J
+MHM2Y$)U"TH(FI42W)4Z%X2J@3TVG/K-6>PE51!,,N7'(B7CN_XH#7M88H^*$
+M,O4=YVFD0MGS:!3.#/HR.TGFCQ1\_G]9H#^/*_$/#$>PNZ4#CU>O082A('I_
+M+O8!$A/8:=JMX,/$R[UK8_<?=E/T6'UM*`P*PLP)ZM*F$@?)]_ZO_(OK[/2U
+MF3S80I40*C#):4!+K+>8Q+<$1"*;&<"%A3P!0#U%\^T!S.M@]6/?:&)"]&R>
+MUM&$.N:#5#%`]36=0DMLM$/Z;=DD]C3\20/@U^.Q#KTX;$#"$ZZWE@AC[G]6
+MT`Z:5];SSL$E]:D-Z*(%-#O2Z&`!>>TZ@B34,B(545`"%9A$;;W)7MKV1LC8
+M"CRX9!?K&.6+3&PRX.65\0@DZFS4"P6*R.$1+SQBAZH]S6*NVV!ZI7IOM:4#
+MWY0Q@`N.W^M00M-\[0`SWQ:0/GK6U?7M:$,M/Z>O.)A":,DFVB_3\EY`L=2B
+M2)JE?@Y?AHL$,.49(/SU`-QKW5[KRCY?L7_(7\W\*?!GE4^)55`T;`'6'7AD
+M)YI5\7?Y]('ICPA3;?$='@4$A>_U[0AMH^JO9>!M@V+0)C4W?BN!Z7I5Y<CG
+M:$+EB-V8"_)E?BSW^'/H;"/5*.U#"$Y-@,ZHB7]U`G%>#QBX71%'@@45Y7()
+MZBO+RN`%L95564AX7ZV`#X`IH(6&!,V2%_Q5/)(&/OT$I(3*M;$-[?9QK;$`
+M^E@>>`/1(O;[V"\$@]6>+WM@>K;!3MY[Z4/@\_T^O3!^$\JIV/JTS]KM]5][
+M7Q?W3.]9VM8[,Y-P@H-[>)2!GB+WWQYA[,;KM4E*NQ>J`>,L`_R($-2AO`.\
+MK2IY95],.H1+6"V$HARL42.$2H7^"Y`)X2Z=*4AEBV45$2I;HQGCVP)K>P6Z
+MS%7H9[5V[#O`ZE?C9@*<_N5"6$DMBB2K40&U$@;&M39#'>@^>>W+0O$!G*-6
+MA>(5.R1]?^)#OXL-DB^Z[,%>M\WOZ%.J3X)#B`>ST`&*NI/"$[X^3WX(>YA@
+M';TQ`\</3W,7Y49"^S]+/E/T'!.:B)75`#'5!$UZF"J%^R7^+F9V<\?';4+*
+MB$N"R8:AG1RN2LH)A*C[/I;'$:"O-4T%,UE\]"8ZHDN.P68F1`Q8-24GICK/
+MVYCY/<S@?:WWV4^LD]?=@IZ9]TD@2L(N&R!X2@Y;F'5^?DU'!M7@PA;9!+I@
+M*IA/?!_R_]HLP?\JW$,-_[J&VJU,$6T3ALH_Y:FO97Y-:5?S).UME5ME;1J[
+MO<>BMN\M[FX\VUDY<[NK'4[.V!65*G2-&QL;NU&[KW=W9%4%:="["K15[N7-
+M6Q<RSN+:H2JHK+J<J8/D@ZM16PK["@CSJ<IHE,&"!=D83*5`,F5LJ)DB%,@0
+MLGN/S/K#J7.0K2W[231`^9*Z5.K^!+L-$),D5AZDS&?,*_P]<F=GTUS0T($I
+MK3$QY\@D`JH<0MLQ;S!)DL5(@LU,1QM\=M`N$HFA4VJ:/$Q"2%=1'^*\/0K[
+MD@A-J9(>QIK]$+8BRIBUGR2&"19Z-MX,)77[V2,5EKK18I<M-1VB:+[2"%C#
+MU"IIF&)%C&V:S*V><[85*KDN;!60W,41:%44547!ABD\T11"YH+NU>M>V[:J
+MXT3>AX31"I9%+2+Y3\W3Y87&&=1VKFL<E\=O86M3[2K+)S_C_XQ;@@SR9)BJ
+MKGZM855O.#>&(Q@BHC(NC9&3"6)0T`I)C:._#QP$/C[3M:GYM6]]SX,I",(^
+MH/]9/W[7&`/]ZDSB7`7!7*[.U$85T912N*@4*ES$$,_B[J_6U$MI616JS;31
+M$8>/(K/\HA/7>7O\MSV;93LD^^PE$B3=4GZ_ZE;?'E[/5CW7H^M]R_36LK=<
+MY/P1GTI;^5BE1'("&U5!#/K-*V4Y@C5!503"PS4CD$TT6ELV\&*C*CM5-1ZQ
+MQ'QT3"(5[3""HZE2_Q\M8A$QP6\HR@:/;2.Q)V_^1`73K45$&5#9<0PFUUFE
+MVUQ);KJ'X%2_G-\J650#C5""HB%]<:WB3.0P%1,^J/403!N[K,WNQS(YU$21
+M4+X]?Y3T#I[*L_RQ0[:_R_;4GK3A)]$2=(PZ_HMFQ/!@L)^P_N^-C7S^SA]M
+M:9_ESM]:WX-2YKE?-MBK9Y[5FMB8A2V)1@X[H((7BTR8A71D1%##:$II]=A8
+M:IJFGO\C25^SY,*=Y/S)`PE1Y;^&O+#[<@GO2`^25/CQ0IR\^&>?/R?G8^S[
+M?M>Y>YMNAW2?<P`X0AC3K?LNC;)EEF',M"NNF3CU4CI#C:2>>>=RR2J5(3.B
+MG_I@8P;OW36!B^"X?<+_+_C_'5`Q?@^^=]?*J6']3]]U=7=(Z0N*Z50Z^J^K
+MJ?=R_K_OU(D>9?R?D\T4<4TD<E!F*B)I%$JW%3`5;+WX3[KTR[Y^%F1Q`;E1
+M$7Y4(=1*AMU?+VV/L(5#WP^P^OPT-(<I4[3P3RX?(ZL;=$#Y,('.^OCX>'NM
+MN-U\(0#ZXA#S0'PF_+47IZ_5XG-\^&PX8\>*H?%A/5XS?MV$'0/LPGS85U!!
+M)!5*;ZS6&CVN-MY:$#5]Z<("R!8ZWSP8TM02=HD+_50!FD,9;YW]G>BS]]_D
+M&GM?LWD#"0Y0`ZN.OPYZWSR7AI3L95W\'?2<2GP2_:R[G77V&I+(:]-=GCW^
+ME_+20-_(*(&G@T94][W@'VF!"PJL(/5$LD=*0H9T<62H(:/5X$)ZMI<:1!#1
+M3QP5X![A(^CW/<-+0\2G'+6D7AZI"FBB2F,6'Y]!D>&9DWY\<C3'I1`-NF96
+M5R'YN=KX[*C\,`]QMC2H?!V]W-V`>V`^[@0R@3@U/P6-D)<204/!)U]ILV];
+MXMV$\TA(:D]&40$9(;3MX^WPQ`D.FGPU]NY('W_BXV[^KMF0)J,AU.[VSN2'
+M3.H!FA%"'AO7T_P+0&W-_L8IL+JJ8;9269)Y9<V,^7Y/9>>A05"0Y_=H(<YU
+M=@!V9)\EA.]5ZKP#-]?OH"/?[6(OB[.6D'Q2@>PFQY+0`>6%;,0#4X6FQ="K
+MG/Q]3C2IGYD`#+EP6QE>(B(5([+F4LJU>SAO0!\YW7ETH\KXO3Y-[6S[DB\Y
+M1._X;?KC<C="%'7<UN2`8.+U[_%Q(!<[YGC:\))^N@30^`Z]`)Y>#1S/TOU_
+M"+W32CWP+\KGSCNVS#.C)`Y^[4(%\8?.]($*2!;V5FD4`P//R[=_+<0/QK?Z
+M>*O,OKII7ZV`/?D\\H?!P<6D@?7K%WIB0+][6PDNP`3VI]'XOL6I#"Q#W+D0
+MJ;^![&<>O<4Z\^9['IZLX$^5"AK;`'Y8_M:X?"K@?`DDFC"2WPY9-_+X_B_'
+MS,2$#7-_2O<(3P\/G^O<@<:4C)`[8STZ&-Y[K7ER89^PR'%X<?(UU\NEFD0]
+M9(/TO3]QU\&XO=(^UKF:1##&8`@H"6GPTCT0%V*F4LQ''JXP1#220AGX.4$#
+MX#V\1-[X^8`/B^+K2#<^-!O)\,*?2D2:!'79Y=R6`#+(FP8H^#7N1NV&*RJH
+MHJJJJJPJX>D==K]='K.`SGJUID<KL;1[70FF&V\=J3:1XT!]:3*6:K"*^V#I
+M-%R>3'"SJE*^>KY%VS',Z27`9&J+R^UK1[._;9W^+*];0JERHY]5LEJV#)"9
+M[L;27-BJD:&&O*R4BL%W,((B"&7BD[2/0@BI;,1QM!YHU;/;R2-2[5C%DL.M
+M7*DE>7"N3BRJ*%J%[*ESTE%-V(B3(6E]2#WY4\T;9E,9&QR-9`2+%J)EZ2B^
+MM-1*LM=GK*N/J\*Y6FFQHWOD:Q0^I:PL*J2Q`!@*+B6:MJFJ6I;DQ8IH,8]6
+M+[%2K45+<1.NN>&-5RM`[*@4RLQ%(5D!,<Z717D-(YH("HE#*(HC:<T"UK.>
+M@Y[W)S`N`BOWJF!,\Y/Y-1U,PPEQ+Z^R9[Z*_RVKW&92GIK'J%?5A8<@>%W0
+MP)U*BJ'9^0T_*\AZ/>?$ZWXTQVZZ[ZO:CCSW#30.ZIE=:4\YTO1=(])$[9!4
+MAAVT";N>MB3!.D[H4=;.,8L.9B@;E#IE0$J#(QUZHAKA%@7(@C0E2/7+_(:?
+MRYZ]8'X^/GW'\\SOJY9:L03WPB\@XC'`(F@W1J:F@)U"L"@%*'QA?B'^HXZ:
+M_+$(L.UCU6U]0429.C+(%\96"6.]$+YFBAD*[/KR9HT\+`#CE9/YY\_SO7.>
+MB'X_ZN_12L-`KN'77^E5$P%_X-X3'AR_`B`!.Q_^M;>B'W?'\Z[MS$T+M3FM
+M!S/<SUAN#L&<N6-N,V&4_1G0"M.>@B[0^G`J4F<D0A\`,A_@B(S@,$2PGCVY
+M;/R/V0G[`_$,']M+T).7&:,,3#<=K:TK^VA/G^;KKW?S>7.[4.M$YWF5Z/FE
+M2(<,*"E,8"H3U?*J>\6`7Q[)@0F$H2%W%5/S*LGO;5F94W^I#^:A_Z0PGWD4
+M`^W^+W.B4D@<U^Q.-RU5^?-_@&.X3H^8.LZ/(ZMY4G33^=\MG(\?6XVKV'0K
+M5J5P*[\XZHK5Q2TN?M])FL].<?UDC^J<PW7,2660BW%AG'5X3'L]80<U7L>0
+M']=%#8T6XH+0O)N<X*:\KJ_51VWSQ&NLNYIO^OS_OC_J?L]WU#,;X-?B95VM
+M,G^$%J,_O/UGK9)34/H3&NBR)%'\M9GTP%^_.K-(.^G[];*O]:A.@K3('(I`
+MO9JOPIX@4<,4BRT6FT1KS#(DB39UI5;5M#4%6KY]+W-D')ZD)VDSQ?2$+FYN
+MOGW88S/^5IGA/9K1S%6LZ5=&]EL\8H0LYG%OTP7GX?D^7L^_%>L_P;_X'!A5
+M&9L#F&5IC&MM54*1T]^C*AY6`,JK156BVD%+2R8I1V:%*K;7OKE_N>UO3>L?
+M)S5-FU;VWMY]/<^WY)#T39G<E4P+_FHLU07-96%09!D,.FM?*81%@/8D1%$D
+M0(11K%!,5,\19".2*82H4!+<A;+X6@4OR&(7Y&E9D'RE)AQUDS$A-6CPXQBI
+MA!B.)%(+8%45V8)5K"U+7.'>EF]%D-(\NP,H=?5%WTEFS++-E27&5SGI.\48
+M\DV<17STLI:MRU.5M;V]A@XT/?S[_N&_AM_E[1+E%43H9OIKQD0H\+\%[5H8
+MN'-A*/@S6+Z.O#.H:ZL"48A>FJ%J^A]TOC:6IKY?90ONKKS:_&V6O%V?<HR)
+MA"K\4<J1U(G)%*BX-D?FOKF4/DI8XO1,\6I@=_-FYL5F^MD4TS#%Q(V?.62Y
+MJ+A"H2T2X,S$XI9:>J1QO)ZD:P<\H=*EO`:>^DF>9NESC"A3%69A20FF@.?I
+MQ@B?I87B$I$\Q[BEE1VFBF<UL4DJR--"),6+`%KXI))5D+HJO&)B_*;-6"5(
+MAJLXTMYTKK*ENU/=E)BI3(6(46"_(WH++`<9Y4)*JM<*)Y2*2-&L)!(+?K7(
+M\\3HUXP&<3U*"W(ZK%:*B7V;7O+.L=FI4LOM3BA`HM321LJ"D[G.)L,#"*Y%
+M/+8MKP<4^-98#,M0Y,L;_#B[][4.SUVVM?._LTR<L)",H'2.+*QZ-'7!SUBN
+M%0=6,-<ZI:+]B(CKDRF!;BBK%'3X=*1]QF>/OUT\Y/4R<XRU,O8Z>JS8P>K!
+M6A2CR-7/%P6@#L45L:)AU)8N!#`Q(J)RO,JZ>V(DM>J^]]?+STN^Z)6W?2V^
+MNOQDE'QFN7GIULYUUOVU3PJV/4HM?'H=)521L7"<_(RXQ]9H.E*53$+XPWV"
+MR11JLF$V2/T.FG&CSI\]C2>/JJSS5-SV6FKN[6R'9E!KVJ]SY,[Z)RR;YYV,
+MOJH\!DQ,<6K.QXE\?"ZVJJ>V>E_<:_#^)!Y2AS&>?[5_;:^#-GJ_H[<>'A@_
+MR<,'[T-^?*3#;$R'XHL<BL:"EH4VBW3`N*5IT9;#5<$K1/JJOD),:>8B(X1N
+M&&?6M0'-"JKGDU1HT@K(,2#&;5H(%2:(S/9UM>V]NNA:RSUY5.>/&^TT,OM[
+MV+W]=BLK]TL72Y[R;6+]ZLV]3=G1QGO,QN.MJ%%%^?'MSSQ?.FKF%,V(IA++
+M+8S<"$6>N+;3H^#R.<,YWSP1$PA+=I;V%GU+43[2QLKXWQ.30@1&%"13&SS8
+M$N.^37VKBZ-54@*.#/D'FGB("CB!$CQY%R1?*%T%`\9!Z8=;#J4DXBBA4]T>
+M3ELAZ49/Q*D4\T]$.75#;+GA#V_%NJ=K\^-^_4."J<%?8-WQS_\H(B((>B]+
+M]=R`((!,I[K?]AZJ6&4((G&C'.,ZJ>/[Y_)J.K$:W@S^!&&'^TP?[Z)?MD?\
+M:'/Z+],4Z*@';)0)_)`<W+XFX9&^OK[7W&X?9<&&88'VYA\?NY9I$#Z!#]"!
+M`#]/]'#)$4/O8:5%"A$/\6=,<_K\0H3[,[[!14ZI%/L?H_7Z43M)$4V@.R6@
+M%#\*13B!'^%`"/$!V%XD/E)^D/L#Z[P5^Q2JJ!2!$)5/5]M5^$[(AU'[63]$
+M-""`%EZX6&<(NHPG!G$D$XHXW&4??!A"%XF,AZH*+O"PEH*A2A(H2E).0$K\
+M@.$XXM52+'1*`B$S_/0-]0L:34K.5)H,O8G@=2?V.1\%6#W'\[9R7^$FK&@!
+M+[%%*RJI62PA7*Z)5$NE@J%,0F$5WS$\SC/Y2BQP8I?3,]IP&HAMS8F$BPY/
+M`J3[%2'*2'D,D#8]?0Z"^-5:W'F$_>#$[S'E7_/B'MD!3\8H:Q0TJ*GLU=Y3
+MV_'=?I><ZGU5:]\3I\6H"<[Y[4KKE8UC.U4(10''`<BJB(E]Y_M7`B7E_MY_
+MO^>RM_Y7_OSNQU&-J_4Z+28//\#C6;HG#@M](:NF35OI)[6RC'FJ&6*+71$8
+ML)6%UZDJRR+'"=S]Q.DD2HJFS<4=?JMW>J]6L734SV+!%6)6ZG>\79P:;=$L
+M[UID=;HA(^*ES+)::(H5Q"-@=/L7S/DA-9;=WT<DZR1.I8)NHA5C'VJA/,_2
+MPV\KS!6BG6/<,ZFQ&Z2)\BO=!N*@;V$=BO!;SICJ&_M5G]3!_GO6OOOUFFCV
+M2)SZR9P_#DU6B:#X0WS,*M.[L43;Z)T4=\L5+U:)Y0JJZ%M\5=AEKW)I*>M:
+MSQ5FI-"LL[TI>K+5*EJ])4C)%B,*#2JMF;8/HJ75CO2VHZ[VF?3"9E?%8J.G
+MBJ#Z+$131&4453*(L2%+^*HM/M%FBO5CF$>L3%MFIB!=4@EWD.GSR\4QGTT$
+M3,T;M`=:+WIYA)=,L@K+&X6XE90JVKB/P?3\,7$OWZ*)[G&CDA@Y#DD4#$Q6
+MJ1KFZ/'RG2QZ20D6KC[_KX[JC*12UR0D@Z5P+$.+$'PA=BD-!&6D&28/Z7X'
+MHHATPUN5!E'](X_'?N]V0^.%U),D3\!ZLD3U2R5CT[E99&99/*553/QPSE"V
+M.2#HI"-6_%E$_1)P3'PSM%]7C;^9?2[GGIELXS,M/LV\=/-FZ^1SRW^Z8Z%K
+MMZ33FO6NYZ_`Q/W>WZL_()QTWVJN+'1Z9<5U45!32(OC^AWQZ.V4[XK0>=O.
+M%[6M+O-Y>)WMBC;7R'*5]"HO7M".+$BNU[Z;X>]G?/HW578<\UME8?;CI+LN
+M]CHEJPGLWQ.2J^%HLRPN+%5G*SY7&(SDOU\.9GBJI*2.H);XC?B0UE(^:7!:
+M:/,<1$1<9S,3D<%51G>6BJ8;/6);T)70]<H.6VL\+%%0=A12$P]QA2M2\9H.
+MD>1EB:_E)=DL4LU#>]2].']2-NQ_*6?GWV</TASC^I_['TTE/,=_C`']?Y8L
+MF->GDG]4K*QEYT,K'B+U>S$-8N)$5;YC)NX+BO?RNEG+\8R--:DC)%OZKASY
+MF)B$"9ARN%>.G>U9=?EOHB8@32C@NXC9A9MK4?-W<SAPK,JR5VMY<E0LM'*/
+M=*Y8[,KH8O?M6C\OV*:8%CJ'YOQ9K4%O?ZD)\2AHJ3\QSWP3'N4IA"KTTY_/
+M9:GUX.O.E&;7M5;_Q`Q/6'8+OJ?^^D<"/#/Q>Z."JQ^>_T2,W_/\'J&*MKR_
+M'))6FR91RS5+U9ZR,4W(XX0583SQR/AAQSN&E)6=,E#IYXRM&Y:-A*D<<F8M
+M[2M*83[UQ^+4K^DT%6=([F6XG)\TK()S"0@2)`'1#W#AE085D-1RFSRMCNNV
+MY[B8=A+0"&LINVZS9%QFA9PXF@NP0)(B.[")=-0)%'C+/$V(LSIT06&'!_CZ
+M#Z=FO2):K_?STB_\+_Q=7[',-(,'_3]+[^?;NBU>YGSR/E(\2PMB:"R1R2M4
+MGEBS'D>B?+'"7B'3Q,U)G&:3R5%GD6HK*%##;J!![2SM/>WMK16D*L=2I179
+MU$+<*'C%,2A4:7!9&E229;$)=)%,Z1TA1IK^O!IU2.,?/7)IO)P2Q7P(B,JO
+MGCF@Q9%**DI:CWKJ9F?5=225ENU8X$4<KBDIQ^7K]ZW&5YKMM[LLMM,[%OSO
+M$(?<3NHHA#YD"PC$!0"_UTS_ADOD)CPP+)$2E)-$"TE%NIDJ>3_L_5[WZ1[6
+M>AH,KD_A0?MUM_CP)KA^PS>;.YW3?4J=ZT4T]0AF#$`DD1V+)X42&(V9GKEC
+M1CG&#$G!?UUP$`S=U==D051#D%)F,:YES;Y-3`39*-919,&08*`J'\%RKC>3
+M3-N:X\(X4/@8'!AX&.'#<#4Q3!)FV$B)`A,>S%LZ18Z4'5)F04SP2TL&6QN0
+MROOEAG/>X5SG'%H:D%0#*-!M(TU^'M^EYG;;63>`3NW6YW,7K#,3K[_DD`^O
+M]/YQ^`/H11`]Q&P>[5'[)F`L7[JK^C?;1/V?Z/J\YG7RWV=(;+-(]_SENNCK
+M5/V9)N<ZMLUK5<[S4JR`O4.Y3?)K]'\_V^/IGS,?8^#/-=?O?>0&2N!$L2P7
+MOG8K]*BU6WD\R!]T+E5<\S"ZF44K@#J2=*I4,2E$>$0*:^K8LN#C5#!5$Y;5
+M"WTGI^L]#V?[#L%F0#+I;D_58_9O.)7RS*S"F1@LFL%Q4`%-\>28[#G6EW#*
+M*KV<]DX`J9-"`;#189/2!$J\@9!/E$H#(2*LD2#$8=RJJBJJJJJCMMAMOVN;
+M8VHI4CLL&BSV\BW.YBTT&T.K<Z9=TSZY"3[QB?Q\?ROY%9ZYU,^7#@Q:A6J4
+MI9^XE]J%%%%%%%%%%%%%%%%%%15%4>KF<@@&>W/L-S".,C949)RVT5B*Y<K6
+MX]N"+Q_H]M:I;1V_J=C!5CQ8J@)QQQQYN[S^&Y'VF-K)'%OV"JMS(V.2N/9Z
+M^!GC!OUQXC7C86-<PL3`D'L-56C;`XCE(LQV0TM[)PLC"EA:?+5XB1K.I;#4
+MRZ]2Y"I$AN2\$519,2+F%E4S=LZI6S,R."37*T]?$BS;L>),-51LC&D00`0"
+M01$`$BAB@4G29>1"J2M/8!SD59ULW:1U#LZC'BE*XF5/,4F(<6[$)FS`3'IE
+M!$'IB9F-=*X0M#8!A8-&)5O\J\7[\:D,$QLBSEV(DIG:U,U?,#($RWW]JVL=
+MHFINTU:`=CXF/:DCJJN,MU9:*.PGS%B,KB6Q%T6=7*KZV[LEXM9!;CPLQQ?6
+M[V3D1OT!+5E.(L10,%15LJQ?2844"#V;0J_,Q\N+.!)4J.G30(_;^+!^63_L
+M7OA_;_MZ4/ISLY*&2)($**I@-*J"([^'*]#@W?R=_\F4!#;F7IM,\RWNN:]1
+M6("X0YGE&7-4QC3EZ]?"]],W["%,AC6K7S^Q\)S#4%\&V#W8_L9I<+[SY>OZ
+M/\_[=AQP[#"$PB,R1)*\>!9L;9EM<GT;QF<096?;LDQ7=1KC67H[,5B,LPB5
+M8G6WL4)4/0>:6JW?LYG/*I/.Z157I[`X9V\"@3)$42<1"(1)?37P[<>/CXY9
+MYYYYYYXU_=W\0QIEM(32P7+H?]2]]?)^H=H</2A1'$40B")_G,Q'SF\E@<?!
+M@Y8NAD0P>)3VNC5BV1-D$5U:ZEUQ%P(L31ZNV!A)U*2AVCJ6&X`W+X"`(CK@
+M#9.6N4&78H#J$PQP&9$]0E*Q;0H$AJ331DAK6&:0EF@,&693#,T<:A4->8&(
+M6IL1PU;,T1.Q4<!VF(E7LXAT!+0\?"X@`$,RI`W=*0X6P*3`N^AP.ONL:`4"
+MAKGI)+%[FN0&<,7Q)@A$M,C,$=DQFJJ/`.JZ)@!PZCL@!N--3M=(BNIC1Q(Q
+MP,*T6!$=G#00Q)S*B1-S`#3.F0*6,0!I@;H(P6#2H8)'],`_X,[\!2JEKL$=
+M@)5Z]/#I`-<<=6JV1'2'"\;]?5PIPG`;[[\CA0%.:2BO)80A8"23+4H@LDTN
+M7F>,$`_/K8(37732]PSD)Q:VZE'3Q+,%`@(PP?7`*$)UC"IE@!_T,H*Y5(!0
+M7JD*JH?"(0G+U)[/;B?@YPX1:,6A$/DU1)+2"5RM,<1CD#`?29A#4FD6*UB+
+MMTE5<7$C,##O/'5`@U]GZ>EL_DXI3'K6%8J\^BI%"7C&/"4Q21KYH"4V8*P;
+M/3.SZ<;N[\3NJJQD*]=%DD;>U%AG(]``CY-'-(^,LC.?,^<(C9.9\5#3FZJV
+M?F7>G<)=)$N3O$'UWZKT</1DO*].$Z)GWD*;YAWF^B!'P>^21ZLPS`@?"U7S
+MSG08OI=XN"L?`1OES'MI]CDFCO#JK+QJ#7U$9$30)F\@[Z[B5@$#.S/3V<DC
+ME=692I(HZ-.Q:+NOEQKT6U=>E-*U5CI4RZ`F>"E2.RKNLAF4H'``=CZAGM;]
+M>VO78TCN[-J.8SNO)O1;%[1*6-1W>Q75>3):R4-H7U)>J=\(T(Z3C'IP\DA[
+M>[?>[S%S[M*LR-LE5XC%=D7K6U7"29=W1VZ\/7?@CSH")KU[JR>E"!*HI7,C
+M0\]IH[US=)#:]?`]GC36GE,C*TO6O>'6GZ>+`]5Y9C=\&B"B0424(^A6/4.8
+MF>H_/F?)'P*2[?QBC>+<IO9T3%7YV21VGQ;J+ZM/LEN.]=I7:)&H&,YUQ@4$
+M.<D;:70),`7LGLVX]X!R,RL%>2*>15>R0EF5?0%TIR6#$G6KRCB?:'<)\7PC
+MR'C[VIC3%FCZ;O1`QL8;Y9>[!%D-6W`U@>*`F)Z&'75/1.37G708$DA;'RGI
+MO(`6WFW\JF`*^8>2:Z,==7M;P4`.)/I]8Q[5Q)%:7#][?2_9=]DYJJ]T\/A&
+M@>^4/2>E5(EJ=*$X,^3F4')AD&"OB).T^NYD2+SX2]L9@EP%<HF:J`S!`[M8
+M)!(GU<QJE<G>$]@?B@#Q\2<K&K4^;XSMWVU,R@-`TCY/;?PE_,`5&_B9%3[Y
+M=/OA+ACWK4CNNI"Q!V]VA<N'>\[H"!`4;5ADQ<0!4+"/4-'+*#>Y?BY5QC]T
+M\37A-3-^>=RW@!9B(@?)]N_'IY600?'WQU0WELR^OOH"_H#WRCL3BGD"/3*V
+MA\P;]2(GZEA_.KO?,OY3C.WY(%]07`SZ75%U#,T4Z0J+B(@"ZD>WL/2F:>.J
+MHR#)HR#IAVH(2`."[$Q!'Q][H@?4"H'I%_#Z4OJ37OH3Z!`C2SB6SQQK?$D-
+M%$8Y95"M+58N(&HS7$H(2(@,B&7B"Q1$"/&(%Y.YM5N1$0-@@`7UT/5,18A!
+M6L(I?1<#/CZ0/ALS!'RDQY$1'Q1)&++F`!$1&I<[WB?GP.Z]VSP`A,`D(<7I
+M=,&MW/:VULRU]<7E6N6"``,^5\D<.SUQ>]-^%"\E:>B(`&YS%%]F^OU^G8)$
+M:\$^WPR*[VC,TW+.1$`0%U8M]O;/M84,HCC1J8",'CY]GIRU8".5X^NXKU$G
+M`.AKK4F5[Y!)B0,2$RA$-G&M&VQGK1D4('7\GXQ-7B]3]Z*'J6>IB(X08KU<
+MK5#3/LL^H`6+0?O@:(B*'S?GSD?%8(WV.($3<&OD^FJ?A0B)%SU\+LP(II?!
+M`'G0Y:8CL6"U$1GP')D1"0WUU\LK/B>X*K5DJVF1\1M$G,'PL>U9/H&8.8],
+ME=KQWFY_WV>($=\%3K-;)?R#G?,,WJ%FOE-VTI*!(&7.\E5D'K<!D"4\D!C9
+MWPO3PB&<&1L1?GQ5OIR_+MR95MBB20?-,Z/`#Z">4V\Y;YW?R/@1Q.K(N1SS
+M3ORX,#FP93JYV[#,DG:T`>Q@U[>P`39%6K\5R6R/.:0?N?#O`,:S3#%9/7H.
+M`<-.YU/EX^6^ZK/8I)-2?)KT0)L.[NI$^/*J)29B?854R*-ZY][;NE:GI.JM
+M%@>4DUT%&O%&/,RYW74ZL55C7KJXF353T31R5V4>J9F?T(_X0<(L`BS:^PQ8
+MJBCM4IWH==6S>]W[@K"F7%.IN1=B[A(LMDW,W=%V&5#J;E-4OBI3,U"3=XU5
+M#)FY=4\H(R'4H4%2$AHHF,RCDU9HN2IIN:"J962:15==!H@YB&/:4W%S-T!%
+M4B;JJ5H,%(W=*?N0,9/V#HCY"CX`(["15/L@;M6QXFX$$)`!B[*RJ0GY_W`?
+M]B@7=X,]TN4/DRPOES]/K%WM9:O#N%3!L8#2YZ4)WIG-!1M9LC)R>&W1G#O7
+M1+IX9L55BL"U/B^X+4YO%6.NI<K%-=R2Y8\&Z9DF3*%5FAV#)%.;5RB5RT86
+MPY0K>HO3.SU#KG7-N=ZUF'#@2YG$\6X55%)F6M7%4@;,6Y7:AAZYGJ#8#QX8
+M7*<TMKFMCM=FS5*PD)+CM<C:=SSL.JYFGLC)TU8UHB\MBW=.1>2G:(%3FZLI
+M<[W-$O;;[-3N^D563F9-ZD$:5<-VGO7QF97"[-T\8PZ+!RU1QD+F*N=FZ5M=
+M680EUCCPF=P8#.)EWET;Y"ZIY)G:JK$C,,<ZP9J:*PFE)QF7)TX+"M64+DW,
+ML7$6K;N>&T-:H;+TU*[<XZ,"ZK(='M>B.&C@+'#JC>'`I%(8IU#KEV3>Y>S-
+M1F9EZ-74'(4C*9[CR3/(R;*V01LXN$Y9-YK%GMV0Q78(@71.#989(/':!DDM
+M9PFVIYV,XLFFF+%8Q=R1J*RA0QC<=8KD4:RK&1HQUF82CDS"E3UT9[4,)Z\[
+MF;-\^I<W&[MXLX]V)A=7:]HX1G4'@'84)H8UQV+JJ(!B],)#@OM4TL<VP[R2
+M`&E&^YBZ98Y^;H=^AFKD'AO4Q'/.I)(&YH>7Z18XVD<%2.75"S`M!A-`3>=:
+M`Z<CT,^N)M4[&>:)@[&X)#OI?K^`C\)."5PBJK54M9?\+MI<]1`*!C+/OSW]
+M/VO]_#:F<QY5R)$B1(R`@W,P`JLOB\IE,F,EXWA_B=N9F9S`>HJ5)I=*E54Q
+MQ@<C+@O*OZ6F0_),:$Z";=&H2:N/>3^J1"?U"(3Z"8Z9R"_)P7JB'2J!;5*%
+MM:FH_!^/]?:;.:C6VD1$0L7]N)F>"(BO<]SG.<\;!6Z[1Z5C3.9SG5_=+>KO
+MLEO<F83^H1"5O[P/;T*>E%[548,!)3=IDM!@:(0*R#'R0O?MGCLVS<F:5D1=
+M'GTJ1<ZA/7I/:G2-RV&U=40*5DQ1-R@PIBIJ1.&E+D'G)X[=K=5B@3O-]3#H
+M@;*B"8`Q%"]5/*TWHB*R1L)8^?1HL;L*NISNZ%6M4:)8S,NI)F$E`@;')T0%
+M-%(4!2%<F"HSC7.=2*97H`LRU,)"LA126S+;$2Y[!8A-LEN:%RR`$/CO]KYO
+MA\^F#;.4:L1(Q$9"H(;P-ZDOCGKXS("O\3ZBE#BU2E#!04I6>E[22-RF/0ZE
+M'7&""32PESB]3"PVDV7&/NU<^P!.+]Y.5#,^>E_,`87X_7Q84,BA,YZ_'0T5
+M6!V,\WD-Y9EC5L51IG-%$@*%\%I+("@L6`Q!2)*TMZ8<]"`<@P,W!<3>4U-M
+M#9416#"9WM=+BK%B*@H:\7M=4%`_?%WO.C1$54E%+T%+OS]-D^NF*)D[=<[K
+MOL].7262#K.O7+CCAVJHI*.L#,*((K`0L)(B(.B4><(@&I?:KDO"R9]OP;7V
+MXSU&[CBY=KPM5Z,"PEV0Z8JYBPGL;Q,EMBX,,(9V9:Z6*RJGOQUU->+=L(;\
+ME[0PT,1]&HC!2U1"#`"N`S$.>R?UKF;%A&G7(U%DC#UU)K+0G1,TKLV<M3-N
+M<F>;-X+W$N>.[SMODI,1'8,C%1@=/8+/7$)VI.$!P*N+'1=!#G%4E#2]"=ZM
+MH=H**I:::^??SQ.PI;!JD_+[N\>LE4)3%,%1$P4ALFAB"@JDJJ:"@&8*2JH"
+M((36`J&*`[Z:XN0*W_!>\,V26M8`LBBB(44#42!2TE(4`?;X[T#LE"].S;6Q
+M1$4T%%+32E`%!5%%1616*#..U7Y,_34]&3Q>P:A5G$+:$KL[>_L=X.XVC&E"
+MMTLA33/&8`+E_=?AQ5PK'Z=X:H9<A'C7:]X\B&9&M&7/=QRG)QX^16XIO>9K
+MB@[2EX,K)H]?;ENCLN>RLOJH&4.L2^2RZ,RT..5)HL)U5`PY<N9D&5;EITI%
+MJ(PV<%@<.T-Y!JE:"BFJ>?/`-$%)0"BFE@H-6$Z].FV6(31D&1WTL6"!8M3R
+MBB(!"-:IHJ"4:_6-+10>MJB*$=+OO\YR@:&DB@B#$6`+SH9VMGEF;;>'?;IQ
+M)M:E(&[=A")@?+4J&;TPS)KTV^XR*^M-+WO4Z]N;Z$CLW>Y=G./%+&B^=#3M
+MH:1654T0DJ.<S=C.*&&2@FRJ=F=4I!*TV7:JMZ=Y<'H:F-FZYR55U-.NY"^Q
+MEX6UJ3)&A)$'-FJ1)%(J%.4Z.D9QR0DVFVTG1E:QI-FQ$Z\!G:8+G3!7,7,4
+M-S%:4^+K+0%/LY;Z[BB:8B'W@TE1#6QHB&IB2@(G?7SQZ0%53=YCDJ4_A(:1
+M"9]_A@$Y?6P4D352T$$41245\T#3>K@L5!BR)D7X,=-^,7&%Z3@*L"P@(`*%
+MBN[5426L>5NFX<;5:Q03HE#$O5,@L@B$XQ5B79Q5[$L9#?.^V4R52"V_STGF
+M6&.RG*[I"J4:?++RP!G.:&*HZIK.=9I<\ZZI:L"!+LV*(QH7*VRF@-(4!IW=
+M3F=H5YT9M@JE4PXNUT]V>IFY5(A+E0TQ69HA%)%`17)FN5RTN$4%4O$AG0\,
+MU0,"M034U-,0$BT10!+QST&BDI@?"#0Q0E1[R&V4,](^H.5(*:OQX^.NO3.>
+M+Q#23+,B!X5P$:@3Q(!'C>B_KJ/5@,R5S3LO9"HC;Z=%<,K#)IRP-V91ZEIY
+MV^>97"PM3K,I3NU58\QOGQ=5(BWAT!G75C`-"[%27*8Y1*1HJB@H+G?9HHBK
+MU&BFFE*6BG3N9\YF^<IH\\Z<`>R4)]H70/SWX_#H^;&@JHE3U89HA8_7C2Q`
+MX[\WN0ZIHQ118B+%B@L6(Q15!L]-+WK771QST"HI>Q0MDU2@H$0B2@8&&%#G
+M]3/OR+!R=,2?B>%CSH4=K6;3$M:]L:_5)(JNND=/97409>62MT-:7TQ4X4#T
+MOKI,=BF3DI)R!JVQS="Q0DV%-U-`BE(V\.K3O8[F+HE(J@.-=+FCKFEVA@L@
+M4BVM*&(6&$6#([<:T0A$%)2PA2!2%`\<\G$F:BBBBJHBF0BKIYAG9A.=*@=>
+MU0#G3M?/IICATZ<A.<AO72@OHT&FXBM0L$88&F-,"),WE#2/I;%C44@RQ4G,
+MH7:PYKX[.2EMNN(ONJA3.4=YWF,8YVXT93K%ET#-F7EB^JIRU=;<\7:DV9=S
+M-S5L7<GK3@3C)DKEL5+N0L.8N%P)J2\C54W2DNTM=<@KS9%8N.\QVCKTO@I+
+MRS5F;9FMN\!H%LOKH-V)US-K",;.*8!F59>PTXF6+R8JI(HS.;+D8[O)INP[
+M6DS;BP`*`$40#>3(`R9RL1JJFJJJJIN+.$0B`"\S,N!;61`@&`\S+S,B`6&3
+M////&>4ELW6R*WH*8"@*"#V^-=E;,-Y@XH+4B%UQH&M]GST8>["'*3KUHT`8
+M$%$1CWWZ]+7`K+(EA(H"Q2`:ZF3GQE;'.^.H<N%F0+2&2M%*@0],5`M$;U+(
+M2TL0ZVUZ:T2R%GE`4!&0%A)GURY&M,]+UFM96[5F8,:VYV^75(N^E\J%A&SF
+MICEF<^B.E=N#*PTCU.Q)(Y31O58+JB@2]0D&-S@&,)P-3,Q,F41*7"(H<=8@
+M=3!F=DZ9H:RRQKF9H;-.J(D)W09%#CE5@,#3)JR`?%^:C2>HY"=ETK\6OCGO
+MO0B:HJ(*BDB)IHBHHB2:KV?&[WD#9D.VA1A%%46:M,!8J,-HF(B)?G"IYY\\
+M5:!\9\LE5"2H,5AUS.;VTOOS6A?;OO3;PMCKR8>&9U;+7$DDP23!,`>QA2W4
+MJ\S4;0H?E)\]VK<VY$JM8J1-2':=*"H-9?7=*06-2$TE75-HH2%"9>].WN9<
+MNZMO4@1DH'5:3+HZADHY*8)>H,L;NE(4;JYNYD*4Z*#$JR3>W=WSPQS3VVEQ
+MPE[DJY:G+:RKQ(ULV^Q7UV2)')Y3I7SY5@(J[S:M[8U9<'$M[B;JB'/7@L*E
+MHZ<,G65-7A61:5XJVGEU:!Q\42E9.KF*I9NJLXAJKWEDMPKO%9QNY'8V#*/)
+M$:QE,U2"?-GJ'+`\5W.,TP[,/*+0`F^4BKVQ),FR="2JCM!;+:G<RKL8"A=W
+M4@DO3K$INHD`D!\)!(%'.=+"^T"Y34(H(6T,2B:UZBLC2-D"0`R@JK5O8HI6
+MFF%SE@5SL/.-DX)(J"FPK6$("`+VPQ57BH\L*8054^HJQ;#BZ$\IBBDAM2&D
+MC3H3M1EA2N-Y44PS?(4!1K6Q2CF"5EPPM<3.H!'5VXY.$)7#"EK!<TICH`.9
+M=J:>F2>2%$57;U4:I80<.\A1:#&5=@<@JF\I5(Y!2*I!D8U2+&73-$A#8=R1
+MA`H$6Y<3%RQDG#4W(M*YNJ-W:4W3!09*=EWEFT*020PK.IVL):O,VKMU:38F
+M6Q6S/$20AG;-:#U]4T40538I3:M98ZU;*-$3UT#-C:ZQ9LSJ&LJ4#385.T@2
+M*!!(H;==5$W+UBZSIKJ#P@8,;TE+9;%:I(ESDZ=9*'53RCK2-&;8O-Y7&<"3
+MTC9"<@.J*A\T^Y!!RF&G)*F4DTR98:2GI;IU%@[$Q%@P"8!)5),AR#?-MW<E
+MI.;/O:FE#WNV.<2Z1(D!$A6W6Q+ITRYL34JB3"8W\+89#%,I@QBQ1&(BD2V?
+M&F6^1:_/+ZSWEO-RTCU^&HIG,<-*/MCH89!\5U2QY.D5>9XML!4>"@D8EFXH
+M2TM8JP'M;9]E[#D9&@%FO<Z'CP(O)ZD3YX.Q'`NM$"8!P2MQ"D,TL("("OCZ
+M_7[/;F='L^O+WGN]_2^WCGUG.+?\I:7\_A_/XJ?@O^GU]YP'?G[]^%^3\-Y]
+M7\?R]Q4]IYZ*BU)GQQU"$<4Y/3)6CA1)4JE:B6%1BFI2U62L^I*Q#95[[WZ_
+M-_@?/6]?TF<[[?L_%UDKXO?J_S^J#0WZ(3OJ]$ZU'J(Q'PAI*F\VA65:0R*%
+M"`8T2%"TB15%488N/\)X&/T\Y[QI'UN1D)$X!I"';3UY\L\XRS(7IJP+X?EF
+M'AR_H>QG3^!_1/A=%)W'#=FY[E'7%0-GYFN-B7]KJ/_OC]O^OM^]_Q403/`A
+M?J@R(:%<Y]EW$_<XC9>ZZOX69Y;D1)@14-/6K:)O;&YU<'[6H0\RCS2*!OD!
+M!0UF6SW7[]:N\.^LAH%55%DA9KN;24#J'48E,5NJ4=,FYJZ1;/;J?5+$]8F3
+MMM.TNR917+MQX^#W+%;M6I[5JY%'''''GG_'X"0ZVAEZLM\20-+;9WQ:V=R%
+MYA`]=JD0Q`)@"IL0%8S4_C^J!<#4<2,$8#W9"=R91<`:$\Y59MU`5'(`J])!
+M81G0<"(Z$%P4!B:>REL@#0,J+D5"@@SE0%5-<W8C!U:9XV<T<=$V0#C#3S=(
+M<W'B+`%A\%BH`&9"W@)<10N>`D/N%]$U(BNR0Y[9TQ6Q1$O(:S`+BK+KHB`"
+MS+5]E``YE]@%W,ZJL10$!'IK`>,<(5:,L$948MJ`0[=Q&1L4`ZB-"`U=QJ9%
+MS$4,X`8O,7,&@B7K%P@%947TDO"Y`UF-(MD3*V+BXF+N9MT!G"M*R;F)X18R
+M8$@3$37<!(<PM(&5(`>@2(<"8&0`J#B!1G":T8_5):P[%A.?UJM_<]#WG&``
+M>@2@D#HD@5U.ACCK:LSYW76%^S#,UP8`N%M-<$,!`8:7[8P;WFT%Q,&),$P$
+M,27DRX^5OGN?=(G0M*@]?-Y:5!M%P!U0@_0-CKXY90Z?J)D3\#<\ONZ$TY/P
+MSM6,H\R_P6,$T+JW-W9E+U`K)%FY;<YY4Y$S9X70M38VE:ZPLQE1O3+'.C:K
+M9(@0`4!!"RE6M:L2DAS-9VS=TC))&K6%F+%NS2K);QRC.K6B^N31L\A,X%DV
+M*MS0X4.4(5LS&65HNT*L=-O@7N[MSP,`"#1(M.9B]Z=G6FJ"MH:*=LC`Q-TE
+MG,2E7&KO5:)X,\Y%4ZDBIYB2]R3)K-#&5`2LD'$)J@V11+I$EI&Q<KK:>UG2
+M:Q'A.\T#,)4K<@Y-C:?3*Q1T@4;*%7NRCU^]`PB"_'PU1H/":&5*5"1;IA"Y
+M.[)HT#N,SIOQM(3U)%AD(92S;B9]+6S4G:*;N\DY8.`ULF1)DND.-6#64J[=
+MV=E6-ONXU>;)YF=R<J@@6PKF)59HGV[DAJEF7LV_56@C>S"!-VE/&IY-L>(]
+MM7:1@JV*4NTW4B:<F59F?5(4J;)&S0J>W0<63/=M0*Y&1XA\4#:OMGS7C,Y4
+MY152*.[-HI4JEFV/;CWAU<=][?8O'PK'+0KO2@C"/*2&S>S?9--4Y%<+XGU<
+M]E*<VKO%V]P/=*>.ZO0>[G76)6W4AO1,UF:+)USO2%(3[N-<3BRI(LJD-,YE
+M$.@6U7:!T`Q#P&YYMS=S(ER)9&&GV#$\S;73]_,][YWO@I=CSY\:3PWUUO%,
+M"1-KA;9D=.HF[%T9L*!55+%;9U"I.S&@ES>Z*S<+[$B)-VZ+76,$,""!-$4#
+M1Y2]9XX:)0(G9JE1=R34`0II3/38/!=?)9=@RN'7BKA6/.-O*8M=M]D:,&6A
+MMV1T]VS1J^8=(B72*Y]C[IT;N6<YN9>6\GIVKFJM>7BC[T['>>^T.R-\K:>M
+MV<%8*D8S,^B(%>U>X:.'J=NND2W<V[<6IO=Q.D+W:].K<FQ-YEISBR97<S@O
+M@<I,I9A%D35@VD"')""*O)X>+%>-I(N^XUTE`BW71,JNGVK.]?MNR6?/BL[-
+M,Z-QLVPLLF$'3U1D:5AR\:H*Z>JPSM*1EP($MZ[JUS0KL:V`T`L)J>N78(,!
+M&+EX9)E$<@J!0MXI-B*)),R'1&\AI!6B;5V\X2"GU$J;[JO$#.SMUF4"2#4!
+M36\MGE5Y$3VJ^LP]8P`=$1[*W?>U]+ZLV1ZM%WMJ1C,L$,()#DJ7$*D(N(N(
+M-HEU2Y9;F+ZKG5WF+W,G!WDC*(`90SVR!9"+&XU@1%^SQ]5BBIOO>K?764=&
+M&I&8T=P(&Q+%]M$)3)AM1).VQDNII#$IF):"IEH*4200G>2U8F[U7@,MW*%-
+M"KUW4:\B5(S=D[L[LVB1=E(@/21QY:P>HDBYY"C@K`%EIIX,&2-V[)HZ\6Y8
+MJ4*UUE$D&!JP065'6A)%XJE5?4AB$R';H;C,D$$BBC/SY<_`>MSHVQR@E)*;
+M838,B?;E5\6XH>5(D$KRB(@57*I!&3H*D3':Y(?:HG)ELLF6V9:#"<R!)AP7
+M*EJ)5"<\'?D6L-B@R@P4,D2#)KU'2.S$;6V*J38G@;L.Z>-#"K62*HB<Y5%X
+M,"G"%05(O6IX4XS!@#F\(*7=O)R+I(K7I8=\.C*I6<H%P26&]F&"NR=4[>W=
+M2)$URJ@@JR@H*D[?-*P4DUA1Z:),3(DX)4E<,NJ(+80`ADX'-W*02M3:DVJ8
+M0J:D"N&J;Y6'RVZN\L`CB1;!*E1DXQIL2L=;.URZ4>P:Q,JE%E.J=R_Y`0`(
+M!VQ,:3!J%H$FH8)OMMO#&1BV#*QD:Z9$!@\L$3P'#4$PT"8EI]Y7]0(B``/Y
+M?4?7OF`],^4B>%U2,GX6D9IY=O*^IFK=4*ZE5IUQDO<PZHO+!49-:*NI"VJJ
+M&E/=9<P,J]-G-RE>*<FXK!MZ[WI#O073$W8S1@JK6V5(P:>X8)/;F3,\+F[-
+M4H:XU>T,G#(>.)+Q573TVQ3UUW'-DXQ0EK3-[AVV^:B09/<IO)*X2*XHRA>5
+MN\)1G1U.ZC'H?7FLBG&"IO51.C4U6/<6N6[P7(&19%W<N:/3<S:)RZXA;6$5
+MW)ASO;=9M/=@H8*2$]LVB#KQ\;ZYRNW,(/`AY+8HV^W>JP<6SN`X6ZG.=C+;
+M"W*R3RJ:SII'=><>TX"0U;:OH$WMEQ)H\U:N]>4GU5F<*GKW9VBJN>&&\W6S
+M5;$BNM]VY>(ES6*L0=[PX[>;N+:/8B0D+-DV)$QEO%M`NYR;","TZD6(ZY9,
+M0.P!$]:6;3JQ+F>RNX2$XBM"S(5V.&WU<\ZQ1BN@H5;8N:3&:@D-%GIZ<8:L
+M=%79DW1FKH;H0T9%B[VD:)6B4K(QQ=EYK>5<-8[W#5YA+>;6$@[*P4NT:.1J
+M79<WLMZ3P[;ES)0>[9ZEM@]U6ZF3=<YDZ53V;S*V8-B[EU&R&B,S+R4&\O>>
+M-;5ON8D+I2VKFN2,T*N^RCU@&QTA'7(8R:BNZHIA=RTB@;E0%V]K&IW%RO^>
+M'V/>_Y/X_YT?PNZ>I^-#G??77ZPY!BK;9X*1-B!\Y8R,J&(>I%%@(^O32RSP
+MG6^8:04.U^YJ,FGM]/3Z*M,0B69AD)Q[O9TXTXM8;,IDWMI+6UJ?\^L2"\0^
+M(6A_/*BM2X&V(T:I4(^<'#*+<FXH<$0AR-BH9W]3G.X_DA:32'ZYSIW0)U/3
+MI=&RTOYAK3U55JHF[U/'9?&\'CL"9)Q=0@%1[&>SHL2RK1*(CEPAF"@:/-TQ
+M1X;R/M<O.NY)(G,XTIR!Z]_09]1_A/32+H&:IT#9IQ?6B+M&J09+T0P?MAX9
+M@4B2"9E[_6D?&GX(7#I_A.I\G.3QIY?PF:N^&*;F(H@`3TTG!F*.3.O644;W
+M>OJ3/:V7M9<E''Q&)7--IC9:L=M&V+9*#&\X[AZT>/&+@]J'M]F28U!DYK$R
+M6(<=?$@[O>_9:3/`#)6/)^_\FE4.I1A4,G<_8'ET:@/CM21AB1!<R']P]#3)
+M0$PL)!)(P4#0,?P_X.:JB(@B2`AI*(*DH3Y@H1AA$H`-,$)5,L)12%1!2-4D
+M2)!24-$$K!+13!24Q!404,$-(X@6E3Y>!@X*3!"E`A$*XBJHJB@HB4_W/&&@
+M&!I9^##@*2*08$A214ZDQ*H988:DJ")(A&"JJE$JJ6)"@*`IBDD(F0\C1.N$
+MJ-^C)$10N!3$CJ]>ZYUXF`2,I2$3),3(D1!%5$10D_MD0\"](>X<H!N0$317
+MHP<1F6"**:AB")D_=&`GEDF:@"8:&@HJB@:>1(O+CE#I!=TD)B@H2*BIE"(*
+M8DH:&`*/QXSB,%!$4E$P5#I3L"R$(.BEI@A99&&8!EY28R>G?2"'OTR^2X((
+MXH/":"9%AA)&0^<Y"9(BJ:&"I6DH&*J(D"H"?<.IE*>PIYI:JD8BAIIB(@I*
+M*%LJ/$EA2DOC+J0AI(AHA_AA&050,B2=R)41+``$^_KTM@X-:BL@)>+ZV(E2
+MU"O_LF\D!2%IRO%`72Z0OY5A)+QYYMD2X/2-!YP[,$#RB00I"I)(,#UX"'4A
+MQLJ#I4'GOU<>WMOPC"2@YV<=G-N?X=C!`@P(';]YA,SP;7N5I.D:JP.@/;&;
+M0#,+PL&N1FQ(RN%`:!'&`(-[@0U;.U-J-GG!(C:D:UZ!`M!D6T7CM\1IF)$V
+M,7RIN=<1,.]4B?,Y)A=&OX/1I@`IJFS9DO,W/+2QEKF6-:!2["K7OZ6Y>D(Y
+MW1JUX!K1K6IZ]*KU"P@\H)I(:"&[IR"JH*"@IEB2F(4IH*0F"8AT@[<]"CTD
+M0W2I6HID-&E9D&DH*6(I)@@F&H*B$H":((23Q^3CEL(LHG`XHAP!#4A%(P2Q
+M0%"4GHL:(2FY8.1!$7ART"GM`/<F%3PJ`":*0B2!E)@H62B(B28`II2@E)*I
+M@D*"BN?+C2F\HKTN-$ERM*A0+Q:)*(EJIBDII#XM21"T)+5!$4,$7ARTKO`-
+M(]P&")1*4#-(104!0$,$#0LU^6$Q(7Z2ZJJBJJI"A/)?($A20"D'B,2U)044
+M4HT%$%5(Q$0*P@0*PR0T$E13-+)`#2ES*GS/.Z^:DL*/""(H"BDB2:BF4I(A
+M*)FJB*0^OXT"&ZP*[!1$D\W,9BHF"I(B"2D(?NPF*("B@:)AH[+`*HAFH2J+
+MG&!$Q+2>3NZ:1#;H.,$*.(33$1505020Q-,0++2)#3,3*J*K(J#`5%@LR[^'
+M+;C/;?<\>GYV5@\CJ\Z'?>/KY=GG<UPK@;0EW8,;>;3NO3%'SP\7C#=-$(^-
+M0E")6'I@IOHUL=WE[1\.-Q-U]"]`$=$#A@K^E]J4_3NOAG&S?QF]*-9[Y`,0
+M-D9[96\R[=74_,%UXATC<RGEK:,T6OE7$BC4J>G&IL3U-B7-(*7U7J!,DP#B
+M]&.Z%3NR*<=.7HLWMD`ZQ4@7M[ZK.UH9,U6+A`4OIB!5^B>0G-;9JWZAWLBP
+MN.$8^>W3&;C@N6MO*4:BB-8J>(>=5'B8OOD"`$,V4#5LC"D15BP$ALW*H7<4
+M1RVA5H6%*WU7(LX5QMAHG<$F[,X!6V,>WER%U;J':<"8G;L6E8NQ1!ZP@.RG
+M-ICNQT\OJ=3!T4Z*(LQF2614LET1)QSAT4.+/8&K="NQ;D=P9V@KQF=X`\;U
+M).1E2I=2Q`V)OX202`DA7S<CD$31I-+2&GYW!.5L89L(5#B5+(02(;F*?8)[
+M9F.?.$#MCB1#N,7*!:$.YY#CGJT:*2(IH:Y`8JF`J"%(N6&D*1BJF%H2(*0.
+M)1-P`E$TC23%%,444$RDA$I(5!$%!!$')4X+(!P"DDHJ2(D@*4B"E)*)"(+K
+MVP`'LCP"0#Q8D*()AH!B)4B*)2IJ8FF*IHI:(21I>\XJR$1(!Q8HH8DH((F(
+M@@J&+]LZ86*"*BA/-OI4-TD!VIBB@>RQ)B98(#4Y)$/?F`45$-%,5>+C0*'0
+MX3`4W`H"FH(HBKJD'PYEBJ(BJ")>=R`ROY(84T(;(7HL&)*29#S]FM-!2TEO
+M8T,01`>CS'@=NX#NLO%.3B*XK*H!M^+I34TQX9E0$R4?/C"HB(B2A*JBBBD,
+MP(Y:`3M'G$L)%60'P&A(::`HJ958+&2#(K%`1`3GC''EJ!X/L`T]>?/U;!V[
+M8MS\^4Q+W&UB^;6.I$])I`]"$!W6(=<IP0J&@!*8"(F8VZ(5MCP5_1/QN@=_
+MLF[VQI%,?5B:PH,%+)FC+YZY<D(>^0`0`8`]F4=[15]9O*.=MT:3^/9DM$],
+MET:(I?*YRZ8T+9L5DTO(YI9M$GPB3"H$5Y"RS%1`(>HXWXBZF9TJ13ZSB;-B
+MTY4>O-NAMR->>F2S>(DB6+K6+HTRV'=T)D:TQ2Y3JVAB=#LY@)=W3OP`9'5I
+MS)K'1^")"$@DGG%2#BV7,L3IP(5%5GS*LYDX&U&T[5-M,DE(:0A;^7*VM(HV
+M]S9RIHV<3P4"E2(0D2FGF.>01K*H[>'N[NN9OKIY6'>=T\''<Z[U-3^&88>>
+M^SI7%/"/FM(DL*XXZ<PP%\L!E-T8,5=ZHIIEFF2[,MK7@7E"&3842DH)D\P%
+M]Y[BC6\"&1,T0F$,`'S-$%"/FL6D("::D89(2JIBA5#O8B::&P"\2@B"$BBH
+M""AI(J4)D8D&:*"J02E0R'`QH`*%.-*T1#02$$014DA,),-5$53240?-H;D@
+M13V(BB)JK*!H0X@0B_;&$@F"998*2B*(B**8BB*0H8(2A1X(R*X$DI"D:"86
+M`I"(&A*2$#PXNI!>%23$+37N30,)4Q,,$$A!0(\19!,)$Q40T44!5$43*4S-
+M%!!143$,4$A0E!0O.174+*,`O%(:"AJ1HF&4(H"$DI"H9A(J6@@OW$J:E"YQ
+M2U+@F2#2+\^HW"`*(F@B*:0(I(@:9"&6):"A@J)D`X!V$JD<@G`B$J))`B$*
+M'V\#(JD;V\7*J'Q99>S.O@]D-/*_I[/$A@"%R*799EA9MZO*XH9SX>-G"*0B
+M$<L]7(T@AYWDIQYP#JYYPH&@)""((X@KL^S??S]+J$F_#@.IF3](4*!$Q="\
+MJ+?CTU@4;7UDKR%,:(#V4<D!$>]=7?IFM5F?0+G/;VJ9O<V]PWEYM6%IJ;.8
+MG.H2]-U=Y2,83:^:HD)4G0D:<J;T*G(N1(.)%EUD]E8LLJV[G!*D',,O+?L4
+MY<@=_;$"%$;H$9`](^@H"A&;[9,3,:!T47QM%)W&R?6,$3S(U51%]7G<H=^,
+MGWK^6`3JPH>0FBBHF]J0R(:I*AHI(@/3`9"11(11%$E(]T`FX/WR8ESD1Z`1
+M%5!$E(11,D14E`R10S$$4E%4P4#4Q)$4E';*)H`VBDH3`0V:"2F9(DHD;V<$
+M,/#`,I)!#02R=_DX";TA5`Y%.U!3%5%)1,I*SL)BJ*(J&FAB"2")8*_'&*B)
+M"2`]0]@`D\)RC0/0""B:)IK\=I**@D*9I*I""B@(B"&`I5?UZ^2<`3H+)2D"
+M1!$PQ!0<2":&5=*%!!21#%2)1-2U34E+))0242S%53,$T,?7Z<%0['LR&][*
+M%`'IB`H&A"J6IB2("(J:`(O/@`:5(4=24T2WN3"Q-04A413,I0TA!0U,S%)%
+M!2'ZXTT2H'IIH\MM&#;)8*=)$&C34(/%I920D*::$HJIA*%A("(`_4R&@I8H
+M8HD:@<\[Y^OIQVX]WKAOUUQZZ@=DP,0%(M%Z@%6A$5:)4!3FB@C:_J*V/"\8
+M)ES"D^_*85S,P0U"&?P&+(^)#"+"Q_P0L"%F.Q.W,J':;?"1.I%,>0J"AOQN
+MG3IVR3#LURD0S:"\11\>MPTX&]>+AA4PXAI"L0WQS=R.&%(.0GAFW`50CV^7
+M`VY7=G@\3;F>'6I73M!&(*&=IU"8*+AI`[L%PU;>6W+=ZUF>(%<HC:5$##W!
+M11.J`P5Q41.\Z-D61>I-!%@:@C#((_H%.J$%:VT:5(0W4<Y-OCO7L]A]=,OU
+M'D<@B32:"\QU35XY47.D-)B>8:;REF^MQVVLEJUD+*VR&[T;QUT.O.&>'T0(
+MF''"YD'A9'N-($2_',<A(7]K^G^([2H<ZN`7*1*T%$A*1%#,#'6=FM4%!,4/
+MGV[=*B<#*#O0,13%1`1!!1(4D-#20DEW`::H89H"*[W"!"D"%*F@J)*%I"(J
+MB(:(O/MH0._GL/VG(-`/I*^,&AI:"OPV"FJJ(":28":BI2@B)@J@H(G\H71,
+M!0%4LM$?ES`)Z!D0Z#,!$0%4I1$U4P4JTA(D4,21(0GF3%4%$IR$60)!-%15
+M!"R4M,!%+!+(0$A!%)#(4D$E`4-`>>%=2M*NBDI*DFEEF6F((B!AI:B:6:"@
+MB@BKWS*$_$4.%3H1(WUET!24`4P$@0<D6#!/9X`G`(6@JJ:4I*:"9*2(8J0H
+M(-L!%2P%11%110$41%*/T7>L!5%1$444,5%!1FT%-%:U%$8`/I=W"&F(9:2J
+M@E(F&1IB%@@@@*:&%[)I_#I;Q.^1C=R=#P\X:G/'F,\Q.^,]>,"@:/@A8)I`
+M61?\?D']P/A$';S/G+S_/U2)D?+MT^J5,VG6##:-J1AP$4)H=4S>8VT'B7.Y
+MD(JZ'[G=$XGHWX*NN.Q1'!]2W![`-(SQFC@;6;>FAZ(`PY5G`OAX<7@XL3AJ
+MJNP=8TF092"VUA"FP2NO9FDVXYG"Y="5*28)!F@%3;J6MQWF9C#:0RKE#;3G
+MGFD<K8,L+K@@VB`3P;;286>S#3!!JH.<N2<0Y88@X\72-=-<]@XF)7EPYKGA
+MV;5V0T4A24!24%-4T%-!04A0E!04A04%!3\4Z=P&]MZ##%!Y(P(?;<P?-*=L
+M;$%,0LL!`3$2%%40R2S5+,!Y*4`,)"E(N(DIB@)(:JF8B"F@H4DHI8[K""B:
+M*BDH@AHB2J28.0(_)M#]\KI:0R&70M*=0EB8$I4J@)FF*%'(LHF:*2:9JB":
+M:JA*"&I*$D@J!B`I`A**6Z7/[[G%[-14'D*^C0\'&*B91>`#QI****I"@B"D
+MJJ@DAI*1E(DET>S8A3L&"0`D&E>D1,22T!020TH1%"1`4T0KH[A,J\$EIIJ*
+MFDB6DF"DE@:4DBI2J*IA4RL-`.BB*HJ1JEJ@B*"BB@@(9&&2FFB_BP&AE.0]
+MPF4:5_B"ZM*0$D-55`S04,R0%#002535`53,TQ!#11$-^D(]$]P`&!#J')]W
+M):&2)FI"O,IA@@OUM&VBF6B"@F!JS<VK3/V]_(?+IWZ>SUAN^/AX>O3()=("
+M'4H^5N.84>2%5/H>WS#B)H(`&'``P7A^B/?U.L;5(L!/]I.5]%$"GE94&7DU
+M9D)BM(X8-K3K4-3ID7`F6,-4*$W@JQN#9G,E#MJ?J6(E*`K-8_#9H>6G:QWJ
+MI,*AUWU.A+AXHXB>&.`S`9"?9,"<3QVEV9VC")SF%$`'6N-D4$\D.K<:M8J5
+MM0XAJQ5SKN'-=$#1S#SWGE!$)CCB%!&8!TDR#68)QRV#L&YPB=EP*2#Y0[,Q
+M().W,2I)6I*8$HHJI$?#P#ZD.50H=2BE*BHAB2EFAH9("0F*JHI@IBH>O'"E
+M66$]K`?9\>PKQRAP0/*":6EI4(;9=4Q2#++-[C-#$L/($E($I`T"0%#`00DA
+M+`1$2A5*4A!!"41$$"F0@')-50U!^.RM(010PA"2$0Q`/`($-$%41#234)%!
+M`RU0TA"W<Z/?>`D2+1QHH2DH"D*0I&`I@F("B92`D._''@=A/G*:@2DX3ZL5
+M--50$10U4U(4TDA0MW8:!CX_7(G/1*.4<2J9(":)IB$H*&BHF6D"BB@HHB4H
+M*"FJ\O32O1Z^+3)E5-"94]!5054051"0%(114P2$44M)#`054TA(%)U\.=M>
+M:[<;^%];]_*'&FG?R*EKRB:=K2T$C0K!LRU@:8\IAX^;$0*O`*N<>0P[D`CZ
+M_>:)GW"0_W^G$UCX1"O<#,&>D5JKMJ9"IB3<BLQ^4?P/8ZYC>^+HP=$:XC>Z
+M0BB<&[`CJ^?.LR=&YB/EW5J\:GNY"FCM9EF_&VN%(.[8[!.+0C+H5)Y,FY50
+M6=#<Y5S=EN0;C.$DY*1R6&7(L2)ED5<T"KUW.X\&TZ"<A7M*S47&.$$(23(,
+MU9&W.^L`?/+YE/J:=G!B1OCC[ZJ8^]=@"?N2#TO%32\0AD"HB@(7F`RQ41*D
+M40%%`4@?4)V#[R\YMHB:<$N<">*LDT1!4L7Z8T4)521344LDD+(%0\<J0)"F
+MF0F@F:"D`F:J864_6,$%$U%)40E$`<%80R$RP4%,S2E`,I0U53*TT$$2$$T0
+M54B^@@X^HK*)T2I*H"8B*:(*F(IH0BDI"I&$^TISBNA7*=K`G`$J`H"DB?QR
+M9HB*!DD2*JHHH:%?3XODH\@B"`>@$M5%25H-!12'VQHB%H(**)FB2A2@+G[F
+M;PG(C!(`H'<H(8BA6H8A*)2&I")?6$,$!5%14+Y.[C9'A%@#<98D:FB"8&)F
+M()&*EH1V32D1+#10S5%\8>]5-,KT8H"":2H"H(J"*ED*8B1@%4$HBP14`613
+MKZ=>/2W33M;6N/?Z3?C?MMY>D:/3IF`6`SQ6;9EXR51*DF7H93$,2&/"!)>D
+MSF=+X/H5>PFRU5*XZV-KTV:^R"5B5)$E2^ZBQ;+<)(FWA3DLTD"-MT#8M1\J
+MWG%1AC3-H,LU2L\>,I092-$FU,R?7DZ'SZD!0=!TE1X&+[LE&X=L@DXKDMG,
+MLM)2(`6S<J<(Y%-%Y182F9DYBMXZ4EAZ6+`5[>39K*JE2QBSM!2&C>\24002
+MES"B-&X"2P+\8A^9:4,A;Z\Z]/C8\A\CSK]PR@<4E\%2*F*@AH9*0YR9%%4,
+M!ZE.B/M#(]`@HF*&D*H)IJ6B!I2H(B(::I@%%%6&U$G)+E#,)'`%@+65%`TS
+M)"/G0-5++!(T,PG[H-2RTE+++!0TG)3Q/(:0#"'09J8B`JJ4H2J`DJHBIJF)
+MIBA"!@9=/$S11.0TAQ(JJ"B@HFGZVAJA))I(BB"8A(>N0Q::3??9?D3WAD]H
+M!'H78Y3$KPI*/-#OHRB:B@J@8&@(F&(CZ]8*"?083`LL0]&EJB2EII6D*5HH
+M*":I")$F+_&<R)/2$PG.N*IB`@)FJB8_#(UIJ@(*&F@'V^8@XL#HJ0PPIV-4
+M$6DQ,8D:4VCI+PJI30!WTQ%%%6,NPY0V5ZOD;,CH,31;&9(K`9-]V'D%"15)
+M#0I$T!^Y@1D6>:FAUR2OMB4T(M55J;%,(4Y(%0+")Q*XBVDCOMK-AVKQ7_3`
+MSDD,_7<MZO8_#;QU]=H8]-/0K/UNELX!]?X?,?O'ZG_%[Z!]U?'/R?Q(`^?7
+MXB!'&(6;E])[A#WYE?=P!^)KO[JW?G'O9\^OGY^NVEY#C^>^G^?>_OS]?I#J
+MNJ.>[V?GZ[\KWX[6`-_/U^/Q\Q?D^_/Y_1N;\!^LM.V?2NFO/1#'G[.`\(P6
+M=*($J:WM""3`G36KGK%`-H5#C><(0YH@\B1'[0^T15B'G?Y[ENV(%NA@P%$Y
+M%BOQ7-XO._OD`D5,Z_,$9SUX`B@.>,1;/R7E]K9]1_BIZ/RERCZ&WTWB^4."
+M&`HL=K7BZ-KJZ)7[&<^2Q]*_I!2$7XF0*#<D^:L8VP2S]QDA^-.CF#:*B""2
+M3(3;_H2:#$CJ*='$]5:I3IM/$ULZ:LB<<*7QLE\]@`(###@M4;6@K,U6K8%9
+M:#1<,4JWGLSG.,SY_`[Z_HU=W=W^?O\]@_HKJ4V)W9Z3Z'_0-1&`/>+)*1"3
+M]93,OP6B#L.YY'SJK.P=51/L[<`>1U]SQ/NK@3/7B7"!-@5IO$+W+V4W#B0&
+M"PM;+@6%42+$"T=P0,X8UA`T;PD2&4N6N6P0)F98!+8@PL.1$(#!#Y(0.0E3
+M,#H@=<0M%96-X!"B&V=XP!(V,'$85O2Q<X(`=,0B(B+@#D@P,$5-<*'2@!P`
+M.0XXY04!!3HQ*W>6A0I1RCH`4&`-60!!FI"*@=.4.IF!C!`LC&*A5BH"HD8I
+M6"'D[;B%`,19K((J^@3QL:,BI"V<@78QK$H`T=T+'#W^^HDZ1;V'$#!R<0!"
+ML``P-J`!/>&,DSOKIAA6@8L30@:&5DUO1*@$_40/MB5.JVS,C1(.5`/W_=^)
+MFR=G88=3(C2$G-S;G;IE.86FEI8&PR,&2,`L901?<?+/>G?8]?P\/-[X?2(O
+M95`9!!`BO2(01$&`""%$1ELC<PUHK*U69"O%),=P-7=\*`!/V(A0+L9>98Z)
+MDD601F7L#%F1X5`0?$\&-W5N54]=T,),8-NZW&6$).]!,=OA0O/'TH@@0!A8
+MR#SSV5=:2]EW+KP'$+R$:]I1(';O;E/WN#M1OI<N-<S.=5L=?*[FV\,9,405
+MM<;H&].]-$,>$81$TUZ\S7R4+V"K?A`]@@#?<;P;5VT.R`9I%`7JFJ:;(.WC
+MN<0NM2=ZD9T>-YX1Z?9XZ?.J27"AB1'B$<(K'(1."T[J\%*B+$U=`DPK]L]0
+M46=*XZ""07-2M8%^B%<6.V8O=;O+:'56$>.7=5MUB1'A`G9':W@'<U8D%U?4
+M9E=`&2].:J&N]I`FS)/G,WP#S@@*",?W@`=7;\.3Y;Q0J2I4K/DRY537#*S%
+MTO'3WK5_!ZO*_#2;!8["_7Q?C+BI-3PWH%&+]W7F^ZA9@CS[%U[%`<UJR9+T
+MVN'7?A&8>0,GU"+&X>M<98)HP313'.5KLC$HLR5H@(!;U\52K)D->[V6K4$=
+MRZ&#S\6@2%@.'T@-DG#1AQN/$VB.CUC*0W+REYBC-5F*E$[DI39G:WT`9UX1
+M36BLZ<]GF/$>4&YOA/=N2V[:'G1R:4\!/;E\9P3Z+]7B^O5Q&/JF]F7+;&/*
+MN!)FI\(%[>U8)XO37@LD[.0`-TU;6:#3S*6^X/A/@'>;;ISXUQM9TZWF*0#H
+M8#F2*S"*!PD*/6I""8:NO.ODEMR+D;([P('?Q?&"ZOSNNI5<](:RE-Y3",DF
+MA3B=!NKO:U_&:5\<25AJS$0J#['U2)F=F-3F)Q529$C$4#/3N[TBY#T&(BQ`
+M,"&4AF=KT\A5*;O::MVI&WG'=-K,[2JOAA$@0;L-,TZT%K,W!.]PZEVRV[J7
+M-#G=ZY6+%9U8RSV(39`%"$4(LA)6N9G>1$1&S92YAM#<73LWWC0FG=X)RPYA
+MR]FRL[J&#CJ>XVJ34$;FZR<4TFR7EO;!ZRV63:J5)!?/LMN9GJ%*7/=$,UVS
+MFA91Z=WL)H54P`-QHO8XF>MYQF=VNLJZJE/`AJ[W)VI*YR.:#)!(X+`:H[/2
+M.&X2:2G5\BA$"QX'--@Z8312!=[()%YF)+TI766%M68%^Z00Y$*2<5C;O*@J
+MFS()-_('.ZWM(JRLX@;)8V])FMMU!NBJ#(TH-+D$ZG)%V3H<"`%[&3X0U/BC
+M[BAQP1.^76=FJP233T.HB(`$/V>WLJY>*IEZRPS!U!<AB0#!$F@85NYI2VD%
+M)E$R9,LM^B*,145`JPKN2R]4DK@75E$,BB3R]Q5[8=%1B&N@<5)Q48NW(&R0
+M!9($F-M+XHRNKG"!JYK>UK:`%(O'RE7L^NSX5ZQ/H$2[NPVS,^KK`,1,BKKV
+M)YR%7YW\`)`'83L',8GO(-]6(^KUY&WBFHS#X1*!0BN=;HY`H>,RI1,4PR*7
+M"\JUA!I2+0*,M*-(V@RSBJ9;;9B4A:"#:%>:DEW3)-TL(%":-T5@OE>/K.B7
+M@5^B.,""0,(`C3$>[N)!/E41[#)RB2,..74^H=NB[56E08VI)()#;NZ#X1"D
+MWU&"R=*H$(>[A[E28M'#QH,XPB=FY$G2$49N3B4CJE:JVT6L+JD58J3!R5@!
+MFU64P9-N$`0:2U)%&DB9>;(V[D;9MUB2*P#1L<%DIBFF;BO0/,DH68(GU7LY
+M@$!"CIA`'I`@>3B_)#76&=N9.-GC(RU>(FJILA%`EF2'1.+95E5Y.99EB7)0
+M;*C6#6U?>`&Z:[@VE"E'&F>%.I]3F29*K.\,[C.:#!()\*(V0@"_'/3E#R&8
+M=E^D51&:"N[>K#KC%I:X4YZR`B3:J(70V9#*QD+I:@QQ0QH41EET:H+WJX`"
+MJ[Y$`!+K]/?-NJJORA$`1$?\>[N3?.EWW)#OU0I+(HF\RS=Y*O%F9<T9$HHH
+MZ;S*&:GJ.9JV[N1>V:"2L@3;:,G<A$@Q/V9E3G+NI\<G:.QVV-I9<Y(<&U+4
+MI\;M#D-@JAG6*`(@1%P\8"GHO+@"MB+F(@3,",DY$9UN8%\>4)6O.<.*HN>'
+MBJ+QFD1QC'%)"4E$EAIG;1N_W%S2[5T.<NJV,JSB\Z.VIKV\KT3V#CM4K#E6
+MIIZ:FNWI;Y33J^T8YPS-,2*MY>B:XCA:Q#+Z7<W8[@,.=5/0K4.MDWNU(RJ<
+MA/*JU3T4AM.\G01V6IK1=N4)V71FQ.;N(MUFA;<Y+W-5\GBHD=N3M8S68+,2
+MZZNY2CTOLTX$.QWF-FW>LFC?5J&7G*\[KZ]JDK&WNF15.R:VJA:L9V=FU-]"
+M",W=ZJ6&9G5<JET[G,6<O+2>8W=3LOL3=BR=T*JC>M8ST6I$LX.Z:Q;M\;J3
+MUCFDP=75E0)HS(W763HRA4AB0>H.=G`]&=H3+=5<S="BB$FB1-OKLJ>G"-U7
+MV23M;--IE&:6&TFT4<M&ZP\-21QCFMLTP<[`R,(O9UI#CWKJ^/$CTKM.)7C&
+M8A%%2:G$(22"H2"AIEAD":ILA-ZY$G.G>IDTA(,F97&&R@C0(ODFPP4`+`C:
+M..^1WB[NJJ\WK;,L/)!EA($C8%")[K*B.H5-\.,YF$(IFV>+5R+FKE6!AOED
+M@[=XA7!.V.%]JFWQDI[:Z65U4;PH5U95;>#,FSM+60*<VK&<S+XZ<EM4\$ZF
+M+F7BQAW57<S:+#I9-HYMWL%$$(ZA8678IHZ*5:YUNA+-7%"L)Q,33E4%M8&S
+M0-ZM9MH.5@K38W;V\0R3,;U7>K+J<-9805Y-!RA88G"*$C&A1-H48`HN+4$I
+MET,M*DT9G;&N-#%5A2V;,8ME.@(3X00[.8[OQS*P_'_#:V.]\6N)T.1*E$86
+M8,1,@B:T]&25JN2U+(T$%%"$=6B2M.7Q?S3%VJC#(("?685=*'6@DYZ\UB_M
+M]"U\O5:7O*N7L634F/7W\P^)K931(]OXU<NYXZ<)K[8QR>XG@,CH#QH%Y;/*
+M&XBP_E6HL7J$]$N0]Q"BWGH.>455K]\(^98A82"6$8S/J?W['8-7J>.Q^#6R
+M-':+(9I7=D6\YPTJHEA3#5+Y5>]PN)*YP/8DIETGL,7FDA>Q/(I`DZZ.CE\>
+MDYW>,L9XSW)L8YOSJEFB=FJT7>%W40Q>JLH`L:<-=\USB&'1VT44<13KV2LO
+M!E4+W+(O%(EL-RE:W4+I!%K&G7N7]UB[01!LA,^SRE[=@8;GMVLTJ(`LQ#%D
+M#/^'];P!\D02%B)33`QE4,V342&'*]:7!>D#]\YQ_-Z9PH7BD,1N6'Q@.6WQ
+M]`[!%)2L1,YJHJ*]4)46"*!TH@.U$AMI>U(._?&%(4D4-4%)2)2E%%045%!"
+M#0Q-#$%#0)2,`A+P.DD2-,AA3BP(0H13$0PH\_P,X![8'HGS*:0(24(.;45$
+M1,LI2![0AX"S2-PP@$3033`0$(;8C@=9*^$[T/)Q')W)%.R3F[[Z<-5)%%E_
+M2!0Z=#L7)36"B@VVG6V$$/]KA^)4?<G7X%A,B')$/NE^+L4D?&*=(16SII#2
+M&@Q);!11I"VII'2FD"J2V1Q%:+8I6HHBDHVU+05D.2A9D#('.4YR+U+X=._?
+MOS_D6\N7&/XWKX;]$SZ,Q*$DGJQ),8E[3&&41L5&]J;24)QE>%B>9OIWR@8T
+ML0DSOXF72-9>3Z0I(^`G3,/TIF_ICN*/-7&R[R?6[$Z7HIGO5N5FE*[#]-,5
+M+VMMDEFE(R[F20.?"=696"*[S9V6B.T`Q';C8GI-9_*![/9E"![Q]%YNB7/S
+MGJLL3\9:K#>5/4G"2VJZ1TSAVB0PQ19BB$1\MB'N<)L`5YA#2A3I36V$MG.]
+MW56H9P7>A4:=V%.TJ>K)NT*P4T99=SXL+4&3-)HPN4W5-DT,M*:O>FTDNAET
+M"EA934TZ@]TIYV^<//)D07/'(1,-ZM%B/'RA4W"V8(/"Y%N8.R'!3[R$,/WG
+MK@PT,)HF0`/-:A*)J"@"GYE.L\\+!$1#!17&L"G#APB:"6BFIX;3J53[YX\(
+MJJ2(Q4.D@.]LL`G+P\FDWW`R`D`^\WQ=,*&Q&+SG`>R%/%QFUPF`<6DF*!1P
+M!?$0O7'5(F=.TTAD(H>!GOKBJ]EI=>[)68XT9++:CPM4R0+RU(`GC(1I!Z^X
+MW84T=$,5\>=F=^=,V.<=/&Z]:^I,1+!\WFKPULW;<=,[=-CH3:FT4#MVOI.E
+MA-_Q$16H"(^>V^DO6'R$_$'5.R*^*R!`P_$IF?@B`O<$R1>;-5Q2G(BMP8T+
+M9C$9;>;LU[6UYR11PO5[=]*$4M,\PQG?308*(,&#HUK24U#7+IFM\Z8.C229
+M,<<6H%-2,2O;,0($YDNNUQP"AA["0$P!A_:@)`GV-@0@``AE`#RZG%P`AX\1
+M<524-B-@A0\LJ[>_)EX;CJ6320!XI:4<)3D;.%`IUP=\ZC8(,!AI`/-`=FL2
+MXHL53OLDN)<B*:#K@$\8QS[L#CGD/*B0)J4D">=6S$(;[6\;VR[%H$M[^WH;
+M^?ES1:20']#\._4'.8.HGD9\,FQ1(LA&(`QL8E$\QAH\3NL"&X2B<CGS[^0T
+M?8/#'9>?7Z="15+&'\BX%GW#<VA,V1,U(Y.^S1<IFZG@'5:/7G4&*((I:!`&
+M`"`-9K0A/]SLU\MCY+G$OAGK\TR`!N1711[:@V:I:,44+[AT(1*A',JGQ"*\
+MY!&+8^#>;A[^]W\<^I"O89B9+`Q(B?@'%Y5'-F:T3;(HTRB25[9A"5A]_QYX
+MJ>?IO2\C(]$(`A@&96>X??=#!UA88E8AD?OCT/0JH:=UE\F/9#H(8AD;I.(S
+M*GG@Y/*5P.C+-,@3`DTQ,3$_;`'UW1Y%1`X?&A"F5AE'K^[KY50E*3VP8F$\
+M9)@"9A@9A2&1)IZ\#2'I5,5,!A79D12=61$C<PB1U"BU1=JT1Q2LA=2Z3W*M
+ML'`SF1SC+BB+).<4':H98HN=TS\SQP!(6J$UTUYMI?%?+_I]%`MX.$UU[5SC
+MTM2`\-6E2RA\?4NI=&G7BZZO=.NAY7).Y=9/>K1PZYXS[<GTNT1KU'=%5GA_
+M8;8.^6%>HJ2B)]?.I%1UG-'1V>F*.*5Q052;?#>^>"Y3#-#"AK5[&@G,RA1A
+MY!A*0%`(5^9&D"(10HI$8`KL&"D1^T.Y3BQDT41#MBB(&-D,GP@VEX8=X*4B
+M:!H*2@I8BE7U(IH0I6)*$H!H*&DH:1/2RG7*';*IY)0RW>I;"*;8]\'DT4EP
+M4($D/PE6E,28JJ(TPO?(G>;X;A""=9QH08EJ:0DGDD`YMV'U9;>6=MI0$N@6
+M\IF`37Q3*"?*&>_F&B$*ADRC-\F:-2#*H\2\N>>"!V(29XV@2JZF_6W'-8SK
+M%S/-1E\&%2^Y@2'8X5/UZK!\K],SZ=U'9JJU+1SX$@D3B&7ZR!^T":C$AK0P
+MYI]?0(@3KF#:7\YPT3==]6/KX[IU)NIVR)`\"39KP/(.K\_;XOGZ<33MM%M&
+MML&K;!0Y.=RF13.@P:53(7,FVUZL$Z0>H>E'Q3NY:D6II1?3X]:@Z6+YI$3O
+MDT-YX'U2J:@AXDRE%.)Q:A$[@%/)@NO#$'S!!H#!`P0,IY+@'PP">KU8`>;K
+MP%U>8])G1)15%Y:_$TB;27U$43114%(6!I7?//TD[==H4"D2D"A:"@H*1ITZ
+M@+""R!D:7\,>7AY.W-Z]N^?E[QAE+FZ$,('\?<<`Z6"(V$']V,+Q_C.!WIU3
+M\W%'%-?;\>R/IK)YF7>K/2Z,\[;&W5B-V\_OE)#9HO$$#>TYOYDC01AB1;LN
+M=/=K4K&OZBZ#0]5_7P0#"G+R5?63MU!1#J1\H5>!'?Y<)'`PC9^AM`&99F5Z
+M:<RV)U@D5"XI'SWV>CN1<%7$SN$4=LQXVP1$8Y&"DUZ3`TLQFF#XEL5W+S-^
+M`3SF&"I+6TJ&@%_.P4%[,AFT,L1=-=D*'PP;3%O83C4Q6,I0UJET8:D?<*<Y
+MO]PA_24U;1$4%#]+UN*!TO*"F\IB!`NE30`T@E*T@M`E"(T`0BPK0"I$`4@E
+M"D0)!"D$HR$(E`E*:4U0I30CH1Q(:*I`TCH=%"4!$BQ*Q*N'`:'P@0W@0-A)
+M0._/#+.8*0[<C"L4?"03T>G!VB&"K"*37O[O@N&)`30TRM".OJV]737?R[>[
+MW<>'7W)K?:I4Z)3E4:E-F:VO8MUO`PA%A>JPZ*6SJ8=6'WCJF&&5^T<7$!1Y
+MWO?<>_R!IDSD(?IZ1E"\2_?-52-F5VTN3-LGZ6FE$11UJ4N>JW"FNDA25W3S
+MI.@O05-2!`@=4Z,W`G)DR1D+SNQ+.)I7XSN"[GWEY^)J$;Z%N(@EPMSV6;VR
+MPB$02BR8,B(S18WD'O3UL.D\0DA)`BD4EAHC6*M+7K9N2S(HN=[VXG7XOGQ@
+M@G>)>>-0('GC$)\/9Q`T+'I@4WT)B4)(=Q@CP!';*FP$J7`N"G24%\ZVC$!B
+MH-E;\,8.$TU@O?";C/GVPEE]'9FN37JG,QPDJ+4R9QY]//JZ>=]:L'KURZ7]
+M<HO)!SKN;6#)99*2GP@-P+?#T\M@]+L+V2(<Y]-NL"3$WO>#4CP_);BPT_/!
+MP`/5<P`Y'V:Q7*@H,Y2M4-$K)4>?J>W,V.FM&F<[))KT9V,`85TDVDE(%=UT
+M0>-=+%O?=`J!!CRG`O%%U$I`C:TM>6">6&>-6E[I/EE&[,)'R0V4ZWXF#W))
+M,1%7&+(*D-F4@][-`<\N/LCLGU.(^?,O"C=X')^Y-CLJH&%T)V!`>)P@?I<^
+MFX?1#F;9R+,#&CBGB@1&F(1[`%'L<=!Q&!!"AH@P-VB@MKB7<;CMH(JJF@Q1
+M59PQ6L#.4IS[>-;U%Q$DDS$Q14.443QRO[,2IA:B=LLL%6[>=C'5\SSVMJGB
+M&MPN;^%2Q9*I60*1#%$*$\2^7B>KK7AKIX:8WR6.1*^D)&:F?,5/5$YB8JJ4
+MY-VYUC=73F.Y<R%54H9TXN(+:;,Z+Q]LJLPYO.WI8ZS9ADDI\IZS"V^'(==E
+M,WM2*Q8.3/"W%NB\P&S,]]>T3/DQE;R4S1=S-3G"6*GV;V0^VF\IA<]=M.^V
+MS<H"]NKZAW;W3=VY'2LEG=73F(YI=RA)V>JJ[BJX9.F[D.R]&:;JE9WEU$AF
+MLS%5:$;6Y)GG>LQUMFZN!J^,L6_L22`9S(18()LNOO[8-.V'.V]XU-Y/92C[
+M=["<X%A`NETMDAR>VOD+%3,,E82COZ[PCZ5B)-5>G'(IR,>#Q1BB3W]EF@#B
+MU#S7V];IS,X8K#Z&S=#9T@O&68(3,<.K:1PDH8,%118`JDK,=O3&69EC]`T/
+M?BJ2C]\/X`9\L]1SB'D,6"RD+'JX>?`K%F*W)@D0(E^^3"GNLQ21/CDD?)))
+M!J(J95=;6>BEQF))4CFJOG6J4SW:M:L]TU#JTDQ$4).U+ZM9]1\D]=:*C19%
+M2O-V[<]>VKCC>37=TXS]EK-ZY\-'C8XIDVSJW?)Z:]>&UY%DBCHJT("<86T.
+M'M6"LI>_9@'<<_1_.-$3BE06ED3'DWO)ZG3ZFJ96@71G7<0<'<\2NG_9Z*<V
+MDL(^9[KP<7/I?'R-#\1?&#UH?1=\J0Q51$EWCC8JJ[?@W,/*B>1,.;4Q'`VB
+M2$IJ0D%<BBB%*HRB)3;UQG0CCUNIAHY4)@'1QQZN5ZK6EUNLU44+)2B`G:"0
+MG\"K$'^14D/EA_X,Z\<=BCAMJ:(8RQCGGJN666667Y,7_']/N-(>.F;:)T#A
+M9OB6Q`\DY)F5F8RE0D8ELF&,%PDQ!+B!*//G%P)=)!M:P0$0"VM22K5-9-!O
+MH%S,RQ2%!Q%Y9-S'H&:J+$LRW&QNP;K16B8"2R[\+GN>"LFK"WI<"=GK+R0;
+MH"S6"@8F!`=AN*$=0$6,YBHFPJ@"`(X*^$`0)J1P:XUD4,`M3`$!MC)$NA<0
+M)D2,P8ZN`XLH"5>L7D$Q&9?9-G2`6QD7ET!:!O8F5(T,%R+`YGLC)4`1W1%:
+M'BT#=ZICJB.AJP`QET.$]`A@38@`*>N`:%9T`36=8R1P$W11B^O7<+>#C8D?
+M*G1&T(;FNVV;&[TQZ<.VZ<"``<NB0*'-50+ERDP90*TP`S(AI`-M9,](!G;,
+MJ%BLDA!-_U@TOAJK=;?%[\YOH*:0.>>,<7Q`F)3A^[7,3O#EP[*;AN;[[G&P
+M(;<$[)W]J<E=N(4">!4)1(5#KZ^OC9YY@ZQA02.!`",@A6("L&AO)2-WJPW"
+ME*CRK;S!BS;JKS;<X(L,$6)20*'BD1(+!DA`X]U6[MZ!3EF&[-21:MI@M7,I
+M*K0N4+6#N=/,S;'(C$07<X!D@5(4(9?%SMD=I?4*H`C#4XIIFD'+-Z\ERV9H
+M<F1)&M@OJX2:):1+2.X:T]T"FH0NQ,YB`6VBGE5?.9'=O<#8%!6)2H@A&9RE
+M35-V6Q1$D,'LIYS&2-I$%%2=04AMDC"@R+L3*VKKD+P32!R"($*GQYJW="35
+M,@J4<21:#?:[GM?2*#"I;4Y8RX&V^[;JK%;UC,[@9!VW<G;;NL<LG%!9U$3)
+M",G")U!9(&#C,44N.I!\E2!+D,5UPG89@B4L6'B,K!FUV6C>5.L)A450><Y!
+MOLGM8(OC1+>[,V01>!2S#GG<7K'&XE:`@0QB$@R9-KB.ISJZQFWI,Y05;J&T
+MCRL77*\J;"%(=80EC%0LJE6(EF1+S.8%WI("G.TVJ*(*".++$]4@\IN55C+D
+M4+8RKHTVDB$1ETZ'8)I6>V<[K'!721!4(7ZH:)*1!1'A.7IZEDA!#LFZ'AIM
+M@I5D>+$\[G&C>9,MO.,M90V28(TWKW4G8=69>,IS,W(LT0?($C"2AM#VN%6>
+MJY][<HDU$ME$++6W*JB1[FB^F[I=;DT7P.=QSL1P@IT)NK*V0SCJ*FB'"<OC
+MTT+)Q4%LR%(9HX4@C01BMK#E'<>4%*!V,@9$.9[76"KG,R7O`R)[B#>'M(N[
+M)M$]>41ADD[BP=;O*`P$!$'7F8PKDQ9(HG,[3@[+NXJL[03-3>O#?)TG=VQA
+MDR2"002=%7>"J$U=*<OI5N4SDFMH\+'"L53AI3@V5-"L.2$IHEH5W9))XCI'
+M%]5+<1RARB5F6&TQ>D.2E!J$\9.S.DW(08N;-]1-+IV:;+ZGO=2TB[.3>B7T
+M1`$$E5<A2,:[=)TB[G+6#32A(GLHMC%V+ASP<:M,JJZ9TQ=$$SB9")W+K4>$
+MS-=NT$0GIEEYG)XJ>98D`'7C2BP>U\ME*R4=\R(G<S'+O&$'1]CLV:`P6[-G
+MSG7H&5-S"G)E^/+,8ZALD3UH=7`I5`%"PO<!`&\.T7L&6A2@6`(`*]-#*`DR
+M"`>D2&/8<'39=E3;LCMS:(;6U>9%7P=(1)Q@CF2.3!(E((I$$`;,,N,W'SV)
+M[=V(OK&,A%E107!J$@$,AE$$R6X,OJ0=9*,KDU([D+H;)>\ERY:',$XT+5RR
+MID2"P0086*1<T)BM:W;G<91;-3CK9BSB55I>ZA%+'#15&]J:RL$QLVQG(Z*C
+MC(XS9:UV43$T-JKIC9S)`L2!T0!9+Y6&+)*S)6S(O<B).;RNI.G%?;/<"3$G
+M`Y:!XN'3"`*4+ADC,RZ`Q6-<Y)>G"2IRG0EBJLK#S@W#FD)(<J:0W;G&Y)N[
+MU-6QYJU*C;J8HL7%TIIHID668)V2AA<C$K(P=*S!@YP(`H[&U>8;B%B*EC+(
+ML@S,\FUE3>)LO;%)*Z"8A8TYA629"UJ\+ME)$WRN[M+LDFKH7,5(O@KD4*72
+MC0-!:6#B6(66#-B11E5,M39D*I+TF$2*%U4@R[['9[IO*&QVMS,F\J+)F>$W
+M6R#+B=CI4&9$%E;(N^LB),7NX;D+9/"YD;)LA);`@=RR:W)N:A68F12:0H.4
+M3<\DR4T,L4RLR3!F.)PL7)E"C9G,.6U-6670D.18E@LJA3DIZ*'L`'G=[Z>:
+MJ?2*HD++\R5=%T[&DF4CW&+JJE0K.;4RT-R6K>1(,3:8V\+[.`DQ$0C`R@<7
+M5))10?/I4@PZ2Y9>R8A8"JPY>T:5Y/\?R_;T0(%6K@H_%]3,_/H-A"09(;=?
+M&*J\(*9$I4ZREE5,X#C,X51C",54YRQAJ3DY8JKMU..K..<F@29QA`S@PR*L
+M6Z(DT)F&<-Y.9F6CES3JS9,V<N[%W=3]2+8DWF-DFY!FT.I&2#HP4!,"1T!B
+MX&%P&ZS*K`N@,`Q!B5F59-3)(S[$"(_:0/DK'??&6?GJI"[Q5:N78=_&9'5T
+M2.:4J%7=-"Y)G>J\Y8H-5=6:NTT>B>E0[[7W,YCU4ZN7(?2'2D5PW*Q;TC;K
+M-WJ%76/*R53?/@-JJPWIK<Z;SDAQ(PZ\ES+MW9.9=3(7;;-]SL=>ZR\HBUAT
+MG>1[%1BBI&<3(H%&E4TKFHI2R=67QS$]O#3I/.T3>TV%+/`3NH9(<MU?=<WF
+MNGE4#:H7K@YDK7S%"75SUH$6GA*%[9)+(=.T]0[NP/0G3%[N(Y0W>N>Y00>'
+M.5I23ZDDGTS)0FSTM:<UKD`LSM;=N<W<Z;V9&SI:=V95/GB%V\-##K&Y-\+=
+M24AV.WAH;FM&R+&:JY\J9C;BC$761-EL`!"A$60!M=3N\63RG5%9TC(`RN@8
+M'8.P<R.L;AZ.,9O>NND/&R8;DVGASI-*.:0BH1P@B31@,.Z'3L7>2",'!':7
+M<879V14.@9#>B^ND(31AAAA+I"!3`S0###+)NZ".'LF8YY-'LM<\Z>:K7W2>
+M&H;734F1/5<Y.JLU[UCN+N\R+1IYBIMN.0DSU[-G,ALYDIV@ZXX;*BZY5E',
+MUC0@]2O#=WU&=E"<%HEEO$LDWR$S.PUSRL-0;GKMT573+&80*N=@;C;,K,Z$
+M`8B1?*^Q@L[PR8U7;WUDA\1Y5FGBG2Y*GCYXU^QYHXM2*Y71F?PJ)[LU-AR8
+MRU5BMHP"7PUI]F]='L.:#G05'LT[&Y7ID6W,48A4&G(Y]@WOE]J]^V#/5J5:
+M%?FD5(*LI$@HQWB.1X_<\#7:VG@5-?7S:,>Y6QV!$M01"7Q=S8BW,"G\<J*=
+M/X7DGWV*"/><$E$11'[BXJ1$"/Z1G^M[WEOA_><#C[^;8W,U#@("D:"-K(LV
+MWFJ<636!(7IU7=V5I;?6<9OJ-YA>W4]A62\Y5."<_UCIM:];Q+Z^'VV$1IH^
+M745)-W(?Q%C/8%<(DI45BORXUO_4XZ)!.1+2*"28!($$BX&C'`^>)#$1D"N"
+M-L":='HR.BB@A-F0J+;*Y8U:`QT"AD_+I;!#H(A%")#HR)I5/O,P!3[[C6O"
+MQXDSC?$T&Q8-^23.];8X%S[V[7;B29N6YF:V:NU9G-S.W0"5N^MZM%5+(9BX
+M0;;8",0BHR93#QXZN^<",,8BXJXN875W([.J-L1<M#;<*MLZY-"5(4RF5125
+MV^O)]WRU\?J^YY>7KYKUB4<P>B&1:62B&&2SWH0S#!0-'W"AOY_;[25^R6Z.
+M_1R;K+L28,68-K"E;4VR1\M2@J%8I+D2,#K2K5I8\&9,R_CO$56DRZI.2:4G
+M*0+%98F]4F,<L)AY((L*..D;*WL03G:S!5G07V9+%TIS0^KEL-TLPVTPAR=2
+M'M;\K)H4A.1YS?K6$!%'J1>EF=)G;%6T,E#)KVU>JM1,D4TY!=KJ"X(&UD@K
+M8?&S-E6F=-,*MSIJA,IB1SP[54V\K&B459"!1?H$0&[JXVO3N*S62\::F\JI
+MFS=)`JC<H2#2R[@EJLY3_4`09@#Y[PYQ_L?'S]L1,-&QIJH@DMMK)5.C-$31
+M*1]1FFF(DBI1%<<NCV#FP^W,PY]Q*"2!(Q%G5$<J'4'HX\MML<KB:'1.5F%R
+M<R.L/#JG6SCCU"`YJ12R+BN*J."*W/M\_<[[YATG;W0B2EHX+&X8;=[-IM<T
+MVVC(N8N3[?3J[ZPZ@-%%QD!12BL6("F*:J]B8UT.[A&@L!WG&;NX[VGC**"C
+M/3QPFZ[\<.1"QP308HDWG#QXKJ)\)1,?H?C_4$"M?3V>K+QZ?.>W>_M$H).>
+MZ%&=2YX5=1",:<):"514JIBQ4`Z>HOWA8N5`@0GLS\GKDC$JDL+OV<D*PO@G
+M,1K1=`FJ$.PG(FZL51R?H[K?%O3U=EXGHI4I,UJD+"`F9$W4$$&+JI$/;Y;G
+M<K[?G@"1&>O=3&K:[XV21Z.M;=C#?G4=2$D))-I"LD(D.!T5/+..9SPPY?$N
+MC[QF!F9WTJKV,DB[AX/)AF;"KYFX25(K@+@+X^Q]F/>,S%S&TZ**N0<YFJFB
+MK62*\ATGVD-W)?'#D43.C10255F:A[4HCWC3YU.]Y;J;&&BRP%%#^W]VOJRF
+M9I`30$@PT90BM)C?KF]/53[?>#AMG6(6'K=7G3@Z+%FS96J:&":S/7Z?8X=S
+MD\N3-I@N0"GF9[T=$5HP,4//M_/./'J>0&(IMM:"@Z@==WI@Q?N^WZ^CXGR*
+M"S91544M5)2H)74Y]N'TKKMMJA#V<U[!*A./54A2@ZI0#"(/J/;4._GTTM[.
+MF,;7VRR+JT%\T;AW<(*)2E8+LH?Q:A.M@5V[MZ[<S#FKE"J4UN;*H3RD[W2;
+M+O.=;C9TSW.5/NT,WIF$YYS_$6JYJ49$\K8*W)#T><]",9/%%R6W,B5K+H8G
+M'#O>>7/0BHHQC$A>L<YHC1H@TZF$I$VQ6C&V$QL6VUB3R?N^\/'@2>G?,LE-
+M2$]6)>X(G7:\R,8``H?5@$W=QV4WX\$/GPG#OO<%%&.3A=WGY\.W9..+T(LU
+M;8L(A%+,8X(55<(_;]+QX=+)H\HUBIQ1CAN0<&9)"GS^YO+WL*X(XB*5SF8J
+M"ECD:*:I$I&K'EXVF663#)DJJ!5(WXX[[[>OEYRU\/03BT1G%625V*DM5%F&
+MZ3``P&#"T84,/(M:2$[Y8\,7JK[7,6],K4Y:]=\L0;WI')9TVUD].D4AR=ZT
+MZ3;-&H[BQ;R8NZLRE=:!`T24EM9<X*+J:E:<I[3G#PG,5O<0[3+]L[JHG",9
+M2=+R_D#M(CP&ZHK'CM(U5`9@!QPFJQT9""0H;\="^B6ML-".AG+R8A>&^;D`
+MC`114:(B*(O@QFTOQ-'":A@F3B404599VXGPX[9RO,KSAHTK$0JBB[R-)PN2
+M-(%".)2("CGB?'7FVY-!$X=GE[.'9X.!T1C!.GO\H"CW>GI]R>E]P47`QHUI
+MI'3B`,_P^.93G,Y6*(JP]MY,J":<%(+F7&;T5JB(S[-Y-ZFPFI%K:7QY]]YK
+MKF$Z(./S^GQUFPXA)(G(EJQ58YELRB1,'&%M94L@BR*AXG7HGGX\\[UC\>8*
+M.$CVVKR&&!'7'%DZ46[8'B<O(9CN(B!?JK5;5:EQ_9E(I)9]I3D618VFY5\A
+MCIS,S)U*Y6YNGAMYS#L[R>XR<G@MFS=3>6V@KNP5+K"\JBU>S5X[?BO*22GK
+M$]Y,RE1DAI-R>B``_Y/,55):G&#'SXG87$FTKG+EBD"*;D@DJ:NB3[7)RV[2
+ME3D=!W08(1[_)WTP"8)/((@F`00?:Q)%5-11\P@^?/>$W3.:A8*HJVQ8-V+<
+MTLVY9K,>`EO!0I9AZN8-TYT@KA&JE-T.!P"2?3U^WZ^9SKLF=EU(F5A+DDR:
+MUHJ(KK(:+=$U6E1R'N?5O+K:"1@'V?7S[.LV>,D!.\[A2R$0(..*LS(/K?9^
+MIS6UZRSW&"W7G,44F#1S:YGMFAX2&JH(@["5I:&"#FS0\G0M%DH262@0M%_E
+M$]-O38S[VT\O/UQ.F.,A1-$OBNHR3"8H(4M.$EK8):2;%^I!('+K^'J:[O[+
+M]N[/TZ9[)DNCI5RJ.S#,#JLN79GL0:%X<4PJ&54G#.SE9=5CK9Q]V8"M=T,&
+M5BY[.@T:R*8NNSLK;,<-!3OYU;E'VBE>AW-,RKJJ;NJ<E>R6IFMI50THJ8D2
+M<-51>9N'+>YI9!N9<DTTT$KL6IN#-9=TE-X?.G9UW@(&6BD+(<@<`><ZWD>7
+MOZ^)JB8K6BBB:&MC3-,6BFC:6P5"T5@J1<9":>@7)^]G*^\^-5!^LX)B*&CK
+MNG%T51V4U2%=7?6><.R510!R/G]_'Q]I8D43;!QD)PA$))@N((%<Y\W64X$X
+MKS$=$$I7!4LA!3"GK]OU?/>=]'2(KW$8*F"D=`FK4UAI`6)7,ZX(XGC'3G3O
+M31P.6FS`:TS+8XD1)%%!$J1$LR`>?'W/;K-Z9P*300BT0U[^&=3CGG77KIMU
+MF\F]%I`HF187K0!9%)THH"8!A3!B2<MBR'%^`(!`@56]?[\>?\4<S)^6L$UK
+MY<)OC058*TW#Z9DJ[L3R5G:F1Z,ME704W14L;:)7@GE)-\0BT,:]4V>/5VZ*
+ML2:9F:M*G9*>@Y@IT;R]W;"-.KW9=[E4P]=SO90P(3=EJJY=C1!*YXO6O#NU
+M:=QCWD&)%G5BE9A3R9E7FU=[4K7PI+109Q&'$AF<V1-41N=/#)0Y*PT2Q,H=
+M.[+)6:M"3I&JJUIXW#D*^2)2("!@D%J"KC['ZBBJ)BB^-J"2VQ-14EL[*WNM
+M)M(EQ!1B#+M;(9WO/%*G!CHJ,44N)+V"H][2YB\*'#5-+%E-*Q/5UREKX&01
+MBA7-Y;-,+BJ806<8ERP7C1X7E[I$3GF\RQ(8BU:TJIHTTYJ3"UH41HW,RY`;
+M',6*9%$X\MMK-<+8Y%.)7/)3;FVY<K16S2%=?#MKW.Q;I[MM;\^@538N#P4$
+M:MGVM=)O53*"%2]3="%DQG8,H!))UQ?3'3/6X?.6N&^+R%]'T.21A4;N[UO?
+M<V53TL,@DH-.4@2,B06425NXQ"`Q"<J>M#:$ZR05H*2G&.R:(NNE9IF^Z"KY
+M!"\OX(@"!3B;MS!A$@9U]68,5I73(SR1>!%!>2AA&D@PL>[U6+5ZLJC"$$\!
+MUZT/G5B%A"$R`HH*HN*H*HOF9!VYHO>O.]&"J.X1DAFV.#C2:^(7ZI[9\.<M
+MF">,B-5:%5Z>EY:Z4XC"DHY5F.55!MIT%:-+$EIR%$W\:S6MY2,P+ZW-;_>\
+MKQBHY'6DWFLP-PVR`LP+F!KT\:SB<8Y)R4EE&-4$068>*>UV39BFJEW#_M[6
+M'IX?-<Z)$C-VV2(20P]W(97`4CF'K]ERW0%AEXWZ9>-=7'>]\[>2C1K@J!$H
+MUWO>X%V68@TQH@!*D4VSRSP2'.=\MM%[ZW\Y/@@?FBM&7+-'F$0Z;$E5>O<&
+M8+(E2C3R:%6+%X#5D$DW<C+Z]2P\9HDB>9[-P7C;CKHB(@5PVM<K;-LD)Y+H
+MX802=8PS#V6/E3@V[%2A+6B654WQJIS.50TB/4Z1U"KUZ+4D"45QXN2WS142
+MW8@=W?<-PYHU>6Q=O8C1D9&#UQRKK\'/0[$5Q1QR)'PY2P%1'Q+2E4H5M510
+M8L956Q:2&M>/H'IB9L/#4I$IJB@I`JWCX>[!>0RF3!5%E2%M_=7DWR,EBO3W
+M6DL@(BBP%`-W'N<Y+8JK2,$16:;]?CF%T3,>4@+17)&`Q@BW[;Z;@YN9`,2*
+MC!0A,]`^O6E$N2#C.DLERPLH&*AEZN-+6KU:[?*;_,?#HM3N0;RY5@8RF9WG
+MW?0,Y]@Q20A"*-G9Z*_P;N0XRL&"XV55OI9%K2OBQL+!JU<`DBCGJU)F6:L^
+M+$@5:L,.?$GFL0?&^H34TQ42QU([-0CJU:EF9U-#VCA4BGXUJT(1257RNF*E
+M:FE:Q/">BB:!'[?0^YL;>9]J\'X^N<_B^$?>Q](_-[VS?[3>*/V,="P-D+,2
+M8+(7)["R&^5Z03%0[?#B%NLG+UGJ(<]80\G_#OB$[Y&W@LB>I$S63R6XM].8
+M88;4=!P0[D^L_'X#_*/[F'!4)E1-?@,"9I:&XU55$=4OW?O_XTRS%'K<'7]%
+M3L]I"KIJZW$NH]PM[(,Q56#"`,JLU?C#BKZ*+*OMGC-F22S3;C#L655>+=NO
+M53Z+=/JMKE\\ZAQ7Z74#]DC!19\D$H0#!].`_NOP[\-X'@?\\?[<-5G+0?I,
+MHM\OQS^L<W[U;^_N6E&NM!)E<@]7W8[M_?D<<<442[.&#1!8XR5Z(%T@3`$S
+M_BH3/FK$8_!@3LZ)@`3D4'%Q(T&F`YA`Q(YPXPQ"HZY^$^[C%TY5$,5<`^1M
+M8XKCV8.!&P'#+9X0#:$KEFM=L40KA6D`\0H6-R\D5:NUN3).BW$`#M@)]@BQ
+M/1L"P#D@#.,Q,C!8N9V=V($.B`,H;5@"A%SBZ$-LR)Z'AR1*(VXE%]C"%[48
+M;-P!PV+N.?<(R)@4+"-C8&@1=0+OHVMK+"B(RM.H<,X;=QU8\D`P.B%@@$QL
+M"-NXZ('$8$'`HZ*$8!<";O7P$1\?@E]H&'RZ=]2'C!;70YY\^Q2LC1:0RF,$
+M#(NQDR-%Y('"'8[+7,8YG0:NI!8:63D05`X6'`Y1``NQBDZ+I!GE-<9$@9MA
+M(!E@M^"#:]51Q_D?1O<9J3*T#?<X7'&+U1#?*Y^N7)3THL6FSI*F-;T:`?4*
+M,!0C$)0TR4NX!D(!<?$",8@P;2-9B-&*+\L.H+AWY/"3\G2G0X4@)K#7D49#
+M*S4V6,I)N\RI55M$;HZ;-YH!V1+>-H6E*JC0#![C)@@X(!6(M([H%G-EI#.&
+MZYT%410[1N5/=UE'5/0]@@D]G*Y9(Q6<JGRP:9%-*EE]S6C,(UN9VB2V+M`G
+M,-C!PX,;*>2<<YHZ\D;KJNNVS/#3W!&:B9#ZQQS!C?'#&[V.^F5>/.D'$+=W
+MO',WM[+F:L)8WNS*)D<0'4W(/!&C:NU"&4VN8.5%*L*T8+:&S=[6]6=H8;:%
+M6"^?6$L5UU;.6-2+LI6:[+LXJ4326A+0<L'8I<=WI5!E7F"9Y8QEX<HM=FE$
+MGJEF%DEFL1MS>X[)!F1[P7&&0&<P=$X5->].3X)O2_/`2+%]V,:]O*EB]*R-
+M!\24<W//.[W#0JFB*J0XU[6Q-LT.S,S4P\8(Z6,/72W-M$@&^T;M\YVIG:'.
+M]$F[V*(66,M=0NPTI8FQ0$B<*<BA%0)Z1F$BBYVJJJJ]Y@>6>=\\#Y\6.T\@
+MVO.KJN9873N9&U?$YHK<J.M7?<,HBAJ39J+HH$DESLI]NU::4:0<04[,SJO9
+MH50%Z$K&*Z<G%:QJ96KFAH[BML839-M8FQD]9&WNK.?#7W=O;?=(N531=:KH
+MO)[9R0M&!YFK7:-SE=0?6'H<Q-36XA5A*3BVIT3M3V32-TJGKXX*24[>=UG4
+MRJU':K@=0O%;J[LUF@98K9.7V;*'+)M@0")KLN1:QV>J:M#JS$Y7-TC:6:-D
+MZQ.-[-J<'7>&U.;&'+.0E16&P<F0`,XK9IGNR3ND,K6<.3:X.SVD7!)(,$DD
+M`P8@FMM5*5F`LYW67)3$B3I!);&9YW,DGAK])/5GM]@"6#'?9*1)N1;W*J20
+MI!5T$*-&[KNMV5.CIK*J;67N]O;UW;W:FAEYF8\@D6>;9K)LZ[GEQK>EF50O
+M+P2>O+PU.[,W*0Q5LE">D4"@HP`U?.PC=2!UR&^*%2[F>IXFCBUSP5]3D2,G
+M6U+NWN[AK=EYCZ2:)+2!T&3$RNY\>*1RY&L2;M9V#I:!V<L*MRX=/I&N;"H]
+MC&S""(7:7+K:F*+E63&Y?=B[-N;[.)F^H0HW=G<Z3EU>8!H3&*^0W7+F1LWP
+MR0Y-*IL-G+WI9S!N;JR<R9S`H%#4[:%7W5FB9%"SNYM3W8)&S+8UO.;9W4BK
+M.WKGI&9ERP0$K2I"B*ODF#<0(:`L%)`D)*MVK[>#>2DA>O=MWNS)FMS;LX"'
+M4]>W1NG<T*U,A4XR:8W5,WLW4@S.7KM[AI3>"WB8.ECH@1&P.T"`ZW`(Z$+A
+MP#.[J;)D-@AH)3CVO``1$0/QOSKV7LKY\S*^4R*!RQNYER+&E+YP6#K[!P,M
+M94C:>R;)AG,)ESPJY=!YW7<X70W-K!9?;.7E+)4+`9&'G=NW9IX30ZZO<$R)
+M8<HU=[6%3*:1D*KJ0G([:E4J&8MO9S6@]GJYY!N;QIR)N*TJ,)5F\<\0Z$M1
+M>6<W*$G*(Z@\WGFZJ*I].N+O*H[-LNJ7&55ND%)O5TXWIJZ1%*45&DT*W)LT
+M\VLLU-"Q(?3N,V$LGGM\9T;J1B;U34R0]A7FI;LR*C:TW2;ITCL7M(#+RK%Q
+M*1NB)2H;$UO'"-BE6;,5UR2")G!K>F])6]-+E-OK6<^E4@6P]+;(Z9D/:'1=
+MM!]NW>FLK%,VBK)V<H3*W<JL1$Z4NOLZT\WD[I8^TY=XQ?((U/*A(&S11=<M
+M=JIMZ6ZFY0("XL18U.;?4ZBS-H87;+$]+XX1-KEW#;GN5+M+5S%";@:!-1PN
+MQJX`[PJPP`6I>G2&I8.@SUR^.G+L:,T9B/;8RWO91RZY98PM<RE4[B4W:"RL
+M$XB:[,2$NMVT)NS0S-&4'0S.R@162NGC<M])Q:^DU6O6Y6;0F#4X#)K7+O.I
+MOAHEA3LH:W+;<]8N\OE@JZU*VV.9U.\R<B03*VL3N1B!LHXNNJ<T=17$)G./
+M!SV7DZLF13,B<FYKAW*55UVU9-$S9OAEV*5%1*.E5:-<IX8I8(M(2L=@MW@8
+MJM"$`2"-(488^4*]*R@$P,XRR?1]';//Q\?AIU/+F=M+!]*<IM$".?3S/'^)
+MG^+5.D%4P-T?]G$K^<PR!(;9D*`3]'^QSO+"L055WX[G^!ON!RE3BKEV?"G6
+MH"UAQ%<MH6%54'K&J!3),EO:TK&#`8D^&*LMZKFE>EB[+M.=JU>I1B0IJ?(4
+M0*'T@QR!!"5A@EETYZAVZ0XD',/#BS7)R36$[A2;H5':=]31=PI('A+J!%-,
+MQ?3`2.+KQ,H>=6NO.Z.HJ]4"$NRX0DP"(**IG.[E,WR9Y32]0(\>JP)TPU"8
+MB"ED%.YD![2"B(B,F$+,B-F;$6/8Q%=@+`N3(8BE/A[)%@4K!"$R%*.S?,['
+M=YPT6&D\H5S=F&M[ES:4*,-(:T:.RPZWF0X;U3>\R%LRX+C;"KH9IVN^MZ6W
+M'FNSP"("@D8*JAS!@D]YK?'GG7M%'+#$;8BJG&GG#=:A^X>_^QVU^R,@JD'3
+M;7/'7;\W6^H/-5"^7MN#1$TAFN\XT-EW+A,L%T^3KU[%&'$X(+;4P%7][:.'
+MK&>;%).+55C:+`>NG9.[=.328MN5M[W0[:I[.BM+%H&Q8%DE8U!0B1%B9&#)
+M,8P4%@*`L"F60LEF(E(D7M6^6M$[[/W?V-<:<SPO8@HVJEB<%*$I%E%,HI"6
+MH`8C\`1^:B&/Q_'UN`J-ZLG2.K0(=H?A)\74EX9'#S5CB)<R:5S-@U(*6Y<Y
+M:=#,#;XM[)O6=."0WP[;@*;V8D$$/F'-,9B%M#2`\LW(R<?)=WF/'"!9H^E&
+M3Z=?O-Y5(R"5Z.SU=A+#%+SJ@`3(I$DD*9(F9/4C3N4T8]-4(NB_3B->5R,K
+MB8P46T;MMIA59FP)$UD'4T<55(BK$50$S5%1%:#&SF)HF:;5)WYW9FJ:VU0Q
+MW.@@C\[R:=K5XX<)FA)[)=426UBT!R[.-5T\W-BP9OJ!/V?/*KR=`6VMK%=;
+MDG*D:7BA>^J\)(A[MHI5TTC01`9M`ZH:2)=)8RFM4A$!$!$#H'3;(.A:0I0T
+M`4-+24E(4@1*"D%%@HH7K]MO`NK`+H6OIXVRQ(J96:EIKI19BK$68:,_*]H7
+M5!6-%5%`H!T\>O/EK?]?U:\?=$K?I4`G6KE]WA7*#B3!!AM8[[;#U[`F'G@0
+M`,\W/GTQC,$R.J\%E'ID?TK%>3%Q<DKLF5>X,:%`G>V6^>'',@%]O;7$S3/.
+MU>6F\B+NT$$9WN9[-$VA5(3*"W*VN-DO$XQ&88FUNXQQHNNN=&R2HF=#BO``
+M0!#5I230(<AF@(`D4)ZYAZQ1F.G9I((5:4<?$"12`-<Q672,B^'.K2K!))/(
+MD$B(D?)Z]'T=V`I(B)@IY9*:HG9/+M\^?/F[!YG$IZC&LFM&U9^.>^*A?O-^
+MGH(GRQ<Y\\>R4I2]4^L^=,5K$%'6^Q9YK;1!51GT@HV.-.R:IL;Y^MV?<XJ7
+M\>?IP.S57NP>OIUL-[>I,S')(4-I4LD2,<PQ1@Y`2$\R]HLNU096!2R65FT-
+M<>/&0U^3$VK2O!.MH0U0U\&]L8&X2PRQ11519)(!5H7O+R0#IVQ<X31,6Q9M
+MBK%<T:VRL:LS([]T&19%*WS8G54.<F7-Y3H$[*9!`(2WEE"=09'HP-B=2,WB
+MZ83NS,.@@B3#J;,QF4L,X1:0RD!S4,:4#%T6#5,/8!=N0,(G#(8!H@R;F`GJ
+MJT*BB:ZT7(YY,NJ$*0P4.NM4CAG=AAMP$G3%:)8!U"U88CDHC"+Q1J0LC3#+
+MF.YR!DAS(BZM;54092]=08>(/`E.AG9T2*0#19-MW0L#JKW#>G0W9"8;<R"M
+M<U4,4)D&Y#,.D$W,A6G-"CV38)%(@[;<B9SHW&FDFR9RT=,YLB4TS-U+!FK0
+M+9L4'/2`1QN(NO`P2"CSA$&B**IFH@B#GQM!]>9\:>[>9PV2LL/-B***M@.?
+M0H'PJHI5-#E.SIW,\X4EPL\6M;<W+@GV#]W#BGEMASYOFZ4U2W$_'QQPNFQM
+M.+6&8B>.^MWM,=ASC$1&D8+!J4415L@JC==?#]#K@\(14%$06+%58BF?:\F+
+MW6RH5@IW-J7+HEY%(;[_M@YY'E&Q;`&!\L"_Y_K?Y::^+\OW[_K^-AABDX\D
+M!/U\N8@;:A?*KA"$=T*$T87L'69F1O5:Y6T8Z7ML:HV&3&$6+4757/L0G$!?
+M\($F"([4R,+>4I`XC7N50&-S,5CJ0:T/`B@@L8#FYD80*$_+D`YQKE)RZ!"/
+M%FV\E@`&XEU;!$FNN^$V<Y,.MDB5`1W<52[IW4/,O@=%DO>\XJ[(7>.U%P4P
+M$5(@)FF@^H-1`4TT2P_/G//K0V1S3A$47`41%'EY>O,?J-_-,=6@@F3]?PY]
+M>;8,1LZN;Q.V(E[%,J2S!J@M9'/!YG$TYC@\<0A`CT/QZ=;T<<5QB.$\4@Y3
+M7O"N/B3<8JU8*"BB*J/TZ=.$/8H*=/CTOC1M1P5;CA,04LJG?TW1U(+*+;&I
+M#1FF"+;[ON]AV[&M&+8<6(CN!4+4@JJ5PBN,2"+52F4-1E"5N=>_E@X[6R-T
+MOZ]]03:BIQ9Y9^LX3A(FVZ*"0=AQ<C3WN_/GZ^_T69>R5+_$_Q<V#%61V=2[
+M,9SER1/$$(89S<?95=SS+M,C:#&].R:RYEQ$\6X'&09Q+=S;2-`Z#Y[LTLWU
+MW5H<<.RMEB:I;M3(Q"C+JO9FY>XS-@VYJ:()!@$/:&J2Y]?,'EH*9@HJ@:KY
+M@>2\F(*:8Y@,0%)$%0<PSQ)JE"TR$$`=,Q',Q<"P^J_,JN(G5E>6E$1%R8Q%
+M1Q2*?+XWO8HL@H*(I,3Q:+(C0<G6C&,62EB8C)M45,$&VLU&2,A[\]IK:S:1
+MPF?+#J%'%Q=*DW+8H1%QD&U;;,R("BE5%!C"2$DQ:1:<22!K;MX[^'>QF=^_
+MD)O)"!M6+2R$3[MB)(+\X5,4+,>2.3V>N\4!`_BC0/J*_:0<)^TT5/*A)8HC
+M"W.L:61)2&+-TX\CQ[MV5MSF5*O*0OE/&B*E($7QM]5/A$(8S6BR)D=X`0`&
+M[2DJWG:^NJ*.3(UFK./2*K40IC`C6_]6]`CX8(BYEI7$1`%`=V.?.Y%"4)\2
+M_4H]A![7FT"AHQ8G01%"Q&,&9GD>IN!>0\6@-'R+%[%%,6#]W.=(QVQL!IBU
+M1G.+3BC25,5-$4%MHHA([^ZSR\\SR*@4&18I)A#%11<43U=&O0V:+!%E:@UD
+M<F*BY',@/7K\OIKOF1.L5,I\_SOT\ZQ]B]$!RC]_0Z]QDV(G:MHHTC\WZ>N^
+M78TX@IT%%.PN0;!IQ=]77TL<]>:XK7GU?5QXQZ0@=GIS9$M+P@>E+3,S2!,P
+M!XD$C!^W>]\FO?N:%?Q"+JDD2E%!T*DG,S)-9D3-&Y$[^_-T*)ZE,[UPAN`*
+MJ>1H-WPFNF;VY1Z;7)N\9GSXRO5/<1>J):(>.>\QG8WF>"IF[A=MW5!?5N80
+M1*JA\\ZBKY.4A\]>;T9Q`OCN1PIWSG?IWY.;G7E.<5S%1=0CBF##2/U"Z2+Y
+ML0E+7QYAX55R.\Q/<CHI2HJHB"Z>;K]WZ_J>_#$HN3,""4A`K()&3,5=@G/I
+MY^/4WRWU-A566A.NW!<N.%XIJE:+46J5=I*YBX$^N4<414;D?3Y=72,48[M*
+ML'*K&6962+$8Y"!"11C&'LFG3JHMD:1GM[W3I8*N2)HI4M2@2DIOOMMU[->6
+MF\SE;/1.]ZKM4`PI![&!AAR'^F,_;ZO)3(M$R^?[49ETVZ,6";90?5ZU>D:5
+M,I!XE>F38N]6LU;).7LZ1*U#\"NOLI2KN5<J9$P",IA.6'!.IF>#O>BC@D$W
+M<A?$R6,1?0DWFWL'F;\%1-)3110M144'.,JJJI::(@I2G6+U*>KGF<>9Q#05
+M,,14S1J<;F8G'#YM!XV*I*/7X!\[D%44=G5&QD-4O(TKZ[N98HHV+ZDYR8JK
+M6\$XGQ^>+I%$%79`CBA3?3,II5=Y&`+!2Q-+@4DEV+`EPL3]Y._GGC/%+,U1
+M(F6PN3,@WX/E[;PT(&Y,$X2%F+3"F%SFL8H5!%$2N_0[G6WIX<;>??GKE6^O
+MGYXRO[$Z]L8ZVEWPQ8D@6LR5(R!+MDE=6)_:YU8:$4$H5Y?W,A4)G$6"?LA;
+M-[B234MV(D@;DSH(WMO,F>V?5Z.5YZ<!0%>7"6%.@:+.AQ">SU"";WP1ZQX5
+M=D(Y4WU].0`$0+0#G:F9TOQH1)"($6FVF"XG.[F&SMI+F';S,34F5%P%,.BD
+MSY3E/>8!EM$X^,SPBC`!(@`$P`"0`2(#:$`:J,Z]:*D\Q52PF/5,^KSW5Z/9
+M>T23HWUQ=SL&T#30)(D40Y%"*FKY^VC%2AYOG.F4E"5^IABE7A)9@X9I7<'0
+MQ8\8)H7E&"])$`)F*)Q3`\@.8B,T&<],R..,A"7"L6)=ZI\F?$>[S8@#1S'C
+M<3+5!^]ET*3K6+]EF('$`UQNDQF92:ZNLN2VN!%C%6*BJB@*W:HB8J7;-4%(
+M43$43$UZK6Q3E:BS(J("BBP6")C'I8/&XH;MR28HC6ECE1$2U@RV2'V>N^^9
+MAF*-HD?#DZK8QIT%,/$5M44"*0BT>6QB\%%`OWV*M,T7!5Q01R<AZ7/L[YMU
+M:*XV1A"5"V7-V;A%V[I/9T7%%(:Z^7MZ?7UT=!(C(B04C`CV2(@XY820EE6S
+M)&&96&85&89D5164%+52.HUAU:Q+GR7$+Y/+\`.`#DO$1(ZX,/%ZX,1+-6Z7
+M<*U>M6H6W2Q25(0BCN.E='+==M[6:]F*OSOM[-JO[N#;?KKTQS;/'#;1<NNN
+M?'&&[VFGYX?K][K1^5^GOSOU>/[S[][\+V+WW=?F_U[\?/SOJD_=Z'Q3Q#UB
+M(THCKQ-'4=5CI6I.5'12U=]<$+AG"B8:X#;A!#5O"+4LGD-A<U_1P.4CX_F)
+MMS$B(*HB&<B*(F%G[7OKO[?E6I,#X'I..[K+C\G>\IL^_44>/'EK5H9YM`J*
+MNLP!YQ2)G*,JJB[1D$MH&&^&==LZ+1:;1OG1-'(Z1=).JSD3IYXK$>K-S672
+M2$")@221]_<^]X_8N[N[_W?L,1`^0`LTA[/"Y'#EF:,PT<QVFY`]\A"<$13#
+MI,E/%L50*70FR>"0RQBB.EF\DSS-KH&M;.,-(NYZ8@`$H961LCNO<98F-DGJ
+MGB+YCN>X!8MY?""(&7&QQH!*`"JB#S'8.5(9M!Y@4W`>OA.`'HG;$#,K1,N]
+M',58H2SHI"`6+F0].=CT1;B#'2P#`G@>S(&WC/3Q&9BATI#%](%B&7=5T\(@
+M"`8T-HC+3TH7`@172*K0(:CNAP!@9EQ(%SO0)S.``@7H(V3=85>;`YFSUD*!
+MVY<5.84,MVA'1``P+@+%JA(UF)Z=8G!0C0+%6A+W!41.0*@Q33R7M9R`HZ!%
+M&+!B(KLZ.H+(BIO`!MT4'#RNC_AB=U%?7_%\/@B>[:^J^&!-9H$Q#QQZ*.@8
+MX?U!D@2(A*AXGLRP_7SP4-`GGR>[WZT01W0,6RM]+P@K6$9"(K)C3U*1R&.6
+M$E@=(]N^]5$\,VD7<R#O<%R]PCP#+SIX56[4::(5(+>TLB22$033.*3!)#(=
+MS)=(49*+&(3*&D*L8JDF@(&6F4#!6/C.CK,B2B$2")DB7F2QV#G#)H"0=J\K
+M"2#I99@@CK8J8)"AKB%JD@S5=P70G$[MMXZI'?7=VO)E3G";8YQGE0,8:2`9
+M%*P"XA/7`FB4CI4&,*(K4R;MO;YV*LSB(-&[3(),J3/!4#>(,$<=9+#A%'#$
+MXM("M`@ZDUQ#6\R9@D[J3"&=>5E\D&>C'Q04V:.`@]E'ON7![YJZ.H+3QJBH
+MJ/@A!5'N:=!FTC&BVQ)QJ+%J&=2)#8IH2,+XR1;4FN3(-DD($4JZ>!ZM:#I3
+M)3+!!)/"^<3-3M13H=+D!:@A:%NJ6=>&2>,%1$B=\A>33FW4F'3M;,W8\AJ3
+MC<5S>KUH%B*ZU2;AQQ'-H+9/"860X#Y]2XC&%8+:5-@LVR=Y+E5D)47<PV.5
+M.V(O;!LA9.X<Y.>.5=0(@'37*1A5I4L*+Y80.E2EUMP&=`ZS7LJCFU'%YN4X
+MQ.I'4SI\[AYUN\%+Q4E$5Y0)-U28:6I&4$9E,P2!Q%8C??=SB=(MZA1R*]Y9
+MR9Y57+K5KR1QMZ9]BJ8K$X,(CL4F"#'B^*-J@D36;ET&#=/*H/N7<ZHR<PI$
+MI!08)W2A1U67!RZK+IQWPV];G>KA'M.E07JPX1I&'NUHX,"BS?;4B2+E`;MN
+M$;J6*&X],D<ZWA4">2Y!F+.D1E`0&QA<J)=N*Q32@@AZJU9KN8&':;W<N>M0
+M":(4I4@,>M`F`1!-&!$0B`]7/ATA%$=N[,--R16*R).[3PBBC9A&`>MSR%02
+M-45#R99XT0S`P@-I)1"J=4Q4<@B9QP3D&#4L;80JE9DP2$U1>T>G"*U#"@D+
+MI##I%+GA1;2Y%(6"-6,4=(B:*$M<1H,F*,R@R3IPAF.Y!]30(#9:MDU5F&03
+MALX3J3QC&EN#9)"K"Q5($R0@;/%S;AD848((P\<(P\5B`PS@*&G2*,$XD)D)
+M)<69($EF!VKGJR8.IQV`U/47THR""EQ=)\AKMDX02C.IZ-=!,Z2;X-*A"SKQ
+M"7=PM>K=.!(YX--.>J1)C>:>F]*#Y88J@H1)"&HJJSK!21/(3J@X!``W3(&D
+M:;U`E<@CJ1,*,UB3N@HG2-,61$EDF-E1%.4R1)%V%)@80:0W',T<U1<M;0H!
+MF,(C":;E.]J3H(*4G"`SM-]:`VUA6*(NDP"#0]C7*@<0KF<8"!X<-(%G+X<P
+MUW#OF@-ZP-ZFE8@!X3IH.:DS<AJ%.`$8TP]@1`6B=V9+%(#(,$D[FL:\%70`
+MF5.ULP3H&''MZKD50"2R+D9=,#2CJ5TMH-T85H,!H#2S`W4*.Y?74!HTZM#*
+M18XX4#(O4+-T#<L3)8(=UHD6*3F78(EH`9=.I-2KJJ4.LR;EY-D2<*)U"TF8
+M(,S4V(A[<FRS1KRL-!$6\>$!G3,[,X6LQ'M%R"$$+L"H#I)0D"':JJJG68!Y
+MWM-<9E'.EN4H<U,+.2HPT0=P/=;.E09MD&$2;TKG9(TRZSA(ZI$S>E$D&*--
+M"C>)&-H3DN;NM5@VA?6.)T4+?.JI298FI3F10H,8M8$>_'8V"&W9R:<01Z<A
+MVA$+N02N^N4VR38AWRY13QJZ=#CJS*.3CR4)@QO54A3C9DSE[,M:",,($D81
+MUISTIJTJ`F9Z>(H&$Y1&2&@L(F8!;%DF>I@32LH'9HJ:F@S1KI#HB@08+II,
+M,D&"0,:PC$$*L%`$@G./`]%E]ISN"!!M\P)V;Q"HLBR00U(SJV4B`CO+,"A=
+MB(NJ4HF<*JJ+0+2%&,M";2H[+JLMF=O&]=36LYI$M)((XW5*C(3K&'ATSQ,Z
+M33MPX,L'J4;((FN]W6I$PD<S>3C57C.J&]<5*C"Z&T&)HLFPB402.R^FD]FD
+M\N@XLJ-*EM\A-\I,DF99>'E4]KM&S0*I8<)RJ-4C-3,LU.@HO4W6Y-7;8X=I
+MHI48Q)G>G<ZYZI,C,>2-I<YZ+%$OC5S1+[-QC@HR[,W@@1&1F1E7D:,&55W,
+M40N[M<"^,U%)0E1Z\BV*5[U*C&W5-75&06)!1;HC9%56Y?TW$"2(%+07[8\C
+MPG51I.W,A(3DX\='=EN2W90GSQCE-8:RGF3UNN##&R\[E0ZEVU9H/5ANAKU-
+M)V9NK8R:S*O@AEY5W,S-3K*$Y#F04$I=#;Y5NV>QU/':4WPG-W.+U21V+<PW
+MQO;&S1RQJU*>/6E?8.!V=G,1TGCLJ=%FL*J6C*V:E57=FDSIQU,S<F9RBHXJ
+M2&S.K>F<IS91/;1#-O,M'9CLW!)Z665*LX=DE">O-!PC,U7KKC?6ANFM,<R;
+MKJB0AHK4K73NZBG=A.34Y8W)QR;JJRC-T'E2&^MBRBRZ=Q-NZ1O:W*!LXN4!
+MI!OG<WPQK-NJRNPYLT+Q<7ECCD49)NW7&ZU(Y8S%0=!CCHP\2SSQX"9F^66L
+M,[-9G+*PWP[D*G'D5W"5DX^"H\G#Z(NK[;R;K>V]3W`ZONN65723E-89MW5<
+MD#N5-X1CK9[*[$M$/$*V!%D&,,D,QAF5B',0(H"(!BS9&&NVV->0!BS;>N[,
+MS;>&(D7$"53L!#.&WT!;%QU2.RJ;K+ZU<@G"C`=D,M2[L6*@$3<W:*F[>9LW
+MIWI96BQU5M]/*T2[+XS<J;>9.#*BSU[R$TAA%7V[7*[GFD[#[>SMG%0.2[&C
+MK6:6-W5.G,R\6,'6&BGKG9GC6R^*IZS=ZY(59,CC3QSDS&SK-A=5\Y?3G`FJ
+M"*)3F1*3T<T-ZS@L.;$I;.0C4R4<:"68JNP:N9NY#HU:RN'#3J.C:W.LR%=!
+M:*HX[(XT0N'/,7$4*P#A$$",&6N2UNA\PKZH>_J:(D#/.V8E],9V]GC^;IH!
+MWK_%W\M\>#`,QX)&$-*+Z%B2$Q$#,%8FL2/4F5$Y(6P.%+#0M$G55BBHBL5%
+M5J@A6XW<7K&YW&YE2A+17J,5G,$&1*MJ>Y%)$*H,$@R(,,)#5-,6,2$O>^-"
+MO'&N6-<KKL[%$:GK<ZQV#J*4Y@?*YVZO%?A`H5*]9/"M=5[0)RQVL-3>=@C0
+M(`L:@!(]6T#<].Y=NBSEC8@#@K67HR:['@7JG17BC)#!Z_1`CUX([-!RF%),
+MK(B)J4%QNYI27=FA=:Z6,A(L618\92'7$TYGG%HJ9(FJHIH(@J:F(IBBB"F)
+MB'F\XOON[YOGF[C)5%1%)$%%-//#%/+Z8,KS2.Q[%Z]6"F*&ZN!*HN>6%_"G
+M,UJY)CB@[DC<TS28H9,]VE`@AO\DH:R(I(YAR%*28JXHY##TZ@;U'HY9);9D
+MC2:T-:XI^!^&X>3YI@MBJUEX</.YS6$XPY,8PEA:"2V)2T48TP\<AL8+.336
+MFC3H**'^ZY^G\I,_XH>..O'EKSQJ_MFF^TXM#F&E0S0D.S+S5J`_8_SM".-`
+MP(Q@AD,Z9S!6U0ZH55;O[]BF+5G9=2%SV[&KC+S3PC+\"^L5.P:49Z2;6'N%
+MWXJ\#WWFTS([D)HHJSN>B)HF@IA1Z1K'-#Q$O>4C8-S-&B1&$GT$15\/S1Y@
+MS)5!36AT4136SJ"J*D:*9.(QZ;ZXZ9NU0Q%)"*B*#G6MMK3QTH\<>-D*50UL
+M7@7ER(BN&ES'Q_:'XGG?-E*#8Q28Q"TN[0EF+%%%B,1B,B7_>WOY9[-E>HAV
+MVQ,:V4+8I"R$+2D2!&200BC,;,EM&PQPS["4<"I$P^MYR)M#-X4@"QP&5V^U
+M@:11DC"CGIX?/X;3,T*JI24I460JIHV51B*-F*4+2530HMJ]/UZV/3MGY=.?
+MG2^<W)`Z0D4<2.QI'IZ,0X-MWT;:UJ4T",2(C/STQ>UDDLW^WMK&MG%.8ZSJ
+MKP>#FA0WA[?;G8*KP9N2QE"-QNW=K22!KP";-1?>8SD;KAN7+BA;<OT4AJ=F
+MP-%>7JP@B13PB0M4;O*MSF11NP@F!",DE_\C(PT%20T4U54M31+53]LXJ(F)
+M1H^;3Y*:2FCU;?%]O?GD]*"HQ(*BHHB(B,5O6ASG;'<45A2_DU\\8P*44DN-
+M62I4JQ"IP;5C$8R&[E5+MMT1QBH+&10OU?5-FQ$1Q)\YXLZFZA+C55V>(78Q
+M7)($M?%[YJ3I%JL-*^R-JY&(I@H6AGW,>3MKY^?.GF";@;D-:H(MFQ*H+6@,
+M\J"Q"%425`5\L%H!UC%3M>Q`0_GAS]5`8I[_%(@+S[%0:I3S=E_2TDZ9JW("
+MYAG<D<)Q>.]6W*S<B?&@Q+[G72IV/1$`01;48?>SI'&,:BF4$J\3MQ7HV5$7
+M04`^PX>8V=$Y$6I+C0@=],"`$8B5-JIYV(JP&6(B/<X+$@!J$0!`K5$>OKK-
+M,EO5,#9RAFL41B)!8*HBQ=VJF&J\QKS:[LY]2'$Y3$4%$Q4S49.`>@+L=8^3
+M*JG`HI=!HUF*"9=L6RNJ:*FP455%%$^T8:Y3<U3"I1KF+01LEL[EA%!%\MN_
+MEYY:AJZ(EJ6!8VKD=-WE:N#JTS8DH.'VZ]DJ((E*Z#\X3R>[(Z-?IC`')T"P
+M>$TSO>I08::HI((K!\WMQXV\]G3QU\/,$SVXKIYVF>*RRPVD`=,J@79=A+-,
+M4C+8J/R;&_?W>U'ZD"79OWRYNX?S>8!0Q+T(:&-NS,G`CWLJQL[N7[`*:4B\
+MF>UC:5=JO@F<M$52F6RJ2%2`=01CLIH$,C0Y)?3K$YCAW6UO@+FJW?&N0O`.
+MV+S9@QMDCQD1<%1!1'?F%$46V9E:DQ73BF-&]>^]Z35',X6*9]=[^X/\CX^W
+M7RZS35$L9BD$+AK,NC3%5020W>0\@?TGO1KJ6B-JK6QN)^_H!=@*"PBJ!!;<
+MX"K%U:-CB]T$1PWAAAWSQ2.MLBK%204I#+#XIX+F]N+@JS4HQJ99!05-I,KF
+M,SVOU>FCQSO*QX1(@I%8(XBE@18HI1F>/)X;<'?Q!-MMCMXW,7P=2@VM,F$L
+M8)'&(`%EFM<90T`(?:.,$B:%JNK)EB;#GNYFP%OZ4DNPI+?C-:+.9/C@C,0[
+M59]!GTN.6L)H@0`"<VAU*]]5;?H;W5F[Z,RKOB)U#0=#L`8\P#@"8((!)@5)
+MBKR$<%517%2PCGB\\,[O,"<)BFF(CD9&&=(>*2RW0&"GU!#7PK!(Q?#TM=+A
+M4E#VSQO<R3QJ$IF=$5+%E=!S>N;';;:J,8T$VRG/7G0:%%-C,W,^G9OYZ.*\
+M()DD!9'-<GA`V[10S[GIHWURO%3&(N1"`.LPMS!UFL9$;F6@E9;W\4N8@FEF
+M[%QD621%D27+@+F,*K<L"-DR"1".0F(EM;`@_,[Y].&>N<ZC+/GW^!0C2(@/
+M^PQ%?P:/D')F']SEO<9^9FU:D)6I(P_+2V<I5&(IX[MWHK+R[FULN55W+HO:
+M$U0DR.F\[#NV]67-#FF;4Y5812QW76N,6+!B++N:X=CXST%Q45$SDQ4U!$P1
+M-\68F29B(*>ZE$K8))(26.;@JH-CJ:^=\*)A*8B)/1;":-.(PQ8PU$T:`F3%
+M$\C454311%4%S8@551$</;UZI\'.GH=1C(I/3=#284*=@4T*4JE`E`%#0`4(
+M4TBD._6]'&9*KNS,Q-4(R4]//MV=&QPZ1@I!CU"JXB#6)(;EAH%!P(]/[8/G
+M9]8_WZI_F0&!`?MS]3+6)-4R2_@@42Z4"043>L:SI;0VS=%/[I:EMPODJ6F$
+M;H%6YJG0=V@Q>*77C-W\R0:Q,=LJEP2(63;$U=S@BA6A#=NJNF+R;XR+K=EZ
+MBM<Y6;E&I280K%E2B8"LX-DR9(PBC%CI<X%6ZJD3:$@]S:!N9<XE5O9-6"N-
+M`FL"]L[->.4:-@3K[!NDV#IRR0"""\Q!+;W*JJJJJJI)59(NUA;S,P&R$KN[
+MN\T3)<2(&\/`D&"#?.U1<LA%5$44D4U-?.#W[VN665PV+!2Q%*90YM'G7'8N
+MV@N^>_?.1/1Z:`J?;B1-:M%%&+4T!1#GAOX<;<(G%$]J'9LNMAJP0II?/?KM
+MX\YYF[1JK(I%B*"I1#C76\P\95HR:X1S9<VVI,O[>OT^>^%151%,JE56;:FE
+ME6+%F,Z9]>.NE=NOC=ZYZ>430WX@;;GW;AI,1<W[0<^N\5N((=4SW@PZ$E1`
+M7&OU\TB1F4566[[&RYG/L(W<Y(H51Z;HC#=F0HX-"M=L4`R+L792>:G6Z1>"
+MY;VM,R*'&)8EM-D&CTXHC.H>$15!Z%A#3X*94\9.D2*%X;.(&,`56':$,[YU
+MJ#%455%40101'%%FTM5&U&S8EBBDV2KIK8I5%E_*;E^T:"(\6#ZC15ZU:*F(
+MBM;LN2I;;$EHT)9%2*P0DBQC$,\X<.$FM:P11<UES,VBD,J7=UZ/#?<-64,%
+M4+C3PY&C"+$B".8E]M>XT-.X)!4M+EE80LBELY_:Y[1@TA'E2%%&2-'FTJQB
+M29&XD%55569OY_3QKG.DCE9*$L0MUAMOMQT\;F/#&]_#QB>$SXZ=4&UAM1U2
+M$"()-$0!^<_=[$))UY"^Y#[S/S0L-55+I"MYFID<+S9RMR;.JKBIK)R]WH0H
+MUW*7:WM9J^5X*,95">JBNMS3E:.G$KS#RC*LK6JD45:N:5&QG/"'DW5/L$QH
+MSL';42AN.F9K`EVSU+;)G*0#N*U[U7U)3/56AWSF\AMWD[H=J,IL(;NJ6;-J
+M\<L."6.$Z'ANY0/%+$YK4&*+3[J;IO"3DL3A,@Z-F\W31<OYW9?@FU+><]\/
+M#GO9>]N6M<\5ES?:.?6;M`@U:&7&EP:>T'LO.S>"1/<:8XQN]DSNBQP'5BQ"
+M]5;*6]QGMLRNDTT#2$X,$&A.-]F4:&.LF\(-*)=UD$8]G+G%5V,DX,=2;5]5
+MDV9P*R)NJW)-V*:>=9O.FQV63<L;CQSBZMFBK-7IR*Q=:G=V=9=%.Y@WUYU,
+MTUU75&QJG*O+*P,:=3OGDM2JVUD/##T;2!-;KYB36]F3B9X"W94O&YEZ04A5
+M4^Z-.'`U:MNU0G$+4LYKR1LI34Z"SQW!PT[*F3,Z'&95XBJ$YM7="M2><6QM
+MJ:G2*V6Q,B^RAE2]*J3&E[Q,V,I"[PO#(["BY58LL<;<MM=G.]R;2HE))^TD
+MT41$5';%:=,TT7,&FOCRYZN=7CP,53,WQ)IH\G+^KG"$=!1%>'*0G%X60<7`
+MG>KEQ6&4+4"[P-$`4$54P4RC<P/;E]^3KJ5%;*TVJ3<WXK2\F2*@(@"`L,GO
+M;?&'$W?M]W>I41W9TDRD`_,A]N=YM(3-E-_4W$2.&Q3\6X:)HB0J-3-5=-19
+M6M;AE.GR!S`F%Q&>"Z(ZPU68=7D<LKL$(8$5-:5UW`MNCO[5_;NR-))3$]FD
+M6$[I)955J*)8X0CL30=3(WUZ1B/S^QKV]4K\U<^_'O?@?)_"_/?@?-S*^?1D
+MY^/SDNJS4T+%&L<*83%-1B.6%26K.ZBK30Z9\MYJ9*RK!9ZLDZV[=AD."MQ[
+M'3+J,1@]:J&!%4\DJO1"^*!C:"H)*X;RN]H=][U/3=M`3+)D*-4*JJ"J(**(
+M7]=S8N0KJ;L9B8$>#&]FE>LK\:WA\A@G%":(U@;\]Y05*:&;1JZ&@CSR<H,U
+MTF#=_;^?[_RN[N[O_;_G_0]7%`QAD;_;?K(R"+04`1^ZP.\PAR'DK]L>?1X>
+M#5*4E*T`D6N-R(`1$$D6RHSP,W>E("\L;M4[F6!<=>!2M$P%4PN$FX`R'L$3
+MVC.R@KS)O1E/K6=-;R8[.(N(O=G*&U`I/<`B!RZP0[8<`BY86Q-8XNA(O!`4
+M#A(OBKFZJ,5NI`00`V@]G#(8ZB.@#$,@!U$8H4S=0-L75$@0,T.QUP*'`'.L
+M,"IZ(&R!<6(GWA8P!73$('MNQ`$6Y-B!:@1A?.L34"DT;?)-F@ZLV9WQPAR&
+M<,B8$5M>M0'>:(G!&\P78N(%3:0D<`%J&?@]8]N?A]J<5$//%3@>\!@33@,[
+M9FH!K,X2BVA)#0(30B8AVFFR\'MF4,@?(48'`'A\7K[,^OH70%FM_W(<00-[
+M$A.+F>N^-9";UK+`0"Q#%@-Z&,12Q#60/?/.1I"`)%EG\'`)@_1^/3KMW8VY
+MOX[^8:WKX2*R5?9AUXY>3N4#>8BR*K"F[O)C)JMMF\JZ+F\BXJ(T&*!-]=+I
+MIBQ+1FW/*:%`O)55.37<3+VM>76:93V]I[A-1L'=Z<W($0'FLKGJJ[&.48PF
+MQV/N9:Z<9RZ6[EKJ8=R>!(K4S9Q3O.KE4%;JB=5\(FEL[PO.XW.LWR?/31!.
+M-S:1W<;[DS8W9S5KD'LIQ,C)!*ZAQ(F;><NW;?,SSR8YCE-R$^FU<NL&.B3<
+MT`<EN:PSA(P[U98S0CS*M#*I/@19RP[NNE)RIYGJ!@\\Y7O)4CNC:,IW>3DP
+M^7<\$Y<W<@.LO=&/AA6V29N-=C%MU,V55EFU.*IICNF185::Q\+N[G,E":ZZ
+MHJ.\WB9$E$;:,BVF]5#MNLN_3-O<OV8\L%U.VM74KGJFE5OS`))!K&1+]V&K
+MY&Z"*"F[4%K@_,K%3:4+$=JKWJ',4"S7471G7=TV[5\LW-7":Q3F=B6+;S<Z
+MWQSBAH!B`.B%$.^>C:H3,5>7F[75?7RP=5SJVQJG@I4O<T62ZK1H6EVKHL.E
+MV]*,T-KMY;/)2)D5&7%*P:31<];2LB15)YEJJW)E\<)1ON9X-;7=8+!F1G9R
+MRAMCIW>I[2WB;K9)+JM.:ZG-L*=?2^.YFBV>;JN%H]<U>8EHX*N66K"<O21A
+M,OBA34-IYF`\CM'!;>4:66[>K+R8--Q`TP3V3,\QV959NTIVMA$$$&"((!$$
+M@D$@TCE1,,&G>&LVE*F;879+YMM[V[&V-NCW5-SB*4PT"(5H0)7.35VPE:AE
+ME[+:%96S!PS$["T)E=-=W1)H2B5IS;S1P;!NQL:K4R^XA]$Y(GM0$US&VU86
+M4<"%6XQ@B],BY,YC"I$2*$@CAMVE9<4<,3DIA@M=CY32U3U.V`(`&<9&3@SI
+M*GGCX),H:+>JQTW$#*K$GMJAK)8=63>]U8!+`@=5+DQHNP'CZ9U*IQV+UT-9
+M6G*2G7++:"T](5U$YEL;I]WNLJU=3U:K5T)D3WG8JJX<#TC=1L$*T@IQHD'!
+M;#W1>=7%F.U+:X-MKLRDCNX*U5*.5C4FWNW-U>GJ2-OELZ,UE*ZMGF'':)/9
+M6GBW(NG=JYYS+.XYN2CLL@[*9UR$M0D3U)W69RR4LIVTE2H*EA!<S.2IT[@X
+M7-CC?5O=6+7NW5'12PCA84C=IV\=Z>E`2I5AAD%7PWF;1P8#I>9T,&5JQU98
+MM5M]TC'TT1-BQ0L2P@4#1O10F:"(V^M].$WBMQS>WEJA6F\V%77*3OC21WC)
+MYNK=(S;M&RD+LF+*=%JY5R!85RG5Z[1!F)H6LO*MLXXL)FZI$R0LS#54;J52
+M,R!((!`(`PF[E*D*K<=/!QRT>S(ZJ8(4NR;IAD4"[^ZX#-1/H+)0EBP#`'HY
+M68@68A\*&BQ0B0K<,Q[=W:X@6$A)DP*Y1#Z=)W`LH9(A!TX(RXS;RS(9HYKY
+MX2J9N5-U-*YN+G0\NMX8N7:LYV=Q6R$F4R;^%\I%2^ZK6]C)+VQN9I%^J]WK
+M5+K]GJKNQ7<VXZP;YS.9<NMNJ5X_2L8YS5-=);S+G"-(G#2RJ#MN;"L$B49/
+M+J5)I.ZOMRCI&'KE]QZI8J9RER%AN:5.E>)3435\L2%=73-JM1V^F,.6CMV!
+MDNIUC%>%6PEW!3>D8))JI.BI$T1I8(XO+%3>+EN&<O!DN<(3FD'O=DCL0ZHT
+M83J9>D7@<JE@*Q19(I&J<]NY7$P#V,9-[-7.,(CG6,&-5,:G.NK(0J`$P\1,
+MP!>4IW#)L0GV4K;JLE;=8)HXQ5VW6*@[I\E8J'R?<YMFD2.Z^WE73UIK1,BG
+M"+E.3*<@F]L8)R:H*;+=8Y4DL2E%8K8B!<W1>[TQ'1J&$R,J@=(-/$&P!K0`
+M<Y0Z+O1!CC$`.,O!V]A![M5PKHS&29=LA!@@V5='1+Q36:H##-CAF1M4)T,9
+M:X'=KILA:D.O,S#;=U<I#CD0!I$1!,"!Q$<UQ64N:F5;7''HN>ZEM\9-B9Q=
+MJK*MX<RE54>RJ0G>Y97=>SDLC1V&<."SVGGW)-4MI2%,]C6GLO%Q.[,G>#%S
+MCK0AM5=[=VZI.;1%O"Y"W)H3H2P(AMOL[0G/3W<15++F]%F>/&PCKS@JZIZR
+M"+I7JDS>&@<%,BCIOPEU(^TA$"(@1"(SZR[%?ZEC[^@[YP(!1B:'?G%20??C
+MMTOLTVLV+4R_#'.6=*(KQG&Q+#WDB2*C8<@@LLH3#A\^OU^CUM-NYKM?6,0C
+MN3O/`\?/;;?,MU#`II0KS9BL5`1(_OR,']\_;XC3,TX1LC^DS4@C^Y!"T*,7
+M*BR)K1A-Q/Q7)NE-TY:-=,ZT%?9M`M!TJMJ]UA96L=BQ(;>VA(NU%FKF3LE=
+M=+"M5%HNM-#+;7P[>7-@^D*O*AX8`!F9ME-O.)Y,/KO(])\WUC21034R3$2W
+MF.>O7OKU/6"FBIJBI(JK)Z@W*.W&;ZSWV`5BIB'N_`97OW"5DH#RRKDGZ%6B
+M+9&JH[V\'(PC*I2&`_0R]>]>(=4A!SI)8_A^'FC;M(X**3',\7#1%-'`\MY&
+MA[)IV,4Q`0GGI=(EP1J#524789\^6NWG69IIJJ5&RI"0I;<(E<K9C&V9'(22
+MLF9,-]_N]/T+]N=7X_7[$XCE1V\.A8&)'RVM+)(*2&2L8+JO;._ODYN8V)TC
+MZ$W0H\^X4!$O9.W9L\YW=F<(#=,"B3=W4A1/#13![NC,.-:^8Z:.]4X#C'`$
+MZ@.:S=F8))N6)29EI1DJ;K4)RM8>53P4&&!S$SMS$7-\X.%^CU[01%,4011%
+M,3,S-555UW5TQV%FJ(EIH*J#7/C9]OB3)BEY1VJUA@BM!MWO:%VF2JH*<FBD
+MR53$M,$A=^WW=\\,%1$:#5#W9$I:N1F2_>IC2%P$4U*)7)]7KPWK8Y%4CBP1
+M'W988N#U(XX*B@7.<M<W-VD@Q&YWR&,)A`I1"6"O1+*MB1#??/PS\*].?*)K
+M]'QC[MWJ?7SZ4.(L,P,245K)(@6OLV"T2C_""=?R34J:4MUW7AJOI[4R9E<H
+MH6;FI0FRS+XZK=5NR'5L*K*QG<:HN<3I4+QU-;.W+QMS=R92I&5-&XK+LDUE
+M`:*JW(S*"JPVW;E/)RYWBLL9>P'U7(E6@N=F3=\LC1AQAFZG8TZ\RN:?5JIK
+ME#5](S+N8<A9=:Y%8CB>)S=:T<95\\O,Y=([*N:ZW84W4N3-";ET)9UN,H-9
+MAB;PFFW@D]6WU+3JKJQ)1/"HE`:]6BKPFLRE4MNSDX[0J<*.9++(DMY>D9(>
+M91P;(U;=/*%R2A5C;5P<A*R2-&9M]04A23NG.=Q?8+OJ.N4VYD)3,A*RKJR\
+M;IF]2:SR<%6S(XBJB(A4$3$D2/.Y'WW)%%>_.-S143QE2=F#8J'&O:\+I@I1
+MJADN7[WOBE8I5(;'LO=5B%[>&G-YE#)%6-0U\J+W!5-R4P^KS[\T[Y*J5I1(
+MQC&N,RP*(K5$,>OOWOUT*0SBQBC4UO1+Q.D8V*=LEC/VW?KMS6\-1%5;54P4
+M"D6Q)9QEQQ;7>V_9\A-]CR+<6E^"^+B"7@*:.1W@F-&10`Q]=3\%O8R1^O?R
+M4[=-BA0NY&4/VPM4%*4Z]+$T+2$A_%!X505-U$\MF%5TZV;CD.QO2AG9$]36
+MZPF\M9@<[H5O)9&V$9E55!5F.*H40')A1A!/$#3IDQE-P"VP#J@6<E`:0=4=
+ME,%*!IC,KK5"Q-%"KO`I@"N.*=-"UV3%39RAI5B@;F,"D4*E\^PGMFR$I`:F
+M9:$XD`BNI4!3KD-EV!MX*%GMW1(NPGI(D&A;$V`4S6+=%;<SED=-4>5#5@Z1
+M\@3E2Z)7E+.UV4S&7,Y<CBYRC0R<K%9NYMT-]VD@]!(")2CD]*P9;.Z[0541
+M1155015&*HL8JL=6J;B%6*66HE)%UV"WD/A@51@PZH(B*B*KRW(M@JT:((BJ
+MBI@@HIB:::[]NO7<<'!04\)@(8Q@HJ*C*_=ZU7;,FHV9`A544'""5)A]/0Y3
+M6PAQ/7XXXH=E*:0QY+]WO=3S%M+@VQ@AOR76.":C$.YAV^=P1-H1!1&552H>
+M?&6MM=_#GK;'R'KT,O)*.7FDFE>.*MCC)]>';BCW)ZN0Q$K]I#!]\&/6PW1H
+ML41_*9_B5N*3C('6\G4A-Y,U2J218L5*S#(RK=R1Z29SL8I$2Q5H#,BXDW<0
+MI,/D+S.0Z0W"2".I"LRIS*&396$CD7I?":$V]R=.4LM]6OAV;2HO!=YJHD7A
+MKC7%F6N0DOZZQN4J+%1@HXJD529*:"DI28*`IIJD**=+;2P7$%1@+$$4BBD1
+M%5%=[&FJWUNL\RWEY4AJBBU3_)]O6QTS"4`>R&AI3V1M@=6(P'V_AN]H)BOM
+M,AQ'AQ")P>?F8>]QJD-!HI(D=!H"(*+%>8>!PQE-G61!1:%('>L@*W.?-^+L
+MVXDBPZA:P<9)AEM+]OVW>@VX%,(@?5Z>W,YN$<F6JU-%FK4V9:B6MTZE_9Z]
+MO9Q?K-9Z<!WVN599F!A'PYE'#UD$^??1"LS'<,XE[@0>,3(DW`(J<$"N60N]
+M:WLS"[D9W*_"$11<YNDIA$XDQP?I":MK@E@17&S(U(JH)U*BE<9(;AIWK/D=
+M8F:O,FJ"O>#-%7,]CD%1<QDJ+;/-J76(IB]=,+R]1NVF?>T5/D[S&J?4:^-I
+M@F->5<FB)**)BV=7O/8X5!1[V8@\V6*BFM'KUB@[VQ%[CMBJ9IO4-&X$<7J0
+MS4Y<@GA(X:DR*(>QI[/N?5TF8?)\CEDDQ-\V'MKW)H/7QGE-O>$6N0IR/4<N
+MR]N>8TIH[/D]D[/DG>Y/(?.8^(XE$.GI"N9X8.;<B'4W1MH"(:;8;<B;2#GA
+MPG(IFW,VG$'6UH`HY94-)AW9XY#(G.Y>3GB'3@*9$SER"D]RO8/4Z3OGG"E;
+MF-)X0_%V'YAK0E*^X/".0)\P'9YTRL8PVC.(``D"I'%R$HAF!1`Z5%=;DW"8
+M`N;3=M(4W:)ATF1,U"+@N9R-5["3%K%0?&PWNQ[ATQ%+S6[FZ=2F'&LQ)J=I
+MIQ<Q$KD$ZA%VX/(%.^6H,WF]9H<CDVD#>H9<U.[G5QZATX:3N9!<Q'M.TU=4
+M1$5!=N%LP5<3Q:%$RZE628X\\7QJ<8"!&&(QC'Q:4489W86&R4DG%V\$"(NG
+M/8S(R(\^_61"TE(144)5$0LRE)1$E)$-.]E7''32=6;\6@"@B'XSF(B(N[#\
+M'[]\D?H^36B!^"_7JZ`[\9X`<-)%$9-Q%RJ(1N&1@5146HV*&X:J)%9#]RY2
+MBX*Q4B3!-KC8,8PMA21DR5B#`%^SY6NC:R1R+&$A""9*+-_/[GRUOICU95S%
+M,$$&0;M'((JI*7G(QRJ*G6F)<?J\>'AW]WD\W&_E>.O"4Z^M'`8HNF(X`6;>
+M/83\M_L]6FSIX&VF+=L4B'^2ZJ;1*(!%_>T]0*MO,\"TYAU?2W<:PSFB\U[;
+MN4.*V,X\9U`U;,K:5NNMW.S#>K$7!8G&\`FKFTG*!*93M(R6R%$S,B?8Q*,N
+MW9&RC=+I31#!HA)!)1"(@F$5B!RO=/E]R5;"^^8^ITE+4$!2Q(%)5%*TTT#2
+M;ZW(`F`BZ45(+BSUNQ6,?9Y9ZX)A%=&JHGCN6ZMR8\LVUJPVARTQ6V8H*-&$
+M9'GIC%\`H2HQKG,Z7Q4IA54`YZYV/+544U3I'R=PH6QK!C\OG@]@J@H._E)@
+MY%)Z5XF.142;[NF18O@5(C&4WT\>+;V+;=.V5=U.QO#,12-]8#W9<SWW0`YJ
+M!W".8KJ;H:#,/08*_`!!@CKNR/.?%NM#C]`,'+'PXZG*S+G)%9;*-V%E!7.)
+MQ/P:>J:@I56UU[<9)X2>PZ:G&-"&[EYJ>O>)E#IW-H':;+[+-7N.,SKRP;.-
+MG"FD;K;D+M8:0LUG7???#OF[%"`XBJ+BBW-YUWY"N8DM!2%%50D252T450M)
+M$LU:^+M?7M/74B2A2ANF^W`/Q@Y:9J"A:?2<-WN>;%$P%4M!VQ1IS6K:.)A_
+M'8Y6V*H",45%$#SYT70#BS-[O6^J\L*FM#RY!N]UT,XK%6*IVIC6D@QH:[^6
+MSV(FU8F+NMSFDH($4%5&S`H?!QMMU],N#COUARQ$>_,(%*"!!.1DR?;VS\!+
+MUES?P7KVK$O>KVQ@J5+/T-8)FQ\+J7SW7DO))Q.,.YB8J<4O=DEZK*ZG)O!M
+M5(QZ;M;QK7JLH'6X?!QF*H$I#&SIBRSN9,=2)(8(25O5K14T;=6"CJ2SPB(H
+MCT2>/$O6\V=7/N/DC0..[$)5`1*5%01,4U-11):+3C!$:U0521:<?)LOZ011
+MMWZ_G]\F\U,E.K(TLC:Q:#?BTA94!8>/C4LB+(JJAG50XZ9];Y94K!*2=2:9
+MY8Q)DRF"R4J*8B3#V$.72UF$7%15(C`A144Q$3//WY[#5'>N]'3=+13,A*8M
+MI7GKQMUTV:,^UO+7MM?.;P#9)-4##O>LJ&69#$%),@9.'TW[Y\==KX)9OG1^
+MS7V"O4YO)I=/.]RD6]8N2HHF;>4*9O5,Z"]S>XNMF6K[)$C:CMV1,BJ&*J,Z
+MA9D$D(]KN!$#>L7F3<(T0)4U-R(C7*81%$B2Y:39:M55'/D5)O<3ESFW(NY5
+M66ZM--*IK"9AMZ]-HJJ06;U0HK0E4),D45)SY]-*.R5524BJJ**+FD\]$#Y[
+MZDQ$:'HVJ1JJ;GA?BV+1,*K-NN,8Q0QBHQJGK14Y6(C5^-DY.-BLLCXA:\CO
+M(PJA]>IMV",=T455186QHY-X>+H0T1!01)]'*AQ`(J"@?3S]7/:O&L2U,B?#
+M&SM">'H-?K`P#&+*%\PQ@XK&I"V^S(7EB7&M_W;?]/\J/]KQZ?CS*?GZ_S=_
+MW;XGYF;+>?:^?W_Y8^NKXHJC*ZI2M2K+'4*KI9L2J^*K6>^2:-EB=1/!JL)&
+MIK(M-%-$4KVW]A!^W[^_SZ\^$?(,^^?<??UD]OSIS+GY^?Q]W[=CK0CEK1RT
+MX=J=F\FK+?JB<4IB+K=C[+R'T\*)`B5"^4$)E/6WWI[[TW3Y/U_0>@]U]G[V
+M-EK?F$XPL5MMCJ`JH*J.4!L-77I<ATLK\W.TFGFTE*5".G`:*9FS(JD*D52)
+MT?%\QS:LV,)M$^`EEF-.5)9]>;@EDFDNTP+,]6U7I="U%%%%%%%K(X[2!'&S
+M,SK^.Q`R[`+\Z@1IBZ!_HX'PT0)2A$4H[ML":9<"*D$`%3FN[=TD8B(,(MBN
+M@0!@@#:JXF=9#@+*53NM"QM/JR+#[:`SI.Q$"!FJAG`"*`%F#2BE&"5%4Q."
+M<RAM`FC*J@13J(J(A:,"$-ZS<Y%CA@WJ'5,Q%*(,:A%B)@B(B8&O@+YZ=9D@
+MXAKL.5KY5.6Q(T"+"GL"P1)0%#'Q0941$'H/7V@@4.]B@6.[WK%"($^8DV`D
+M!.0'+`UQ%<,'7K@=@`$V,\%@61`&:QF@>78`P@XB:ZQTB$"4=$1&C7`P=72`
+M\98F<G3,;V=<0*`?2(%;@H9$14@,`Y$`"58(40!S!&4^F5608#K!/&0*`$3E
+MN!"$;PP3&*;R]L7M1$3?#,S;`E`=`"K_>C=27T-`B!X>PKGU!9L?"`H'R[&_
+M[L4!(QX('VXTQJ9Z-MLM[5)I`(:%`&R!%!6)%(F*)3P6!9A`G8(9D@),'0$"
+M^6"A(04(D04D@I)!MAB#1HT:-%L:*-L&AI"FAH::&FAII"D*!H:P(WT<Q%$$
+M$/+/'I+BGB]3D]$US6NNQAF:OYNC.,Y6$=BD<36=DXP0YNL-7,Y-546%>7;G
+M!?6^K,RIRGV]J<(86$1DH,C5=W.T$6YI5F%R<YC'(:;I2&G@N;8$AXK=4ZF)
+M0*.6Z6\K,FZ=BJ7;Q-B;N>=QQQ4)DP8*[N%3/8*G$=)U\9MS434Y1I32,W8*
+MKJRJG-%V*0)*T5O;.!]FSFE22#+Y:B]H.;9D5=%5V":F\Q`.LJTN3VML+.<\
+M3(RPD)-S>&I.!M3VS=XHVAC0;IPY==ULVS,J!3VAP-BG1[;5,WS2O@MZLTU(
+M-FMQ]5[M2M,).'.4-%"J6R%AIO7(XH@<$*%KE178MV[O%(Q0NL[:N;WK#D7T
+M5(G-V:V6J5Y09XO,S1DUM%7>YMB52U/.Q36!O!DNCC10V[O<SL7$)5DJ9>8[
+M1G363,2K%>Z0B363YHR41T;9<T!WMW&GDWM^N\@PCIL+5R11E1PT7YCIXO&@
+M>IY[I#H^Y\,S<G+$C)Q6]J#1O+YW72.:KCN=MV!SG;T:1MB[4]3M,U=R1RYF
+MYJW6=<TVIABS<TJQ/;OJ53KJNB)`$8(<!@!#2QQ?9N3+JZJP^XW-Y6G$=>T@
+M5U](Z[@F"=%35SJJ0\HJ\,\DQLR>6"1?;.P8OJ+T,,$\LQ#&#V1,67)S)RKR
+M\A'K'&@MEA;EO*D'+RQPH.MX]DFL0%YVF..Z'1RKN8U`<<RY?(9=Y>V%&[1F
+M=N]L+".*UQ9JJTCC:TN[8H=8Y:9[G$[8S4)'4<)+Q2-O'C'36[6.ENV=X6*G
+M;3&Y82IU(G0&^H-K&>J\M;TM<N=S;PW63,W1FEIMRW;LSG2>SK%U53(RU)!#
+M&9M3SQRZ=R=Z0;8XJ2)X5/.E2#MA$]5.T4M)5(W62Y[+H7G*ZR!/=!NW*S>5
+M'JRWM7$\CW4EKT6+Z9KHM2Y&/*&8Q`$"=&SE\JQZ'$R9DY)M$V7N(4T0*-$4
+MWG3ARGN"MFQITAMVG@_XI'6JL@ZT4F6%[N0DA3:TW9!]=K&"]J=&K*W"YFK;
+M%+3MN$"FI(5$[N(L3EM/5V8[!2KLRI@2.GMG#:"VMG=O*[LH[LKJ1;<9!R94
+M8$T-8L'KU]HXS-G.HHD!ZJL5C&9,&U@2VJ<MYDXCE.AME(6-!T4-9WCO.N9S
+M1VGM/#LJ9G,SN[AQT9RPQ@6W-=LH:C/%3)#C-NYGNN;S"IK16J="J,X]-]VY
+MRO9IXZ5S5H9=WHLG*P)DUEB`-@(!3.K=E,U8MY1VNTUU/KZ:BU9%Y-(C42))
+MJNK;32.56M:LUB:=JJ6MV"%M=:D;&F"TN)E(0ATX:2-3KUKME=9IV:S1?5>C
+MMW--1F2'1=)95"B-HH@W$T[JYD&;G;UFE8JAVVFZ*<]-_*WI]F$EV^RW?4/"
+M41/;8G#NFTQILEB]KLX&LT%X+G6IU8ZF42@L$Z#/6JU%`U*R5G-S1'3+5[H>
+MG9G'W17272"SJIWD]FV<K=3+U-473/4;D.:9$I6#<,619PF07B&8E;I9%2)G
+M%>WA>T[H`J4I(>*YIXYD](6LYO:T$)WJ,)S1[,-;H1O>-SE#EA5U3M"E,VBK
+M03H9..G4JN[-FC,SD0))(#X87A9J:J9P+L83F<$Y0H"1490H0V#4BS0&3F2'
+M.8\S#@1L,JJCMFLS)`FC-9EW0G"I`;6))&&IPW=&3<VZNKP5!3N15559(JJJ
+MB@<F=\-+5NF:[BYG0KAV]*J%<(YMS#"VZUAJ[WO<5W-V*N2&9B(:\1ILIS4>
+M1T\Y-$0BJJJJNG&QDU[=^-YOLZZC1<==1,Y>N:B!4^T'<P!Q2&'B8(&@HM\L
+M!*%];Z9!PSMBI^9U=UTYP7ZC5(&[",VJNJ\"[I8ZZ9I:*=[?>UJGN'#ZISW8
+M]K<VM&=Z%9J;%8JZZ:"2+62N.*E8]-V*"TZ=G##>9,H\02LR^/,YN!TIG?"1
+MHD8=;[B*D;C)(/MV_9G'<6NF0MK9W>F16;1-![E<]`,I&:JZV1<F3Q!E+5I%
+M;R<X9VNN`M0P9P!1<TT2.F9*.YG'=5B=6DG"VYMIPM*T(G;4L232YH55+3!%
+M6K:[7>5U98GBQ3?HVG++[)#[FZFWP(+\[GN=\>G0;-*1ML;LBR%,D(5I6-3*
+M!2LGFJD!\YTO:BY"'J5UESH,]C8?>MVJJ^#M=5<#)6RF,&SFY><UNPU0-E33
+M/%N:W46!N6]Y*5JIC,V3="R[UQ5H9EK7HHXGN5K<Q).K*OI=;TEY!N]%QN/'
+MU:7:8O'/#=T5.WEX*&3.LS487;:%8BV3@FCKHF)P/+=`@;@$9%@8!?0+%WI.
+MY43S)%3URJ;'$2+%-$@GKC"*OL*;/"3D/*Z;D7*-5,SR%UC.FNP*A=5B2D]6
+M3.]M;-%`C9QD,V)0Z;9GD)D4;QE:"DNV[J0JFJ#HY8YR1LMG:DS';+%3F2E.
+MF9QU35.7:P6MZ=,75SD)6<S'=T.>Y6(7F=>2A>]55R.![1(O<!4K<L9.-F<=
+M3U]2OM[$^H-2^"FJB]%@7JWWQ-T-OND.N[('OTYXU;"S+?4IO^GCPX*K!\)E
+MXD">F2*9].U=6VFVVM.VE1J2A;*EN=Z`CA%!145$$5^O>^C>$B6$XG!^FY>Y
+MHYG=^T^V%>V/>[;SK)PRP1G)K7IG%>S<P;1%K-5];1R=INZY31>MX1B.D31T
+M]*S$.,BBR:B`*J)RD<!)ED&&<QS)H\X4$SSAV=R5>.<.F-`+@Q0N-8A#/\>^
+M2HJBR*+&I(BAIH*2?C>O67K$7J'5:SA]=P_%N"Q(?IKZ^>]')"/$*^-[N*CH
+M].=:VBIL#]C^I+KD)A'(*-W3*(@\^-<[WQ1Q''K/TNI3CL5P53&F';O1'+JQ
+M*7/7MOG@U1CFRB4RA$6DI-"JBQJFVQN7'<*4X4S$1RQ;&JBF,4I:E*BQB%4'
+MXO?M^/3JZ7-MYKLD^5C]9?V\\>)L&2`B(*4"`Y,`(@DP(0F9N"0('^.O>H_J
+M=^<>WX[-BM=]*Q5<U>TT4)R]C+5WR=(Y>GE6\J*.8:+E+.P2QU*N&!W6N)#=
+M3G*)S,W9V;@]-1=YA=MS<G3HLVQO:G(2U,.Z,LSDZ:N@;F\FJJ.K#(F[BYK8
+M68L-3?59P;B`@2&5W#JRVALB=K,HO-*R@@P"P#-QGP&I(D:HJ^<ZH**JFHHA
+M)6=S*]^)DE"B)CB"N+MGB?(5%`7QQX9Z8R!16,:_O]0LQ872E8TI356K6-L:
+M#$L044-+$--)2553[LSR:K1C&G]N='K)4OKWZ\INP;,&JG.L&,O?N/G]>^H?
+M4L"5-`U13KU:J*JA#XN\Y9&UH`*B,54A0U$B"1KMI?/,Z^777+7Y.9IX7MC5
+ML08P(P#EJ[*!')*DE_P(0NOX%_ASBU]-4VOK\U5T:N9W!/7BT5?:GIL[A,Y$
+M!&>73@-$(D8;!Q[LY:J1G8,TX#MYT\[ZS..6<8)46_"/;E^&B8P$4*31Q-I$
+MN010]6P39D41%4C%8BHJBQ2+!CF:VUOJA899*1F:*0OM'O\+SAY/76FK'W[I
+M%=C/;!S8IT-!B2("JITNBDXW*>8T:Y7X_I<\")EBZQM.I1C1@T1HU3+Y<"((
+MYBSLV-:]_-#3M7%R9>$1%*FF4I)E<6L156+QGSX5UK">F4[:=MZ+][MB79(!
+M&00Q7T0@J.`8.'L<Y:3TYZ:DYV;=^^]R?:-:WNK:=7MT4W1%5M7LS:&`OAJ7
+M/*L8)QND.P3V*JFSADM0=(,S-'!CB`$LUUVDQTH+FP[G3(DL&$8/*2):!N$*
+M*@^>?0.HHBJ&FDJ:J6J(CCCCEOK?()*FB:J)DA3NB%%3PW**Y;&C(@1(CJY!
+M0N9]FG4A$E)HL(**JEZ^F:JBE*8GH=GG)*I*$*/8<"][D5'2TU3:>UPS2G)-
+M46QF#]ONYVHBKP\6'!1)2[#%55!D1%51$8JHH*H#:^GIIUU[\^A>?S>*83+I
+M/$>C5PM()BBS:$O2,K#"!?BJOX;">.ES.^JLXR]I,AW=1O[T.`@9E-<:KD]I
+M)$(VDIHT,+RQG49-.1<LUO7KI!P-D;LWU;A==S<DC&,5)(]TZ.&?<Z[]'$P4
+M-J.EI*0I:*2C[7VP9/HCI"3%4E1)$GKOEQ?9[WZ^_*"R&C8+9:-SN'H0\7.H
+MC]CW^OG3R(BP>>PN:7!5U0^R72.(+-))*V'LQ&>G/6B*IG<AR2J2A>-.#HC4
+M://IVL7R8#%IJ!1?!MOY5VW^,ZSCF$-];4[O%TJUPJT,5:>%PJ$5)>H%`DGJ
+MC#3/<C]UOO3^_P?-`K;ZGINV`>N4I5;,V4<"TTYZA.3NOM(G355>3)%\R9ZH
+M@"C%G<."<M5OM#5F,KFU4:4&>T-?':$-]]DB,%$I@B&DHI/B`TA23)7;1IYP
+M*:Z\1X'28A$I,#54:VY:+@7[OZUU/?Z^:B"MFV*BJ#FBXU$BKUX^>^M\5>M%
+ML@KB0417&'U)*DU"B0&"B%#O1HUB*=_27C,10F9\;M>"K(15<5B[A<2R"*"E
+MN<,)^WG>TS`47<0>%4H<SFA(2+&6P(F%$C!",A,(J8I9(4HBQ`Z^O+5[7MI>
+MVP:$OHC'!1OC&`+J2JD8T$J,(!,8P!I7CIXXMHWQ:T(@61(DDK&PS%2I,F;,
+MAR6T4A/\9[;S&"*LJ5+$J(G<F]MH(#2C9%#N<\5)DBKR:H@"-68H=6]88()"
+M*)*,$'<NI+R0=3C4CTQ7.M1:UN;FA!>7=Q>]-,D11BD42@RL:;;"*"J*I$E*
+M0J)3NU/+U`9"Y$5&C0KCD8*CD\,Z<T^Q)R4H1`C))+[?'7R2JF\DHUH-&VC9
+M',D1)'%R#OY_9S1L>,81(R1PGA+B*+27`Q0XHC:;#O7#BU$4-`4:V[>GBWX3
+MB0RPB2*<F4JIB*$T(EK(U35"TTDMVX->_5]?;--,S:%20P]I`$\?2X%4<+)F
+M8(J$<R\U3A\\RUHGYU7^^:E=S4V#0*#\.X&,%0\7'<D\)IM:)=$LASG"I#MT
+M=Z=Q*VKIWI5%-Y-R9YL]=;."W9VS.4Q>BKUXU5D3.".>7.RN?(/9IWQQG*(H
+M1Q)!,5(]1L$&5*!HJDI2FFBF">6BEYL%7,:%I/J30E%+?@5Q-4T'P?GMQT'9
+M2(0\/UW.;%3B,D*.L+2A)$9",;2`PA)(7#,),5'%2/JZ,^.N:>9"0W(UDMOU
+M0UBE%%H84Q9+U19"A,7WWZ=>=S7QQK;@#M.,=AG7.2O`43#!$4S!UV%2O>BO
+M\[^NT_ELY(OZ6T-'PP)E*5ID]52II5?5E*Q:H1`BFS*I;5/K)=R^)8#,@U>4
+M@>.6L:9%[@J\5T33U7MBK&;UV.0T='+Y#&-DTS*SOI:7M%%4576:0S15""I2
+M7UM!0E#2524GN??<MUPZ=%)?&32\YQ1^K\H(E\_2Y/"-C`8M#K044R::<;!H
+MDI*@J'\N<"JIY+LV:M:B+'U9X(N2,Q-=:KH&")%!B=@_5\]TW,C$3$1F%F%$
+M2V_7X];S%#)5/=OTM=%-$A16VFO&1ITWWQSX;=L)P<=.._2H8A`R@H,"4`B!
+M@_(_*XKORS,W/#S%V/OY,'@>O`[ZKZ^>=<[+8W;U3H1%@J;520TNWM%Y69IN
+M>FIP7!'2S8N:H%T<RKV6*)RZF<12FN0XC:67LY(1N7$WV2RBL3("[,D16(:2
+M1-"V)[@G71FFAAPC@=9%C3N5C%[:&R-<[C%J[VV*#4SE50+>Y-CE;>8]Z7D2
+M;<Q<ZZI9F]K"&].8R06),QQ6C9V[V6N0OM[EU';-LGEQ>9QG3M2;N3ER<%*W
+MFXZ>3,M4@,SJOK1%7E8X1)*&,6S2CSXA-F"BP%%`50(HK4_:!TDQV^H3A`=E
+M,RT47?CG!T>HJ*BO+"CF*BH'I2%0'"H%2)UZ%6D+BQ@5;B]U5BC`KCMQ?&"B
+MBJ=!\_?QO>.**.;FX4+C"22-,6AJ';6UQ159OS62!=(L"R1:4$9:]2.F=UBO
+M8QJ,4;+3+!2\_Q&3H,O&L5EIOW.K/N7(J[FOK=V2W?3M+>O[\E:B>>.)RRU6
+MH="JU,DX]U-$[I'NDGBD<KIBA6I4)*C%262_IGFDD$J30*KYIZM6>F$44=5X
+M^BET*LSECIA5HJ3M%'4JU1IZ8Z1)9)`=5H<]VP%K+",DH@U0DMUVYTZ9=7?K
+MSVX#;O6E[X;URAL&NUC[,&!1&X(>*118<HC`AS10&O@5M>BB-Y:K#$<DG\54
+M"*P%E@^")/R_?YEMOX]`?Z6>?^K_A8!-86AMNJJ!:4<6&YOV'M;UR^P.4Y^W
+M,'&://KE6<G'M[.VJ(92H*HJH**;.Q@OA)K87^1E1/E,92SQOJ]'M*U:KFT-
+MG.L6F:%C/Z"$EZ$=2K4J^ZL]TFVIH6JL[G#-H;>T<YHQ^&8"515!7=O\OB_C
+M^G\KF[N[_I_D$A`LX'"_K&]'[7E](5C^M:/@]X20+00)\E#(F0_;(\IWV:(1
+MR=9-!@8!6QVV!%8Y"ZJ`7#`'.8R,T[T#''#0(`S"O59F_!Q6W.UVNQ?F5G2W
+M&T`&+TAI`S9"QH28#.Q5R7Q((8O-XP+:)KT`3"%@CX^#!B`)ZCL1GHFX$`.J
+M#&BW3RE8:.@3`BK$2>VN((MR9S<$UE`QD`;Z,@#ANB/#8$#JCY\ST1P^<#4;
+M`NP!YO8&[T4*ZL'C%1WAA$%781$!0@4,P<+$MP(T&7"$+MO")`!0PM;4;7`5
+MS$ASH,H3&@5L$+$#$\*#$#-QB!$Q0CE.Q9X7$0MCV20L][#A=BBPY""#'(`"
+M@!`&NM_NS?9:*-2QG(6LA"P;?AA09Y2TQ));7.C&T,3F]:YY\8,)"!#9A`AJ
+M25)M(R1,2E#24-$1"00K`+$P@20)0L$I0[*/::*(BBB"""**(@H@BB8B*)@@
+MBB())B99B8F2:HAF)IEF)B9)IEF6(F688P&+&1B,2*Q:DSW==,%8OC2]L&RM
+M_8G-N;S9HR)&5MF`!20^,7,FC.92$[+1VQ-BLQ]U]VQ0L7G34RLHH[(K!(/1
+M`VA2SF9O$>9DH6)&Z,J\P3IQSBLR*ESMS9G;N#!MT5IWLEVF)J^D\=OKT"QD
+M]O39I8)X%BQ6F9S:T1%:>[@ZL]KZ6;RZ)D4,MS53@`0%3VW10V.P(9$L[UUG
+M;1V]&-]LR-3UH+-D+%2SEDPUE5:.;R8,,2>X0*5]M;.6<3-YNX'/7O/+'+M.
+M2I+=,]1Y&ZF>CA0-SNX0%L[L](*;YVAE5U3;&,[L$;.\*O:>*$0WE3IW:T89
+M-'!9NS6:%<\6C>=4W738FHFLH=;6G)EU5V;M#*&M<,(5R9UT97@B228F<@A)
+M>SAN3DXS=!DIYE2#+=4O;5:01LB($7-[MJY=E)4**XD&`)KWD;X^7"@_9M3+
+M:<]TM9,02S?;6%#KNBT#A5RW:6YN[@JJWC`6\^>%+L6GIO=S,M9G92-2=NXR
+MS=G3==;UO?7<NS5X4BJ)F\T*JXZPS8%.+G;J9D;=90JGHVFA>N=E4YVIUCCP
+ML=+>\")6D7N5M"ZWAE5>53=*RKU*M/4GUYN*2+-U<[/&DEU8.5;"QA.=R<%S
+M=SM"ZT.3.YLS*13J9T8W?!*M[++W<N9=')(JQ2U9N7U*<[)5\NMTNX;@O#KV
+M9V[&SLU8U.G8N^S2-L(\'BK,FG0RCRG-5H7,7LJ]U;VY13:9M;VY&S?=V.LZ
+M073S*V[54$1?5BPW@+=#>OF[U@"Z:/*QDI[SS)U"G8GM%)-7Q5T9VI-*AI1(
+M.;(E#9H#2-FL12ZZ58JDT=<(K5EA]NX;W&BY?4T;VLDANWR&A.;X[-LP(`@&
+MI"96SVTIS$3(R`=36+<52)>[5;.<9W$BCBLRL4I[E(%BKL6@Y5"E=!R'-J.%
+M<I)ODGNS2R#V&T)YDB>59,Y(L1"@\>L\LK7R"PZNIJ6Y>TC40-$0.B+$!Q$J
+M<0HK2*=Q,LI$Q=3HPX6R:%6KN0@30B$;VSE$$I:6^<U2J8JKW;5\YN;O-UYN
+M<I2<$:29L52,V#(L%L\*TNK=TZRHJQ<,+)MG0'PNZS<BE2O::Z4&-&Z'A9!?
+M'10D51&O'M[4LC;UD,W*RCLYD4</1,M:G4]=*1P:(H9BIB>NKH4;:76K79FF
+M3JIT9/$'Q$CV9L#O=&:M6/QRZFZ4VPV+V\65QT<7=O3N<0;'3F[6MR];'$+G
+MH)JC?"ZN=>!]>\MK4$--<65*V90H@DU6[5C*S<P;(63;"7<*ONS)6RLF9ME4
+M>X+N)([KV4T.2[JH:21TR$@:G)PT13JJ6@OLK-VQ>6\)1&*+=5.!].M'K%D;
+M+U3TJL7`=)N1HIUM$DY.`2!4[8X!Z%8R\@"7H%BR#6'HN["X<2"=S50I511B
+M*J@JJJM99QOAUQC/)DYE;;0>MG"BUJT9[PS-:,/M&UZ_7IRJGSY)U7N]VG8G
+M3[8<W73:6`[MDL[)3FML[=&G[N/8VV>VBI.YR=/L!RQA`>5M;9;MWP;!(W=R
+MLJS6*G>69L;4WM:$<6H[..'I$C7)4U@QUE&\OC,@=6N12F1)6RNQ:;J@2C<X
+M9I+3=<96U3NK3X4DDR+I#9O#(=4]Z17+BYGFCN],ZW04SD]G<2<"(VX*VIKE
+M5%'36=5DYUYSMD9(G-77AFKNJ2X+,J["5FI!E&BS,H*STJ]RHVZ>MGF,<UKP
+MJ\+.5:$[*%N#0OKW!6W6V"VF@:*U7)R>6;@2+8F<D;(>7IN<QH6J>]=,SF/L
+MIH*%H69LU=S*E9J>;0RK59F=V=U3DVUM2;K3)%-5<SU=.@]-@\AUW8?">M3M
+M7CUMPLO.-70%!+A+$P=!PUTTHNIRYS>%'-4X,=6;`2:0N!</=`8GH"71PVM'
+M!QW3FS6D)2AA5R)$JXGH(WM9.FI69TZW-L8<IG;>C,!M2.O9K14FZV<.9SW&
+M7(7.\UTYZ>5SM-K#+#3F=9Y82;W7P(T*%VSU;G.KX7G<#?7:YZGW:\`RZW7/
+M6]S4NDR=,Z*15(60D$)7)[,T072MT*N<$X,G#K[N&LY3.:9&:QFF;:1:2GGL
+MQ0VIV^J;1D:=XZJ$O1IGG;;+X*+&#8D6$;WH$\^STENV6U0AK?IKQ3UI+%6I
+M64:'%8T[:3J];&53+@+3G,_!L]G%L]IAQWTV0AFJA95!+IB0"Y:4LU&'W6@B
+M(Y&085(BK34\7GU^TQG55KIZ97MD-JB7I9M:V,M/8<?-82)V4ARYEMU=K($W
+M4YF\@KLS<XT</`YJG4+M]BKJU2HTG$$U$DVD411B:36/=[9ZTK`#V=,!%%$(
+MC@T&VXAVY8\NU0?1V#YD-4E)12!$4U0$5'O>^]-'"`*(JJF^54`?8>VW[#<C
+M[Z4:HHJHP%$E_`06?A.2QYWH(I_"6M8D"J\ZM5%5.AUQZ(8/)F70KMU.B*M5
+M30?<N&F5\!D5IVJ6+BHR5/'&D"883-:F9F@,I7\_OK>XJ*L5H3,7<E"1A&$0
+MDBZ0M%,&9JW+:ZYL6R)E/:>XJ_BZ'A2>'Y7OL.V#1HW=B3AL<G.L-<QJ"HV=
+M*D2$A(-M$JN3(6X9,HY`R0A%:+)HH;&<04:"VMG:Q6V:I:H8V"(MFJ-#0Q.C
+M(T4"(10$#/[J<^K?U:;96\:DGAS4(0U:HJWDPEX60;E!C*:\)SZ^+L.+VADW
+M\:H3N1T2*AB("=?KG',GR-\WXE[YXE1U#/ME_R%AAZ^4B=6JG8(TPRY6Y0/*
+MJ1YG3&#%U".NJ:=NG,UJ]:-SD*B$D-H;64E(R_AO;Z9>&F'CB;I<N&6ZRU,U
+M=Y6#;R7)T4;J?=9$T1I@V80-3SDE6V#72W(U"G/181/7MS)JYN9JFBQP0JK:
+M0F9%X!C[,G:4X'-2ZHMHL^E4*7((89(?"PQ=#7=2U=,.B72A*;1HG%1%V2*L
+MJA:=XL-[`8(5Y=#W;UXADXS((6^,SM9O7P5MX52!((0*"0-CH@^`!),!>W)@
+M@N:DXA$&0(./+XY%W@=8\0BJ104-'71+D/!C+T%>EK68U14R=YKE5&VV9^;B
+M,7+8SK6)C;$33,%%&QL8UL_/K<>E%#^_UWG8(BB9I"BL?L;',4[1TCA#S)Z^
+M.KR(*J**`HHB.PFJ0#BJ+*)151H[^QTWTY\:.MO4=<0XS1-/"O>/G[@\]&:6
+M(:['.8(@(A69D$`I"?(WZ^+K6EDKQMBW3%KW&UARM-ZQC%0D`T9^%FA8FVFW
+M8<RKKYF:W.&+TJ"6P\W,!6#"L9*6%O&>H,D'2$1(N^:N[OC-\IS#57>YMG,M
+MJ,IA@O7$S+2OCTURL;6SI8K(%!:Z!DS834L2A;0)@G>SG-[]'>/J+VJ?0?4@
+M4D35(EL:E0T1O:P%K4EI4BHP8S;;WW)X,4$E9E(A3\/1H(F>1B,8Q-%$200D
+M01-$A'Y?7#L5URX@8K1P!8L*[P58H97QC`JHDKQ241$1D("X<PIY^<-[4A\"
+M7CI!E(C8.R2XC9IJI!>NNW7C/M73OOU%S#<F"W&G-0PJ&5!2,2!@RV\\^KGI
+MUVZ:X1+C'X@$V0+$CZI#8T%!U-BJ</$=EA&;NG*RXEOFGMO,E):G-`*]<R)V
+MTJPR[I,,_20]U"_*-9)0*LAI$MACWG(:N;&79V+@IR*3"07@9OSG8FAB=)$`
+M^H,Q45!H?/'/2&FFB@/?JN#I/IN^V*JJ.(S/BW*21(.(0<8JTS%1BS1;8*I(
+MML116VT88J4<35%4&_Q?.144<U,".7Q*Z%P5!))"3/;TE%TJ*XD<`Y[_7]?Q
+M[[J3WK%HV36I*IEOWXA86-BBI54J\X[&^O'%[0GLBG:&K("IX=@<]>/+II=F
+M26)$+,$Z0:A(/X`-YJ)^?6_9OX%4UL((/'91-AS4-3EZK$B;J25LAQ2#)VY$
+MQID&,:@CX@)($RH-@\)$@E,*Q!6KLWCO6==*[-+JNL#VZF]3FB[VK>K*O@:>
+M8T$P9QX[K,'5>Z;-YJ`K*9-%_%3MB@'44I"MBG-S,\[HW?7:RQ!3]?0?/MOJ
+MV,-%&--HC0?-R>46S@SLFB?C;ZL,GDFABP501%F"^>CC+'CG?JQ0615A28A*
+M5B^[X[U*#KHQO7L07XA0?7SYTKU"(11("(+(2,9"",8)IK+SASC1108Z?NX'
+M:6".KD>MI2JJI/'2UF)A2FFUNG7FV2`K%RA77U6RXQ#)@L$0%A%7OGBL>.U5
+MQW\[Z9VY\=.NFPG2%6U&K%N>;79QXT!23$%9`60#/OL!@\TVM87'ZG![*.+=
+MI^)M!6)<L+BNEDYM=M<":W9E)T.&JR2-*X]HZ=V[MS5'<[#V<W)-MRC*DH'I
+M.`S+023`U8'@&8Q4$9&(,E\T*.EUSDS)"U"7?7&+F-1555<S*:9W2:Z[$IBP
+M8R"HYB*J''#GB-@=.T447%7%FNRFLSY&*@Q60Z;41$1A[TN*"MQT5HQL8BJ*
+M"/I^W>(43]!C=ID24(A7`]$T*5Q^4N.92$<5QDT96$]W`B25,?'SX_!5>;1Z
+MHVY4:=`;;6=%QQCG+3MDY,)24HA3%I:"A:8<99^>M_'KC+7MY:973+H;AQCK
+M138$5@*C'O0I4`L):Q(&20DSF<)?$\K!5KU;P\#:^6("7V[9WWU*:#X2[M=1
+M"K,0NJACA00HB:*06"3U*J1>B9=R>S&.*V4V\*SA)XK<.Z*>!Y:-VY#[4W3I
+M[R%%E&`Q`NX1P;529PZUA#^1[*I8,;-3.41SO#DTZ#$NC*NT\!FI\SMN:2W/
+M,J;0L\4;EH4I8;P]5.:42C;QKE)&5>`@X$4B0P&%4JBJH3/HU1317J72T%%+
+M5#VT.VMKUYV:!5CD<1$I".%+W@<^KGU#TS%<5)GT:440<\?2YE?.Y4DR9@L`
+MYX\W#"H8JF)%4%*\=;6N415E>.5Y<A*::)@V'?0&H-,B<<]:BJ*[L8T8<U%$
+M158T248^_G*25&W)C+QYOSX=^F^66E:>DTRYV2NAR!0^#`F597+@4TB,%!&0
+M62)OGY>75\,.@U<U?4%P^-^>YLNU8KKQX@C2Z6JV*2BM#>;,UJ:+%L*ALD.L
+MF1V7,@[BBI!ER#05`C$*LCF%&-!X:H&A08M49SLG:;M;IA;KN#16=*[0<4]!
+M=U/*;%5/7=&\KGF9H*J[)O@14U0DZ3-LG@JDSAQT6\J[++MIII.XFV@ATV]K
+MG3.659GY.=S][:CV>>N"K[7O8T=1Q)?1FTU&10%44%C%$B@I!8YM[0RL4",1
+M50+ZG#\'GC(\DBQ0!40)73M8LMZ1E2J**&<^?3$F!@HPQ4AV9:*B(L#3I@M>
+MBVSEQ[V.:(*2L<P<B8YU-4C#<T(JE)'%<];2ID2"J8D^QRM'%CDC!8I$(HOF
+M<WX[[.%OGKX^O,_-_7U-]SZG]8]]HW90E@5TCF0TJ$*'PR/MY[Z1H7:0.52=
+M0OH6%+<^K+ZKQOKK,QX%>"2\<JZHUDL*6R;RSEG<ZJ.B<O,.[:S:ZM>/<T]C
+M'.4E'8L.SF<.L\+#RV'U)0F^OA6Y8SEA(RLBR4.5O%ETQ116AHBD"I!HK5-"
+M2AL83P22'#;^DH^8"GW*:2A:JYPYYS#UDB1!10*<IJ/>V`ZBM'PZY[WP3*BF
+M)56H-1-54T?IC2'(K#8J339BF<CJ'L\?'#5"]G/S]-A-R(D:%S;T;7YYVXT-
+M9E04C2U114BFW%KB"@P4?MA!-Y(S(S,ZZ/G=B#O/I]/LNMA$(XK51:8M%L:9
+M:>>_CMMN8YTRW]5N)UZ2<CRF$@?1`')124&#'\C`-AVA^PS2CJKJ_!SN-XI%
+M49[*MO*P8[(OKGDA6J;V^H7TQMJ:E5DH[BS<U#)FL2T!Y-3%O&Q3%KNYTW1W
+M52ZQ+1?.;0J9PV`7U9W-I*AD\:T':>V2'#[)(JC@2RF,""&(V^DRV]L-7H:O
+M9C;/KZ5]45(%(4A$E!RQE1=DU2%,BK,T*&%C;7SM?ME2*C5")$/L8!4Q5P%)
+MYM!$1?6ZUFIBK1:FJIU55H--7SYP[51U(R0&3KY:HX@IKZ2JN*^O@=Y=9)DT
+M93$Q]^UR:FBM#@BL!B?M^98EQBBP%A#J&CU\.=[:\[8JW?V_WWZD_-#SE_?8
+MN%Y'2VU6FS:JV;5J***S+:FA!8VENQ0MR/FOVI:1[JTM*JHS^OY^[WWS[^?B
+M?ROS]YW]9F=P;^-E?5_67/9[:O?Q^/?FS]O[WZWZ_/Y^;^?FW^N];Y?G\U;_
+M+]S^#TG[+[Z^_3OX^ZS[^?9G,JL4WGVL?OQ+'U\IV_K[G\_@?0O[*K\_6G\.
+M_Q5:K*]9$"T:O6H<8*Y14557J,9@-"I?ZCTEBOU\02*@1*`"_*]!S,FO\S\[
+MTWU_L?9]?].K5^A-]AVI!-2:GRE_WK=7WS^JAUNBT&?S=%.3D4XXJIQ*$FD8
+M$85-(V8K]"\=I-'4&T<TQ5K3SZ330KW]HXOJ?K.S^WZ_L1._51_S:$V3_P/O
+MMOY\D?BU=W=_B,-$FA`S$/X(#-7'YQE*J?XV8@1RD4(A9?KS%"?&;XZH"&!Y
+M%N.FYS0'.9I]S,1.'!8ZL'N[/7WD<R[4KJ\U`@9Q..+KHBD#L(5.D8(B`-<0
+M&I2SA>%,0&U-1D!0Q>C7!K(X4]@B1N#1(A0=!D(Z)&"J,P(%@"(>.[V.L#@&
+M*J,B+R;F-S,%W$B`)@``0A![LD#)X;>ZV.``AU&=VY008?=,$"^Z@%>I1C![
+M1'3PHUU4.%1L*[!VN.O0M8T,0'$<ZP!P',#D^B-Z`8("'#,J!8:QCNVI%"YW
+M8_X(J[!^#YOR)X3WRJ;X9:WK[Y"QH5F6SOG8+93B?IVU)#!#9TDHR)"GES!0
+MUYAF'',"^G4AUW6FEJ09EWIV/?+Q';Z;G;U"AB[E@U7S[<N>EDR2(.-69:`)
+M"OM%T-P$<QI"RNM](DR-6#M3-)=!055-FB*CF730DXE:!;DC#F%,.W)CK$S=
+MC:#.$'4$;VPA,I4-#W7%96FMC)',3L2-8<*0@4-[9F>[)ZJN2,4S(Z5%]K)F
+MF-G0&HLETZF[JG$DI,K,"W1CFQ325W8>S.[I,4RYNAIA"P13!!LS==:%(@KB
+MZG=F)*NK$ZF1J5U&D956Y#JQ0(96OKN>J1;"HHW2.2:;Z+&J+#NT1@E(@$$U
+M4A`2:QBQM+CO`R;NLF472A9-<+JR&A28F0@;(9T8:D22VB"#;;G`Z(UTX*JY
+M"&;LO+,DI2S%F$4:"FY36AS5$G=H"CD2,:,XS#+U2Z%HW)*#=`LB@3E.B+I6
+M3AH9(:.5/;9==@)#R4&$52"@$R4*NWFU11L(8E:"0Q(3:=!%U76=S*)%%SA=
+M"A0EJ339!3*3V2D[HRY/$DD,\B>(1RCNB<.JVLS*ET%J"&@+'%FYZ6A+&<^Q
+M\%N"I!N31T-Y=!'-O%.:.5G#HXXSD@#HVZB>PT9<$@DP3IYW,Y0VLJ<%EP3K
+M3).)4[<]>)R#BHMI"C.Q%*BIF0@3)TL$&"!6E.#*R]H228IUO(]NB]@($CKZ
+M0IFD-Z<ZMP@T)W>X;U!KF:,(W8LG)9,6ZITH%;BG6Y5B@2%.NS#1MBB.D.F\
+M<SN8<0))$4Q670FK#!!;#9B0.3(J13S*Z;Q,JB$)-5>4-ZW5;QXCLZR;H6<.
+ME4B,IN55D+089O):J`,Y0'-%;2)[6;INSJPDL66)RY$SNT:WJ`0#(.<YZTKJ
+M[?'&A.).N,S45$M;FMH8+RK>,3CSDH^O4A%&,&SX,5R##\K]37MD6+63CC$&
+MT$AOFL.N:CL5A!XA))W5?4GFSLX7;UDS4T(,S/.TLG1U#%XK"1>KW)F]-1!,
+M#C$@6:.)$Y6+TZ4U$RS3,;HL<-Q\N0RK5'+M"N.G2>Z76FC9N]V[V16GID79
+MGP]NG,S2)8N]:M>+U`I&4K1KO8?4\[:K>NY=V#ZLSPS9K'*LWTO,L"7O$B!2
+M1JK]0.'W=>D$:EL)0NN71$$$!5S9,KF-;FE];&-;E[ZL%1!8H1=!E<%>$;=U
+MG3-]NR>/3UW$%XHP@':UJ1HIQ9$(N;[`DG1NJ*=*N1QDX3KDR[R5,K#O%3#[
+M`,''>K;LT[DY3V;OAVU@5W*RJ6YBI9.)2+NKE'IOML5M55ALFFKUSDFW54J3
+M.(8ZV<[9NM"/%7N6#5CG(PX16U\6OE6+9DD+WU-<F]];(+(H"K$20%4%D4(J
+ME\RU],&61>Q(Y4&N.SL,F;ODQ4[4ET)-(;6R;IR#U5*=(34S8O$I+JM5(&:W
+M#G5KO.D/&R^1%TZYB0\O;H3AP8KFIH<WEKJOC#6[W4Z?3-3IH]PSNYIKCSS*
+M-]TSA!&%SF3CXAC<OIMYF1)B"2`0++G03>RZV;ID3#3T25NZ9JN[=.HU,6.O
+M6\0K,HS8.[E36Q'*B06)"@I7ID=BB]P29*;9PQLW<@FREC11`6]`B`GU[($C
+M#K)H\IDP3D%"33*1<R-K:T)J9S9%#`8@@@$`B`=27<.[:P2M'=0?2=F-((M!
+M!YDQ3A]P>S*RQAY*R\3DXLL9TPN-3NVO"!-TJ\D.82020F<%"R+/I]J]5.Z0
+MO7I>4:(IAM'6F92&8N3+AU4F8\SIAF!E3!4T2B/82WV'*]CR4+V!OAM3(($0
+MC`!O';FE0D<JJYZ76;/;%%GG@M42X&4IQEBHHX\Y:W/'B.W;0MBV>*0Y#M5*
+M;DA:]":E5*F^IAJ^4V*(F9H(T16AIF@03)A"8I/)H1Z"0"^K"!XG$U>F>M3X
+MYMA7=$:FR5)Y.S$F4$R#F;EN5?,8]G*JJSLWN[NS,6E[-X<[=<9R`US-<*S+
+M+I2T#4IG4J&9@H7F,$HJ91N9:I*IS'(.`LQ9ZD0<0*5RKK)Y;-[!21!`2"U3
+M+F3!$/<$0G6]?5N<J,222)W)@559(HC<U\YF0M[`LH2X4I<$%6+1,U4.70%D
+M2B%)EBM<Q)-[3':L!K)(,H3!+.;,YB@N)!),2(`N,=#:[7FC%+!4AR=U`UFU
+M6%0#A%URS*:54KJR:AS%T@0R[<E2U+;/%+7<G,J*PDVDUSU\W:)TA]8*F1O$
+M<Z"0RY*90R04%(9FPA1N0D4[FE-*;;IZ-K":IAF"+W'(9-*CVH&98-I&\F9-
+MK#TUVB=%BK'$K9$W.U+=0@2BL2B5@:IB</.B+QO"5):PT1527!I,MRB\E,22
+MBBNE421(()H(K-JB<4ZZFIJX?7MR+L9PN'(2)F6"2"!!DC&(NTM>LCF!4A`@
+MA[M(31#(X3PLF557)!IJ[1;31F]ZD76`S-O2C-H"2*NNJE-7/73TL@T:(;$8
+MWA*EA`DP,TXF+L:<FYH/CIBP,DP!)BCIIV*D8'UBDAID$C+K,HU1[,-VD7UR
+M-(IE')3DXK.S1(,&BG:!#V99175LHHW>NL`6M49),S9G*TLSB1*=R2$-,J@<
+MU6+L(+2FD,""HZU%H*DC56YJYOMR^*.HF38*"F)$M(X[;55!<V'M'JLD[2@@
+M&,QADDD"6X=O$T*5U>FE5'A0%8@YHV84B>0#LV:S+P-NIFZH<41-)A=0#V>@
+MB3M@66#D8'TY2/#EIR6XO#6"`+%3EY1Z\U2EBPEX:-I"LW)%8"VY-W676K3>
+M*PF9DF91:&H*M7-E]J+FU4T)#Q!Q=UV6+-H!&S%DA1SHT020=Z<J,(LRREKF
+M2-=,;2&WHN3H5DKDR"31YA--H$/LLT\@W`O"A4E"IN9'HD(::K2]/-'*;M0U
+MG51*]6\J%G46V4D;O4I`G%72&22236#NDH)K<67>3"#UB<QC$<76\J[==IP=
+M:TEL<.[+@8"1A1:P,)2&RRGB&61!!`))PHC7FTKI,BZ"WDE0Q79#IV.E85:+
+M5F1DYE5)1B6G<ADN2[8F6>VJYAT$)0+3@"<8PBPI$R9W2Z5\)VAS$1``_I`@
+M>XLUIZGT@%NH9@4;JR#<AAFVK2$TR;*\2S=X;LR1.2SF9:PH38JE)`P8VC9M
+MU.*PL.>F6:UZ9-5M3XBM"W5N(G9\JHE4'"*P0P$.B`ZB150D.VJZ!%M`6S&P
+M&@C:-%OSAB2558EQF4V9E:4Y.X%JM7@W/E]B][/6R6:V[IU<*Q84R_7(3GU"
+MKM2L5BS4OG)U,$4;GM*,[<60J/C9[`MG)GIZW.!SE^W$,K32"6W96BIVZ,"[
+MI>B31>#L4[.:'NC!6(5,O'0F<?3QFPN=Y6JGV(RL>3-\JT'M*>+95[-U8>S.
+M36@[FUU"W+[;T%SE<-MW,Z*VW(UNIT[15ZPFS8JAS81['MJ9=0M.I-GAJGJ6
+M;N,W=T)E1.Y>UG1E`:S<NJ.X5?9V<%.CJ8H5=5$Y)Z9GJ&D:)-S74#P;Z:&3
+M@5=7:.'I]RME6V/4.34ZTS;L@B[$RUU2_/:[:K7HY4ZUH73S'VVL=IXW2IVT
+MQSJ[TST\3G#90O$+8GMJ$\=LH,Y2!?)3:BA>9O-YHZFB\V:JD4Q>SCG7E3<A
+M8'*T*-QCKG<J>J$),3>9EHZG(KMNE@.[*5Z-<"Q&Q0`GHK@AI':%-<+)JZ4`
+M];&4HJ0H"$HHH<)DQDP--0\X.I0M3K4LRQ./3=6S62+>-R=G'9SHK;EOAC.*
+MC5UM22F0ZL&PI,G;SES/<<JB1=MWDV-D;BL@R,G-;1MO&+%5ESW+"[JY%"U5
+MR^-5>6YGE,33SF+,@K>J<0ZKI3LK!K[79S%2;W,ZK&X9BW.B4P@I,X9KKWK,
+MZ6[S)4]3RD]"G1C'IKFK9H9Q-[WL!B@-B:WO%_#$0";B)4_K_GQ^0/T`<9<<
+M;2X6>IUS_Q>K8MG,]0:@:B",*"\#B.(V&YWVZIJ;JS5RX7W#?&I>+^)JQ8N,
+M7S#*@HJ"@"9+AD@12$`*`SO\_Z#2K8>QY4_$,>*\M+A(D8[U77-S,K-G%CL\
+MIF72D&LH=<WW.ZY\#R.8ZQ69*.B<&Y1"D3(W@JP[HF;0+"Q&QN6[@LB9N#4[
+MS#H(<;)DE1`\0W>[-:[UQX7#L>O)@57%#%,4#773*Y+C,"`4FN?\7/K=_YF>
+MOP"DB5U@8M+PBZKC$6>B?;IV"H[G=#^O]WCY3,$247AC!-%%!_)_C=TFJ.DY
+MB@YYWO9"9+?/F?MX>5$URT9VIK?H?T_1P[4^3I3%MAT:=MIVS0%,FX=M<>%_
+MGE\<4R;]:UTJB7UL6J#32`TU$`@Q`$K^2HL)I_ROY5CPNL6*?6,D',$C%M,T
+M;9PX9%99]ARYUE5@;.=<YVZ=MU1?2UDRG20USU#--%<Y9%OCF9O8D]%2L31.
+M]-SVV]WDFQLR4)C22:0"[/"),5XZP:/GG.#2E*%.[G!QQ242F6=,]'W],=-5
+M6JIJ0WZN:97P94%4M*7$DT5,5',:8*28HDB*:UN(;(<)*)FA,!S\>!VHJI41
+M&9=^<\1#%4T4@R#5$.AV-JP!AH(FA\JM,9VC;+[Y@X348PHU0(U%<BUE@B+%
+M-.G'AKSWY_4[UCH\VXXZ&VU!=NE)`C`2+"[#P2[):Y4AM(/$`BXAS,//7)O3
+MQSK6N/B[]W=$DIIP0I+:7JM(*9)-9F/HVIF>Z:FRBN``=I[3MX:OLJ7G+>E;
+MG=-!XUV"\DS:2-%3N.=3*'2DIV5EW-K7+"#FZTT`Y%Z<OL`IR]S,D<YQ&F2F
+M*>T@2<112(MC&O&-1!%]/J&@H*.[%--!5#>;R/+L^X304T)5)ZLAQH]/NX^7
+M=\?%%$S99CU].S;>0H*B7=3'(L3EX8:=HIBJK#N\6_;QQ--!QKE5D6"7&(I*
+M-+6018@6\<;^.#)$>8Q(.121Q(.*JS.O7X[<WM#@B208,(@F"1`1A`;,#5.O
+MOOOC4UV'YK#@L[K5&W-C-"X%F`;^<K73G2K56RZXMC4EMTY/%&[O'-S=I9E9
+M[;>.4]NB)*=SH-FFW+F[%&=+:QS-K;'\7F3S*WE*MMS&AW>5ERJGMIBIHG01
+MDFQV7>MF]:9FN=2QIER<.NJWBZ:&6>,WSF2YFT[,U%V9M&0E(Y.C;K)RZ!Q5
+MB=RV<'%Z-IS@<K6IL4IX)F3U6<HEZ+HL@B3MX9WEC\;,ZQ4]5$AJ0EO5@P.F
+MSUS<Z1.5)'0*>VJI:**8GYV/4Z#YQM?7F?J7R"\P:7WYLA^>.E^62VU;$?+Y
+M\Y>^7D;5IMMM@S.B@H8BDC8*A;-`O<BBBP%ESI5@B-J)QB]H*AVU1H*39/O_
+M'':.V'8JJHM)!2212,B&.>.Y="(HI+:XJCKTW-.WG3;J^'2^?37,YL\)WHE`
+M"XM4EMM;%B3%S5%L;D2R@?T$NM*^%[9M.I)Q"XI-#+#V@EKFUH4HZ<I%;>VA
+M0T;&;?ZN2MZ<5C'VS7.5RZ@V+-2ZFDD2+.%VR5QG:UW*H8O>^13`TF8BW=#+
+M5DVRB1!4?B%WUD\[=X+044K50>D_/!^0=#OXMS2.206+)BQ6`B"HJXD,14U8
+M[]=.5W,[5;:*V,Q$R(AKX@4TBK'!17<K@JJ**,0G.VXTT$5@^/S.'6J8IOJ#
+M._'3C7&4*JE%II%%E28._.V3H<Z8[O8L8Z'?B0NAH\6*ZH4J"-F2B=4%STVR
+M+B,18+[!QT7Y&TRUNY)=&LK@\)F]:J\A"I8,O#UL,"`<TS:+>2,P&T&%3)&I
+M"3F@2SEV**0!('`@*T`-R;)ZCK"!G'TW-$1&&9ZLRK(1L@M2'UTY>S=5NA=*
+MI7!=&6--!B-),&0KKJJ_1`)`XP4BPF3412)I6R!85%4#)AMWKI@<A)"+&))D
+M)`B9Y]O3QO?"#@HB%C$KOMS4T/$H_'\.]*I[.KXM3%<3;!!.-HU,Z?Q_.^>^
+M*WF-"4Z]>US$$P%SI5FZM*R*4(M513221#N?XSG/3T^4?7KP*'L@=CF5,,;N
+MV:IWJ00#`B`_O^(6#\3DJ>_4RNN49I"AB)>+W[KM04(];H:[V=`Z`1QN=QF2
+M;MS1JI3W<6(W9ZL+3&\MES5UM[>B`I0`B<!@DRM[96L6*RK30;W0U@0UF*AL
+MAJDE]2*HL618*)KMIIB85@BI%,8;:>&)W1([#L8*#8LM#0/Z_;\N'E>$21;:
+M,'Q^G>]*VULF:FK%D*(@*2":(JH#1I**&BF*(BG6B"(B(J"*`Q.FBBIVS%12
+M6LA^_['W\.^04V?P][G2',(L`A(0?M.I0TXL"8_/71=[PDBB01%(Y]G/6[=Q
+M15R'FE15OQKW?'LZ5SY'AQEX\^-^.WEX]LV21$R;6-BV4Q4BE7*"(P)G04@)
+M)!20F3KU>U9EK9MKWI42E%E$2']!-'B)SVG*DHT:,TLS$F*)U"KJZN@!%/QJ
+MXO<1=Y=2]-+1G9.F=W33WEEYD@F+>ZI!2!(K*"OK[17,I/`$71PM'IZ9@XYN
+M@&5UJ^MY);PD2<.[+=U>UA!210*X%/-V^K,%C0W=*X,0-E'D-B&*H`N*I6>>
+MFA#A#-(OA+I-:=IA'O%%/#.;>%\!J4I0515-5*=)@H(//?3L%-TSJ***K>_U
+M[U4<5=9=7`KH9",!^OVIK6,)%")';AJ*JH*R<DI()"E*$Z^WN\BW/E78^6NV
+M<G!L^%N;7X:"7J4(HPB@$_!0((9[\#!\D_?I*Y,BHIR?<E8PV1=A!_)8<C;<
+MC4AFH;0TEV?K!8/6,.&S1V;@#1-!"]0<J,L#2)Y"35;I=3HFZ[A0J[F8%<+(
+MB!<X`@00^8>%;;PR"%*!N3FMZF9QUO`LN//4"H81P%!<1!3)O,JJ#-DF&+(9
+M5GZ_7Z=,04SKMT\,%T9AH%@'AUQT[YPS3,92B-"4!43)L610A`Y2(%%)(**2
+M0157"";593OX=>#TQB)IH?W?N[TD"[L81$:JVQYVP((K#$B&B!86"Q@'EKZN
+M,M[^=>5]^OIEMZ2=#&=<EZ6J:D$C!-;E[BP&Y130R>J9'+('.9;+5\<7=\C)
+MRK:M'P5D,MY0K+:%\\&X]GJS1.S.\KZ,H/>F;J2KO+D/!/R@_<W>GC9F9;F)
+M]I]7)UE9DTH`(?K'EG!WSPV,S8XZ8B^-WA\J?KNE=U<2/<W.Q#.#<FDJ)JT/
+M/:`EL7WN5;Y>]?BE5WCN;KADWE-W:W=IS-*10M:DY%;0AJI\%#*U29-RF;FL
+M0#&Z+CT#WG[W3/NJW4F^P5Z0R&M<OJEZTO0B+SIC#,$E!+T'TI2$6KMF=H<2
+M-[.47N#:W>FWK;Z1]^,'Q\P4%!0GP0XAHH::T!K?&.W/-JQ@U,'EH-(Y(F&_
+M7[/3YAP45Q.#X\_2<YMY(*0(;]IO1NB*KB+)&.$18@?9Z^UYO)R(Q&2!(=(\
+M.O!WJ#>'5HEJJ:08LL`!VU--/#*9HS-**HIJ"4P(HI!0H@X2S9@U3506GTL$
+MVMX?Q'CZNWAQ'7ANMT"EM,15G"V*%]*M$]JY'4NNJ7*\<+LD(6+42PA3+;-?
+MR^OBS\_-<KY\F?H2M^_7QJ?67]A5FKDN(NJ:87:DLE-%,Y4B%J0K$(5JE!5J
+M06*I5D:2.68J.</BJU99X@28:*-8ZTR-%6GE&41);`9>Y;>ZM@';?+]SNXHD
+M(*&>$4!%5$#UGFOL<5DTRQPHTG4\[_GRD:&I\JJ*W<9!E&89!C$E>_)3&'DL
+MGN^;P<S*A4]'CXT_II9_;5'*X]=&X=US>GT+=<2,3+?"93K6/^A4UUO_9^(>
+MO/JOY_4[>'>^I;/Q9]&?_-05[WZS4\$VC8>&DN[]$CL](OO247G?ZOMM\QV!
+MJM1SQL?6!O,8Z`3*R%HL5EJN`$8N,,]]JU!%78NA$"JJ*!SB@8JQ*@A<%0R<
+M?)R\R2G=0(#R!)F$D\QAD,I:%T-F&>'29:HB!$"H7!F5?%%&@,-+KFNQVR*B
+M#IWTTY_)P<87J5Q#)3GV9FC,2M6GLUZH_4N<I9?G\Z.%M9Y,!GZ#`?>(XY9!
+MATT[G"S37J,**O@3PBA*]6*UAQ33"M7@Z:#.6JK+)"#S$P\:U'4+_08B!E&?
+M-L"A`N"('.B"#!ZE=9QS$2NT.RUQ#KNH_$^23K1$"1QZK/P=Y#1^8Y/R^!JF
+MWV%K':/39%.F%\D07H8-V)M+2Y^-=#I79[1,K:%;<[W*;7S`1VX$4<.9>52,
+MAPF:Q4@^(UGHWOC4C5E#@O>X8TU16>1+/-!8WRK\*J]UU8W6E&)IX8(Y9+$"
+M:%64\\^EQ%%JW/6A:+$SJ37M+%',U$(W#66LWJKH6+"67$;J7*Z)ZOLJT0\I
+MPBZ80;G:CW.VK.Q%57;8Q=_71"?Q161%->%<FW"JJJJJXV)$`62]%$JO,45,
+MB88A#>C-YVK+Q=BK>7`9JJ*7]3"FRXL915>X:*.H,2!7BBQU?DPB=+E8Y+/<
+M6;(R:]1HXG9D):,I+,Y(D2"R1$KXW.*RULNH^.4D6JYSA)U<ZV4/?>R-<;0%
+M#T3I5H`26ON5OX(SGLX#53,GTM[9]I[K8>2%C/Z_$=._C?U_TZ;J3SKN,C-6
+MNL9=)?@'3'$FOV`1\1KO!113N`H#BXE5H`9`H`2XNTB&<Z!`BZ40OE9=P(]`
+MD#/=M%YZ"J1"$8#)J!00('!%$F7JU/I8_KM'TGM<S1\5YC?YO'_'_I^7^->T
+M(HE=4^I^WE.G]QW3AZW\?\M9\GV#KI^Y\1&B("U10XT3;HB,2H:/PEW8S:@@
+M&A74JRF:`?0%9454-(B9NB<$!2(1*_FD?@DI_B$<<8D2`?GF[@;&QP4#H<T3
+M3JT9;84T:U#`/$WS7[X_C'XS^VBYW+W`X\YB..)./>Q(K*HH6)@37EH%"M67
+M,%#F1RM53#5C$5/+8&RY?NL7VW-=_<]9[;3^QJ",J">BWWQ+#S!WK>^&T1U(
+MK^S0#*O2XJ1ITZ$;NEFXM69TC+"%56_0`U&6)E@Q7TFC'#"G-^1Y%8D<S*[I
+M5<<:2AZ(J)WJWIQ"@46(>H!HRV"CP!]=9RAG,YN0'/17J]SE3KU,#[[&C[O(
+MT,V3QWCPD%[B=T_M^2\TOT^17U9^&*3Q?U__+]#^;P<?I_AZGZC^%]-OUT_]
+M=#K&_/_1[B=]#WC[*R>UA"7]DSZD/0JOT'N6HW0X3W4J^K^USUD?4A(T<;_Q
+MU(GV7$E7Y?]:D;0GXWYZTR%:S?75HFJ1TWEA7<YT<2SQEJ%))[HH<*OR%@72
+M*K'0L\Y+!F61TA&U6%#,T4Y$S#**HN(79/;EF._]72ZM,MDA11")U*UZI14F
+MLK):M67.:HZJ1X323.<[[#F)IX7ZU*F$K1S+0NJ[33=JC#&RUIGNU.;?\9Y!
+M>W9>[.6><4@H:KL^CFXKHXHE3B#=`HQNA<'[G<(.0X2R*1O.)0JB*)MR!:X^
+M3KOV\!R)%)*JOZ%>]\)?L_07XWMO^-2ZCSN'X_U_V_,U>#L.>\7K,#B>8?9Y
+MMOI_S][P.7:`O[_:Q^;JWQ%\#0MTBY7&M\=?AJKUYCVDY1G,1ST2>0I]JZI^
+MIK:RM[?[T<-<=+58CJ>E;WL3=OE-\*@;YW]_(=_\[&P*%3/S5L!M+UC;KG*N
+MHI(.]ED1PW-94]Y5A5EUE;PW5?A?X<U)5W\;J>$'S:<:'S[]L5[?/I^`.P;T
+M7TOHE*E.Q\+^&RCJPJ>[JP_$KL:*&B)U.<K=S_ZI'=JT^]7NBM_CST;NZH5,
+M]5J_8C^M6JS?RJ9"5\.5VOF5*F%?2[33;3WQ-#_+>8]9:BUH4T4Y,5'OY.)^
+M]R_I-<%$^'\B^GUOZ]G]1\?+JDW&SVYSX%JU??0HC\HJ3S;;58^ZMYF?P8PZ
+M2;0XMCH)N"[6W@OK&+^6W+D\&_J!+AUM%3A\(DP`DK2X-ZK^LQM&%^22>-))
+MO=Y+H`EEE^;++JLF7&#IY<37XDOT-'GT+V)5QL#7Z0UV(&=7KUYN:_CXOL[P
+M85["G^;F_(Z8V.M"6Q++MI9?N&GF"66W+Q-N7^99U@197"U.9B:+D?)!@9<N
+MPEEV>QJ;(,_6P_7W-?LS'LA)))R$DE!B7P1V=5D:+\76Z/2!6ER?;UJU:^M2
+MA+F38.WU\U_J9<^&?R,+Z<\NG,R0))+G&7))#*XP+4LL>YULNK+$H2RRY'86
+M)>(Z>S_\&DFFK[JOF:;<69@ZV7"W.@U&.2=4%]EXW0V:_*</'E"]7KXU>6]Q
+M,O3!H#OI=M+9WQ<D#$NUN0VF;@L:_IPDCJZ*K):U6TE"W9EV4LNLXW:=(&)6
+MTNSUVGL:>S*&!8SM_G6,'2;/H@EL6-'8SI,O;RACU\/CL.^O&;T(85]+Y:^D
+MUQMY`DCSMQ>DD*.?"22K[[A28!=D"3!LZZSC9[+T?*AH;&%_B6O7))`JU;NV
+MRI,0S_&!5MS?HP)-/:$Z;+$[SO3O8/[YE%5S.8;N/(>9B&9YIG]E(*SA7LL?
+MSZX(YECW@@RH&L$BC57`&W-]39SP?RR0$)BK_DM?R^R7^,1_ZWZ,9=;&>0XC
+MZ&;C<E)&"\@U(Y`]/(7+SR-=)^[WWD^-OXO\_Z&]K]3J\9,:&78<U_NB>CI_
+MQQ)))/Z?\F8?U;/Z;/]W!VQ11S3"?KSN*9Z`:BCX$OR/J^9T-G0==M22NO8<
+M[S/NLKI.7YJ]`51)FIU0JU@4&=+$MW[3O%7N,=U1DH.,5JS$>'B$U,0WX"(?
+M&1H@(8D**E\<V'OE`[NO3/4E@2X2F0^..646PX$5*Q5G%YB$Z**%3>UB?.R2
+M`$[HY]=J+_^AXF5M'_.?BYUL(2`7]@FA54Y>2L*6O"5S.=.]2+<UG2V`L2B$
+M+$F[RG*MU2X_KI%UAAJ%_D0B?=_5UPZ_P/?]9WX7;QNX1LGWV4(R+L',5`2-
+M2E(BB5F5S-/^YMMK#&PZQ>-G;^0IM*_>JG5ON%RB,&?T_ZVMRJ-S7KS)4&(X
+MB3CY<\FR%=JROVXPV0]RJJ*BJJN^(1//&'G%E4;EED2CMG(=/Y-D!-FO[?B>
+MG6+OU\G"+6U[%T<SG[CY"(`E\((@@@J`&>@&65I`I0"A!"&1$I$9J15:5%J9
+M$"A2DI4`*4&A4B`8(5"A5&E!:5*14(E1I4$:05*1"84*`0B40H5*02(4:49D
+M14H$2D5"E2A1H0&2$)J1A(2E4&E!6@5&A6E"@I2D!1J840I1*F6:)!$64"`4
+M@(`I**:&EI8E:4I6B@*:*2AH**`JA**5H:!H`H*$B"D(@8@:1I6E*:4HJ)""
+M2BE***$H**0IJD*&DH`I"AI`I*$:&E*F0I5H`I6F(:&8:&AIB2E**!HJ)&JJ
+MA(J$JBJ0HH*")JAHH*2D*))5!*01&)JJF4D("8(9*$8@4B&(5"((F)`"E&4J
+M$*J(`:*@FI*@I&A*51&H(6E!I2:)(H@"(F@@6D$J24I1:$:12@42(4I1$:0:
+M4JI($:4`H!**I6D$H$`I1&!:8::5"&%1*$2D*)E4I4ID8%1:HA@5@BIH:2!I
+M1`I%`H`8E0*`H4"E`H*$)@`:0B1HH*10D*&EB6JE(I@*1:`#6C$%5V_O?5E=
+M6<RBJ]G*<G/NIL/PN(X,^=ZO=^KBGCGDWDL\Q,3%),2E)&4E1*R$HU9=ZRL;
+M`WRGU\3SM\_/PA!Z2R*V8+)@MJME/OM]Q&^4H551%)%WV4"@^FG>D5:'QD;;
+MCHC<KIG;OXZ#;82#D=1:I1"*:F00BG!`]@":V(*(728!`D=+Y?*'*NT9OQ",
+M,1(*K&V0$`'TP@0043!3[V/M5NM$1K&-2NIB&'CF$2`CA044:7&U,=>4`ZSQ
+MV0$-MT.B=LUY[Z?JO*^T^SS/VOT_`\UBE&WOVP572%;B\.%]I]&FK1$41!$T
+MH(J(BA`"_/!3E]3G[)]$P]]4^)`?D<O@4=`]Q`D!Q/[GASAH/)Q5)*4-$%5$
+M1W_D9I)B9D""YX&$K`T,E3?J9Q@I:B%^\A_*]'7Z^R[4'7#MS-@)'\8W\(P>
+M.(T4-)B#?V<&@J.[^ML;&5=U6OV5N[R1$H+?*C"J(J@JBC6JO-6#(-$;T888
+M888]BGN%47\*JAOSUSZ,X.("KAU:C&(.$`0!^MYL0`1E`,`5!N\.=&616YB:
+M5X*`;+"+Y%PP%(Q(=,Z)FEPS"_[`-=?AFV,S-T_:91#0=OK;L\T)@^F]?7+6
+MZ7#H?UH0_KWO&K(F#/`5!PDC)!_J/JM-"D\4G[4)I2D_?&?QYH30Y!8D(+]<
+M#^4#+'3"$[6@9[&&9\(SX*JLD4-Y`UFLILZ#5:K#QX8PJ%0I!WK]<[(493A`
+M+P/P])WOHX=UUOE7<!3KO5UK_ZO>^G\W%*B(G]=.P)NC/:6IM14>"97.J-38
+M_8G[!(`ES^UA^\?T=!STU5_?L_[2J&A6WZ8<BB@FQ49%478:DBL/U"1;U7<G
+MO+J%<X"I-HZA-I6FVFI?&JJJHG(]/WGN>0W@;P(^PWH@RK=6JR*&M&5VOVP&
+M:<]7Q&27"`DN7EGO)>5\13?I59H#T0F5F8`1I)?R)L]SZ\;#2A14HR-!N!GO
+M(6^G>B/0Z!H*XZSV`G%"0)>+X#I)&4*ZUWL2=FC7N`3NB5%4TS#7^\LHFK4^
+MG[8_4?N/3N@@>CGZ7I*VLYKW&OEU/S^W3SC,^YJ^BX3APX</VIL^8.K>6,3H
+M^(Z'>K%TF-N]GM36YG)ZXUZ\QO-@;)PRB[E694VGE=]2\3F9M4KMPF"N$"XE
+M[7LJC:O)[-VV@V"RM6TUF\E;L?#$V&?BBBP\]9XE*51*43296E;B]ORWW/F?
+M-_/@AQH4XYFX!>!]US0`1P'ETN1C(D67Z(SE4OA&09V#/?8CIDPE(<'13/1`
+M0?((DP8:!3J`1#>:!)'V0TT\R?FV,^SZ>`9P@8?"X8TT#>:39!J(Y_<U2:$;
+MA[VM#D`0NL3U((I$R.(AT]+6](5$0*(B[$D50#CA*)EK%0-%8%M.=9'<6L"#
+MT=!!Q=F>75AOF\DJ;E$>@;"6.#4$PYT2.1:!42&I\NHI4MI+(!O33@<\X^W[
+MC_CM!RVHZ[^G8>:P/^\IQ?L.CU'N<#R7FN?ON5Z*&W2[:\/Q[?FJ/^^-\N3_
+M$GUNA\UE\(Y(TJ*"Z,$`$`L$!,IM.@IEBCUCXYG2,Y6%<SW<D!K$`0T_"%4?
+M&+JCB.;V4G':O6;L0_<;7@+[7\/Q7A]T,S\GOK]9IW+6B6\/VI:_E(EO*I^4
+M<ACE^(,_V;X&,&J/YE%BQ/^/L20`G^VUEQ(H%[_T?CTT%]NUFQD:4T4%)8,?
+MZWY_T9P[>?7^V97C#U9PJ#A!]/L%!,OU_G?`]?R7R8S9>'TO0]5V6=S7,_S[
+MY>A^9['_Z[_*+\]>QV_\/Q>B=YEE\R]VV]EZLXC@(3F;%MP-&HC^\]8XT/:^
+MMAKO3>4:JX<1D9&3=T-Q=7;<7$:KK@3@*@)ZW/KYOOE<S]PHFP)=@B(B*47_
+M)[?J/\?6\I&&_#CA$H1+2(`M%^8(W<@IMS3C@]^U/Y8Y(O)5Y4TN((IATND8
+M)?\X_SG$UMA0^H]/:8@)'L_P?J_OC^\SJ7H(J@>24!`=RR&UHH6")B=KRZ9@
+MET@4"V&&(D041418["`P]9H]ZIMP`%/,<3A8/@?YB.DT74>U_AH_;^TW'RMY
+M8W=/K>V^DW3-]3D==D;8W8NWXA=VR%/FTY?>IS:*K<G!(@6>FF/82=XA&>]$
+M#0!,Z)E;07AMG[+P-SKY>ZW`1AO)T\UJFU=A"NJ*JJ'Z=?[4!183.55_\X1S
+M+Q_3N_I>7^F9?C%<_VY8M:[<!(1($E'R:_NA;$P<W^=`O_K%!41$0.G5$0-=
+MKOBY_^VK[3#R)>[^2K6QVXY->68>:46Z<HHY1YZS^=&CV_4H$!ZO9@"M\P%M
+ML0<^@9I%B/1=3P^R]M;T(:$-%QYY-0SD\B</U;5A_H;&FFA=$!`$C`T:BT/2
+M-%$Y;EM10D(!HPJ!6H^UR=9>7UL(GNL*_U$E,0/4B9D);#[3YH,)RE9ZEBI%
+M7++^6!RI$Q:]'C$U=`KJ!5?>ILV)+=]0A$31+%.RI&%0I'+1K2JL$$R7"LK4
+MM-%$G.<[U./,&%"Q$)_4FM1<QHIDT[8,S5$4W]F3G/]`O!?]PF6"ORF1986C
+M54VS8RY?8P3\)]LKC!`Q7B*,ES/T?]<H2I@'?6YW`?ZO\;^G^3M_=_C_&^YN
+M>A@:./S1]W2WUO1HA[?=84K,WM?.;/Q>3VG)/Y#;Q1<MU7#W-7B4*IFKRQ6K
+MND""**R<B"(<JU\+>W:IFWGS<W1_CK?;/=O\]XM0-Z%.]-PJ)4/HJ/0-.JH*
+M:^X],?`^SXF)VMN-#([`3#T?V>5T/R7B9P2XZKI%;+<[V^3HH^2YC3='I^VT
+M>7C5>BTT(=OAOM7XI3:,2)Z<2J//+>2%SYT8SE%892'A6-6S1G:?4X?[[ZV&
+MG"@XU4)J6Y903D5`<K4B"N@AJ%%5-DSL^`]@TB@F>$5#WV?]]]7VL-]\[Y6P
+MY/'U6WHE]Y^4R^E@T%T!JDYI1[Q+:@JC*<P-&IJA7GS2IVRGR?(6]_R?D,6J
+MY9MT)1FDSQ:%F2Y<P."YL?=W*&G>\^295L-#$$2J$U^U5_XLYE\?]I]GM=7H
+M*@=%SRT5;8ZA1!QQUCH*7CWO>\>]AFD[RJJ)S\PB?O;B7PFLSTJ+^=>]LFWN
+M@!>B1D_I6KT/[DXAK;&,@;I)\X=;)!9E6JE!C6#I,2))8YT`;BY49[U%%U2S
+M'$'6>LU\1BJJJJC-T<]2WASH\1@Y14]UT52'K?*?T^+L\W7_.^E_/VFK^_^;
+ME*_.?Z^)W79_FBOD1!$N\9Z/:/^;_;7GOF[78FM-Y$1,"(>U9THF>3B!=RZ1
+ME9#1KN59=."09:3E33(""`ARR@!IS2L(XV+>A11?C"HT@X8DB[]5:=._!=?K
+M4192D5-[,J!:J@G<[Z;E?<;/W?B^%R]-=AN)%L(E\]P;AX;M3W@^(X[%%=W<
+M0.%GB55E<"!;59V:RF(H$PB);144D'.+IO^V:#Q6%83%C&+]6Y9.S)C^B45H
+M]<Y]ZW^I;Y-J>,2%M**Y"WJ9&1M9JGZ*+.;W>DC$/VJ(;'K,CI/F_9RMMKY:
+M>$N+O/K</I/Y^!%Z&*<GX[9&`.MP#"'/7"9>NZU[U7GH67#F<_%T>,M?1:0-
+M(SU1P"!$$8R$'#N?W?L-3Q,4FKH"8'*#(@JT`*,"(C4<RP(A7Z-7;`G]&TRM
+M;']GI)B0D`B'?*BC2;ERKI@-01UB/&YPPA%ZB,G<CZ/_/]W]+5^%]77/VZ4P
+M7V>VVC>S4&89D98#^EZLS/.4-4T#4#\"R6"H)'!DF,?W$[[W/UI#/Z1,^G^/
+M\_OM8(]03>C_1V+'Z8<ZTG.>3F5&O_?+[#X2_6.8K$ND8/%=R:.!1494'LW6
+M[AG*V&.'+@C,=0IHO/J)U6\!RF*&A<)$>H[WM-E:XWG3/"3J.*@"!G560(E5
+ME1[<NG#=%&`P8>>258/`A^?OQLZ3:X$"B79$$:N<2'F:1!+/8&L6FGKP>\EI
+M2=:YJ$?(SHZP"!<GWDBB")8<2N?^/U//OEJ)_G22&,?$XH3%O^E8^+&)8IIJ
+MFGXZI!558MV."`@HY7JYF%@S"XQ*!XT3)^3O>FLYW)_,_U]SPNYS_Q.R\>JB
+M;'ZWKO]]?LXMI&N".UW"ZWKU%'#B35"""`F(J"(@!P&0RI54V,X[9*S*CV7P
+MCPA6#DXF9HG`C"XTQ/L*\42MF\'A!PNPSYR-H0%0FPUKG=[;>U3W_$A/7%0!
+M"@H;4;&V;D?;K%O;$K]HZ<04RWT`DDHY400$$/$F+RL11>O$J2+(@RDR2B.*
+MGG7,0PX$3P100)7?I_S&?EJJO^RS`S#W\F]#((2!,%EI&G_F`VP^#/WG/CD<
+M&441^^#[GZCH_4[AQ56EH45)"(Y_=@_M4,+^+^EX4U(OH6B'\,-6Q@L^?.6G
+M>1K&D:LCA24')@8NA:RLR7E4$CS[2_2])J'\>X?R3SHEN`2BA,:KU+C6KK>K
+MD-ACMFO;IA;*T8[?>+*(BB`RJH*GR<_R5_NH('I?*X+OM\]7K]7SFQBB;H^<
+M^QQ_7-UWV3ZWZ/Z:;R?Y7_@^)XJ_.]D64OL[XS8&DS=",YV)!.`>$@QE"Z>+
+MDIGY$"!`="52)%ITG$JJO-2L%E&T%1%51=XM3YA\SWSMPYTG6@2DA&;<;6<H
+M+4.L5)(E5>00X^`2(]R=8*3UV%6L_91=<J$B`0Y<'[<Y[9$#!M+T%KXP<$P=
+M<!DPTZU/V]].IK>[K02%H7O;A`_+35"*BL,9&9P*BN%`NQGJ9"2W4('J@3<(
+M@11#V&D&'"N&4XX.F4XM#<(*<6@(A`DDD*YYYE'0>]SN6$!`#GBK?84B;<4X
+MU4""@RI_]V%UV$NE_YXW->/I(N?YWLYAF=?0O*R\Y\SA]+@GB')RU"\"(<P@
+MB&L0$0$0H5X#<%,YF&9=?:31:+M)S(+J(/>ZO4==Z"*)E65C#*2IR(6K_;Q<
+M*YB;2^VM6HJV[2MK+8^X!;[R]&>=>U^9"RQ48$3\"[W>X)8YJ[I9%LZ5G.4>
+M.+,`$1!$1$->K\.:77IL+JH1[&R('13V@$0!()?)<EE:"0BI9!$&Z+I>J9F4
+M>)Y@0)V0OATG5>7FR$$0P[2JLSZ@C8)NK"T"`_=7!`*CK=R>HIR4<99,/#K/
+M>`>X@*0.XA,_BZ[[2GA_KVK%%%/V[+%558_2YOY/V;VF8Y.8M5(460587MM_
+M1JFZ(H0P4M4M5^W7TNG^/GQ<Q\Q=U+Q76DJ5$6JW5J8_?"]U_O,B@7+=)899
+M(C5=F<YF:9PP[?%@9)U`&$1$@;`1SL+-B2^2_Q[Y_OESZASRAB*A\KW*,!V7
+MY^<3:/3,%OP1&QW:=AGO917*Y-"J5_G52GGXGJ)4K\\_,I7X*,Q/#%[,#/[=
+M_L[?&8@S$3AD;3KA"`/'/1[B#$DLU09AL*J@X':-"`U/>L0M?.&A(CTLVU]#
+M[>#NQ<53=J:SNIQ4$&GF%"R`@;Y`:.T`@-%(!&Z"H:`:0-OFSE/)5[4)8A8@
+M'6!`Z]NL*V_O]3Q/3H;E4^?(LJ5$C(HC_:_,VT;*3%4E$40%&V*VRTUK&K&W
+M\=8YS9)BUFBU@Y+M'..DM%!BC&M:R!(D%6L+(J".",P%P9VL03!MHBIP%MM&
+MV/[;FYM!+_A!MS`-@\Y\/>O.V"V.;%/.99C3*JJI(Q\;4%H^?Y:I&?[^^/\Z
+M^'E_KN+@:BH$S(P#`I"@K^^YAH3YN8FV248IH%11]P!(#:PHO4)#^(O9$K3-
+M$:4&:#PQ%#<*86LXCXW-ZOW)&"ANTV[KKM,XXK!Q-/<&(S%,(BYO=\'U'J*>
+M+N*JM[[CZ&XYES;416X%G7VX=<BZ-$UBH@4<AQ^!-R'(&>38D\V8_=[X0XT\
+MX_CW[EF5E)!`.":O3"J0.0HV@\)N=2\@B(UI8665$?7XCB$E0BVJJ/M`($^`
+M)V#,GZ-`:5\Q5Y$3%47H:8TT%)7K]F(5[LY&$#_I?E?V_XO\#=10_])01/]H
+MFBBD^C?Z$Y.0&OO-PI%/]O-\S3Q`GS8!__[^[^O_U/_3MQ%IN%K-K<U>ESU_
+MKM7'!W4;6+>5(S&5%%%&UU5IV:-S,L3AGBT$&6"E&MJ)Z=\2HNF,QNK7.5R5
+M4,]$G'\@FG&701ZESI'BHJI,J2NL$B.'3P2E/**@KN.6\*]H.3:86R9W5?H\
+MSU_9-Z<U/OCQ<Z:<#X%5V\L"**"&<KLQG6MYQ1QNCT.SFQ2=J!%'IGE%I'`^
+M2/A<2FZY%5%5R%;2:2SIZ:ZE1-#F-SJ!I+X!R55;=*&EYR1P:7@,;V2X%T(P
+M0-(HI$C*,*BJJC115K.V*2JI*FVT'Y<U'''Z4A@Y8P7"),8B)(R/\34_"Y][
+M_9G*>C-(RN<"UG<F(GD2IAVXS4JA[G6S;]YBT:!QE^0`;+,8-ED)RBC$"&SS
+M''"SV?P^UTM#>:*8681IDDYE15G/<T&&>+6@YQC9VU-J&2CG$!DN`_,7KQ14
+M494H4E7'*)2<VTR)0_3(J'K%)]MY#5]%YS-_[GOP3:WRGH.(W+G:&**Z3N?9
+M&L1&_,^\Y_;*JQ&CGAI!FP.6J9.$#<NH=NIMS)S%S%&5)V95'*57DK;8^A^`
+M>4T,L""#)^@Q'0D_VJ?ZOU^?[?X(&.Q]FX=UHEXU&GU_S1*FM7';IF,EG3X*
+M\CA,AF(+00'ZI]5S.+"RUW9WV0?OOH!B^NI.$JH_2>8>VT_\R1^J`P(6?P?^
+MU/_%3M<[!41\2W'\NI^I!ZXB(C)HB(8P,#C7OG&_>;F^OGCG.U)0>7.WD!>4
+M'"B@/`>G.+B8BEQF'.C^KS_B.!I[<MZK!PS8@&BGM=%T0D/SPV?K!G".7^L`
+MV/^(S(=U,GIYIK4R6T%0U(=5Q3OR.'QAC,@6P-)[SN/3Z58C]'^/6MN-9FQ&
+M050XO.7;YKK;GLZSF.R)I^!`^(FP=E1[8_^`?9'KZP]<G[=@,*:_P\<*$H2A
+MH^9?DZ!QB2B`^+`90S!%$$,,)$E`04U1%41(G[3^=@:FAG]6$Y4!4U!$EL8,
+MJ@PR*G>\T<WS;>T]TKK/7Q[Z/JH04S=$.L5KL2UB"]AY!UT55TK:*18'26UG
+MW%X":A069IAO#<6ZK:C:%;WE99Z?+4\U?01'$<U\YQ"K@&JKJSPB*)5F9SKY
+MTCVMP$?1V>)DW;F+A>2F@L/6Q:[2LZG6[;MB&??'LUG7&#3VC_/[WM_F^/EK
+MQEE]5$UF_KX,)BR^9Q/*SHB-7NGM`^[*RY$\KXW37+91+CO0Q(%F-VT6"D57
+M&P+^WA5Y2Q&Y)'N1(MH)."*)4!+X$V3`XC[OE^(_'>QJD:"F(JE*$IJ@)@*"
+M)*`JF)B**F*(DH"@*`I**&BFBHB(@FJ2I(")B4J*8IB0I44505%5:8YF5;"I
+M=SUOIB$2WKC[Y)5R&[BN9Q8GP20Q9211^O;)PI8/9:)6RWL6\*QZ^\D*LN5/
+M9JL12PEJ5M#,3KBJ6*YCRN<KA4^"LEW'P:J6XAD<N&ND+3&3;:U%(]'U\%US
+M0],\L/B]<7^'BC/)T[6MH\>RNV+E.FO'?V&,LZTS^37Q??$GPG)=F&OUJ468
+M4TM-".%_BN9RXRX$5Q2!%9F?AK:CCL1&'=F==4BGIGJ4SN*(8/XZ)8NLP'C1
+MX4Y@59+M%Z9!TK-)%>TIN7'Q_3Z<U>B3I]"IO7B7WQ9"Z22?H?UCW$DV"?+$
+M[KS0(#!S2B<ZJ"!U'TA$">B70U<8,ZLVD4551T;TD$4$R41A!@%45$.I8]SY
+MOS,OJO5?)C^%PL#3M^_>Q;!-YQARJ"O/J'$JIHVWS^598N<77H(;QSHCC5[<
+MY!+`PSD\Z*=/_9Z\E6M+T]=.3M:I#_>_$#*H;0?VO[!;?C$P&)$P)4%GU)]/
+MZ-ARVRF00W_HGL+.!4RL_<0I`H.^,E*B4,?\ZPT[76#:.HPW[;3D>,P[FU$,
+MC5]7L^Y[']C;#[GDO@ZG^G]O.R?ZZ3^%A,PY[@ZC400U&BC'!J.\11Z#H^L.
+MP\H:H@`]2=0.ASN>^YG5>X5(\]RR57:RYL>N[SRLUA0ZDE:\S+U`W>*Z#*YV
+MSO4Q#F<]`VI!L$<*KE;#)GP9O3NZ0Y43E3=`P=&$%#&U`)RW<G*G,;GACP'\
+MKYKU#.CKG*]_-S?$U:]`W-%`)$1SKQO%**JJ**JJ**WJ1R"G"BBBBBBBBBBB
+MBBA11111111111111111111111111111111111111111111111111111110<
+M?-_0OZO]"][6O*A02]Y"TL`MNHDMB_F?Q=C><T2;TJHBZD%555+32:):!)K2
+MNS-IEWO1>#K-877P.ZJS-6LPDW=$R9K2JJVVVK;;02"1,S,B9F7,2`)@"9F)
+MDP"()F6VR39S/:0>V4I&(_:^3V*S]@:]E*/&7J_8>NH<14#H"[G6X8'+$%/W
+M`=AHV-Q#]0'[@P\@T/E,&9_>F0:`F4#54#.!@2K,B@8$CP.[&SIV">P_9-$5
+M$T43!31?70\]AZ][9V,<,*]CA)CJG\X%$[#"%CT]+&0'"8&0EC;C9UI*5/TB
+MV9"-.>&-&N%RU^-JXQ6#&T5JM:]J6(C;4P>A8(;$!_$B*P1S#U]O>G<*<A.K
+M#NYC?MO)E567W(1UCO-"%+0AP(=L;.WIWH8EC,P?*'>;AR.,J4JF9)BKU8&B
+M.9W'<<8%B0[E)?/!B,_;(.C!AR"EP3SON!D.ZYMD$`\EVFP[B+>;/G-?M5;E
+M>TZ)^/P-%EZC]GA-@[S;7=6YUXJKMV&%'<0&WDW;+NG;I54BXR)RN2R=`_?#
+MVYE6413?C,L;F<+XS#&^]9A]&(]`\'YWF.3OH3<36[VL-VPY[(_D(]54\KO=
+M:82>NTK32\)PKASF5@9.UZ_P?E_O^L<-MC\T_2<<?/1%-1Q]O51;.Q^)]V&)
+MQ#]\=QBGX<MV/3MV.HD0I:H*!:B`WV-][:#S94Z0!GPL=PY$/)#PD>OAAH1?
+M)72NH)`=/Q]90T3LDCD@4!DF]Q9TP^Q/GLUOQMS%-*3UZT6]L*[F>>%5=+EK
+MH=/VLKZX,BQFS4*XY!$$<1*"LBBG&\#K-7W6(O*]9@<Q*XO$3L>$K[/,1/C@
+MT5`^6*'"JWSY*2FI4J.H[J8IK20<M98XG+'36D=6FFAA15+).T4Q-6J34RT$
+M5$17DFJTTTU9XX++/SKHYZL&LNEFIK/D2I2U,CI2K%!Y11)7)HYYZE2F5T(H
+MZRP?IIYYYG6&::FHJQQQ/A]?C\WGYI[I_;WX^[?R:^OS[[^^Z??+^CTC]MKZ
+M]7VO5\?JMW[YM'6H@0O+?P1[_+^_U7YW]N7/[G?CG['YJOR?Y@<!3.,(8-R,
+MR)PV8,$NC05;"8*8B5''F2O4MV+=UUJU?NP(KQ?8$C5)%P\!TV"I"=U6Q5JQ
+MRRRQW770?//)B!JU%4V[\;V2CY'MG7M^&;F3+3'+)^#_AOD'-#A3A@FY;NQ$
+MK_9S7>>[W/)NY".R?[T=U<^CN2(*9P3!RH:,C&2;\RZ4I,A2?P8,RT4B+AUM
+MN9A4S`K)/'VFOZ*:US?1W*.+6H.KM6`B%AA"FF20E104#)1+U_?X^-?83.:^
+MB=BQY!')C8@ZO6LI7KBHBB(I-)1436WJ](4T1'E+"!C,.WP\6A3^,.^<0U1^
+M5O_>R.,K%F8T+D)!YDH2@.#@7^@?Z(P/`-3<%^OP'@2S%9.R_GS1-5%R>/'.
+MC!`-4\-A@@CF1Y!EN%R`3O]^]1.%YX&UD!GQ&H&YID?W$HH.>)*3&+"6,1*M
+M)4**0(^!D#X]^SFQ1LX*])Z>UUZ@H(H@+S5)YRSN.E\*^NY5W*YM[E150UR*
+M,HJB6U1Q<LQMM(1"FA,;;<X<B>8=^.%+J@NB3!QLK2.7*7'D":_OTC'PS)N;
+MJ"&"@)I%!$51UPG*#E_3_%70#7$_Q,]"=LP',P240O<H%M-7^-V8(+^M[/^5
+MZT]@E@P$`637YX`>![1#P^QX`<WJ"Q'76&Q<]AJ9%D4AEDK\Y2%I)?3U^K[7
+ML/5[OOV?:F(3-@X+VDFKCYUD:*?%PI-%/)7$*)[)9!5"Z,",B*((D!%3ZOL0
+M/F0I`_N\I5,F,F?(;.7D*K+'M#7!\EOE2QD3.(`E@L,STP!D0<S.]$VAA+"W
+MQT;W"$T6MR)=_M'P)W@B#_08B+^M'H(`26,DR$$*::BC*E6EU+A6!1'FR6_3
+MR^,TZFL953DD\P3Y;>87AB6D^/+B@B+,I$,?9"&&5--:!3_3,0U''',/S0/Y
+MO0\D_S!T3+L9=M,4=V'G=0(EEL?GT+`M-I>J$1`-&%V2.53`>39$ZGZ/^'&O
+M=5@.2S766515D8-5!EBA,,4T8DZ5\0F0#Y3M'Y6VM"?@R)^+W$62.IT2:O%8
+MG6&M&_O:.P7\_V?B!6ATI']$QXB/:9CZ`D5ZQ]>8FD?4-J10Z0Z`38TCC<"3
+M"%@V8`<T^(WX@K0Z"M<BPO#SD;P`WNBD'(#D2M+."^8)X0?K<%;0F0!8!()@
+M$`?)-"Z]=B1[?<K>1#Q1#"`2'\Y"35#8`%)E1'1$!#A!"4*)M=5KM6?,'(%.
+M`4V0'^@2J<G">C0-4L%A6P9AK5`<`!-3V=<Y,]\B!^[BNY]'/\V6]&#-!$ZC
+M)@/4G/,:Z$S<@YL_A>X/"B-M0L31$0LOVFL=$2V&/!Q[):W-6Y.G>>MD'Z)0
+MX$KR`WX;\><TXI""=**2VVP6.+F.*@*N++>="8C^P_**N/'M90R-(E!!(=]]
+M(JO?O><,+4$/G.XUJ8>!7KD&)$?*>0`^H?`_$T:F\T0T;-MQ-B%DI(K96!24
+M2E/D4"&X$31SV-ZWM-\T:FM<FSD8G4=2Y&0%20GF?04>45=A=D$B(8&&6J6(
+M(IE[!\0B'?LFR&R!S.Y[1$34">SA^U;1XPR"G589@(B2V7G*QHTOJ75-7".M
+MD+SYOF-*[()('8/M_2784/J'-YM/!NB&ZB'C13RCVSQR1#?94\2G`H*IO]U]
+MPWK.]EN0(-$PMP`J.*YECA!P4,<7!P"DI+4S!3MJ6("]N&\N%LS-!FLB4B;$
+MO[F+[RG8ZPYSK`B*^AUIY#GX&E,S"UBE&HDB0(J"E$J0J&K`\W/++!>@X!N=
+MH_%+7FNL2RW.Q54V@+["0.N!#>VE&GV0@G)1#I[RZ?(0"D'I*F@:7R7W)_)+
+MK=R!KA'(*-(?,/J9E`[!R`\CDTJGL@#(L>\BZ6NELIF$A6))_"R"AF3W&V1G
+M5%S/?7D\!#!L`C!&1&04&=B@"P?L,`\@]`793@-':NSX"O]#P7L$J(H+X>2Z
+M0`^`['36H4_07*!]*P7+VIE)6)08"6X#L#F\^8['QC=B`'<)3K2[&0BJ6HJ2
+M"#NQ7*EB/8?Y#TOC[P&WR8N!+C#<5+:@7LH%@^8[AZB:D(<<"/\[%(&,:,%@
+M8^3T#Q.R%%,+&"((T%GZ<BI9@34K8;0AY/,;SS<<450_#*X)@&Q,A719X"4:
+M8:'*I"S,$;F*"H5.%(".!]1#1&SMNF_=\F!*"@II6A/?#XH;`Z0>"DF%=NI3
+MO\4%&Y=8H:P*8^5A[4GJ5[0(%EO0`X^VDIW+KMNN3J50YSY30ZAX,XVQ4VE"
+M8!IB$H\Q"Z:/9.($Z;WQ=(&@`[Z(Q$%)R5.]X)IGB1ZFJ;'LZX24P9*('-2A
+M!*-2LX8,2P8,R?:X#7/VN8$/(/5F'V.`TS5$!D810T8?8/L&?J(GRH*5`H2@
+M4YBG;(?!,>U@9A9Z=QZNR\@1B2-,2'@>(/J,>S1-`SK!?,8S$1%#$W'&CYCZ
+M3('TGJ,$!F4RD1L)XV(4I]VEM8`L-A"*H>KS[;&X.^!*S57,.B![IX#K1X'S
+M23XT@80'CO9@E)I2*&@]KREI.LD`MC#FYA$2>[Z4/7ZS!I$]C1\6TNI'$D`[
+M:,$=N<RWV,&E>$!X13H#O'P.PR\:*8H>B@IU2&1F!C30%$P_@494W+6JG6#\
+MR-/(6V3R$XQPM3;&"E)JS&@B(G5IR>8PG0Z'?(.]_-2W^0'[_D?X>V=!5`1)
+M+G!B'0YA8<10^1)8`J>[GJ4RK":VA8,_UA"9FH0WS/*6Z`<*[[^83K(8E8@(
+M)"D]WV*WW8$(K?`46,8^2XA>+D=V]A404!$--/G5]UBA2UJA2)D7@="\8PN>
+MA&>J-MU#K.,>_T=B@R*AKLSKA-2!JB8F24"A@(#0&/Y.AP.$_)"X@!A/,X/4
+MCIA&@/=D@>S1@(@3;2L%#`1$]QH6@BI0CW!E:$2HGJ2.D/D\,FVM:BR7N=/.
+M3_N$D"QXS??BBFBD*#2'>8ENB6L5\$I0+L/@E'P")O\%L/K*J8HT=B,-#`0%
+M!$BC21>,.1/J519))$P[@+!FV`*("(1$4<\AF)LN&%"G9*/KB>G,[H2^OGFS
+M'E%A`RIG>+U")L%\TEBZX6Z2US9RY0UP*9F=72*U"=E)SSUXWUCEY"S5F*R`
+M:P])")DZ+;,@S#T/F`9SLP1`4,$T;>R^(.MFS6;M$IK"O!X#.;W.!/)6Z&8#
+ML(';)0E"K0DL0ROO>P'5PAS#,S"'`2"`WZ?GZK,+=$S;/CD`/`>Z=<[W!N<W
+ME<D.\<IMX<S1G&.!L<?G'9X;G1&9R'"M3%)Q/.`JLHL3,B&E8),?@2MU!D0@
+M0NS]7+KQLJ4AZ6":D:")D"6FTW:8D$Q?+Z"KB(LW39D-+FN]P+;T0J,W9@TK
+M(TH)=@;C,\BC5LRZ"*X9=D:M8"^>HA['<@C>;#<Q3MHDH3K#Y!+3FC/">?^8
+MRI&0V,!Y"6+I\WJ\2=/(4Z0.)%+JZ_SWQ`>L?:1,0=NWNFJ622@/&^3^,V#`
+M!A)/[DN0I!#0!$-`FH,,W'="J2P378TFY\F"E-^%ZC(+6S'.=#R(P*GI`X&Z
+M)*R7XQH45:(B"$KHGE+;G%#P,P4%%(;`YEQP*=$R=:.BAAK'@A/.-,P::/C#
+MV]%2>$W)>/`X0ASE%CBXR+E0N3:9O)=N@Z<R``/,.%-\$F'OQQZZ>:98V::X
+M;5#O\3(Y""M)'/$QAB20G,U!IIC/@]_QQ]]\1?[V0#DE.294;GNGYKA-T[MG
+M'`42/;\/;K'Q"M3%PA=`(&J%3G!W-)?FDIC<C*KA$(U#D=[4U"UMY)OXFF5<
+MR*&>X$4)9FDU_`HY!<>F:22#WNGXJ#J'59VICCEGFEJR33LZ6K429U%,L**(
+MY):-^_B*FO=^>_'EGB'?XS\#[-3]^G\_/B^#+R_S?ORA/SZ8W>_.?&W5Y9F_
+M8LO\??P_2^OSE\_C?ID_?S<N?GW=<_QOOFL=\O[S[F;_/F9\I'UE=[Z[3\_*
+M'\_S^OUZU4@M--%1T=+UCHIFJUGM&M2AZQU2>26K)-4K--'-/)(0IJ3D&?"#
+MGOBI-AHQ>$M4-MHR"6[=N=;5=6L5H5K+G1OO@)IJ.(*3[11-?JN&G;[4AL$#
+M,P",']$K]:Q15PG'O>"PM*PS;`T01)HR)!EWC<9$+@,CH33-@*W$Q(XB5*H7
+M+V*8&'<P()%C7;SX/C@)#)-9?CR2QE)+)/9;%=C0IG:%;(BCH9TC*S,^<#;>
+MR]A\L1!)*EJY177+?8NY5B3-MPL<^6>;.?G]OV?80UGH?:%0P4'"H.>8+$+)
+M9A"F22H>[8[F73OY^??W97MWKP?+'CY=9VA';I0:4J):?``WTIH6E&[H3LT>
+M]\&(/8/WP`&JB2*E/1&)3`1H^F=4A0`;,=1K)DP=AW(*D)6@2Z7'(X"F]4EL
+M/MEA<.W<E4N)))(X+UQA#BRP54K)\A8\UD4_>Q@8?#Z[6@^LS/,^L7<1HHV@
+M44%'I$PJ`?R)%:%7UD"D0"AA(A0"T*H>U!MO&NY#J)I:*H""J@3W,$&C%B"B
+M@&"@EFI!H(J%)HAB-8B&B"QA="%-`'V"B(X^U`,H:'4`E`4M)+L!S53CD\PB
+M,.%'XZG4/@02_:XR4%>&,L24T50?F&0#"(4@!&Q(?RAC[QT#\!_%YUCZ\A)]
+MO555555QBUKE4M0"&Q,MU0S]HXN&M3`)-E,RW=`+;0,-B%>L?U,`4`OF^3WC
+MSY>41$S![#H&M%&QTU,88P6TUV\Y'&+2$X+R#X@6"?R3H<$)<ED.P4S)F9(O
+M&?2.QVVZ!BC@H4`,7B%^SV0Z&XJ;@M`.$JZ4"^#/R6.#A,S05.L6S)**J3U*
+MHHG:O]`:I]Q$3;%+C?;/9O>GR=]C3VO%ZG,][U7HHO?GY(?A]&[Y'R&X`@GF
+MM>7Y;WW3]?VC8G7Z6/C2"IG*+([;PEBED8299NGT(@;Y`-6;G0;C7V$V^AS]
+MPW2G9Z%$J*I<'WL%R9*H*S=5!FS/W/J]K6Q?A^%=GX<=MF(/W,!H2!KZQ-G%
+M'Q_0'^/^X.VRZQVHT&)*83,2_Z<J>O^11+Y@50DK(J$#0L4#9*D)MMP=>O^W
+MIHM"9Y_DJ;V/U"P6G@-[98'P+W3Y*EPM!F1UM=K29A_&/U0IP_$>T_A'@7TG
+MGTUEPF3=@I)DVPVD=6I-#3$CZLI.LB?D2&9L)04SJ'Q#"'C]1KOT?!A[L\.)
+M*&T1$E-`>Q@\!^#CGJ_>^"Y+F5O+OPVMXYR&8L.A6!VHVW[:>\_>TD.J`0-H
+MG>Q"P6G)K]6U]..T'W7Z/?&QEEK1>NN'+30N"6WMC,QEDN>/#8)-/JUN7D=]
+MM^[SY@2%<;%@)"7RV+[<]=?'!=P]="'FR33'3:VVV,=N]+IXJ[Z8ECJ-///,
+MT<*ZT.A%)$YU6B`I2UH6>I*UBI-%3"LOOYM_D.?N<^GR'Y$[]:,?'KBN0_:/
+MS?[3\1OJ3_,5#4,0J.KO?(Z$S59W4.G<SZ]6HKJS2UZSIGU)83X"!?D/PPSO
+M@_OLV]TX/0$MK'(*6J*N9D?RCF!@DD0.4!4$014*;D=BN];5RXMU;4T<L>-8
+M4,4A/OV>?T>^'@'8R899C%9@AF85^K,!ST=JO:OX68#H(5Q@_`;$)4DAJ&1J
+MNU;W_/]!BX8D!A!22%5*)=L;P(NNUSTJ=PNE5J:?#$;2?&/<@<B\"@V$LJC/
+M:<:_/?AR(G)2E%50%D"E@*H"GS$/Y9K&([^R::$8@JE4B)()@BIJ0_!(R*'L
+M-]U*45051!AE4@['P)L&Y!V`0??RI7NQ7U]')!\DV!UF0@K,B5)Z]3`*5P$A
+M08=3#KSQ5*2972VRU#$FL10MWPD0B'%J"*PS*,B7&$28$+%*84U2O)867*J:
+M:U%%8=;?$UFC`W]D^+"?*2]SOQ\\IJ#551"=)+6]2Q>>/AWN5I"YC$I;!R<=
+MZ/.=@P%@,=GA:XAW&+$&C3UX6?`)70>3XT%<(-`0<GA:TT4>$(;O>`'.X$.S
+MB1TB\G3I!CV=_#KKVKIXZ9>&ELS+XO',XDZ02*'8WT\"YM(P[U3(N;9L*6$M
+M:H3K[_<?U.?=)/3M_#<;E`A1WX"">1`IZW\SIP@MT0H?*G73AUAT0Y;+]8//
+MZP6S$XW=V'UVM.:B-**<P.M9AB)"F(CJ0,<FA(`X[=O1GI+I?E>*`EH1UB>2
+M.*[G.FD<05,S$6U:DQFN@JY(8%Y41?2(:D/31#$^BR=C>B2*)FJ2?0/JZ$.>
+MN[TZ0=?,AW@&;UQX'"*XR/`5I,L!R\X:=&[NY!F1S,36LMT0(0R-HP-B7-#D
+MDRR8FX:M$@E1S9ET&M`F]0PU)FQ3[\O';8:-:T<;%P;;=?26%NDF808$IZ$,
+M<!<$<.H$?=<6'YTL8*W)%%U(M]4.@&>]KL&_%X7$#[2#).O;-$^D"\8>-?(J
+MAS\KTJY`R%*%41%0Q`TQ1,%?S;$5:P25-#!!1!%7,:!H)B(B:HF*&$BD*FS`
+M:I"LSIBHT)@#\Z@X@G7`!2HZ5&2@E""4QN%^($Z-AE?&#Y#O#W5!\FMM@S&P
+MRI&0$I149)K,CGFW:0V,'8GF%S11*3SG9[JZ'VCR&?*W1<1\`/`.=P1T@UD8
+M[JV=?&=QW%=7/15LV:8($`"@%OV!PJ($:JJLB,@TXM)$$P4,0KI=-!14!$'<
+M)SAPCE$3%1_"$R.EQRL!E0E0*%$2?P,B9J`2@0I5:6&$FI"D8D`I1(X#][QY
+MZ,.(BT:2V74ATG?\$30'6=9YM"KA^<2&U7!R_-+;9/5VEW[6R>Z-DV>?YU[*
+MH^><`.@P@P3KX9!CU0]>QKB@9$)%2@`DB2%)(6E.8-UCK*B9GW<RHF=!R=!B
+M&.?<046CH<H())%5.##PX0U!_7@A`#;),/Y;;T8YG.FH3PQ2)1;&PEA*/S+0
+M$7`9*!H:B9(:&&6DQ8F9(AHJ)]!'G-1255=%9-#DL7W'\?.#V-(*B+TJA8*F
+MA4?A9L?%;&(MR!51@(DQ=YN;;'<\D*B$BI;^E)@Z8RU551,A0%56BSFD^DQ`
+MX0)CB_E6B-)!YX'&3O[$[R#;:AI:B:&B_$QIF2)(FJ2F$D`O9YP>G<TXM024
+M^$^N&/Z)X0T!@:JX0P,0F6(IIYZ#D2GD-`I]9'!P5[`'K$UAI,JTOH)I0OG;
+MO],YZ\K$)I1B"A`HH/HP:`YFTY`_E!YFAK@BPE%F`S!1%(APX<X.)*(@*[)B
+M9>QE*8G%H7!!$`<GA#2I#4E%+)3*`=?OR89!YYFE-)R$X(8."'']W[MR8([>
+MWT[%(I%PX;A)4$II5Y&FATKN1A1BS!,@4<@-PR&E.$Z4-.BJ5>'<IHH`X2A3
+MH6D[*.DT<E&ZEQK)B)2`UDUFVRC[`\S`T)31S6S#0$$,TM`F@5J@4I$,0`AT
+M9XJ'!Q#2#PG#1;`A(!]TA-P,B3N28._).A`3PGOE6+N1,IGL`98.-Y&1,`_?
+MA='I..=W;-)$$2$9MMQ565QK6P:_FDCTJ(P6(@H=&J*6H@JI?B=5Q/@N,#U"
+MHJ9\3;CSL=UY3R<7%5MNBX&K8>EUE,\"(IDHX8<S+!FU)D;%Z"(,NM6QC1JX
+M94%5+.XW/%)O+HOZQLYV=_A9Y_.AEGT=0=4<E(XH/V29L>1;!S8H;9)YC(5R
+MJBQEI+;-%5R7,1%/+5:8HMUU$$<J:NY.-S=YSN'>LA2TE4"/J"J"9&@.0'8.
+M0\AY*TH&E2J*%/'O$_64?)TT-+2T-(&A2@4T*4"&,XTQY40VW&S,7"2:ZKE&
+MSD29<:.:Y.<`Q3&#EBQLOA:>D[P^#V=ZQ'J,5XW:8N:(0D(&Y,_M*!-=H%#6
+MHJX=^&'A05&LM0:/7'/,%@R1KO)/%1V/5)D38YK!"(&-Y;>6AJ23M%R![.)H
+MH:/#Q5Y*<CKPX5$<,1'IYF!78->N]XO72:47FPBZ-FJ&C;FH$2ZNC<VY4#-X
+M;(L1T3"IH<^Q'<U`TT7>)H5+G1<M!2E@[8]P>IX?;)WB[L:YS#PGC.M;^E>[
+MR-UP08'X]<0ZUTG!$>3MM)_6M"<+!"TDRX@-11`(@G@G+!5P#2%H17$=,<\$
+MR"=;F-VY15HZ_A(:"H"(A@N:(PX7`*FDH^8H"84P1),5<U&#+62>'.1ZA$^"
+MX&9A(";.!(4U(8..$-2YI@IPYG"FP-Q047%$A"8.#MUC5L)R4:)P1,%B0Q$0
+MS$11IS8=>HK=-`#K]U"F;2&YG!#((JJ(F==F[R[X=-9[EYWO&BJ8)I@B1B"8
+MTA!''#9^=-FB)M(X5(XCSA:1J%Q>F-<)B0U`N(IYD%3G4YH#JF*;L8ND&"C6
+MYAIQ,01LZ0@IBC</#F)I>\\VJ>%1:#>%H:0"(*0HZ3H*1.2FNP&HDEB/<"<+
+MGAC!-!7JT<SH"GRQCM[XIV`UI)?=@J4H`B3;>8<^RQ^$<\QV$IF$]P=OU_.[
+M#A\]#.W@!D)FRVD?0$SO\Z&>PX;MB<T73^V;<@XF`0Z1ZAG?6Z&R3!UK3U>R
+M^;!PM-"^3MM>,/F-X2$32^6/(R&GM1N<W$:0T:0.0.ET.EI"VVR:'DAIQ(ZY
+M]WZAZND)B%Q8\./.&?:0<IX6(MD4>#.%&<,H.&%$&L;?"MV",EDPE:/<4X;3
+M:*>::+?GO%#^6N_COY]U=_'\^?9I7HSRD=_R+^Z=\?[?K_#_D;L_7?BO37OP
+M1/UX'Y^?=](?G[9.XJ7M_+LYOY/X_'OJOR/A_'X^Q?S]?![[S9.S^EMYUE5[
+M+7W[\+]3\)_.2K%U8G*5:TD\E6E74UJ65HJ6GJ4RUIZ)*DL51JE#IR.I59::
+MU66[OMC':^STTEN^YSITVTOS#Q9#T%/[CS+FD(4L?.>7$1Y;C%/?5<A[A]X?
+M9'C@/SSG!<\+!/;<,(E@.`L%68@P48H6"%B#A%$9`1044GN7UVQ'<A?.E(J7
+MDCK]KL<=W2E5"L'M>G2`_4"7Z6`?6[IN@Y9!$GO)X/(__K8%@,*O$ZE46I5Q
+MI;*VRVQ%!]R%R1V/$RQW8/QF2OCX$L2QUMKIMG\UBUN1URQT/?E?KI7/IIIF
+MA9)^00%A*2'\9L,@H`C#7?+3KUZO%-=LNU\=7@D.)`E\_'3X=N?`YXO?G<)/
+MTCX>P?LA>`=HJ(R09;#(.2D2L2C32@^5/>D,"Y8T5>)PBC*M*=7<!>:.["::
+M:;F0Y0[G#2<AX0@4F&1S,9P\<A7#CJG$&((D*!UH34M`Y"Q.I:I2DN[P[>OQ
+M9KPV\]K2$U1@>6OO]\_:P4?@&ZI7R;JTT'I7.644*X/DD!AIE*`I::2*EH/N
+M,PG+W2:CMY#\+566D\RQ6"]-%641Q+L+PPF(%%JJ5>XOG[M=GV^!E>X?80_M
+MT/U%$A`,`OR@5-1@40(.C4"(42V89$/@<&'V^./ACAD0QOK`K<N<FT[?(=R6
+M9`I41<"X!2&'&""KF*"M!QC\@_//;T?H^/>[V0KL2+Q/RRH3K\S-S.$<&87"
+MXE)!P#^XF\.)LT;2YTZ!_//#(8W[J=BI#>/BR2!5!X7HYJIOL8V+4M%02A5%
+M4(P\#$DFE>N/P?"/ROPVQ\#6/:XK.JQ\73R`O"<0XT!D9_N9?KUFUA,C(A,S
+M^W#Z_M^G^KMTM"0O5,(-`06#A4)'LB*&7>N^27B<S/[[$GL8>^QRPH9Q?5T9
+M2<7!"*9*B"8*\2B=`UKRCU^P'W5BS]#7L;-G@7EC:."9;IPF[2YIQMI0(RV,
+MNEPPD7,^YN7$]4DR-YPJ3W0%=-%%57K#@*HHJ)***8NTT=4S!"R'!L#\$A2U
+MZ-@=M&'UO4"IF*)"<'$):P]-!+"CE3,[7.`FH"1=BWK^?]VT[[,!`E%,P%/D
+M.L[B#;9AI9`B"L)#O-&4_)PP9BNAG^ZX.G]Y'7F:Q^8".YQ_,X8[PR?##S/N
+M'SF9F;$OM"N=8'"&SDZV0('((IR`2A?.FYMJ/,G(?.U6/1[-F6&L(XN,(PTT
+M+J07QHNGF\S-:TTY(EPRJ"1[/"_:!^!]S%0>LFE3GU&DOO)8BGE&$I$V8_M#
+M-E=)OT(>*N\@8,=VC6S:E17KOY:0J#"[0"8O1?>]*W-PJ`^?JWTZUX52(B)X
+M%4Q8<3&'DV8$/T\GM/G/Q9)G&H3SK`E"_YZ#X7IO_>+I.!)FU.UNUH_;QVMM
+MV>\Y3L];>Y#R//\[#//F?-)-1-111F9O-V"TIC75(:8>SB!P+SGZMB+(XTDE
+MD(IE24$%-KA&&L44Y)$(NU(L,A$H*DZE2?4.GB?,Y\;Y.>%PDZ%3>OX['M<+
+MH2J43UW%D4J%>ZS)7+%HNO[/BQ9Q_G`P'?%P!_W[+T7Y")(\"-L7UV4)KX$\
+MPF?I"3\*29_K_T689/;DSL_2YW8NIMR9N*G%-?^)H(B<JK3-ER&3"!,_,]@\
+M_-$[J(X9Z[O\T^_/GZ4C8%GZ3?X^3]*<EU]77M'L&UESOTVI^JD3BXR";_+V
+ME_PSLX],W+)3'7-?*0'D,'9/34-->K9473IQ&[I%8D$@_4RBFZ-LI2&_F>4C
+M9*;M`G&<0GZ56+X(YVYF%M`JBR"40"&5#^LJJ0F%01HZ33'RO6R-]69A&7M2
+MD/'X-;D:7X9V5@ROQEFA>+GE%"Y'%J1?XF3EBAZ7\EOW1F6*HI_[OS(D'XD0
+M0CU`7H%D40=ZM;KBM#PTFG6`:H$EU"10(JAI+[4!RT1#[A.3PEI+8'0E#RY!
+MRH:"FJ:UJF@"BDH&E(E2A**'0:>2&N;4A2%#K2`4EL&(:&A"@I?F^H\[CR'0
+MT!0E%%L)R3DOALT%YG_11Z[F)[&@[4^2;F-(6P<VT\#\IT-BD6:D"J#FTLF1
+M4J!]3MP^>X5Y976H1T0@<+V\-[RR"YL199",$Q!*X?B;=)I-$?O,F9EIXTX2
+M!6(DIFB_VI_M:Q9512P()JB;J79`\;DH1.JSUH\DL+"L6M`RVJ82R"R[KA:7
+MA!0/L-*D/J7LU<MVW-L=U?@@EG\&K[9_8B2&?#?AW:PO$!@L6E^/"B0*+:1C
+MX;ZG^UEM`69!'\A20)T\2T3'3?51()%[KL?>+2)!'V41\*(^7[^3V[:^O52/
+MV^%K6Q7BZ^ZDEH)2@$?95>I5(W5LJW!18MA?CU-7Y>O\:?HZ;%#J)N^]:=^1
+M[79\0>0JS=(R-^+"5)>PME":%A+;@FO6!F2M\:[U@M`_F($;\/U]",<T/L5K
+M8&D?@COGOKYX+_C7GYQ:K462219^G:+20\FQ0\#\V'R)F>KAMYUM;)G9F#8)
+M+=XY'(:RC>]3-G3%$4+]I#,4Q<,,-T6`6-M_$TF)I#0DW_L-C(WQG-P8`^NN
+M",Z?P?H4LQC^`(&_6_M]7^VBMW[B,&*%]?(\_L9+3E'[.(LA/X$"9!@-I42A
+M7"X;7<2LBNN>.+:=KAMY&AD$UG!,<)R-B98RW-3$OYFPEL[WSK"2L!.%B"YW
+MK7L-SI>QK1;+J8H;4;I5>)IF8Q4F]N'9G8RUYWJ=C(TTB%%-34=K&WB/&J0V
+M,C4\.9'B]M)MWQ92]NIR-BUN8/R)%1.*@_V&Z/H?*ZF$1]C]`H?0H>@_&(6,
+M)W)&8"]H02'T\]J![ZF?-^4]@E@1I/(\'4OFG>Z:#G3I`6Q2PDP\B*8WJ%R>
+M@UVVV\='?..),TFYN)4#B!BVE<A@#DUJ63/2W)K,3LA83J57/?!K?N]$G#+C
+MHKLVZG=+H^._GH^'('G(+8$R3V'HENL0]LCE].V.7''"Y'-HB*H,0>2@JBI3
+MTW`Z=GFVU'@<%GJ3#7;FML''%;&34C8T-;T(.A7`T6$5KHD>2B+"&6N4P&>F
+MV=H5C!K6.J=MZ;588'0;6*@\FE6&]S:;R5C+7>^-#<_4:,"^YR:@F!`(+"X@
+M,&0H6@T;Z?S>4J11$OGUYN6-:(8G1FS,8,LIJR2_38L=<ZLC(C)IJ-W,TW1F
+M;VMM?(,S,;&F`"C2YH<7ENN9KJ7-3';!F&V><.EQM1V.7?@N:@A[M`TDHFH_
+M'\?).!!H=@_0OZ$Z#^`6K:@E]>B$A8DW3/.]N+:Z.U3JY27JHSO6UN>MYEV*
+MFN5;IPPMC7C$P]/#,N2"HENM8XMOVP9(B*2LM3DZ5B^A;@Q<Z9%A02)Q':V6
+MDJ0Z6J!,F20-DD,\BYR-NVM@V[53@X*Z%&V+=2T.>G60RM9SN9U,@J)N9G7H
+M8IE'&72:96)P:T0I))=M$1C,\6)S>5KG6[ATPWA7!U+W<9"31K*J2;ITP8#>
+M9YY!S;MTYFDFR"SC3G38L-BY0WM73IMP\G2MC0VQBKFQDW-/.LB92D#!0IG1
+M]_/DY/_.J_KZ_.A>'ZY1]XP3?8*\)S>_.76W);?&+3"?D+7[&#2BW-]W=Q,&
+MZYE@6%H,G2YWAX)O@30FGC16EY-"^FE!W1>O2IWL9I89-DK%2VUX>5S*UJJ&
+M7AI8/K&I;GRXSQ"M>.+.CM?*\JQ5K\'A9\#4ZP?"_26L;L+#";[&E947EN<O
+M#;?*\&&PPU8'1NVL5)N,[O443+/3B[H4%SV]#%SHX0SY)O):1."I!!R9I@8N
+M$T1+P<ZI#.[)MR7.4L_MM;5(Q]/;^"OAC^!R_(TH\F8/[?F'^!8^C>7<#2&S
+M\`\1]!+16_8&1]=18G-$B'X7^R^ONYKBJ[<:TVW;T"E<]2&9C*G%BV6[.5%0
+M2YD\;9PT-"H!Y9YSH%7AA+DO&$X0[;<:'%^8354>S("HP#<O12#8HE%FCE$=
+MAA6XZ[;9;F??CQVW,SPD[8ME:DQTTI,B_<ZFW;?:YSO$XVV#366,\_5R-K&_
+M-9%N--9FV8-8.D^$J-(,.@F$6W@(AV.&_L7]7P(.C?K/#0XT,!VVS-],>)K,
+M;6L;7##&G!W3A-+&1C-J>-C:T,/%^G6'2V!9,N"ITMIQTTR"R8=]#K:)MMC+
+M&K`PSDJQQUP`ES-LE9A1K)I5]L@ZNL9S6]JYJ!3`NS*VV??!DE+;$L<U5@S)
+M&Y:X0\GU7(GN.&AS#VG7@T=[@=FG-N79"&C(+(&O-K23*Y0.M!RG$SSL?C[4
+MY]0061(88^@;8O,`\1[U@X!L-KZNJONI1I8E9E27&!A,B<(LRLF^EH:EC66F
+M!*9("8*306D2`F9Q@R.,S0R+GB!O1M^KWZ]QT#Z-\@W\J?"8T%Q$=]L1-(9=
+MCB7,4YF07-M2*+"VMX>5!"\-AD!8$4F[*1'/(JW%0%).FN#EN'B:%=*R&VI>
+MC4)#OE,%KP\F2NQG8VJCD=`:[>'ERIUU\=37O6-JH:+G<%3LPM-%G.GAMEE?
+MP+;0P>1KM:>`UBNB>'/3%Y5'2Q@\,JQ,\;-C6LQ+&E4%X?.$T,U0Q;:'?H"U
+M[P5!</W_<=%T3J^VNIW(XN6M8D:.\/CT8-%$5G[\)!^$>ABL^@G#D>E&!ZF$
+MG%!?+6I$ATPQCICU?1]7?:]PGZ4^T7]^8L?N%<7$_>EAB8DBOV`&^+Z\=2VF
+MI=SVXUG1RP30QOQ:BT0<4%11?!;1D\/8?U0]5+][-+?W#'V1)`)U#]DP0T.(
+M;^3^``_K]71P!=]OL4_%'O*+*(SZ_2DCX[&_@7I'KMMS<*QGWW[R3N<ZPVZ&
+M#9)NR3HRS(YAS9'F0F.>!/@]?!S>M===!Q%$&%#-[E9VR-^F-#H'0SV-K6L/
+M0N8+WYK1LJ8FE%/:T:(&QP\GB&>J>"2]1SIW$N_0?;5Z#LC(Z/A1,830_'UH
+M7E!2!0;#@P%:^A80^98?T&!,Q^P<7(^GBD7PCR2>`CA3TS!,#]*_N9N_3:R'
+MX>$F(_8P?PA^OK>^YY*:&>>.Q;!N<%BWKZ%SF`N!\,\[:8*OO;-+7F<O5=(#
+MWP@T'J*YRU6<Z(JF!B>8R"[6L%]:*M@H:-**]6$31/,Q^_\>_@99BZ^_K(']
+ME;NW\K(P>3O^7Y6<%\STA/6BTZ^N%=M+_Y)?KP8MJUR0[B06*"D6"@H+!ZG-
+M^U>LVY-=M&6>7>13P\/9OS/&4FOQ_08\/]@]WZ\.^+IES\;U_@[]`4PA)'_.
+M(8_M#M?3?S/SIBO7(A&T;6\4S-'XQ<J6OJ@R!I;*9:AHQ54U5,(VR[XQT3+(
+M5.0Y5?@&"X%$7\^Y$@74($3]Z'V`T.!$GOL7-S,\XQ#+\+'ZZAFKB%]"O,+U
+MR'RPQZ1D*?HT:"&XW91%&LD3]?,K1JE8Z^['T/?A_.GI+-A4"-!CS%A@?7V$
+M(J[^@N$S\F/BC?O):X&_@>_0H,<"$<A4/H?22X7"\M]]C1E5R)O;2V>*YRL>
+M6DY+F9D75&;S0T#V6Z=.7FM>-=>&_H,3/+VO+Z9O=.J;JHR@KTS^(N0RO,(B
+MV=;ZPOMC8Y2M-6?"%L<!V9FBZG)SKIER[Z'3*++_##UN,^EPJ_KZ9KJ\?5[\
+M%:3Y<_V88^RLH9&"HT$+OR;E3I5I$_BO6I!_,;T0*^^_%?>S]K*J?6*^QU#Z
+MJ1RDFSO4.%2NJ1_8#^/J%"0)L'"R47)5+8H`:D5609`'H4\%D3A*/;A,`$02
+M(15AU_Q\E''NR73"<CFSSU>'PH3DL]2=#FF&55QRVB3UHZDK/IG9:')@T6)E
+MM#ZUB>Q1-1.(B()7*Y70BKS5Z6HK4Z"$3HB*K`?6FJT3Q%A7UIU>TTM#IY*D
+M)JC1TR1V'Q4(!`'[1^_"LS??1G$L]OM_'3^WXG.FJYJ3>?4O\SOU9G.]WVOG
+M?>Y]_:3OM-_?Z#^S7R_KU>^&O?R_/Y^?:8Z[]>EG@QESWR;'&F1SGUQIO6TG
+M;?MMEKMJ3N7ARF6K_)W\_;ZOQ/Z^_OWO<K[/S]B]OOU7U^.1_#_!KA7P_5=Y
+MQ')&LLLS2Q4QUAEPU)6P&=@-G[C8+X\A95A%(S8ZM?DF)/?Y@08@0%#L"G+]
+MRKZ^=8W,^U9$E#9\OA&[/=@M=)Z$]H5I^IGVZF^#8-]($A0(2%N<5ZD6/6'$
+M5>&1-%/*T%@N79".0(B0:@F-"SI9:D:R4E;,80['F%CB,N/0#H4=1D#0P<CM
+MEH-46F0(3026#<T18/>J-3WGQ>SW>[V^[+IG\?Q5K>]KM[D?CH!D!F'X'R`\
+MA.A)K"LPC,2)J(9L)0108C%B,1KW/U`;'\)A<A#Q^0P/+$2!$YAB8>F_ANE7
+M-CV0F""&0AB$@Y',BA2D*$/X?T![9-@B$Q8P9#8OY0`_RY!UZ?G^EO5<UC3N
+M9ZH3]C[$+KOD2'^(:1V1[`_;$)OQ<S@B884>&\R#G"4G,B8.>P,21V>NPQ%P
+M\.(D="/$67%6:>62;$I$NH&"+9!3IBLP=TY5-1>>,I&"C[1CZ"W9JP6.AT<,
+MBU9PZTK%=3$:Z(%69J=,(2-"(2-`)C$0,.\@=.,(2HBH_!S30>X*(#*(8/:*
+MROOJ_$)&3`=CE["H>"77-(4)66O>,>(VDPJ4[C!X3AHDW<"\)(AP$O!$=NT!
+MQ-5W=EAF%I,*F5,_`YA.;$U0T%LNH@T);"%)5(L!9)K!#MH9VR+6A=+QL&E#
+M6<9,ZL9.XPT)O:<J3H(;E_K^Q:L'!-@]HGD(GN$TD5*OJ43D#T@))=4EY#S*
+M(!H4:?!)#C?,U]?U@S^BV7)]557U=J^.:.UZ*F_!2J'6]LL56)G=-MRZVR]^
+M:8UFK[,\MFZ(;VUO197=+Y47^Q>VG?/]"[I:/2NEL5DK91/W<0%]*3/?I@$B
+M?+]&L;FOT/@<Q/P5E369,_VFE^])C]G6^7B/&B-(&%_-W6*'%`:OX6WQ[+?[
+M*U6[Z[8Z5CAS,FDX</5ICX:]Z,C"=4E,UZUUO7@F-MM,]]&S19LRD?"]6VRJ
+MI#8!!_!0/\6*<]_,#YRLQ]^Y7=,5^V<KR11U]]#N';;<TQ?MTQ#&E=K6VURN
+M<MQNYPACME;'/&9TU-0S1MB2[\/3/\E^WU_5_P1^M\NGZ2)^C)%?Q]C*_6.Q
+MGY_*]1,AC-"_:QIP&1-A?G!KQ4&@(TP+I)NR2[#5%>;>%GFQIY>!LX-37/%B
+MP2'%$^[?L9>KFC2BAXKP<A-1&)T*RUHTL-!(_;\9'[6A6J!M?GZG\_MT]ES_
+M03T[JT)A]^:S['Q_,/R6)\0_4/AK<$CY3^A\J/P/!T@0%CAKZHZT99PS!].A
+M:!9E),%9G3QHT8MTF7G4AU0P54T3`M_#3C&1CGN:$#5)PR9)%R\SMUZ[]\!O
+M@X+6+9&IC@Y-=FQQ?0SA;&F9>:)20SZ9<7*3-U349:YWU+IB^]5G.)8]NACR
+MN;#Z\'J+4&FH1&)J1P6!;+X%>S$.C@A/2U<A5H*X\O=OED=1YY,CG?/POBJG
+M8>V*AUT+(383*C.P?YPD,"G*\)$2=,6-7'#`9D@M08BRX?$"C4BQW!S\-]]#
+M[B!.+YJ!D'Q0_"P8827]<M.,S'@)V<\I7AZDH[BGC6H\6WL7.ENFP?)_3LQG
+M[#\G/"A?UU#0.O^;3^\[H;HFMPF?#-S&A^@6-T+SOP.S[10K1QT5*#/S9`%3
+M%M<I@Y3^38KM][?W(X'-BW$]'TQX&S]'W\CD69UH:)"PW:B<0\^&`J1-X$Z!
+M/X"[?CBEH<RBT12E2I++)7$L*"J"&+6Q<?/96$Z*3.?'A12VJ*E=JK#)!8*^
+MY<LQVB$5PNKB`B@.$"]+46O;@E6X67Y=D2`!-?&5)G8Q@EE,(02;*F"=$2..
+MND2(D$1,X,CGPAYCT7)?5('F@Q)"A2J*%^`P@T%&C)F*6))@2(C[K"'(&P1@
+M#)/9`TE(1*)2#_+^Z[?8U?#+N>C>6GOP22..+!S]%Z59L"J@B$L3WX-:),2_
+M&I%M=7-W;OY@IN.-@CMV3C">0+_H*O$N3`GE1I<H9#*@3!:PAV\ML3S@?+`^
+M:)!008G!-`D,1%4$D\7?UTAG,]W!'W6]L@.`%!`]$J!SZ_1['=Z7^60+>WPU
+M*^U2@:>SWUMKT%!0DB(&Y/B#]/X!2Y4T/LNP`?6P@M,-*?8[[D7H(RIH/3WH
+M.R=1\9,/5OGL#Z5.+\XA2F30SB(3'1&(?'>!H!P'"0S`AK`YH+T%7J&70AU"
+M_$(.I^#TX5Y3IV]$.ICVT]P^E\C"[AW5P4\0^"ML/0[/EG9$4R!\0VRKSSK!
+M0'61@9'%>!.3;@WC)[64R$3W>>$ZE?(40"'5U*>:?Y^@V(['H^;N.Z8S!,)R
+M$\1I//V@8?XP]`\9Y%ZP>`+`CG84F8^Q^3VOM`:L)7U9X_H"H^Q[)W>71KD[
+MVJHC%)<K&*7#,)MBTEJJ?7C,KMRPO-1?'Z\GCFOP=3J:AQ$P.U^AA)@3("D-
+M8@C$21C%,ZVC3Y'.)M9UG$Q@HQ9QX=7T'QP_N43T>#XHQ(>F9`.`S#6"SRWJ
+M%A)39"PP%;4'@3,K@H*(B9K2TKY0J2PHZPKD@=W8G6(!]"41,.#S]!]OR=I\
+MV0#O(.2Y9-1A.)#$0]`3CCL_QMS`/+<LSX:Q!_9P@F*'OH],!*!`73"$4&#.
+MU_:H;WI%V.,@BBB-)E2HX)"!,<4SFM^-)N8'@WXT:>P-ER$24,N[2(DPU2"(
+MY;<I)!A(#^*DRNFCF%0R.9$=U4N%MI7,*34N0ZE[6,)X#2[W+%_2IEP3L']H
+M<$Z$-YD<2!PA/G=A(E?Y5KC21$A:1X*3DM`GA/%K'W_!00H3]K$`GT^&D!_!
+M<O$BP%!T&0%`$BB>/#5928D:%LJ*-2,$@X<2"<OUCR+,0Z$3(`!,(+P5M_.A
+M@@=V*`]Q$$2JYV`,U!V#ZZ/2:0P8T53(?+>."(X.(#<X/@/>81:JG$\KU5P*
+MY3LK]%J/@9,:4&DM1J):HH,6\&28+(NTX%=#DG\*`,!@V"C\)F;>=RILY@>?
+M20UGFP?29`A#K'+ICGAR:>Q!'RYH$-#A+#+)F_18`543(HL"8$@9=I:T*&"D
+MI)CGI$RAH<#O,.CM!01.9<Z2)AUX]$R.!)%A3U&O<#ER(&%BYCUI/60DS9@]
+M9)E,F2]Q!D/:1L0=-AT^R<Q]!R]/O@71[3G->'<YV!W)\V5,1:4W'9,1#XQ*
+M'(?#WR'CIBX/PR(3",-HQ-'B`^<;_%YC$1+1XTW`YB"A)GE"'Q<DGM==8:@U
+MAA2E%Z@'W?.BFU>$AYYXUMJE_!G<A[]PK^C/O[Y-.^4_!T=;X(ZT:U&R!Y;;
+M\X+GGWVN[Q`H=(:0_"--`?P[G,]H3:00BI)$5R*)])/DOEK\/0>63EILVO12
+M49[11Y=<BI%@(ZQ`AV.W4A)UOD,@9,DBZG$HYV#2QZ,-<:AU0N6&=5YKIUW+
+M'?N5ICL6DBR3::CMQ@IP%W#PT0]*CNFGQ)CD2`4B$(>">/$RPS'6I56,H+G#
+MJ96W[/2;8,3DTWA<TQ4LRFZLM;*K`B2[AP)AD=][`9I,<T&X7^@L=("+SJ5*
+M.N6LXP5J;Y%F$G..4G00PP!MCY8:<P\P:9^T_)5<^Z/HZ;W-SM-44U%H3Q#X
+MT3D/A,C[IV>TP^C24@YM^'P<'O=[SJCZP>$GDWAAY*]H=B#(94PTQXXH1%6Z
+MCZPUFMV80O8G00#%ZNQ2E5\C&+"BBAV:&70R.O#S>[#)UM4ET+I9%77,R3%7
+M*.^=I@3D5#OTVL;)U-J--W*V:8!$0&U&'")URL72A.L9-1"-VH!JF'HPX9&'
+MV;`?QJ`P"/&B`R"?!VQFJ2![V[,4Q+455$9T)*A9LZI.W%I8N<A4AV-9#`TB
+MAWC)04)2$DGB0Q%H8)4/Q)<!$`00]8&(@D*"BBA**(D))2FE"`AFAAD!HHL@
+M3`)8[!8#7GF'1@`R(!4DJS%02%`L1(23"204#[(PI@HBC#,G<XXLNI>A5EQ!
+MNT6"Q#!M8`DRECL29$J'&8A/$8D(A"HA`B2J#A%W'GI>P^V<!,>IT9&FH*F0
+M49&87GVKT!C]4[WDE@XERPIA@+#UI`$GJA4GL#O]%2W4N?UBX?!(^P!*8?S/
+M71`_+X8+9#%#YSYY<M#YRBCYG#BQ%'JZNX/4^(\<!X2KZ8]U]JU>LX-SV\I8
+MOO#VT&Z&;$2!AE)23!:LV[9E"!K:ELS&M346U[0NX87Q0635V0U9DC,\K)2+
+MG4&I"CD2:@/9AU":(=76$!(!T0YG8Z(I*GV%?62.I982]$1"IE0(RI8EH9A8
+M`#XQ-ODP=N:4=<!G+XM\Y8O9+^._T=\M<BE*#3CC5Q>L*28G)J]3):O4GJ1N
+M9SW3/JJU*RU'%$LRE>(=.P4CE7Z*]\^Q)=G#6KZ.<'#^GM+Y:R98W^)>`+VJ
+M.NSU=ZSK%Y\!'FI[_.>U)ZI-=R>GS3KWX5].",`_<D?HJQLY?/ZNR/']80;'
+MS@*+G^9[*'X_6S/S]G@D^(L$_8\/V%_P%^=ZF>&?3](4J/]S.K]OPNUO'R,Y
+MXEPKGFV.DZ=/+IQQI@\-)39V-<H8R+W";YO1]?-[]>;+':>X^SEZ(8Y">6Y#
+MGOX/DV>0*DL;R42:!&0J/A.`626(KV1Y+0S/:*(F4<<K^OQ&0_A\`H+&T@6&
+M1PP4$L_D?S[[O7]6$-^5HP(3'ZK[JOV1W]]_=M)C,^"K@?G]V_P!7X'4/!+\
+M'7)JQ><&DJT>>BF/W(_)^IE@]F.>?9\I;\C]]R_#`FNY0QFV)H-";&$7DU%7
+MM2D+=+H@"!$"A-.E7W?ROVW;"&B6*:&.OO&&%=K&W7:A]>^P869XGHN(B!X$
+M"(!"%KFRH9T6KO]CY?>^ZQP$#M"`&9`/ZDEI]6YCL+YQ"#U(@]'$#<\9X[6"
+M21#3/D);4*-RI29&UPJXS)#)B8JB<9HY;6PQ.LXN?R=_=!T\35FQ1@#XP32!
+M@',.(M:)F(J"EW]#AIY1$@RP)$`X+Y\O-G=V<^7MZ3EF,C"'M=,[`E02PYZ5
+MC%3V">P8'LDZZRP985+>`D#@@>1<,B\DFOCMXECG?J:RU%(Q[RF.;%)]Y=YB
+MEB).XP$U4B%#/%+'W:H$U,1Z0FA^7[FLM`8YG0$#FJG(%D76B.;YQS#=($-P
+M#E#PGL>L#=4?`5'<^L%DX/*R;/A%!C\`;F>6",,\9W'H/FD.PZ/FDB'JE:`V
+M1#M.<47"AZ3<4.[QAYNV`Y;^M;$'S+$,I,0G(A28(AX$KVU=@7/U:EVS6)[[
+M,2#N#F2E%+T>:G1Z(UUG0ZS1BO0XV3Y."-2.8Z(1-$F,9H0/4/Q&@*+Z![#$
+MYOD)3.U["*0B)2#H8AVO:%!21-"3`%55/L88_&D2FBAI&+V)?(?L]%OM200S
+M/1.G0=;$DRE!LG/#Y'R#-Y.PL@I*B:JFEI*8@T1B0OJ(`PHD+Y,8E-/'R^M.
+M:$40%!(P;;Q3$D(C!?VCM:K5_2+34_1+[4M511E!(L0"FBN@=/?#WY%\TBYW
+M8)K[`M*?%>$]$G]Q%?W$@>/^@Q_8&HQL.@0_]6O*&Z,S_G)VM)O&6LY[\!0G
+MDGUR(<[I-[U][6Z[4:3-!$0F`^1L8NZ_`L0B(;94Y2*#W?H:B_$UD6K7T]SV
+M$"@0!&ED)!20@?>^JK2K&#Y+_EKW:S_+F11E_E@6_7A-3F_+[=?+Q,+-5G/8
+M,W/>QT/YT1$Q21B)H!-"&E%TIX2<@.0<AF1*$_.EP@W^:>/D6P[?:8:MI3,L
+M1_!G(C<^G^A'AKYZ_;B;9$TF("A(AP=,7+G";R-`:)3KGJ@=.^)REUIK.E^,
+MY+F!^)Y3C(5@HBB@$@@["AR.>;$#0->%\!2R\)2(X0!9RKZC2?$)GU@!VPND
+M")1U&P1)2ZQ"C0U21L&@H(9$P6J0]SSB5N0WO!G#!B(C+;7+W;@4AC^L=CP_
+M7.`RZ>=4PFGA=TR0W:AVDI5(G5LA^%/XKXL43V($X&G@Y`X,;G`[@M)AQ'&:
+M3C8/8GJ0)$1I84Q4SSQ4N61\NFB@T3S'C8X,M*Q5:C$&<Z2:.*5J*)!\4=?'
+M5]=40)YT1;%,)J:E2JYS/KQB3*(\"=TDC.GCGKS45XIXH4R/FDIETOZ^9^W+
+M[W]JOWY^S^/SGX^#CW7^;_/?@OV;^>/SZTUYZ]/X?U=_B3^/W]/UV?7OM>^?
+M`!^%\]WR(]@$`=Z2X$AHP+,("R:I=`A,(5KUJT)S?DSZ]+U(T2I/(T9.]T(1
+M3N$)GS5*L52BAJ6BI6..6*>B=J2FHTG;U`\`'G.48'Z1]%**MY2^X+35/J/.
+M>3Q[%:UT\NE95Z7\]-<8W]PLB$9$%@.F^[:Z2!@D(AB9FJ*^XBJ3R?:X"FIV
+MB(JEF"HGJK+*J',*?1S]7G.[KOC5OQUO>_K5Q(JQ9_:!^<0Q;A`)JP`$H=0Z
+MP6*C0>@)%#`I1Y5=4JX%22*B)G3M1UHD)Z*DLD(X;\;G?MH-^6*^OUV+[9ZB
+M+`%X)1.^%4CG4"`ZT[][$['2@\?3U*P[YWWS\=))\:$FDD=QZXH(A`P9:D9<
+M"01!`M`):G<E:9M?79E9,Q,N&FE*_QY(9C;1),ND'"LG07H/,YC,EN"HFQX^
+M-=WH[^-H#WBB1!689*]F-QY")$'*`!>"=D2U/?1/OKZJX"PZ[4Z;=GH`Y(/P
+MVCKP#"0'B`!.Y9>RW@.LC;5&(0>%Y.6R]P3M-(GQF4P>HP"9RIAJ'<3V\%$-
+M+(G5@>+IR.N(]+=P?A*I#^F4>L7NB]1OY>AB&A0H!^QLHH012&V$H0H7R6$.
+M_=XZE(AB7]TV!.VR#V0R8@+I^5[*'J$38%1.(Z=VLP\U=IH-F4#HDZV"F#&Y
+M9$;2F6=ZA?BL(,&&\,04J_&G>CPDP0.+B<S"E91I&H%]2M>T#R^(#SD8>2=\
+MNGU*OF@PNC<\UOKS;FM\44R`*H$)Z;HQ%%:T<[70+K1*&CACJR=$;8J<FO(0
+M[!R`()1H4I52#Y@<%5]VQAC2*22>B_;"IY"?\5$D,!;$JVWKU,0QTA4*3&YA
+MKG,JL7TH3J8Z39M.'O#T[S8;-$3C,HI!2B\<V9B59,(WA:%<VC#%S.]$"RAA
+MHSJ!NQN0[=YLA(T"FW,ZULO&&4>.C,"35DSW+@X8#">BH:5B8]B_H1`47C0?
+M8P('!7R"C[)[17MFRC[F#L!>0^D9(5!AHE,4`TC2?L]NW;ZO\G(,V0YA\0^Y
+MUD6?=;7Q^."*"1J+Y:,F$E/X&,Y4\X@<`#0Y@B#C1C)_:[)5'=@XK,E/BBW/
+MN`?-MRX,#Y1PG7K=5`(A147K0^8?,,/.)T;@Q`BD"D:0*I`8D3ZL"H#VP`WP
+M7#@BAM<V/LF-SZ%0![YL8O*IYTZ?X$!_=M34$GPBL!R'25B-"$R#,HT--*3`
+M.E#0IS34@L9-I>5;:"4TZPD/<7.I[Z"U8N%K1CB7HYFX'=P$?.^"O<=4[L/A
+M'WT^`>/CCF.#['K[%TANI2E%%(]V5OO]T6Q)T&D/[D]_UO!VQK[#S#647`LL
+M0,\\+8KU2@Y#%T-<@P06(BJ*:ETQ>XHK1%7RX-S0KE*IU9B@5&^+D7:'@$>/
+M;BP/O(47=AA;[3&T`_OA!$D4`Z7(3![7^.-(+'C8$JBU%3J%Y(%4;`E4-"H2
+M4$IB7)*4'YGYF3HM^D4/BK(H4A,!,'AXYM@`JEB'9A0_#G[P(:I`V&(HL]P6
+M^(%3NU3Z?\ZDK_/?8TKET^A<.!<A!%Y_H/)9."[C7CSEY(QX\A$\D(D3H![X
+M4;;6#21NZ#"R)T$`3)5!`Q5!&$5$]HA3VY%-H#\W-S2B>0ER5-X1R4^Q(43+
+ME)O(`Z@*6BD4^="*ZZ0*.(52ET"Z`/"$>$:(H3Q7YG[/.A)O*G4$8$4=^8!0
+MTM+M,D)D/T%AJ3HF#3'SR7$NPP?%5"'(/DS"!4_/:#`G5'@R\3[8T&X$*P&`
+MJ"Y7SC%BE@R+3:'E"_YB?B_&?DS\F>H>O/0\F4"*`?"T+2">Y)@E@%L(:2+1
+MV0T<)$TFY8XC*FH<8\E.0%#R#%H5/(00_JFPOSK2)'/DL##04)0L'S<6((."
+M.*IGQA\P/)R&=H6P7(@2PB2DCVJADUN#!`08PA8`SG&;J6^A4Y-=)=L&/3[/
+MOT4B2$I]F(@HI*%I(D@*H"AB1I:*6""AB%^!ZU%YR.E>#CK9/&;H/8'6I,I2
+M\9*!XK!T@T'H#2_;O`<YI(HIFNXC#.L1.T81T>+.H>I6BF8JEKH'!FLP\WE3
+MM`\8JG2!`7L?(O,`0["00(Z)U1H#EV;9Y^_[WZ[]_-1-=HTU`R*J*L$B4NH%
+M+W$$8Y09F9E40U2W.IPSWV4#?+T(!`'.\NR0H0PJ3XWJVASD:>6K.3[9B)AP
+M8*=FJT88<!L.PH>@)$&L%928'+49(:IA'*H5!%/E_DU;#P2X00$J=9E\GV8"
+M<#5QI#N90<NST&CT[D-5*D9H9FT#*V7J?;)1:$BJ(E!(4QVK$L10(1`?U:KD
+M:2H7`RHJB61%D(D0@HK6+BQ6QJ@J-.)*QYPW-#!W=XX*&/Z,YW>#PD\-B*`@
+M@V<&\R:X,ITZ&X<@:5PZ`Q$11<R9DH_S'ES@78,$$0Q!--'D6<&\X<$.;!-)
+M021)I--<C5>2N`(XJ((J8@@UC""Y`D.G!W,XH=00T\FCDFX8N9QK8DV,$420
+M\.8`XO,8AY1LN.1"J'QKGK-F<ZR8%%W(JXIT(B.R609`H3..U]PP*?B^Z`,8
+M_F=[#1GVX_3'O'V![%3N>!.9GQ-&S=R">ZIC\/%@N0Q=WQL$U/00:0Y',-!M
+M$3\07=0\R)"I1)`:=JIAF-S1]D%N.VZ)"E*!!R`4/NG^_L!$I&A$VPL3,C,+
+M,,2(!0@4D\$#H*'X$8V*A.^R```]-4HTC0(4%41$$RE*E`4!0I0$2L)&A'24
+M#$E#54%`1%(!1$4T!15%(4H4M!$C,"14I2@44$P;8`I&E:5"AJF@":J%*:1B
+M2AB2(B&)I0I62$"9&""D6J0"B)"BD"(*`B$:*4I()(@I2B)%/)0#2M,42A2U
+M%0@4M($P%3)(0E*1`4#3$#543(4003`C0R244I12E(4#,(FA=)$B4$0L034`
+MA$BA0LR@R%C;Z8AZ"4H(!^7,L6U&6NA:%NQUN!=$HV=60Y<Y\*HGWP@1`I15
+M"(,*2JTP2(T(3`@%+$K0=\4,5)MMV(!WCAJZ!&RJ>*#_%^2!_PJ%=1K:*,&)
+MQK14F,.I(2BHC5)I=@S8V)/RN045S,5;1">GX[TN@B^Y%Y[S[3@:34%053DA
+M]L>H.O2B`J)<&.A@X\BJEF+.)6D)DXGN6P</1DR'U\*4!D#V!"T#!-#21(1(
+MDRQ4M)T"Q@2@H")"(0H\?/#K-Q`#<-CT/RX:Z'TP01['O3Q'E25\F=)8H@PZ
+M1]IYE$,%-*Q30I0D40,5-$E$$301!133%1341$A%$45$4$140$2U$BQ!%1Y`
+MABI)A`PXX4ZB`Y'K>%`^41LIP8*=.>E.SJO=5!:P+J'NR;0T&`B0EPD2`^:\
+MP.88S1JP@H"FS5^QT9)K9_`TJ<DY`C>C.XAD%.$Z]'8R!WG</B(<<5(*)9FG
+M&%!D5L(2CFE3#%.Y6E7*'8)MN;!G`?1I\?T7J>;_=SO^.A?ZOU>GIU*<5B*.
+MUOI;+#####'>CTB=T;M;N&<K"WJ]@]MK"K^0G\K^X/FV`/W6'VI`0$K]_'WJ
+M('+'0;-!-:^4#7YI+I4G7?;",D19D\@V@'@SE%8&91HF7G?R-G%B\J0R9`4F
+M=OSFQZTLOZ-"5D>[SP#<2)"F))S%O'VAM^(.K5K_(4#QC](A$".KTB:0#ROC
+M^@9&&861E%I`D`=5,1-Z>(^$1$4E3P\(.`%PZ*$(Q#'@8_GKIITHXD/[L_('
+M<1$W%W,`)RWE'4_K0D,HR:6DL83!`!2#<<IH7\HB*J^DL;\!@HO[P^UY_8Z=
+M:T;6^!J6*:L,+WT#G18%01$508#B$^/K4"LE3[6>1[X@!?N@+F*^3H@=G6'X
+MP',.1T/LQ(<(I/'"81P9'^$10`Q4X2A@XF2TA#S+9`.M!Z@/J$T@3(S)L2@8
+M$S)2MUAU[CXST1XPHJ':'&$UX88:[--![7MCON%+P&A18+X$7[%+44&(9D`Q
+M#;3]A)<\M:.AHG4]IVTFX3!Q$S)2IX0G4O&':JLV&R(I8)97*D5;AZOVIC,@
+M(9%<)0$LPDC?@D9XS/&$LP3UB%BQ3>U(P3%L76^"E+M(QBRS3`53J'E+BIS#
+M^VG)^5/KE5V"%Y3<M:!8@L0%1A$3#I0,'L(<0!A?P#JW5(4])(I>(?`.TV&D
+M.[#`[K,Z:=3FQP0<,V9&<M%Q+JEX`2N]9`X;WE\X<_PBR>`7-`-(=I#]HN#G
+M[@PRQ>6L1&4BFT:C8ET['RX-P96-%#(0L2T$$4$E=9>KH=1L/A\KS9R4_<P-
+M*AUGZ$/RE2%,&=IHQ0E-`0K]X#Z!]I3UDJ\`0'C'8'N`C`QPBE-HQB&%J"8"
+MJ%B:5O;"T,1,48A,[&PD"F4$P!HY&:0VL,O9.\E(NFHZ0TM%*4@8@<4324`4
+MJ;82)`B0:7(QCSA\P-B+O3U"$!(=I[O)W3IUD,'09)1L>9U\>QZ%Z&Y:]B][
+MV.HE066[!\WQ`GK\H[;00$BP2(Q(4"D$/94Y4A*"*0',0_PBGS]4:9`PC85Y
+M2TH4WF#J"DJ)X3E*E`<>-4U,)30U@T&T$21#25T#XBY[HVD8)/)TS)3@!$VQ
+M-T4Z[3L0Y'OR!NLFTIDN60%))!10^2VEH%Q4D4BHP8=J"AF>#"41+PMLWR8'
+M^ES!24J>;><YQ!Y)H6F@CD9\A$TB-#H3I*/(`:B2G^E+I8B/#`]A>"U).MK=
+MJI+M8#YB4>XL2B<"'[AE?W_WPT20>U[(137@/O]5,1'0[>KTGI`J:&6HB*@J
+MBBBHJ:#6O1C]\"Z#":I^KAA15%3)$%?.,<KJ3L[DB4_24//"E?]A`C3Q-L>#
+M-&X$MY1U[A/J>/0>3+%/BU52^J`#4EP9EP&P8FFN)C%(FB;^`SL41K&(R-B,
+M-,SZ3ZIIUXN#QCS-D3S$GN>'@L`*"V[7UZ55B>C"[2!K4UGL>OP5=;LH_=NT
+M?+_$?I?Z/M+_1,9(4TPCQF5]UCV+_`LZK80+DZ#%)K>K7>EM<5?VU]&ELLS<
+MR`S>64DBGAB';@PG8N1GB%?;F[R;J^/KE]6.JW.E/#@QM[+Y8W/L5L46YYM8
+MQ,;%8X9S+U$G0L8BA_`3C;01$$8!]`<_ERXA8X'Y$T@Q/Y">A4NC8K/M>SP;
+M^.ECB_7GCMEF:\/.H<7[=<M],6*0\/@H3\B10]?RLBZWZ(T`@J%]V)?V+'\?
+MJ/Q?4<PRAP8R;:CC$H>::AFG67F`TQ#+L::2=0T4A/W*X'#)FH6H/4L24'\G
+M?RIW]8`B/OU_I"0^(^$!A)`MCAL4*(OXYE9G\-`VRDMX9=KU@IC3WT['!<#)
+MA#F'%^=>M[F4U%US$<Q^`LD1D$&.06E?N8^</!=K$-#@+(J8/3>"[%5`[],?
+MF)_<Q\\!18"4AE<T8%3`U830[\;=0^AN:X%`/GH3V-&_7Y:OE6Q3'NGUR^[W
+M"6.B&#ZZ'Z^?G]_H88[V>_4CYB].S71]=X1V?7#.WAX+WR_Q^POZ@$?.'T<_
+M/X8KZ3319[:$R,EG(XG@F^<S,)8R*,%]Y4.N08_(?T+$T:A?PMOZN?VQ\*9"
+M@/YH\/F(?85XMYN@HIG+`KF@;W?.LJ5#ZE2.%2&[R8=;>KP;KE89]_9P`_")
+MF&S_"GDG?T<]A)&,&G<Q/,48LDOV&/H#7[U.T]DR3"F#,STGSSZ+[3[_M&YD
+M9-.`78Q45,3S8<1BS"1,D#$'3F@>[(%`[;#12U3$G1,,!\0]9\HM!MNB3@$1
+M,Q%`_LOV6&P1M`0!*4+5!2%)2T/R8,):.V?8)\L*!A]:O">>,PS$:*B/C5:&
+M<R)?+*LL[O77YO%71J=9ET1UH$E@BB7)C;""01I82X\3B&OQG13SKI55IG,`
+MN%,\+;V1"YF8Q4/Z)TRS+V),!1F&JN1$7$A$9DB?WFW?!53DBBZ`5.')HHB`
+MB/8VB">"`G\6,G@)#T4XJ!YL=Z+2(=+S]7]X?=`>^8,"R5#1$\C#"@B-_G>C
+MMZ$/'K5[..L#W@/;YTE%*E`R0"%34*TL%1!)2%-"5044`%$0E(,0K2%4K)`$
+M0,0K#)0E`))-(25`1*4E($0,2%!$E+0@4(44*50M)2E*I\R)H4H*2(%J)4HG
+M8=(@3"-!,Q)2D0+^,.D(FE9J1DD30N24\DW$B0FHB><MR]G=]^/;V.0G0%Q`
+M93X!3J>0O`!\('4_/@:'J=!\B"B(/![A/>!7YI!`YUGF>L\HBN0H&!!R<!@*
+M>2`<)*!IHE*AB2B2!@(F8@]V5R:6(*!@@@FJ&"E@A99F8H8@AHB088HB&*:(
+MI&"FD$I&.F0PD$R4P8A,G=E[S<1B2"4FJ8EB2:8"(7D#HHJBJ*6@B0D)HJ4B
+M"#IDPG0,FDS`9@LQ-0Z*AO-AZ$[D[R!\4J7B^,>G6><B]B]KV2Y;['J/(JBQ
+M81,0R#2'J@=.S@/`F)>\U/J9$9$0160#DS/>>,/<`7G8FT-(&&%230I!9#7(
+M[&X'1A(>HM<[=BSDOIAY],#I4=)7-]C0!TW<4Y3$U0>PZ8;IGA]971V?"#U`
+MWP'(XQ!U)%=1XJ?!\8_F7G('8-Y\,<:#;,98).8#$'%-],7R_(>"Q]?SM!-L
+MR10%H=Y#HB/R:D58D"@#R$OLBG]_@[J!(]0H/G3PJ8Z;^>H?%U(BS-:(2A#!
+M0'W?.3S#,[5`RMZN\N845M4O*Q8JYZCR+DS0R`S"=)O`ZPDU/5<+$VSUU/3;
+M::<A"^]X*F3<*G+NC(&27L=\;Z0DX9S)G(&T1APB,.F[ZPO>@CO#4)W&.I9V
+MY:>'B9Q%3)55I^4PTF!XRPHC<.B.@T+CHVX\.G3,O.YX6#?#AG011_)B/[8Q
+MQ]2!UP5$1!Q9'+94T1H)H0^66&C4C0WN9@*9H!&ZF5%C=EIJ!#1*8BDH.`0:
+M(FFBA2Q3,*JH**MA,S-35KK5-:H]$\RHA+S-_8_:D$$S>NO\GI\KW'4<SU'\
+M^[]I_'R_F_E?+]MZ#[_#N'!5>%N^QX?)<EA+%S[<)M6XFG@#1CS>=-T?><=R
+M\='2+2Q$1$1$4U%S#OEU``HP.+5=F9BTK"J-12&>-LC(:89W,#(4:TB$=^4X
+M[2B03"((;Y4!5!!J9`I*0*&(H&EH*$*%28B"D2D`I$^_&%`3\`\/J?4H-2TI
+M)O&("5Q%1`6DE-@+85=(Q8[0\NKO4YS`O.FQ1VVQ%YV_'8=K;PB?".0.=&.K
+ML*JZ/2ORHF45RN<]R9)YIO+-Q\O[L$\AVM*1)2'W\^V?BN]\G<^0[7%RLDB8
+MA'^KC_1W`"LO>4QM)`C@"20E$X@R*.!NS'J'!!$B9F4<TF!QK@;=DE.6#DZQ
+MPG%V,0W^XL>!>0^KW61B\+-[E[`8-;0('.#"BPA]<UV*QJ'\DT.WW./(Y-P1
+MN0HO,M+^NH"JF*BIBF(BKZDR0$LRT,2D''[A\<B,0+5`B46,$(0"E,2I2!0O
+M9\=B#<WX,`.3OOOP/($"D*$,I,T@H="TQ69F+<1A#33W[.P%$@N".2+V!!Z(
+M78>\W('H0'.9!T`4(7O"^_<$4A52BH>H0TJK-\Y#[0%:#K&@8&JV*)9S9"8V
+M#)B@HQR"</BZ,`0/<<ZUG(L#%CX?5^F_Q^G"4G`,!_.02<,_TO^3^S9F0$ST
+M6.NK4VAA)%AUU>[%BV@U4`D'PYS`\@RC[DC,S:\7D-S_6>U6QH?=CWM9"TIV
+MU&2NIH?%.]T5Q!^>Q%$!0`\A:(\WG-T[TUC5)G]"*;W=S]1MSK^)3.8;!_#<
+MGBY;V(^-Y=E(+F#D<:*F+.18V+X=BKI:0@BX;&G2R02%)TX[AV-B[&XF&CZ%
+M7&Y'>9BF$JP$P8(INP5%*24E3%N:F[PE*J)F+@""H\S>6B%)`<X@L-Q9-Y&[
+M+BF(*B1JB@H*(B(HHY!R7BPITA\(>2S`TC4T`4L0R1WNX\<9\YCSS/DG4P9%
+MX9?-54/X[9G&90&4+RNOS6EG&M26M(>D"ODW-AK=J.93""*YX(2J0F'NP51N
+M2<A/?^#/IFL`X40\S_GZ]_$-?S4?6Y3D:,#38.!N=SRFZ"'>BOC-B-L?B(!S
+M#<;HJ?E.G@.*`H=N:=$F*0JB',%Y"KN)N(Q&'[[C<B(/`V5X>"(D';+"%KZE
+M_$Q3>JB=+B2@:&2L@P@?DF28AIX,<Y!H#(>\YZKK=3ML3T9M/&C2[(#O0`5M
+M00A2<#A4QBH>??]BX!QU@N=CU)5*IIQE%2<3)42D8C"%IAA^2$:@V#+W)3'<
+ME),%$*((29Z3]<5+1E;%L6M397<#:&YZ":(9DKI`8[A,LA^PPFMH%B[N<V4S
+M$*FZ$L)B)$=$(40WEYK#6F8FF688<T?<N#(.S@]'0;,*09KHF$'CF:1'"",L
+MN5V2`B'I[[+T'.3`>]CN*%V)?%S?`AH7;PTTI84.0?7>\U'+%.N]\\.P?4X>
+MMG6LU!G.]PHZE0<9G][IS1I4%H0LVVDS$'Y9T:-LZ*.<W(/6%[HN5D6VV)^6
+M0]O;/O9V=4,RPOI76YI\FFQ#^A*E3U>I6!A5#X`HW3D2';^VMV2&'`,2*Y)E
+MIKZ37&.(BCAV29HF'*>6B8.*Z[H0L*)),8PG]'FN=YOMG9ZI?;&P">!O-UB)
+MR3RL%5$O=#A!*,04$<&R#ZC\Q[Q.L[#]<0957+N"GEP"G?4;0O0-:T:6I*(@
+MBI<LK$KA$,%,HJB(2843]=ZM#>J5D=$@D99J011,4PKJP,KF00L6IM4*&7Z;
+M?G[R6KIBJD+9F>QG,2;"1&$4""`A#5S&%%RQB^/Z61E42*!8T&#Z'SNQ(0[&
+MSB=[U!SP@B$@4[@J&TZ9B$W#]P_*?$'Q6MERHIJ-#!!08@#V[$&,@#G%()JF
+M!BI:=#V`';*,7<B'I`Q5B4`W.+9'S'38V\I&J=8S+3N'B3WDVE.:CG9(+S#[
+M@V6E8Y<0"I7!>\]I1Q?1+9%U\M+PEQ8>5%04B@-H:M@52Q:HM,-`'OB]E/2T
+M8J`V*26!HHJ8\L8\>_!//R+0I++%!KO8+-Z&]Y>77(/1FYV+1#*E45W=`-^1
+M&*IY0W\?)<,2$8G43B,21-'$^0QSZ#@4E0Q59K0`,`=V/@>;*>(*1#^&0."A
+MNX'2G[H:IUH9S&\N!-+_?%CLYM=W.1B%T$;:#TF31/9=).,'9N#VX$$!SAQY
+M,S(T@0EL.]8,5%X!/(>-%4QX=,$\5[*^2)V,,FV7PX1@>3P)Y-=SF*(BH\J.
+M7C/@3U6R:%I"B)6*O3VZ$3D;!D<G'29H0XFU[$!I01T<\4<5!I!G%P2&B3"0
+M!R7R`;8`"D`Q"%,2*4CJAJ@*,1Z.Q7.4F!`['/-$TL6_[!,%_%L+,(T>)5CH
+M3^F(4-`G[#!](H^/@M`?H?MKJYCI(F10`X%F0UGC4@?#;;C0=NQ^V$/!X1)S
+M9V896$E"*B&0)IFBJ8AA^%<,$F608E*0PG"0*?S?9[UN?:[]?M!/'-T<C8(C
+M)WREM3;$-5UDP*9FS8:B7,`!`2$+@;23ITN2S=&"*H!9K8:`46_;&)B*H%Q(
+M'A`X8+'+FC53DIEF%28*A#AD%_8C'?W%(#'WK%:$8@4"'`Q&!2'8S,P:H9@"
+M9)@(@F2)TO`RCD3$?&XP`\0"PB]8'!\D]A1W7MPV,$X$A=S:)(1#[5B3Y^KB
+MM]#XS8Q\Z7R],\J_PV+@X9:C^2]-!HB!5!`:6Y"+"/^]MS,*G'JL'PVQC1K%
+MO74+MU<@E(LP\):"!JP*(-77X!H$9]#6I"!S1J3GQ&B:N0R04411$RK(,U,A
+M0'*#)EL14DJ5/V)IRE2<%0A;D<)!JR@H4`*IAD8;S(-06P92Q?B18HH52#2(
+M)B4$/JG#ET)^#?]N;J%)/QL@E'Z?=JT?8;_&[QP>?@SF)Q@D9,EG&#0]5&9B
+MA0:G\VV+7STF52)&,-@BC6_EFOE);6J?PQ.R-<M#3^0>P6QLWNQ8N./G*JP;
+MNQ<213F?4$3X2*E&Z^?/;NPM+M0I&76^MZZX5ZYGP`?.GVN$-ZHS[)=3%2L)
+MSYZ"@1X)OOD^%UG646-U6]1Q/ON0\;QNU_'[C^?0>#_+U>_O!P31BHJKB<0_
+M,=OQ\80Q#T^_D,^[S#S#49T9+R.HI$G).,BC<S,=&-=V_>D6U(V^P$K^EGG@
+MJUC^IBG\_?CQK\+32"(J,D"@5,))D'']*9BY^Q>&^"(H%">JBH.E<Y^\!`0-
+MOT.Y#DFV0804G=C@4D0UD_M`,:*.=IXPYNS9`A:3(7-W-#U,UF(XCIS31AM_
+M=4TETH2%I,S[N--9D'ZYZ98.AD[A;/.#[8::$[WA&#7#@1&(K$=4>Y4OF.9J
+MWUL=OVM\>Q%,'Z)VHVP6:SZBQ+6`4115%<<7$H0!2#BDD%%#H#Q].6\X(D\H
+MZ/6.H'S`[Z-`Y\XTB=9VD)7!8A"%4]J)>-"="PGZ0S[\</$:=DJ(^_6P"1W-
+M&:8IHO%SB2'A?$*?'S[]H2L<L?/SC.X<(C/#L9T?`!VJ"`0(]P%<@Y#,I13U
+M!#G8$@R%$A^/\0.3!;4&AA]^E8'^F!8P7D4ZES[^(0X,LCOH3"*!B23!P9?"
+MQ:ER@VAB3NQ!Q42?/SEB5::;F2C^&()Y=]*GF[&*"B0X,8)*@T#UHB6$TY,7
+M<,"E&8,$FZ0HL'4OA!R@.%;.-48<D8C;APQQC1/,:0Y1M89MBB2QBS()24<=
+M!4NL*]W"!M!TA$@4JQS%ECCJ"SC8S68"@(BDQ+RY-Q><QZ#P2BB(""2BB&#;
+M!M)@I*M156H)W`,IG#*8&>/EOM6?GC![(.<]>N)ZZMX!T`8"E6E*4'8<$A*5
+M2D,*4G>=0HX<WL-0XU'S?U8V*6BU@1$9#]@JI8B'/A1H%$YC,VG'.;V%F0W:
+MW(S'-*ZT$V*UWA\'7J04!R`F5^WWD]XTW3)D0AG($5$D(M%D115Z/CX]<!<,
+M[_>>9E`.<3T[R*T@1I`MD@B"-S@[G)!1367ST0'\>Q$\(A$L2&FJ^HH'`['%
+MU@ZP6X7@`IHO`'J\Q]B.8BCQQ]&Q@QB?/1-+MD6L>QKTR*MJ$.]4%]11,7"+
+M<"%D:5B..O@_K#V#`P,#PAY?+P',/YM2&!.D+C(6!)#^2$^DEB$N!W#!N73I
+MU8)D:2BF9(D@A(8"DPIOFE85*2.YPT`*Z/NF#6!$$!2I8S`M:IA:O/;BBP'?
+M%2Q@P?J[@_T#YCP\$[Q7@D12Z&1I>TH(&)8D@HB%J(GR2(AD'!U5P]G!#&,K
+MF4Z1'ASHF$/Y#"'!]G\.?A\UC$?)+P:!F2F@CF=&V"@FJHBW#CQFBKA&MFC`
+M5"C3`-#GG!B8#KG@.I!9#XG`ABV">GICDL@\$-1)QF&F:[/4];B_Y1U8+J53
+MPQ41`\D*J@#*(GHE+*G@^DY;2OUO,>WU<G1]'I]52-,JL)YI,U6)]@;W?Y`4
+M\KZE546E%7V?Q,"`%)(0#!<J20#3,T,";;YGW,U#Y%-T?X3<:>%(OI]G=LYK
+M8/>V7'9W*LA[R([0TFG")A7T&-UO$2KHY<L"?CNKZ/+N*BII"A:2D>3L5D1Y
+M!@B_&(::JJ&@*"B)0HH9J***I*)DB8N5M;6SCD(J8O5RXNIH1K(F-D5)*U1%
+M$7-RV:0MD&$MH_U0GOCBXN"BBU";9$[[.S3ID@K8$5Q1>2(H=HX^$=%!7@*=
+M+F+1YS/AYST;OX+F;R?,97R$QI4"]RC=DL8NV-[E%R6MBX>3Y+'X%H9H*@[G
+M3$=/,!I^X32+KLWS2J!,=R%\;-AMZ>=9J1@YU@ZN:$MRPCA7*>Z:=`ZS4(:`
+M'?F5T<EJ283VT34--[2,_2U<QS#28IF3189M0)WDE$28.$"3`B".[Y#00XX&
+MB[M<$UK-:'3BY(46CD++`I<A164IN>V]79U2\)F[@FB=NDS-'("3,-XCK(9-
+M:NBE*7"9EY,N@[$C4.80YCHT7T)FTT9MWKK-`H:P1`QG+24GT?''B^_:<]!@
+M=U*4_&3"<P%X;G\W!X<@G!W9X-ZAZ2E'>V&].G*(VDIV&L,-8:AH\N"]"$D$
+MQ`A2`:>`BAXQ:3,8UE41]5304D5UV:=!L&7A0\-D)HD,KD-LTXR#`C"?T<Z'
+M-9J=0%#GR-E,U#>6%RS+D2=ZT*#U-#F\<@FLDIFDGC-E;NQI)E@ZA7,4Q<N(
+M=V$L&$*@N1)N5P%TJC@*J"9$#6-RVE3IVU+N#PMMV.ES\=PO'P\X)V4Q*=B*
+MJ0H*0BYC.8[<C<=RP<,/4D"BMDR(EA<<R8D3L4,ZX&G&=DMPD!)W2J',%.LR
+MN"2%)C;&)0L-]=9>!L7`XDR"B@I)F35+A@P'$N:"+36:H8N3B9@D4D73_%05
+M2U0.*@,.G),VA@U@M(YXD4_3123#W$S)X)9+)5%**%21EGG8J'=-+%&2\'5C
+MAI/`%-\WL^M,";(29,-H1SYM3CG-S4D')B8*<<R#).6$]-W,J!W,[_3S>$@=
+M7WQ="^24H?4!Y')"(6D-YWN(+1<KY5S"'O_K6=G-:0LP.1"45\&#'`5@C8E&
+M.Z;LL'#7L8%%5*MQ8###QE55>/IF:3,HQ-M!@\2^PLLM,$79H-&](<X<T9,5
+MFAXW.9V\'T`57X,?SO*YWQXI64:$7&*_HT%'Z0RXQ8W"J/ZY6>1^@2<<PZH#
+MT*:*03(1(:Z7-)@#O!`S+2&A8:`1J>U(%H6&`WE@)@7$E2-NAFL=!8%$N08!
+M(IFSB=F['9.D'2YS'(U*:><,\0*):($I0B$B"X1C3JS8&`AII"($P&TU'I1/
+M^F"`(A0=S8MM&(AO-`Q^M`WG2\1H(%\!`I`%,+Z*HK6-S')%.5@93T$54[DR
+M0I$-"!0HE*G82@I&CL"!0:!.PO+6A,5"=D+M91[`4/)%Z2/&8H*8,2=N<PK$
+M',&'D)UT`89NU!H.PIS8(@3D*4J=9%Z9,8Z<.]>!')>XP)HY';DI$G9.5%(!
+M!LO8![*'1,S$`QQ=(1S,RMUI)+9"FDMK*8-?1[7G'Q'/B\!2'1M@@D(X9?8$
+MID$]G;G!U46G"$#P\`#B0''3T_HLN\P@>>6>$H`1(Z*.FX&8[U.Q2-S%L(4"
+M@G7O>S0;[=UTWG`R!%%%!4_5F"@A>!"F`B$DD.1HI*2@&@DHFB=&>F^N&(9\
+M)T%"1>G&!B//[TWI+Q(VT;;\RX9<4EIT3S;)85(4A-RTNVFHD&[4L(9@<@1@
+ME*;`W2=!\:>-4Q#<Q3!($L6(R`H[1\O]FW2A'$HM5%]BYL3$=2%5P'@:VA@`
+MJC\'X;V9ZT%/HJ@VO1;+P+A<@?[_VKCQNL#0[!.9*9U)1"F$-CT18J&\"4B@
+M]>&+!1!$U,B$,J#0%"(#,"%*@T(I$A,$Q4$`M*501`E)2-"4@[7D533(&'IY
+M[:0],(.\J&PA."D(8[@>?GU[!Z`ZAC8V8&4]B:_>7LHU\[A?'1>4GP1HZZ.X
+M/.:QCI7=V3C$V/4F(/"%]`&!?@#M),0Y+W0A$J)N;@]8[[!2H02;!LQ9N0K\
+M3O%?7.B`*H0G,S`T)9D018%`:,L7#`P0C8(9$$)08J^V=H'>C]J0)D!:/M@T
+M)+0J'4J%0B(H]3:TEE55%VA7!HQ)J'P-&>`VP`GVV"Z@=35)DU%,5$4)$`4E
+M"4`%"ID`80&64R?K0XV]PVUFM9[BIGB7T$)0..\AP;^X&P;#6444NI4W[^U/
+M(=_)`Z8-3W^8P')`Y`U$@'D)JQCES%BM'(TH\A2/ZF3A('>84^Q(/6\8O6!]
+MP1<ZX#PE/+IW.!T.1S%LGH@?J4G2`H!![0Z0KB%#VY`=M*X@L<7GM!Z#@-_'
+M`41&$".H89!Z(<,\,%TP(F5V0H#(,D1()Q8C35801&PQ5$)%':E\J:&ATA40
+M\G;!-=),$@;;:-N%P!I0`X.A)MDU8SAJO\,[AX]*))(P1S@J`.TAQ48I(S@B
+MC.Z8T0Q/D%X8<P'$HCDD3X<P:*>/-RJG3X088*\)QT@<1`&@R$%/D/(XE!L%
+M!0XVK'`LG-M)DX((#E<9`QL[G-$8TG],8'O!J"DJD8FEIZ"]4QI/!N\5\D-$
+MU=(X'`!]DPP'@4,"BAWPC`'9I29'$@%"I2*&`@.H$`<2#9?`A,>(_THZ]/#F
+MSK!Y`#V%R\%(D`I1B)(24P4>CA7$.`AE;I(.J-)1&3#X08AE(FF*F!(:)Q+P
+MW4YU\^ZHYZ3QW<N(-)L&W/V#%>9U&(,,`'4$D@1,NA(=S@`3#VN=G%(1Q)]]
+M813X1D/9#ZCPP5&,<B2?FT^]G@]4<LE;U&GZ%[U"!$@=2H!A]3]7:OXU%V^U
+MVFQ<W%\;7W/&QZ?CN(W.SZBMQV[W^MWG'X]FFS39IL]=:JVKENQ1<N6JE:Y;
+MK6+ERM9J6**TU22BY/>BZW/J-(PK:]+^T4"V&&9I2/?LS-)36>.9SQYF#9OT
+MOF_9BJGS)H:4H2BFD*(J(FABB:IIB*IH:OF_?FM5AEHYR@S^_[T[AMVQFM$H
+MW^?-HQ877U#']MF"&W%&,1C%=L<K%$DG[M(^?N$S/1_>]E<)"F0SB$"PD"4:
+MG,+&;(7Q>Q.0!/A]W%4-*TG(.&Q6*A#0$0G(0B0T@?=!HIZR_?!PW.?ISB5`
+MR3)-$-+5)"ZBNX-M*&MFP&Y)[8.$TZ0^"YYEU]H?+E[<6#08=LLS1XD$ZUMI
+M/\OK,<:5-B02$\@YFG@;P/<D1ST!\6;OD\;V1,)L9<2F*+EQHY+5#`DF$"@0
+M.$F20NF$Q>KN+[%B&1:@689D.S)+.@S`H"BH$!5"_:^"%7D4BE,%EVRS2>0\
+MEZ2:`Y`;XP14&;_$?G1+YS!+[=RQW<&`H8B2'"2>7[)[O?ZK^^D;+G/<Y8DC
+MV2,J&P1D`J:^FBXECD8K,M<4@1M,I9J13P*Z'KO8O$T)K+%Y*@?U)P7EH445
+M!I=&GJK[)XNS?IS-/L)LGLSU*_<7:TJ1/>!UA^]?U!Y.`.`$ZH8[=OP7Z>!^
+M#&+1,E)/O8N>L1^68&FD@-H`B1H':!30$8*A"&`*>2AQ3_!DR)T%*2!3L(FE
+M&(92$\V1@(`F"+<>`*P,S#@!R0Z@ZU`.S?E)G[(V-C9B.SMY"),H>O2XH?$`
+M%"4!-S@EH*B.2B\+Y-U/NO:-TZ@Z@W!^(OM$\)[79V??>E=Y(J`?:JJ(#"H`
+M--*:T(E($5*Q(1#@AB2B8J65B`*2L8@JB*_"$?Y`!;(]!.X'8V$/Q1>.OV>^
+MBE@)`FH0]?;XP]J,-7B1$94-MC6E:!%H!`ZP*Z`*!`:%6J%-9&")HH@@/N7O
+M["=Z6/YE)9AY!W)W.FL"0#H!6`]9_,@&C77LJ?.'^V44:!*0B54(D$HB6@9A
+M&B"&EI1I28%0F%&@H`:"E2AIH0'K.L!](+WD%*4"N!"F2#[_F0-I5:DM'>]H
+MP_S`DSB!)#@\89^98\"X8A"9?(V$'E3K%ZT[@([13RJQ\4`0GV/)6VB`W?02
+M^<;*V>EPP*1#A#D`OJ*#"T_RJ"`2)\'MI/>`L&"B-(X)BLR@<:&(HKLL3V`C
+M`2&Z^9BQW][T#VMQ6)56J!B5H2A0I(@4Z29Z`>DBAU01%`ID(?`@7X?.3Z:+
+MT<`R!#(=V`.;#%+`8@T)0:$TT!0K!"%",T3B$T$0J7JQ0%'":R!)PQ(DQ0^C
+M(8K32E*!\?Q!9$^2";W!X3[M"'7I@>1$!2Q#8Q_;GXJY`[('@6BAH:2)I`-X
+MI#6L<N)>NKWY#J7DX!ZB1[SF]!F##OB@B3\*B0H263T+P,E4IZX;SMZ0?DH<
+M-3+$!$H%<E19+.K(4'R%3!?&`+B&I[L;%?W@'7G6&$/O>*1()2AF*#J[$"2)
+M%]LD=AX>L$\1`(<0`ID!2+$(4+2!0@7C[`-^J:%'4*.$AO^Z]HI5!'H2JA0R
+M8*@#%B=X&$$!X"<%#`2CZG+\^?0'43;@C$#G%._-*'RR'@'Q9,/8$ZY#R'@/
+ML?@XFQ!62:WSWI!VJ!':*4#<V%ZWR&R/$1$44A%`%*M3`GD:38`\'P/:#I2;
+MEBN30,P$V,&F&L!&G9<T3M27V,/]I/&N=3AS"GL_1?OE(J/V@38]S,D!%($#
+M(M!5)"0)04!$$21,0U01`;=8=CP#Q%R#GN\`9(^/C(?(+VK@=@:*J)6EJ@%1
+M7(T@!Y489)E\VG/@UJ]J];+DO!('*,/7OL'#`]H*<+2"4OC6BF(3@T@7L;"3
+M8NE$8,NBDSO1%@79FY'!$#6LN7MBU[2)<W">7-#AOFRL8L00>X=:)*?.GL\(
+M#QQ=VF/;N/`]4!,S-)2%441%54<"\3'<<?@Z.!+1PYU>:"F@)9>IWB45%7!4
+M'71*H(HT_FITZ)"+YC$I'DZAOG'/`NH<8D^VPN)K3YLWS`G,S7@+'HDF="B1
+MQ06$@FB#TG#B3W':8C[A_("#QQ5&'8'6O;UAK5/`;0<![`','K<69,DB4P*?
+MC@Y<R6`T1`1)`:B-_5:!09+`79L:;;*L//:2%F$BR$\391/K.I:9(#`48E]!
+M_W.M^1I\2@^HEO#$PCV3PY-Z(R3&'!@DJH.X#7G#YC[I]D'.V77=D-)1_,4S
+MH'UC]32'$<40;"^9Z$B-(#5*C0E(M-*E-(;O4<@W7R\'L;\CF',#4Y)!$O#%
+M!UL4GGW5]VT*')+OQ\)EF68@EF=TN":=+$\A)GGD52=\>;($*?WU![E>$`@<
+M&C&4#DT(4)I*]WQH=H&Q!"<!`N)^&'(Y8Z/.`>I#@">[*BDF6IEJFPAR,I13
+M4T4DBBIX=3CQW#Y";B!B_**G`=QU)Y_BB__$$)$T*0P`4Q%5V*GI-^Q,"C(,
+M""&::9\#/`/*)Y4`X4T[:<T1IQMJ8#!)3B"VS&V--!2&@*)(VU;&<12:H-J\
+M#^`'W[0$`;.2:HGUF8:'W32?*T-`!1$$2(41`A2E!2@4)$(*GD>4D!$$)>""
+M=Y\9S)V"Q-ITED*Q19K[`ABQ>"(E8+6I%JM#D(`?!"$/HFAMIE)',+\27LXF
+M068AX)`=X]EHZ(8)S-&1%O\+^;KTNM:/(3UPZG%UKL_XO8/TV)C^1/S/S+V%
+M1(+EG)\O76T*0M:PRT`*E"K$0/#POA*9$P6&8R?*FBAR!&6<`8D(YU*A];XO
+M@ZGPI\A8*J#2"T?OO.5J#1_4WR=.EQIU8B9S%6,Q@V8QCR'DD0<<:M&/`HG7
+MHQAI_M#&#W8M&@#WIF#>X!"@,RS(!P+<]\N6B>P,""7$0DE$,9\B-`<B.&!N
+M9=";+^7\K\T'W>Q9T2P2,X\XIQTK`;RIJ-5]/BHL[0;?;(_;/I96R]0U&P(T
+MUY'C/W+)$,?CV6YD?L8_85.=ZJJ-?S=]=2[$#R%^G*T#*'7P*`^-T^R54GW-
+MU[\%56-1VB",48@@Q&3!Q]C!"QD6M+&A123H9S2;I!4/:>O1[?FZSFTCG4R*
+M!H@:2XZ<H\][PCVQW1Y#_,7>.B?[C":7F(21XP'D8:$H&I"0A81(YWQF:R0R
+M8BDV\*L'!_L\KZ..Q*\9B47'CV.=O\3/;MKD9;/QS(L1/'W#8]#T/\'I:W;?
+M?,VCU08R(,N.(D0*D3+!2&9HN&V$K`O,8#ML?^'#`&8L&"!@R!]2=1U^MP6T
+MJ(BZ5_^A#_\H?8!#X330F%`%!E%;`&YIL6:"(HH76N#BY$#(SV07R\K>_O[(
+MEAO\7KDM[_=X98K'JJVVE$_R,NEM(&A(:"=0,'=T'LREB3<L^RPK`BJ#/8/X
+M([;$7H]T$P=))24DP6Z+]V=.LAU`7]%P>>HF)(@(@H_LYG"Z8("@@AJ(JGQ#
+M8S$O^1AS:YR(R"FR'M9*;\^^V^TA[]<?7#](GCX@M08@!!02.,Y*DIH*6DF/
+MR1)Q(6V`GC""7#=+^5K%X9XMOS%U+""/0#DN=5Q!UFC.1CT0#]:0H!2TAQTB
+M4D(0H(@)AJ(9FJ/A?%VN^^[@6;;FX]B)MN?LQY.<MG$J(Z*N48^?)@N`X!^+
+M(EI80-`G:$)#I"CM;<X%ODZ8WH/'T;]VX)/$SI8)UDHJ[TY;,;!P(=DH%%(`
+M3-%"]^PG4+`GR)#3+DB!1$KULCJ"*-A,Z+43&(P'"=.G6/J]0AX9RYW"%3B:
+M_C!!#8(L%I`][O\-0^%(N!]LGY;T.7``53VP/D6<-"T%DAQI2$R9:%+#]N9:
+MNI%T:-:U.'Y2:TJZY6\"RAV.!F;;J`?N;.G#`VYD0KF!4"8M1(TU`O4"DVS>
+M+\))LQTSLW9&C47P0'^'8DY[]:CA8V<3L9V,ZEE[@-:'5/S4;X[QW#[XZIT<
+M"R@4@4*4S*$$E)$'7&$$+"%4!R,<KNS%\J'C(#1H*B?<CS8X9%8,_5L8ZE/_
+M++1Y>6%L!N!<NA['H:(@]19!!$!Z.9RK@>.";T@8.?)"68B#=>!XQ\\9X]M#
+MI)(@V+0G(\%%%'O\!Q>P?6^V#\@$G45?A:L)/BDDT:%P321$T5*NB0P!UX'/
+MI*)ZC/4I1+'!`$'ZG`C"2&/SSX1Y*@:\;QE!,!1V(9A>HP?&>LT]>^YGY/EG
+MLO4Q6,9N:VQC:2@J!8B<22Q4%&!*P23!!(%-`U#]9:Q%5,TTEW&"&"!`GIS!
+M`I%B*8("(:"B24F0F&$(4*2)/B#!"%?B3B#]Y\(8.3T,:G,@(,&)FJ)P->UY
+MCP*KJO,Z"EAD'N$6X)J6R4;T0BIJ*##5ASF=/D=DX;43?FL?*_O/B7XP6DPP
+M=9?:A*B?TSX4B!3UZVV2`@AO352=B>/6B%51P"!)<@:G'ICDU-PDUJ@Z9C,N
+M=`#$\VVCYIM[<X01],,SSXG^)>YKU.@AI1>9RR/)[T!21D]5`I*@9=O.UT9'
+MO4!Q\IX\=^FHKHX8N5M[2[]E,NE0RII<O/PI-&(IV7_F3N.T[38/#4Y_AZT<
+MSG]WM3F<QPSF'R+E\L6*;15/[4_HU_$?.?D:6K<YK7V?=[.U%DX^&I<H0N-_
+M8-`&Z[(8;?+3/E\C?XAQI`Q`GXRJ80X"01Q\C6^FDV%+C08(:_:$'"J@$*4(
+M2N'HBB?I_ST6/D?6_C[N645$5#F\OVOD.]T.FV.Y_E^7144\O>U^S,V`/MI7
+M8^\C\NT`_3D4YX"?K1%<H0@H22OA:`D`OC[0.5E-K6LRTE_PG[ELJM8L_F&;
+MK-+100%A_/*)4D46?K$O:R#_-%_>;D`:'LB<AS6P9JH0*!*0*6N7)>0<FA>0
+M%`4`7+&+^U;G.W-!P:8:A4Y`CN&D4P4)"`6BJV,@5!<VJ68UY%<VM/`X0KA?
+M3(DP@%RCG+&N8P2A412#06O.6<TT0$D$$T$7LSAZ/F4Y06"S4>BTTWHP9(>X
+MTA,\C!7X_A<`#I/6?*]XY%TVN;#/O&+R<32%&VY<DY/CM:,;88B(Z04<D*#B
+M=C3$1,1'C9F)D+'\W%=&IB!LN4:1P&"1,0EN5',;`K5C*.5H"0DPIE9E8BN)
+MD3'8,$0BQ)PSHJ2$HB:JF.3Y'%YL140PQ!`4=MR''(S`<M3!JDTT&P8@Y",0
+M0,<,N.8"6!6CDX:)*9;!%Q4!#1,*9$M5RPI9B(1RCMV[-F['(Y:>R]X4&F/[
+M]UZW((.F=&@#U!P@-.HH)2:A2<3B,;12PFLI08@(A8@-G&8#11MSB>KG0-2D
+M2M$>!8\C0%+";$)DA^-@_9?6^&G<FC@A'OU6,2A(14OH]&M#,2$2'7!&90!%
+M2^@VKAL+%$'VZ&T/)X3$Y@32NMN<>2(?B0F)H#E6@#L?Y:")[TP%)V:$H:=.
+MLY#?20/V9WD[#YRCOI.[%))VD2)O]V3+]!Z2X@>B%^Z-^V'X'H=3`\"#U`Z:
+M:*$E@0[W#/)A04F()^7!-!"/@_JQG-B"/8<_OCF[+U)"@>(\0/8<NL%.B\")
+MRH@Y#H1$X!/[\YL6():`2:^)_"9;AJ&#`M%%62GQ#0.)@DE!HP_0`>H0PX>4
+M4W`=0@;)"!$`4`E=I(I]\&P'@]CC!0'+,1H(ECXR&HH(&)#XE)+4DO4Z-3E`
+MY4K!\8R0!.SBH*F4B0I))0H`J(*0)A"JB5#\OJ%Y*>!VB/QY$>4H]7&E.8=#
+M`_P_5#A",0ST(RBG4!X'#Z#G`,?PX!^\7;!(7@Y'%9LFDM&22T1`8O,Z&(B=
+M`XX[%$0-$54`\D];$<JA@T+H8B((YL'.=C2QR.U<)02IHP<FJBFJEX,;1<`@
+MX9P:ND89A@@>]C<1:L3:>#P@UD#02U)R'3!L38%)Q=YS'!Q=A*B<3)/0BL7,
+M!MEH"G<-BSG6)VT3NEJ"D8X;I59BA4J*B&5HAEPL`E!,AEA;@B#,*4<"%R5D
+M*(F2$A`B1A"D*V8%3,J02Q%*."UQLN61LI@D(R!0;"5&QQ%2BVQ-3D9936K(
+MU&$YXRT#W];"2/ID,(K#+$CR'Y"OY1DRD0[[C^#[>.H+5'0/QA5_Q!1N![(%
+M[",57RGM2X>R"1C%#S&F%@01`KQ#,S$_$?">\;%V+$%"511ZP?51(FM&@T51
+M42E"0F]_?_!RYOXM6-L$\R?XJY0<QHE):Y<M309I\)>]E5$V)OK#=!?.:=P\
+M/7H-$U.%@0!32%#@P:/;V3BQ!3$G2`Q`2:-8S-1HT&V&(8A-)%[G'#!I*HH)
+MBD"(7R#0PP0RI/GVP&C+">/J_AWV3;7-((P*2VQ<E&&:F\(5"BI0H6Q4D+DF
+M+)!56F\"W%P76JCR1*#M50$8L554>N;XQEKKN9G<;QX$CIVK@Y""<UDR<((9
+M9*:LL@B9#(W#H>!)$)$E^E4Y/,28"JJ@I*28*[P#,I+\3,88CJ?-V)VL%VNM
+M":EUCE1";$=8+R+H["ZYUVH8X%YA'B$8B)0*H6$0Z<;CF)G@3P33$3"3*]@R
+M"XEKC(=TA[2TJ"L&`Q%]I_-+6?400RF,/M7,>L-&C2/:;Z"(,>M\8=QS\,#1
+MI43$[X5?QV0I$-*)X!OU:'81`W$&1ZT(]`@<N8O7!Y3GAY.[$WD'@N9=Y[CS
+M7S!XD1.-<8D2T&4H0"@+**1!%+E?'][+O:U<+<_(>,_E"(BS<)X>)9RWZRI.
+MENWB-%YX^6]PT,Z,C/25=A80,8K%++#"]B]F`"R&FL/?%8-*FR]`H[!-&,D'
+MO'Z@`_,@2%W'$-E`@.LY!@/6;'-$WWHZU#8/(0_D14035-)(P304=C`T(4`4
+M#LX:0[?(/S8SW_'SY)F9DB<C2Y`E*Z%0H5(2)(8(F/,&:#T<^[R/&?"3)'*8
+MP6(T&PX><!P\$H'G"(PG!)QMAV,`];H=06C!#NTS%VJ^,]1BB'40>0E((4()
+M.]HJ53)!I5H42@H2A5H!,W9=@>^0_'(XV/6*29AKP+V,>+&%$R).U'CL(@(Q
+MUD/<,#PA`F^$`>@DR'$/>)]8@;2UQQT*;3,V%T3%SD".&C.X/('E0F6#[PYJ
+M`^N!ZT5VMQ0D,`P)T0IO+$`AQ.F#H3H#A!B+C@H%TM*Q+5\K$PD2)*&(*F6)
+M2@HY&M!HB$*7I)N.&TXH(@H%U8QI*!,,&DVP7,:'2ZH9X6><Q86,!)H4S22R
+M#GC^8+$4`$0<0@8X=Q=,3&0QJR;%?]I@K%QBJ)38H<5K%#$$Q$&(&%8?ZGX\
+M.4D'4WH(XIA,;B"2;&P$?U3AS&#AQVV8B"-/GY?/@^/>_J?@*(02H:-"5RL$
+MA7V(P)&3PQ#YL.,FJ("+A`YB=C*=0S$ETMK*(@HC!QXH\I%**DN'$"`CCPH-
+M#N3R.%3BI7&Q:-$3<M#Q,1I.!8@VQPP6%W)V38!B"X'#ADXXDR;,T)GFN9QK
+M6X<,8G$U[+3#79K:<#3#`;8(BFKMF"&(8F8B8@K1JANS='IQ[_P\YB+FS^T,
+MZUOKHZ.%QR(RG3PT:!0/2]2D#7?1[*;SGT?/1SUVQ2TWH>OY+AW_;:1_A\SJ
+M=%4,'\/9_W^A^[\_U?2^EFQ;N/?:O!9#Q;BEP=L]%&S2;.!FXT6;5ES^*'-5
+MYCB8<=1)"9HH,^>HT2QTQ]!/1QD6I&Z!U1G1&Q55GC6Q225GS)2T3ZKXX$=>
+M)G-"LZO-)0C:U&9;^82QP.=+=`,EE>`RS:R6O;%?7K,Q7?88M0VT;1D8U2*!
+M!Y!T;/580OXVE@M_HH%F+.'YGG!Q.[G_NG3<`D&LR52?R463HHH$&4UA\Z?P
+M_0+/W+;I0XXA.6-,[("\9]X/TC)M)C_$_[<'T:/<#^LHBI(C\D;_[RG$PR^M
+M$MG0)=Q8ETLBDWG0KITM9I-K6M(G]O\WZV*P^,8TDOOOHN9SIF",O_953"%)
+M#["5D3]RP2YEB)_>RX0.?NI.7?U+'',E?P'A`6J,E8ER0Q(:E!1!MAD@PL13
+M#*)-EDAA:E$J;K\NZ12,EC^*ECU!MI@GI2!9(?1]!RN"XOFTI$2,\PI<TVNT
+M6BP2B@V@&J*:1^*9'\?JYI'B_F8Q=F:D@4=)&FY\?2;5-]8SYNM.CV$IIBA'
+M7K:^&?A+2N=,'C$>H:GS^O`##YIG.)I*@H(FIBJF@HCZS6B)^)UJ_KU1S@G)
+M:C:?<FBGD+H(J&)"A^(W;`]V=?WW=%/V^,<!%</L?3<^X+YA;.68DB>)+HB2
+M$LBV$Q(UUJ+T^V[N?&^]ROV<A\W#F?AU\_;?>H7IW[>A4#!OR%MVT`A9)+L(
+M!0=M*#JAL"#QV<K9Z]Q#T$/5AG!R,`<E3D<'@<%4[[LH/D(Z6^^QV32ON$^V
+MXX,S&+'BG^K>O7=TQ.W0K:BV>Y<Y>O36UQO?G71)1O\$*4D#S:;,5!F4^5NJ
+ME(*90HA%':@B'@LRNCRRN.)W,H_7S5SP;F42?7\M?RM_@(C\T/QX6_K%/]6/
+MO\U]1(A:PF/@K7)NT""H](_7V\;(*7[J;,6+2^"E,%1\7W<]_'7I%Q'VLF/J
+M&'`4#[S(JF"&/L?]'^A4CPU"9P17>ND+HFKV4T0E#N4]ME-GOK?6IP;E0S$Q
+MXLABGXA_!7PD+")HP/+:"&F"=,]=)G<-!MC(3CIX6G-DRMEJ%!Q)"_9*C8,R
+MA=SGL.HX-^6*%U(;@;3^S+^QDBB/[#\,#YJ`^U@H?FAOI%_&42SEB)$MB?Z(
+M>H?H"-)F8<0`-N8YQXP^1=Z)<DL>T^[XI<B&@\#A[/29SX'AYU#OESOT-TYN
+MW`B3T7X8_;_NI..K:&`KXEUQ=;<7B_DPAL")&SX5]#DAFSOZS66W&3*Q7@B[
+M(-BH4._%2F\AU-;RD.-JJY,6MH8/"R>669KVU*@G;:H&O02_CE,(1EN"O3>V
+M-O#/>\QON&E^6&N^9Y&*L>"_<.2/@'</ZSY@'10^R/?5C-'7.D5\!<_7P?RO
+MQOMMKR6R$Z471.F4S,CALXN-#O?,\7&5^4*LN98*08L6?AX5.8?"P3$984K1
+MH2B?A^ON0CWAF((?:0CR0OOY,?N`>'[K3A2UPV$.D$A]!"+P.$9-$0\?T)HQ
+M%G2%\C[X)H(VKK:\R.ZIJD[8ZV`XZ&6O.>+8F,B]%&\7QS"Q=EQM:BK&^II,
+M48F_?:U^K;(Z;][$.L'/7XWV;W1/24*?M')TPD9FBVQ,CD8+%$&=?94)8$EQ
+MJ(U1X1/#;OTS.Z),]$^$V;CFOE2%-ZI=;;VGT?!T?0IWT<8+7LUDIHUYT76C
+M&!Z$UKYD-Y9@FJ>!1/D1GOXB[>WX(:8'T^LQAB4JR&&/YP`1'!C&$=>*3M[F
+M6[(;Z5-:E&M<38-D\^_AQ/'R[3Y>QYO7W.[7-'L=7>NI1$/7WG8]\(5B)](7
+M8%LC+M<L,/-U$S1RH@5UT+280X\A#+FBZYV*C!C,RBA.=:FKGO^U6-#&7C1H
+M,*!_E]8'XC^CU\:'\?R?X&&[^5""%./YVHN1_%O\UHT/`P+/5F$,'0UE6RFF
+M!:\/`M?OY:7U?`ZS\F-)^0D,FA(1!<_2IJQ4X)P^.?\S-"?Q2_(F/M_KX):K
+MWW'V`#,T@R[1B0O@U5HRQEU9E4$JQ;0N_E4\-C[4.']>F+!_L(5Z8^`";BAB
+M*`ABU]-0_HT,(?I=$2:X^5?KOGTA(7#>T5X%Z-^0]!H5>@]0F-4<<'L-[^JT
+M@_@;X=[D#[Y\X^I@@(*TSP24T`6?AH$40>K?G#7MT#><S`UG@T>.%B'P==NC
+MA]=SC6H='5OO17>\VV[.1-\6<%PF:=:J4U1E8.1DX5M[+;W.VV3-;A6XC5[\
+M&)V,7F#5.N0=30]@O`0/,T$V0[_'OGT*5`?6,&=;D?V0XR$415G)7J,R,P]J
+M72*E_9CBKD;BM4L$Y*]+,Y-!]<ICJVP]<6':_I>LA_FSZ_ST^.&[OZ1'NP6D
+MY][GOU><7+$2SLPTD:83K%]/'?4I$Y7I-+$RR3$B-(PXD+(#QI5P(UEM!$5]
+MQ4J4UHI):&NQ0)P6H)48?4>BQ3D;LJ<3Q9+#7YC@_R59IPC\Z$-$KX8%&:.=
+M_>VUR2:JWIE=_Y&LLVR,ME*NZ7*CA+94:0QQ*9?@OM9]YBTVMVMW-N.6N^-S
+MP0J&#?2]L]W(_(MNF)XWHOJAPA+LA-1$YOO.K\B%(690JS!!H,(/1/Y&Q5V8
+MTK]H.=@K-/P3U:'G[3PF?UPJC&,?8P=(W]]BK%8/]W@X@""02:P-"(9DTYQS
+MGOM)5S%6FB<Z<8IQ>V`R=;U*S4E:M7I"(DYOI_S]^OX'=/)0,,>_P_$T\#9[
+M^>SB^L]ZCF=/OV@W<B:-=[-[.;?O]]`_&,7C5;,_@](1!'BV/\Y$C/LCOP:'
+MI.D<)$LD?%<Z[_$KI5VY$C\^4V8^_Q]1^3/TI?YC\_B22/6C"^VV/LL_24V9
+MX?9[LT2,IR>E%,=`CN!(BL,C/%+Z8)U]_LO>^94_$5?H\GGQB@S[XM?C,R\*
+M.F.MB!-C/7#G@)#!G43AF>Z6-H$4[W0D%%E<^/_ZH59JV3[WO`DT5.[J20Q"
+MJ4B3!.OPF5];WL^]\_2_JST+:56WQ>6+[ZBDD(:1@O82AA":`(8A5-)J/W!U
+M:&.X[A%P$.A@O(7D`1#2%H&(`WOS05#)RJ(A@*3ZIUGS9/6)L#>3Y2F')-AI
+M9DB22!V_2[#U.Z;H?;DXRT**MA30@#YR496`-,3Q.LDAV?B#/W@-$&3P9I1S
+M;%=N1P4/%S>:I$:`.!H!()G$RTI4A_E7H0UATG`N-3(='6&M'2%ILH8TALX3
+M4$AN3+WG.YQ<FQRJZ'?VV#JYL^C.]%D\A\CWZ!3SGL,GGQ@-#T@.F5U&-GI@
+M,"Q,(R5[LB9O/M*`P)=\(H08XH@W3NX^.)Y%W'33['Y%B*B(@A2`LR@\,+""
+MVB%-_*^=4ANV(%[U8CF,%`%:-&CD=GI$2=GO,-(1!0\"<$25204Q-$1)@EI*
+MEE045%8?&=`*9GQJ7#60ET.SGL5?ZW\GO34.TIP$.@T"4\_@#H=G;X!1:637
+MJ26UU6IS`EK;E56N6<>FI;ADV@@B;)-*%-)K&Q-4;K=T"ZCX\(A^!#08?`'E
+M6"%O@L%`P%NP^LX*GML`L#SIP9O=)R*.`>2Z#0!4>A`[7QG?"=9*UYQ9ZU$\
+M+2Q9M1:6*M5E+GTGWC;,(9R<<*(:E]2B@2U%ZB`Q21?V:GX;%F4XX9HJC]3&
+M'1[_M?9D_$#\F62`<'K)8]YK6A&R",8L;6HD#VB9!F&,+[[I[PG2'AOE-:!X
+M4TF@:TX.#0A%24P!`T)'6)ZGUV^O8()C5HFW#9.;DX.=P&2`OU^O:_&A3]CH
+M?'N]Q424+CF*/OCJ$J4AV:>[&&VQB8[;#UFR;,3',?3*>"\#V(P]G8%.!UP=
+M&4VV)21#^2Y^'K$@H#&CL?'90+.!]W6$.RHS%_LMXSU_%_,[="!ID""`HB"D
+M4.TFTI)J!IB2X"BE6^/C4Y$\H-P0\P!O,5%!4$Q4$5,AHR$4"TI32%0$>8#J
+M$V=)11YN1HTQZ<<CF64)*@L1`N&LRXDF,8U(,$,[-RA:A04)2N2E%/UXG^[]
+MWX9,1_=;1->G&9D\=BQ:(P3@KTL0E2`2FBN+!9LT+G`**5N57\Y.`?K-SYS!
+M<,SR.G%HO^Z(@=2>0U6@S!2%^V7$&(T6SGF2V>2IHH$J!B*8KB1M@=+%0O[0
+MFC0Z`BO!PJ8:*:8IE&`\D\D+8>0&%#"F"*($>J$#X^AL%[@T:F(2)HG'GZ]3
+M7V]:$?IRF5Y3.NB,T2;W7"N,@#M=:14R&76;&;-38CA;,-[NCFM;.,QPBA,8
+ML<V<"Z);JV_!JFMDG<U>'6H:.&][1@$A,7'(#F[-9AK8[-C"AN87>.2[I=B'
+M;R2ZFB+A;2K#<-$)873K+O<HZ('#2#;HXJ2^W.3![S8XD!/C&$B"`4J#;RD@
+M::6MC$CD8.1`%78&B$$^`[%WW`@IH!PS-E>QTNA*:"D/H8H^K0&0^:<E:%*2
+M+K.L###1B56&&!U'>9[0J;&#_K!WC`OC.Y0Y'BFET'UBO(E0ZF/B3'2JB(/(
+M?W?.*7B^D]"QMAV`R;P,#(IB&7T=1".X^0&X#E\'^3-MLD_#@4H,S68_='Z_
+M(N/KT9_7]KUKO2^]"Q\[%D;,LH4^>/SWI[S012G\)Y_[+*7^!TMI:;`E&&CX
+MJ6<E@O:T(>!"4A%0$440%-`=XD)553,CVNT%>%AY<0PWW*I#7D/(#Q$[)053
+M5,0?48IAJJ****J*H`EI*4(J]W<G6JB8DB6EJJ:/:KP#G'"'STZ=)DF$*H*^
+MOH.))P>&U28,\HFGK<<@AI[)K=U@$2Q%"4$*"J"@H"BHOIC5II<C1Z-UDS]E
+M<?(KWT&2PJ8Y$4!Y%(*R;+K.LA5AGT1;]42=35K$18SG%\I79AQ1$Z1F0%WT
+M8J&I%^>^%B@(FML\WGP`>6V9TSI`9R;<_'8O54.GPT:!\8A_V?V:7,Q!.M0T
+M-;VD$$VO18^7]3K>^5[6.;:XQI^MCJE_'6U9YXEG>UV2NVG=$423*BK;CZI0
+M*2!,&BH)5+'SC^CMQK^G@]LS!E86?OR^S67B@@?87[D$K<<W/9D9-=7;ZCJI
+M[]>TV76]&@[W`#DA]B&1R@,[L'O%/LIIBJ(:I**J?NV+HM4I&Q^$OD]DH*+?
+MVS]'=DNS77'24J;4TH,1$PTL510B@IB.8*5B*C&"94"WNQJUR9Q+&[S\,].^
+MQ`\D'R[(Z>2'"*"@J$<7.,<$3$=.V\D7$K'4@+F>R:3I.D([?2R7WFJZU*:]
+M/G3BO3#YVVOWMJR^,];G#C$A0Q+2H4K!R*LUZ&++<Z3*6Q-^M=+90NYF5FG2
+MZ)9-P^L>4RP8*,L'S>Z!DUZ,EV8@8<-[-Z,M],AZOS3G`0('^0-CW@*]$?:A
+M"O+$E(0$?G8M,T+^AF&0*I"THF"*40Q&"A7[51+&0180FZK^33%P-'\\D51@
+M*/@\$`HS1?`DR/C:V$,'+.BJ,]+.[H>%S4_7V-S6];SH6AF,BGFPOD<NQL(>
+MUUK?@(:F81P7#/1AZDR0.;3!$$ZIR*?V1&7."-16B#6\=T%!$=D7]FOD54B]
+M-2.<,4ZP48+PT&`#\WY$R:^-PC&A`_N_HB6%88C2$(\0OA\/*QX9F#I&@N0=
+M^1ZR.R6A0\I&PQW6Q?VN)`)CNX_*@+1-R)(!5Q,*HZ[%,2K`P.,^O?7OO8<Y
+M^2Y8XW`6/4;&U[<:V,R2`$J7YHYP:9<YZ\9YZG6-;XMJ&R*)G<IFLIYX,&+]
+M.MC/(.M!2L>&M,S+8=:@!V$(I%#+&)#+-ST0C\?E@*ZC@CFK1(7Y<(>*GN7U
+MG7&#18_`;@A\!>H4'P/#D$*R(((&@?*XQP*0D)LZ%IX&)!@@I(17Z7ZZ:^+`
+MX%F3YH5"C:Y4F$639L<\;<]#0WTDFQIR7*],`HHL-]J"LSJ6E/&91H*&V8<E
+MC6V)F:<G-7U.FJ.%#A+L,$B4/S1^G&4KQ!$8A(_CZB@-,,'.SJF)9>:-E"I&
+MF_<DR!V1:>#\?IC)7PQ#'AYTK>`Q9%V6R>@5%R(<D,)!0HAL!P.GX#&7^XR)
+M!S+C2*J8"`)`V-#"@2I!IB9^I'RE$A7*@!TA\RS0G\_TV1P=G0D#IZ9G@\G7
+M0YZ[E#:=]/3RBBL?O&#M%0R$0$+@?*[]N&C<=:'^-"P?%8P+J-R)H7]CA'01
+M$"J[]_.?S!KZFJ@4(SYUF<I0R/X(L5^A<I!3:^XWY0T?5Q/\0$.O"JB)$'RW
+MJ)*36?4>)@5.KJDV0)L\OJPU,SIXT^D""^T":F9WWW>/21N<F%<CF=.J3#K6
+MK@CV,[F['$WHAO>KF(YO!^>CJQ@;'ROM?7M'A\SX*QD.+L;OZT3TC^+R>1^U
+M$8)QZU#(H$5[[A"`-_/3&`D6<PRB?E6P;TON:SHW`=M.!P]-'B[EFX6R?!\M
+M[-&W+8BDI)!0T+=H[7->A>6.^E3([:F@[.DL4<NA@/#)MKCO8*M4&#%B!@0W
+MSV&K[XW;4YV+L,L-8WO?L^=:?.'>O4R_?S-;S,UH+<'8M;2K2VOAD8PXQWJV
+M8T'4H[>=7W'OTX#K>8F4[/9^5@'S1K)1_H=-$5\^U[]D!^@_?>B&1Z+5GFJL
+MOI&!A$#PJAPFAQ]_>@OY\_&/'\&!T'$_GQU!U#TB000,""2B.J"I89S$YJ2Y
+M^4@R3$#[V=!%CYL<CW"W>"@:%V$-+.F!NA`D20)G=F!WV+#\02!8:MRPLIQI
+MJ:L\154>JV,GJ%M[^[XWF9@!G[7^6/^?]>>`[)QMVP4&,2V*G9/5,>JB["]6
+M;W]AB&A'72@-A(]*(N$3[;&J7NRR>%-3/!4,A*#(0\^HX/(QO[!)`782;&#F
+MGI[+QD'*ZTB9C9HUU225(YKK-#-;>?F+]WT/S&D:H:%B!B$:0'Y^L'XCBU)"
+M=8'V))UCJGX9RJ0B(B8BS"B"!R0A['VK$I1/NQIY\M]L.P+[8*<<:#@([R%1
+M[(4H>EZ##(FD.L^C^L_&+@C[@.<OI.$]U(,R#2D2%!0A1!`O1\<M#M$D&D%E
+M(#N%.H[7K9B)CD080]<TXCP.`0^P]JX%_QGOVOOW3';W';EY`\C2OAM8R/4K
+MSQ,''Q&>:($NZ97$0AO)7`J15$J9-##NP1W43Z/,\>[(>IX0^IU):*ZDF-8-
+M4\+A.(T#C8<=WF#)I''4FAN.5@XFX-<BE(;*HIN(FY&L5AX4-=0]<;JZB8I#
+MFIR.$ZK'2NGQ\_N>IHFBT,[<S>IG'.79*4CD(,(ZNC1U13:/2Y,*Z+WO0;DX
+MDYKFLRFH)J`P^H[T''`..`)LFHV^%&AO;#BS!N,?$`H/7(%@@,6H`HN'E4:)
+MA!)%QJI,55"Y0U2+-WF6"*-VD-*MC!`VE@Z30*A"9027YY"T*K7690"HSKUA
+MJDH#FAH)!P^'ER.P%W%/8,58BM0\#,`B;CGMIF)>`'!D$K!H!UCO#NJ:(7J.
+MS7INK-L-Q4[)[X'PJ!4,V!?-<U$5I6TDF8R=T@330V-KAG!.!))ML%!C$*+,
+MAO9J6L)626&?://,'F<Q>.PAO>#'LP_('F4/5XGP9>P_7OY/.X^QE/?T,S)1
+M5&!\D`^(T@_(R;YRK\%[]^<]S0Q#]5:P9,4@'Q"-'>.4]RTN@B+NM*Z@'K`#
+MFQCB;28$$.A[-"\&MA._OV;.]3J)W8F"4Y(2&\G%&L/(!^9.K'X;G`Q)0D0,
+M2'8#%$E%-Y9`HH)D")[#I:&(+$,]L'"?0/0GMA0I`J9120F$+E(2020PA?BM
+M"'N$]Q/87%GVB8-?#!\^W7F9YSL`Q+#E@&X2AU9589@8&>1![9/6=NJ!'5]K
+MOOI?S=TQ?-'*6C0=II,S%B?D2(--F7"S(IGG;,3@G22BRX/`R&)$,2,8R$/V
+M2S',>SCCJGWHO[;$`H2*E`I0HE(JR17Q.4%*0$2$:4!_OX$-4@E")2J&A%72
+M4J%(.A=*"%`!H%T`-*!MK%61H44I06J$4H!I0"!61]J6!BD"(8D@84)DU=#H
+MA[_2@YV8%S=D[:DWG;4<V8FC>9>>'G'<V.;%.W(?/'*&M&D*U(Z10(GC`[,P
+M45>9<ZK9!V%*0&DD2%I%NPX'/,;%ZHM<S)`2*$HM(THT4*U$JLD3(00E,;*!
+MVG4"=#R\'I)"/YSHBH"L8[M7M&7`0U`<"2@G/*>#S<\H!EE-)F56J0"-F,XI
+M]HI`/SR1G2.LS)*!;+D_C"R%,R3,D!"H]R'"'\M"42U(D1Z.!Z(O)R8BCB`>
+MP]O2(--(RV9D&B")H&&4`=#Z?\GQXUSA"@>OK$Z&S:'4@5>68#=I8"-@&$T)
+M=7-%!HL..R7,6YPH^^_H<PBY,6_E(2=PUD/#4]_@7G-SQC0:H.580,*YD4D:
+M0R0Q@F%)%`T7%U<BI"9$A(-3,0!A."C9D#X%0.X,)/^C8B7X7T00>\YP/C:E
+MQM,222`:-%,#RQSAM'OOU]K';DNA*\C;9H)TYF<2&*BA"AHKS'J0^;SQT\PF
+M]8-1)-!#1'J'US1-,/K;;/NA@\3*AK1`VS`0<!10F[8:A='Y8.%TVH[&+R#7
+M3=YWB])WQE\\4WSMR\N1Z;;.29BC.S:QHQ-7=NNU1)4/,YJFFV,DQ:QRQ5BP
+MSPVBHMS<E>YFL:X$?!X[-YK:R<D,:S#%!<4%%Q`J5-Q[WOL.Y.0F/)S.QNXQ
+MK3HWFP4%1QV2DB`H(*8"W3(<)(B#IM0Q3>3H,=.'$BI"*.9Q,>M1IN%JJ.V8
+M*6IJ(8IK;$)\2Z^D]OR=`R'PBP'@?)%\8WA6>9P5R,1$$T$/&*F*)H>4_5.L
+M/[-FYV\$T32=K@H5P"9=)P=USY3S"(:=6%FL2@:7)EN1ME+K>LTC<9!<(+N4
+MH1-.":#XWU\'I+F=&'`^\/T!%*01Z%"%9\@UX!#HIF&I(HBIH28JD(@*`2+L
+MX@I(L2B&A:1`H4[-(KB.2ODKU(4.U-(4J$2E(R2TK2I%0@5V4U-$K04$0T*2
+M2&A="%%(!$`T4-&FT@7,GR%HDWX3VS.1X'</(HZ%A[@'8-C<2*(R+]50M8"D
+MQSG'7%WXOY2M4!24$%5105$051H/?A`,U$S21)$CP\0>ITD*M8#Y-@G0ET9$
+MFIL"6;`H>I#ZD`OOH!N^Y!UH1[N6*X$A7,?7P9(M%3Q-K]0;&4^)GL35,WUH
+M2S+P,R5+$.&1P@2@T"Q,DC"0I4'\U5?I_09<94E[VM>T2*QF@G!F'NXIEVR^
+M@/2=.?(-P'6N,+#T^@W!/040K2!QN\U=/(:0A5#7AN.`F,!XLL;6(Y;'B<(#
+MD-+#!G/V7ZCL>\?',BU8G5/KXWW\?M8IDYQP0ZA-2)2FH%O?LGKS2D4Q4DQ]
+M+9[B.1MKA=M`HWO8%*'?<"^D\-[R9D1!(YUU'<,];#."<2M'$VXR)HGGHT<$
+MSC@$V0"9Z<N:!\FSK6=EJU>]&N:0@YD-P@XN;.%$UDUCF'JJ'&9=%.:(9J!"
+M&N$#@DPX"&9<R?((%ID3/?@!2,-&&8@%(A]-4UJ%<@XB40(!W-)1P/9VF+"F
+MVY0&$(;9-4X11<S$ATD+0,RT.LGF^_4*8#&S,E$%PU:8W#F;G-DQ[3TE\7D(
+M1`T1[0^5]CX/LP^OPA^`(B>?;<@[C$=VV0NX=):,4CX_?'Y0D0%!H="S*]53
+MJ1>7LB.R(8;['"N(A>;0[GBSPDU9)3K\=BGD4O=A[+ZN33Y&J#1^/Q#H\`!&
+M2!A)TYX:9I/`C(;D:VXN]NN^*M,<]>*&+-#G!MC+;6ULBV0P*>R80M=45D@K
+MG,CG#G(,JBA)CD^<!3:8QETGFN'Q7UMWSO=[OVV]])O_9=O>V'RON]W^#L>:
+M]5\_]7^>60-;QP)RZ`O>*JJJJJKP,8QO/LRO&;S`PW((3=_L8$,\(&X5$00W
+MKGC^(@K],OA*FK-:;#ZT_S?\+84YGVS]VE<9DFC?6BC-)M"I@./*4I[')[/:
+M("BX9Z>!Q0^%*-B@-T"CZ'VIBO<@:8-M`'W3(&B`^25@>?D\K_H9'A*\QBK;
+M3IK!86L-:,@JCF;AW?F&A=0+5032TH-(IL76@%!$+O)^B?;+V!H.X$]&/<?C
+MP>J/'(E18HQTE./#O#O3`%-TQZ,B:.F-)+_8/Z[U$PP?5<3`"?`0=@BF>S7`
+M'4'[S3].4HB%=!*["F#'C8$Z,A["_>O4>5@G)BDJ@KR'G^HE`F$!MH:%/X(=
+MH22&"3R6`H9_[A-/::-J;]I[;EP,<'6::*C!3&#;5H;!E^],<:"E-&&O9A]0
+M_B<D:6))D>0'+RHT0RP0G2P>1[`/<'A$N0,C("&0_EHK]Q(%!GE]P[%$@2(,
+M4P?T328S!_@D$?3#6O)Z&$2BA4((H&"$8A!7T@`1W)@.S[=Q-!]Q8256Q[I`
+MB@?Y*^G;>=\PB_@F.+_!)PN^3+UV1HU$GZ@A;]>%#P^R)U,!PX.#^BOL/;Z>
+M`LRW`OK`O`-)=$1HJ@[C,-[U<Y@\W9O7>R^!='QQD,P]V+O>AZ\YP;AOMP&:
+M4V]+V$&!O[I'!R3=>):1F(@I)Y\V6)#F0F0G''OO/</6<A"D"8$*ACL&!`+J
+MH)-[#G.`?C-LI[N+L54S$A9.2:DT9A=YMJBYQE[=@N0F$)T1$YH]YS'D;B'F
+MA>&`3A>HYIXCD(F)'`).Q@>M?=+X.#O[,X'8OY6,"%F7983V"E!4$M+7)3=(
+M##I)(8^<X?DF8!<:H)82AH),3BS#1,E`;.&P\YQ_G<5YRKI?4&AJ?,<)>2^$
+M!BEIC$Q5]3\!TFA/`$/BF@-"%*5V@=JWNGC`/;]\998HF"*@)DB;F'^8X;'Y
+MYT.H(>G5X2]A/452%!3433\@L>$:I<9L:3&-\Q@XZUB>[C%,FV"J'A#H2%B-
+MC&P:(MLA##MB(H=4&#!2].?L878LR'6H(REL31K<0^A[GXL`O9UCR3,3D7,B
+MPL:<C-#N'4`0O!*0<T]0%P!Z/$6=!+R?"5.903B/*.$\^\37.;7IQR.U.P8Y
+M;9*)7FX5ST_[RQ==83J,):'_>F8Q6O@#^?*,64VS8AL49%%'*PHK,,S'*1:4
+M.+9,ZD>B2ZS%$#)I7CK(&2."62B((0B"8,8*&55#2;^E6M^CKD;DGS_<F8:2
+ME101!+28C&L)CZXW@<.G[,,#J.HPY*0J4GA:#1@@0J9(DV<_6,532E=@#W75
+MC[VC'O[MDVMS$=R9$H:6A(BJ$XSHC9#6-LXQB`K-'.]YW66$ML14QTCDG)SS
+MNX#Y>!-',:/+V1U.XPZ"A:3OOS_+_\)YZCV7SKY,;@4/;5\@AR'JIT#9)/\M
+MG.D,5,%,,'V#W'(K1@.DAXW^5P88)@D)HS&3$`>U]0,$T!0E`D)@+L['8=IH
+M39@#I*=.L29?H]"?/CXFF((`]J?=M][6:XF<`<06`HC$9%&(AIPSFW6:UL6K
+M18YMG6ML*CS3B8_*/FO4<!S#@(X!!P@9PHZ\!VKQ'A"T9"CY-JRY#YC0%@B"
+M&Y"^I+E:$FTU!]AKZ5Z9U>%#P[D3T,\_=ML:@S)WF)9C$G_(_PD1BHIWVPL^
+MQH?^7CNF_6_Y&DG)*.+\C:%T,/,P'/8CCB9.-071:?Y'SUKY_Y!P\QZ0T^Z8
+MF4E*47>&.B=0-!,T?S;-,10D4E$*4)$"J@NH(JK'1Y;=]R4B29M#.500[7HE
+M5A/./.QT=4@*\##GTE^9^$;?#][F'XA45$E7GV^G3(S!!D8Q$U=/5^E!^'78
+M.2&!`4D!(,22LOWD@_YOF`QMI_MTX[!V,3L')^B,`A`"%/Q*&D4IH8^\\DH'
+MZ5#G22!I8N]*""B>`<1#AP6!X'`,PXB$)O,B6R(4R!\&`.Z,J<GG3ITZ4_W6
+M,D(D%`5$/80Q`3"LP4%%1`3-#RL@KVB/M>75HW%25.68J%`+'D?$>3M4`/&=
+MA'9S_-Z9Y5#$1Q:4`*4()B")3D':P*\Q!^>3OO$A$P2';#E*2I!(4!,T<P+H
+M9.;!JA`,>/K^QTNCR+B4$0F(H^UIX;1C02'@B9%1`J,I[I3=*JZ%03_V/^1Q
+MF7$PIDGUHVBT.AY:/=\30>0J[UTHJ%%%3K58<7!,3A#ZC]S$2$$0>MEZ#*)*
+M*8HKM=;[7,@0RSTHSJ]HS[.E@L)G(FR9'=-?[+OU9GAA2HJE)H'S\"*6@>CT
+M9EI&&B:B-)D!T1=1-"M/AY)J4@=_\RB\9"H1*:(&_2T#]_!1W/X28G[Q??@P
+M_!=A,.8<'<!DCO*1(O60B/AY`I#3K)-+.44$H&$H&RRH/!UV(`:D4B`(@(E=
+MT5Q@W+<[3H3:URCD/7?^)-CN-M].$:4[+Q-+_4[V+.U&G&%U#AK3(P<@NQMP
+MQ.'H'C*1PBC1>48:@/0:%F9C:"!-%(+4M4?&T)_0V;9HT&G^7M_>>=S:MVM^
+M?#E1[_K<>^K'Z>.]QJLOS#J)Y:*"+Y-$>CN.D][FCL::H3H)H&@/Z!PLA`4$
+M<K$8SI7"I4PB%262*&F`@=HH(JMT6BT^E&JX*M:J/$-)G3]'/5R.>*Q1>0HW
+M(LL;95DHVVL+6P&RK225]]3VKN4=:VRT)J*BXB'WPUKPP3>OS:79%Y$0*/H_
+M+0=[G-[]PI4<T0CQT.<-C#<9,6PCB3EVFA#=_=<-^CS"PT^]/@NSL/<-^INX
+M&QSD*>.1%'HPU`<1*J("D8@R0366[T3<FD!ZZ+J30:=L49($A4&@GH];13$P
+M](DDC)3M2`9BEKMU?Y'^O8B!\T"P?Z_7`21X_K_@[DCN2&$?M(6O)-W-7R*I
+M[L-1,L86ZWI\,=[2EN!+[H1.^]Y1/&B=&#\W+O.BB&/1:(A5$;"X)V]"/F:K
+M\4Z`^C&O>SYE,P+`L%0T98-&FYK>TO-IBV4MN8R3'BAE>BKU.`[6+YFI,L9.
+M5NE4P9B12MA`-&92^Q\NI\CD.93<V.J(Y=FRNN@[Z3!.T-.-(.(]>O!N723-
+M#DRPX=Z+X.%`&"13'#-8O3DF%R;*MAIPJL3.D6?TLZI\I-O74>$'$5<DWE-9
+M[PT;)#?GY#HV;AM*./'1A84D9)J29E/;QN73F*8NV$<1$76>M*ZDA.-^!&<N
+M_&L\9N$I:5D/:9:#/K8Y17$V?.X9F5S4$J'N:G9?%Y)GHV_+HH:P<YX]<-X=
+MIPX.WX=GF;JAYI],9J$[%RWCW0_"^VIQ(;8!8%A"O)HTAU[:T\]J>CI->P_9
+M/?6GGF>WO(Q5IR$OD<C0;K@]XQYMBPQ1,U(5`F"CBB1(5A7=UK1K4A[+BI?.
+M\X>;:.?1@ZG=C\\[F&VCP2UO"M;BB)+PJW6]2]02]"T,3"7>=G;)05O6Q->[
+M$U>']Q\-^CA)V`:HQC;)M7-!26O>^/7U_*?<V,'$[!LRA5=-8>TFQEO>LK]N
+MG:95*#SO:_80G1T*_,!Z^><V#EXLZS6%1K1K9PSK]:!YH58C@7$#Q*>PCUB!
+M2H3(]1R3[>`""*0'QOCP-'E[#@%Y$`4/BD?9.CT&7N'M%2?())X>"IH@?>)L
+M1(D_P-28Z9]`LT(>7?")VMO_[W_(BZ357O+U;V#5Y#]7(_EU-.GX7E;>B$$3
+M<<1H]"AIB(+G?H>M$01Q*J\?L&P'X[MICZ--/7KR3J9XTTH@'("H`B,*@4(4
+M(^X2&30)];]:&(/!FBC0O*JB[5!2RBJB*GX_E_D=\3;M]SD,`\YM6&&'CQY@
+M8L:BKRK**YFLH78+R['NG@@IU74:2!R,\TTLQ,<3)%''(^,@20HB@@*6((EW
+M8'U4'0_GR'2'7^0.6"(#(B:BJ^KX.7(GA]5'Y"$(R/KYM_/TL*1*M8V'']ER
+M,?85CC:'YW?[Z\^J/B@K@0Z"M+4._;N%YK@RX/5'"+#<:I1Y$,2LY<1SUXME
+M[1U%P@S,O"H7UM!%*MN-RFAFE<^9G"V!R-S2VYL1U:([1)NONU8\BI]2;$^9
+M1'>+-*UH0F3WH"V>8P*8\?-PJ;7*%:5%5`TF\V7INN[#J/4MMY=US_W?!Z+^
+MK_Q],_4OEWO!W2BC%LX:$+B+Q*>=-^+\KBEXK"9APPQ&<([)HC3<E"H,YSJ8
+MC_2FR%#EE$SVP9`$C0$2BXSF89F5J3E"N>@.^*KXX=B3%/6]E>]]<YOU];D^
+M3[?&KUK5KE-)Y#VF2967E_!PL+F<W,YGL\ZU:M6LBW;MV[5JU:M6K5JU:M6H
+M6(K':V;)9+)0ZR8`(5(JD=2*Z6RV6QV1<,B*MD29$N1)?E^7YD.OS(AD17H7
+MY?%XNF0_(AD19$=\7Q=,@NF073(,@P2^+Q=+ACF.)CF.7Q>,<O&.7C',<QS'
+MO7<?'O8]]&9%_&1D1D7<B]>R(%]D1#QB]D9%]D7SR^R,C`D(QX\NY&1=NY#S
+M(OHAXXN9&1=NY#R]D1#QB0PA44`,M3+G6=7N9156U4VL58]\U^+'].8UD/\`
+M()6GH)_;20O(_X9:WJUX7,^GW]A(*+NE(HID(WQR-*=CP^,WG.MP=:S$.E'<
+M#?R*L;N"7?0P>^^Y_>?W\LY;_%\>+R;YJ,TZ_H/<_KCL$_H?:X+'_0?K\>%'
+M_H%7;0_!.P;YC_'#'Y_?<][Z'5EKO)I3,PT4L)^UA%4D)%G5"#\6*5841=0\
+M*D);41`CLL74$_!^3_C=5]2'X?_-F;?7Z71;;?!?#Y-Z-[)VIC8TL:Q"LK.6
+M`K2C/T3SY'F?*.!/(J1^_X,FFYOSOMY7^XV,.?HN_%J.E0"PUM67E"Y@([U?
+ML5KI2-FUKVL)^5D_ST_@=C$J,2=(#(?Z"'_!+_*6`V866*7%EEMQ%T=V<OTI
+MS_!WP%6M>^E45]:GG^:))?;2M!EE&%IN2UOF&81E&G/K9.YJWJI+FJ4@J"@J
+M@$Z@,H`U1V=F1E93VKXUTN+K;6%64%0==]A]KG_T']0^"C=L**K*X9!4'#AZ
+M"=I?_PTV=<BDLHUM<$9D@S/,9RX./![F<*PK*ZT,>N_3T-^]*2VJ6E+8Y'CF
+M849@@H?8TGAZ;R+0#'W&Y_#^K21)=+RJ"K='92\YA,]="-T@\8?FITN*TCT!
+ME#[GS=,Z?H^9<E.4:AAQI55:J+)T7/="S!:@AKK.LE>J4#('3*@D:GR=/"[>
+MJUII#2###@9F9=))D887$4PU1F:$<BWKBN+"F'4YYT:O96TJG%F,R)A^D8T_
+MA;YQ@@+.*H*QA7L!]\T0YL,W8[K=E^=!R(Y1.L453<@,(B,:[!XJ^SLY)/,<
+M#S*,C_,_#^!#UJ>S%\.KYK]'T'OLB)7SV>R^PT#[%[H>I[3(`-+2:YQJF.T>
+MCD4SZ^114SM62BJS<4YY,M9ED!P>,J:-4L*FH5($S!IO_,?)_BNJ44[Y]Q%*
+MJJBI6J+J/)O#9HEE@3Z75L)[CQF#)U-+F9SFPMQ4J0@*)W%Z!N545F>!SZG[
+MA4/S"B'E<[&\IKH':7*^YX&FB`LVVZ<M,>/DT?Y/QHB)7]..IAJJO:3G^B_W
+M=C>(+!$/W^6^@X\+QM!8.0N4%O(ER*]UQ9F:K-!6&9AW6<:1CD@X48`\[OE8
+M$?FLB>'[?\'\_W_>;WOW?/.FMV[S+?&SORV5XU5FB&V:%F*%Q#S:,@1"[05*
+MGD&^VJ(>24_)US(%-7>\IZG]VQZGFO]?,P\FE+:KN]UKC!<.(`:!$4UO.&MX
+M5O@PX[9.IU+R*!`@0($I*2DA&;*>MJF&6@9LO"J/',YP_I%3V2EI4SZIY'GO
+M/]QS'TO(9<A71<U*P5G6&7W*([48C$%B&KZF89G055%-GRK$:WE:_8""H%]M
+M&/=>%M?>/,OJ:VP5'#AAQ=`KQ;$5+EQBQ!F9K;E58[321#.=$_(83EA4*%"-
+M3F;5ST?R_+KK/E+K?"Y+^#O6']ZA?+:M*,<Z8`X=J<ME5V$RBJ]G*7^UP]WQ
+MEC7/BC="9TD<D8_&Z;!Y=E6F$0W!WST3RPBB*@B*EI1?W?4;XG<:3A?9^W][
+MF/;\+2\G1S'1^7L`&`"F[Z%?*.B;1_KZ?]7ZKG.W/^^ZE]1[GGKWD-7M8Z^>
+MM9Y51=!K-KH=R/9SX;>342CF<KWAO`PY69M-!(UXA66/8[YR:]5(?GRW\2(J
+M'?*%GGFKQ/3R*_6J__=CZK1>ZB3DU_-[SY?M?@\MXGE?<_ZZ^W\-;V-EW_5>
+M0XNWU&>P\ORGF^D\;I>VQ:X@B>9^W:GIY-P:).5ZY564>JZ4;6("BH:Q1+[F
+M>QTNEPZ9NIE2842A2=1!E6'I>Z>>0_>2*'N.$II0B&D,RZ`Q9E,1I1Q*!%0H
+MZ0<2![5$%$EQV1*NQBGA%SN34Z:O%-46NLD\\13[MGNBV,'5/%1)=K8P.-L-
+M![WP]+&B5":_J,S#+-BN=8915>SU>BZG3UQO=Y/K_(0A5J+5];[_V$O6RD77
+M>)I>(^E.5**\LSE!4?6>#0T5EZ30(>^]!#=3%$LGP7TE=]I(4VJE>Q/XNVH,
+ME2OQ%8JM/V>'/5DE46K,7U+[2M31+!HR.&Z<\K2R7\=Q[+!;DE6Q-(8%20CF
+MDILQ06#+$^5SQ9[#W?`^"Q)#!LN+]Y4>4WO$4]!W=J%O$*]FL?4JUH0O8%B$
+M/J!*SU?@8G&OA,L=1\BV[]7WY")8Y.(2^;)S+$6358E(ZM-FG%PUJY.;6,UR
+MZAM14FGM5JUZ]@6""82R*Z25<JU#$CM4R8,C9Z[&ZNCKZ9Q/(N34P(2F'4D<
+M,/2BO-%@PEDDTXAZ[4*MJ%B9KV?GIW51I[K-).ZO88E<M:)[.IOY)\J/(6-\
+ME3(FFR]R]/OX.!ZH]L:-74MH*M6**#A$)DX:H:K<:WR6W]Y%_GE_R^O]3W')
+M]-Y;_&^UIOCH-TE6'=JJU4'$:KPV+JFT;BM7Z/TOI==@*!*H*J%UF1'`K&&(
+MIT2[53GHM2ZKK=[D;'=6N-\).-',Z8NE\,"K@C*S1,HJN917+I=DYU5E>/T:
+MZ*\\?HX;13:1M!66&HC<K/U5[HO;*_[[_B_6\)\*'X&*3R/XH@I_/B5$H1"K
+MU5'M'.=`VOH_1[O<<[T^[D!"UE-505413)#5+RNRLZW6UG=_GGR0YV(B(B4E
+M'DI10M",@RKGJG(O1Y,QXE_]_W6NT42(3_,H^U%^2)+_WRXW[FR>.B'4!9==
+M9=6%L556T^"J:I\&%<B/5>O(/>]S**X5S-UCF53;^H]1[S^>DB`T:A^W[?/.
+M0Y<ZA=,EY-9,>2Z1+"2IZ4T>"HM_H;YFB,O`B<8'M9W*L?)8%G2002_4([?L
+M_3<QI.R\YR,RS-J<3D.P\J.9SXB.]><<HGD4-H0,-;<6Q:$(,^!VGI?/_/>B
+M6554UZX*DX"*?@Y]-&B&T_M@?&_C\'P,CO90$-"4FA7Q%ZDVV$Y<D9`Q]YJ_
+M.[W<[C9]7JY@+`B`G^$0$80OU3X6TY/N?R;GP/A\3Z7Z=>A$0#G50WBH@FOQ
+M<7RVWA?:WK>E,D@<WJNN7;[/#.;Y#1;BKHJ#7%<X"LJLY/6+H-(P")65`\_N
+M_#Y_.Y?;\#WW(>%\KL_N_KYW;ZGMK/L/:>[XA$`O9QD[308O30R5:AC,Y+B7
+MZ-VCBYGI*<K*GHS^ETM3*6@31**FC=6%Y,4A>;??S[;S[T1(E3I\.[JO`XOY
+MVF[_W',3Z;YTW#?_Z#5+E=S,]W.XRBD3A4(9N:/VB8?D>P[!9`9F-$++4&)<
+MN8%%55Q\B&:JLZ)PINKWH.:>F8J`JJIO%0WWX-)S=OLW_-_MV.S_^ZS]WY/E
+M^R_K/7Y#RK9@!U[,"X6YNXF+J]I+E<6[%RJ,J>C019#F://.Y)_(Q%8@/(R,
+MF(3$9,.LK1U[+HQG+H+CLU6NRTO/GWT^,_KE51,%407RNL]QP_0>D[SJ/B>A
+M^'PB7R=1$*5`]>L/T-E^3S44=ZQ<5<!E88$S$7:9(B!DF7D9T0SG2/7DQF3_
+MMSI;ST0VZ^I]3I'2BGS%LN9F1JZE872K7&5;".>,,FA4.TWG.FU[V"'ENZ_=
+M]8>GB>T]ZX1*AIVUN%QV/SO':YUUX\>1D9&;9)5%#WA'7VMAIM^2]4:HVM_;
+MQ.G2O@:V,BPOU=Z%=O]!8\]K+G'\S/R?3=UZS]7/\]_.N6!44U?+`.1R*HI^
+M_5^?[KWO8\OB2;?NN.<)F*E[&48UM8ZQ[V;4^IS='-%Z7?-*?NZ(!!DX:LHO
+MY?Q'8O_]'ZO;_U+X.GG]_R^ZMK#E2?N.,J1;6M0R8_95IZZL;8.?+RSD^UZ_
+M\&FPODX.#'VDH!_KR6#ZC7^9BM^L8N"*F`(#'KA05/IJA*:8'T_K4+2'[!G_
+M`_`9U:FY*T]0`F*F'/)K=A%#XO:1'A(B*BB"FP[CI>]YC$]QZO9Z/R].NU_H
+MNWZ+:_2_;GL]WULRKV.:I,8<FLV2M!F<*PK.84W8@9NASSX.96#\/KN%WKP#
+M*%0YCH6/G^T][WLG9:SY?\/H?Z4Z(3!I_$)SS=*BW]\S-$*."WL,5AR\1*K&
+M-%M9(YF5S.5?P(?NJ:C$FBNP9`S=MF]=\WIY/):/1RI,9UG@WK[L?/]EZCYG
+MR/@X&!QU_\CQM593&%1.<S=X,\4</3@B/,AUU=>]M@*KF<YG\5@X/79T09.B
+M1A-"J`R3HM*?VY7V4'_4C$=19J\+@V[22$@NGU%IS[\5D0]/9&`0ZQ03QA1!
+M$[I4/1&MVW#_'_/5:KUO]O5>+ZZC\?H?^<#@X&APME?EW!$3%895[:/CN;<Z
+MUOF,H?*/T?GOU?9M;KC@0W:=11L+;ZDM.4_,$#KEKB*;CHV.-UG>]#;Y3=?S
+M\UYC_[U7$:?M^W[;F=1^?Q/$_!][T/T_I_8\;N>W]]B\'/F?5169QJ5#,4U/
+M+>=9AVB.I!D;5B_"-5Z;@Q#Q1142&JKN-;R->QOZ_JO@=Q_#`^I'ZCMO<:3M
+MM%ZCD/E^I^'_WD?Q?.JX`G%&;YGH<>#-NL7C'8V-&&2:)DYU-UQ+B..1T:J.
+M9SF>O^A?/]4HJM740[94.=YZ9RV^.T[6'P9GBH'0663D>A&$E(V$->H<D*)>
+M%0CH83UU(EU+I=5F9TCHJ9G;&7DXHXY?)3UV=8;R4"!(\6@H&H*!B*Q:%5Q6
+M'*]6<4,,*RN^5T=O6/3(5$[O.5%3TI[WW'*Q45&9F3:&?S55<!'D!>_]*P!M
+M^R7LM\SPTRH7_J_[^Q_CV7(]7(FCR.?\3+U^<<$P3BS1F'L./]YT_(Y_568K
+M"BML413O%S;&DJBWC#Z1BQQCQ^DM5C[V=/W(#/ZCY))XO^J1G7U>[\S_KYWS
+M_6__?Y_3J_QW:B4U$$1P".%7@#;IRW'.9F[]0B[!@\87/`*"@@BL*(P*?._I
+MZ/S/O.CP=U(G-<.Q7X*D%5;?%YB9MUH#F<1,K*_2"P5S,QS2G&F@%T+#-IWH
+M']E!/*]8WA^'\=?&^DO[?A+A'9=E_[:?'\=%*EW1*RLO)>E5=I?Q(8W-JV'(
+MS,RBH#*@;[W@J,/4S5-_O^Q\?P.PZS^OQ\'GO8\SW]0PA%]AI[IR/19^=^?W
+M?[_<5MS]+9G9?!_7[RBSUNTS-IEC.=#.79J1;6`YRJO_K]&1@$%`V:H8W+_$
+M^!JOTX?H/0=2O8GU9*#79O9X".'#A]OK&9;BZ!M^Y%9F;A"HX-^,RS(S+B#4
+M'/CT!RFJ[OKG$W3_LUG1.^C]!>S/!\W9.27AE"(F_8J)HHK+E<R7+RBBBCQR
+MZ%AEP,OJWR=&QV2_+A_N3_S_[V'^9\OP-/.\5^ECK(F_,([)!.+]CZ!QWW9>
+M0J=OV6Q_5UOZ.\]+]_L>QY+J>Q]/;[FGW?L_8_A?G&-O>BVOE3I#7F(2&>-,
+M2G&G@&K-4<<>6-V;0UYQYW1KC7FP-Z;(O''&^-\=.8!RQ@&J,`V1@&,8!C&`
+M;$P#BC`,@P#(,@P#(,`R#`,@V>"9(V"9)@F28)@&08!D&`9!@&08!D&`9!@&
+M08)D&"9!@F08)D&`8)D&"9%;(PJ[25L#(KK@9!8P,BRN!D%K`R+:X.06\+(R
+M5Q,DN9.,MS)Q\&Z['R2[DY*W=A:VDX.,6O7OD<4H18\<<,5R"8*A]G3;_ONB
+M;VRQ%$^!?Y?IZ_D/L<I\S\VJ]3^KT':>^]7[/_?EON_WZ;AT])[K\/\7X>&/
+MW_Q^X^]18OA^,4?B%LU1^J?K6/OOZQ@K]2,*5$"49!!D1-7HH;;9<IV^ZVDJ
+M3LLXZ,C8*FJU3M=&,NL8\LLJB'S?#]5\C^WR=/]S1<[]#\.B_/XUDK(GF/']
+M=S?^_)\O]O\7X_)3AC:+>57KI!@K+YY1:*UPFOB\:T__@0G^XF*F'\0+XZ""
+MB?T1-",JI`15#3\DO)'-\PKW.>:9"/U5?SN?GX7B?%^/N?O?@H.XY[$L[:UM
+MOV?(M_(]9/^G]W\78F!T5;?.SRBJ&(MN,7,%(NC3I689LX>>\5E$^4LPDS>R
+MUF@[M$ZI8?"VSD!TBR[Y4!5$9..'C(*M89@LJ;/4?V[_N(!6%]7D[;T'KO:?
+MH];??%P/N^T]]5J]OS>2VF[+GN9;/<UGG[WMM;E[N;=]MFNEJ315(0GD?)+/
+M4KUZE:M8S57RB;33UY+2K&?TYY%:K>K6JPMJ;-9JZ7_M(%OZ*!#_;(!M`7:[
+M_H^<_P>J_=NG2?:WE3=4=GZ;GOD9PG3B7Z*JJE%U`%+;E:`KA)_OR441B.+_
+M:_X/\SYG[HJM^J^#+_'^1HOPG?X@=15Y/VKE#F_QZ?I^CZ+EJM;&@[535-FC
+MZDG^J)GNGK_`_)_%^O]I#3;JZ=:U636JRZ0@"%!X/!E<Y[%=`C`YSY'R.>W'
+M-\G^SOL&9;K("476PF5D0<H*N`*(>15+BB/1!%/1^ID=WNB_-W/5YZ+')-R:
+M@LG#*Q:+18,XYHR3B#=FA-N91F&>-P:(W1X1H#0F[-699HS"-,81S9AFH,0W
+MABFI-Z<R8IB&&81@F"8)@F"8)D&$9!AF08AD&*9!D&08AAF$8)@&`8!@&`8!
+MDY)A&289DF(9)BF29)DF*8AAF$8)6P3!,$P3!,@PC(,,R#$,@Q3(,@R#%,0P
+MS",$P3!,$P3!,@PC(,,R##,@Q#(,@R#$,,PC!,@P3!,$P3!,$B,$R#",@PS(
+MAB6,B/(CAD9.3C9.-DXV3C9.-DX^3DV\F_R<#)P86,G!LR8&3+:R<"W-DX%R
+M6W);BQLG)NW<FUE47,"Y:#J2(V"CGT^(V%JJZ=/C[EJL==*<OE,[>ZFI#X'Z
+MQ.DDQ5F:_VGZ^W]A[SS/0_6]MJ?J:KB?&K%=3@!8-VJ(B(75$!$!SRYI%QE5
+MZ)(F9H)>!FNTBLV&QR-*1JB(&NF;)>\9^/JT-8F9J`$.G!T^/\/=]#L\9P?(
+M$'G")YZ**A3S0H`Y9)&$D2>=_BW$I*_BV-)H!#C"0F8`_*RA)(PY(F_QZWJ&
+M^F:Y3>`*[CNTCFW)9TY@3G)O60TS,:,XK9`;#;E<-R#4FV.8:2V9AM,4,1H$
+M-=)'7N\/.\$TI2&V.\V47B<='3L*S4SIPS3BYCJ*ZDHIQVZ(WKG7-G4C)IJ8
+M8*&%3,9>M:>-LF;K+C-[UEW"N]:W)H@D<R.&02:MDF!5<`'Z=W+-DMY;J]?N
+M-QT]IMY3J[;BM)<P.V1I$=`_7K\ZO\X6/N^=P55!6115;`!)!DD1'C*]61/R
+MPZ+R'X-YOOQ?WWOE)['J-[^:_8?C]GIX#:UPQ@K\A]/Q#C&+5\_Z8BHM_X60
+M]_NH-]V+"9_*F`=2IB@N8E?-<R@1&46!Q?*A@"*BH(D&%5"6)VSNSYKT?1=T
+M&?W<5W!W*.S\XR5IAL)S"O<JK7HA!FXO1#/7$)!455K4VKI&B!A(`I77^*H&
+M7]KM4Z)%5YU(=F'S75U5%3C."C(7;[$NL1D%5<$&$ZA4+"BJ@>C5$^4IV'';
+M1'4@O'K/D:$0=LM!BYY".%H9&,:*/0")H8HF9@3?\LQJM7'F/,\T@.412<9L
+MYE9`OU/LH*?:\OFN$*,'M8_M>[SOU^\E0L5QJY@:M16Q/*Q8.%("<W[/IL]Y
+MCXGB7\?\?\-,B(>570)5SL]L>@-OSZBBBF:ENY+-/J[]N_[!MH+H%%-",F8*
+MGMNCX&N_3[_^_OMUXW>^?HVVX8MBZ5<$57,YS.5!PNBZQ-P$!Z=RIA8K!LUA
+M_/4=Q\GJ_$]3_W\'?_J_5GZ^E\/<[OT$+-K2C7P./)J:@4>*BI=OARI[001D
+M$TJFAUWL-[7^-YO1>W]O\FI163NBH9X[$Z'LMOS/&\;+R\_0ZG:5'\OFXM?>
+M<U7LYV]LV]=O;=W?=%;OM?H+5]O,]:O7R6;M>W5LT]]^OV>G!N_%58^X[F1.
+M^>3P*-A;4=],K'XPP=.MV5RH)ZY?F_<\?M?103_:*?#9$3V7I?6S>M]E$@AA
+MRU64:L-B#A+;L%P6U3KP4E$1`KHB`Q&"BF,K(28A-E>P^%X/\8I!,B/07W;\
+M#K-,[A_T:PB%BA;"LJJM\RMK13/+I!8+GQ5%>Y@TEC1RZ+0:*6*6\L%D:1Q-
+MQ:*F,J(B&WP=TCB+=:;(GGA6LXMO3VXJ%4OII]<PPP_/(I$M`S!URFPNO<X<
+MYAR,*)YD1035_F8T?,U_R_1^1$?Y^%]6\;=3`%55K$:8`J=JO=@0_C^Z>E47
+M^+UZ_LM5:Z57]G$P\#]FJ:I&P]"JPM$R(9]?F]#_?T?[/$^%R$A:!5GQJCZ@
+MS(JVAF/V&`HJK=<%A4]-_Z-VD]_HW<:4Z4<G'KB+2L202^7I7M6^O.(_K50P
+M='L>M]!O?Y7U]@'M]S_1T^K\[\&RVW2I^/]ZMSFI)^._CL[%LM9[FK#<UZ-%
+M15%1<.`HH)X:@55/R&HYSX7P6_@T(PC2JMH6N.%KLS,CJPJ$3'GD<&<H;..3
+M<Y7T?8<9R'@=UT_V_9\_5`XT7RNJ,D<VD160<MUE9>>8#W2"P4>+QVKMZ3W6
+ME\KZ3V<A*(3*BJ"&U_5YCN5\[_9T7+5MCN.,1X\>/(%M3;BF\SE%SC1C*RJS
+M[`J?P14T2A\WBV!,9?5_FUNN>:H054.$PRI0O%C,6'S:W.A$*_&O0?J_)*JJ
+MR)Q?KF/X:G^-]T'L8BJO$#5Q\5^U*47_I/RWJ>>A7\.<1$J'RY'RJ4UE=_I^
+MWB[-)J8R105.Q4^ES?.??B@)LU/L\[J7=9<M95J`3(+HV9F:]"$;P(T$%!0T
+M'25'G5<QU_N_.02HHDZD8J:&I5BQ(!C(IR=I8R:)8P9L6U#'+9BJTC,Z=_+_
+M/<<@(IK51""JJ"JG<J@@RJJ"*H*(HQFR2\MJO*V>8T.RXOI^:[7XFXYKXOHL
+M8MIJAL5QB[51;[;8$&8R/+29,0AT*H'.>L]=^#E>\XF./WFAL:3$`JBI'"SF
+M1YKN1EBSY(7;N0C.77$S.H&8\`41E10550_(^[]O_9]?]+_HO]^YJ]""BEIH
+MI/J?$,U/JZO'[VWT9E02+:^>]3M/_1`1X"4RCT&-,(R#Q7T-VSXZ8AS.[HK>
+M)(2*GN5Q7#(B\)B=2-@9445E8&8;IU3F_9^T7`>'JB69B!CWAK5!4U'^J),,
+M/WU2O'#:T\'Y[586U(V]/L%H?J?J(_M_Y)^KF9&C]H9CD51#3"^5\!@]_P_W
+M^1[CZ?3:.'1?MX[[/4_5G_MBWV'QR*6;VV%9,?3&_,G;ZB,9SL8>2#AI%<(:
+M1=&O&*CRLP,IX6VZ&\\(*BBBJJBJ1-K*MG<^AK>AB+AT1I"\3FZ-$>F-$7YN
+M"+SQPSVI6-8<J:PQRZ<J<43Y!Q9RQV)V)B&S,^9\YPR#:&?,BYD7<B]D7V1S
+M.3@Y.%DX>3B8F3BY.-DX^3D9.3@9.!DX&3@9-]DWV3?9-]DYF:BHJK[Q'J/O
+MVO9X%&UFG4\//MYU0-6,CS=6DKN>M<@G&*4**+D?,W]'6\&7=^IE"9%$51%5
+M$M96>R\:]DR:(DTL?^83Z=O9<JUO@OS55],2:>Y?A,YO^-R7(5'_[_M@(/>J
+MBHNM9T^1!A<L!!?5_`WK@@J"JJH&!S/S=IO/F[W\._ZS?3Z*EF-F.LO32*.1
+M=-JE%T2/?GF5@(EU0JO9PJN9RC\G*HS\44&62)<HJ,[7)BDB>'7\VX/+`*`"
+MB/$!D%`!2@4#>*PH"J)[7N_\<U_CE_ZYLAI%L*VT3;&V444T6M12L:I)!ETH
+MPV*RLX<RXFKH>'^^C557SU1_[OGL:Y1#TJTK2H:Y2KFY_><"]Q.[D1)A1!45
+M.6553N_CTZ^5'RY_3?-^LS`]LV.N_P/^P_=Z0_D#)^?'!4%1/;]+R^D^CI?;
+M_?]C*"3**H*JJB"BBHJ)_+G??<CQ<(A=H<BJ@MC]@O/?8H_!/X4K^K&?Q]/N
+M9W^V5>V+5O:J6S5_VCXG\LB;JLK=?`)/'=);?'ZGYV`&Q+4EV:JOSO.R9?MM
+M9GR/4(O^;34&KYYKYSG.>AQ5T:^.(B57*N`-#;[_]_]A1?HN'-3TA(^QT(L'
+MR2!C*E*11-#3,!!(5C!#K/P_]'_C^S_,_U/D_V(Y_*_I_M51;YV>SX#V^!4^
+MPHVJK861_?!GS"(G^G?S%$^JH?.\6)PB*HB?U][\GO/V?(YB=B02405#AKP5
+M$1RJ*8??>2\3>]YLS3F"<6891@G&G&&V./-P:@Z`W)LBZ=`:`\@:\V!R!HC8
+MG-&S.7-,9)A&$81A&$8)MS#PS#-F89AG9F(8AJS$,0Q#$,0W9BF*8IBF*8N#
+M<Q,+$P\35XLC8N+%#<3D,2+)Q\7'QHL7'QHLF+&R,>+'R,B+6Q9+9$,CLX96
+M3DQQ9>7E1>@CR=%FY:X[DJ9MC&9F<\=`S*[ZE5<N_=8N4NY?*ST66^](TA(,
+M2$Y.3DIA(4VD5,7#;:)94^.HHH+KN.UW7?-]_S'JO$^#\K_F!U/D.^^+[7M;
+MB<LJ7XJ(F:IT3`R(@J"B!Q7+^EYCYG,^FYK+P>0TU!I:C*NVKJ:W<:S.5_$.
+M?-')H9@GXDD-8K*K3:V9B72"GP^G7UR*T8PO[]1^'?>M]QL,]]3^'Q=MQ,7B
+M_:]D=/--[3<9<?UI\OY6!1KOVQ]SP_6QXR@HJJB%*AK%X?F61$SXJ"HS'DOQ
+M^]<A84G6,5$F[X%)69A5!6R[WV]]YOM.*[9WL_._KJ`G754:L(J)]!?#_DR(
+M>3004UIM+32:>',YW-*K7[X@5.8225%<D!-JHRSI*]SU7:&U%155CP#P<[]'
+M9\AQ/QO6_"UW?>E^_B^DN^W][]/]-N^%U:H)K?8MKE0#^>8R`JIL,IF81HQN
+M/Q7Y#V9NMX:2P,]5CS[Y!<\N>5L^%<')R<7Q_*<U]"_R,S['T>8ZKT'V=YG_
+MP>U]GR'=?_<==0$O!U0P&D%1%<;=?5`(I_18]EV6J\6"(G_?KL@G`N-E&4R]
+M,K:\9ES[>50<,IH(:!PSG='O(D!-6*AM5)%]#P_.=IKT/2I%>4141S%DT/V/
+M+ZJ'&*BKWA5#:@[8(*8`\9#W8O@6/T.0+!8`&1#QMOU''^H\?7Z30RB)X:^K
+MWO(W?\9Q%U./U;LW`;"C45SWVNM5C@*0TC':;J6`SG/:B5Q[L4)Q43OE3Z7C
+M:;<?*YSE.7YC[G4/\!:!+8B^@VG(="YSAPXY8B(E$45;X9B^5PILGLS,B<VH
+M?15.2I;2AZ*3F_0X<-@K*;M2E4V>9%*YZSLD2_*=X5AYZ+NM9V_F/V?RTG5>
+MN^!KO7^+I+!6/5+=2RFQSRW@OP51/C)[P+SN&`QG(PE.Q[WXO@L_AUR?PLPV
+MGL&`_3QSA.T*#W@Q@GLEVE$H(7^+KUER;C'?YI;6)+&TI'YLNUC8B2&V^_RA
+MU7]/EWX_KOI/8_9P'5,IU=(&.!B&I#7+FMX6P3%R,K(-8;X#:3(#*IVP=A!3
+M!N9P<\!J%Z?I#I+AF0O-X;SR)KTAB'3J7GC^G!J\3)Z!U>M@A:J/"#`\&=AD
+M!YKH023-L7TKI<A?SHG$,N`R)?DGA74%\0G-X7M'QNX'D7OQ#?A\R'/;O[N$
+M,5Z(>8.@G"H/*Y7(A`N@YTE'(1%\#Z?W']>T($Z.A"3FM%=6ZJ);P;#3P7+<
+M3J"1*@BJCQK+;BX]]Q"!8)F2(%13/(($;OT;S2?*^5!$]3H?4^O9&3R,`G%0
+M+:UQPV0*PMM1#R7PF1.CXAN)5!0%5%S\V%B3CF=#?XG$YV)FXT=I=F*M+.%5
+MS.50)P9]HCYJ1^]]ST`.^W+(\/@Z#N/E1H&!_B>G#IW>1J:7F_,_G]_^7P?<
+M;3:2)@;+@;/A:#C/V>'=T*HB(;#9,;]<_M=AHMMA;/.XK2<WI=OSN9'#;>ES
+M=/I]2TCK:$HPPI,@S*JZC4:A[WC$<AE0TBH'N_;=GXO$</K/@J<5*>AXEO)J
+M@>2_-I=+Z'NHK?[[V?W6+H,:")@Z`F&XC%2!J?[7^=O6C=X+P9SDX<_'E(OZ
+M'[/TU_#<]1]7^4AVB:?287?>XY2)",%`50-8!R;"#",J#**9NP^UMWQH")?W
+MM-KM=TG*]_@;#RNQII%,K7ZYZHH:\5656,U3;39F&)I$'K?UDF5^5&/.BF/_
+M)_]O_K_'V3>*KN4AR$540_S[W]_Z=KTGL8R^05)5P!FT[EMBLXU:ZN)G.969
+M6:PJ=63]QGY63]))<$,)#\G^MTZ?P_P:_G?.B6+'U&R5)Z`6!KQ3-N65UVN5
+MQ%Q5W2QR:*^46BE=JRLRSC#+'Q2*7]5:A(FCV/][/[7^&?[/_=Y)OR;)(@H2
+M`J1L(#)];L?(^]D.I$-/';%!\XA72Z;-69HKK?#P<OU?UJ_P;?/]?2J#IRK+
+MN=JL+:FS7ZS/H5#\O7WR$"^!$'@AMEM*FZ3]2*K(4*B(*H`DIYKY?EMW\#V6
+M+HKBBC$U3C&TRPTNBUF/-#=<3-A8N#/A;"+2Q1<'4R22:W^)2_90L4E)22%)
+M24E).3%)&6"P6"L6""52P52J3VBXAY%D.02.B]TB(IHH)[,_<_S/ZW]K9.!I
+M(Y*9+8I31$TE-#R'U^3$#S?8N;[9IR*(@P;%0R\OH^UU?U*WLN+W2?Q25&C1
+MWCU41`]^MHJ%\N-A6;A'&*FK6^R^G47/Z[5+-H*!R3&JHH9F`PQ5`0542%<E
+M_J_I<TD(U5!4$G]#R?7=G^I_V/_;\',1\*[(B7PNEVQMBT:5696U18(]L8FI
+MH@*SB#*ST#[(Y#\B'^Z?4?P?AGQ^#**M4M:J;-6\2&`,@V4$6J`"AH8:&"J@
+MDJJ2FD*B2AII^W\?_)]9L[B2%$PM+0PL+04,'P*%D5!30%4*1+112%!1$4T-
+M*%45#-#\2.A*7^SL4C'8S1045,243$1$10345'3`?;_H>?]9_V?_1P/WJ2@T
+M]+[(S%[3VC6J#M$C^&=Q\.D.0%$J!A1,X!41(O&YO$VFK_?YKCNP^E#Y^R:T
+M(B&Y4)_LW-Y9++,&7>T"KE:*?&EH59<ER1:32S1#.=*<BJD2M&!A"AQ2G%7O
+M/T\3L_DCF$!35YL,ADFEDII9F)R#)A8RL,CJ^X^X_OOMO_SYB'(7G-"M+2"1
+M)$)40(4@U04-$PE-`1#1#4%%>6'"*]$&@/TAT41(?ODTE!54!04!0-(E([0=
+M\G$FU04%%)Z9U!V3VQO7.P:FJJH"D**0B"J"JB"FAF$^0_YK?Q<_H[`?T"X$
+M7\/#).TQSW3,\/8_/`?:]RW\A!R$8.A(?>*I24#*IH7^6(B(CWM%4!0$%,C"
+MOT#^K]=CEF:1.9#N]I.8/Y.:OK["K[.'HA:A(81**%58A8@(F"8#V,PN9AS'
+M0Y_@9_QF?P$3^%ML0W2JY"(]+QD#]A[O09O6P$RM+V6-HL]5$M*)(@*>(H,H
+MB@_Z0P>'LK_:1V$-24U)#044M!6RC+'ZY@#0,\_7[&DYJA!M_V@/K!PG!XOB
+MVUO%W8:&]4L\"221T,]R5(A+HHXAG.>GQ!1-8H,BD&`*=N@U)V^=P?AZ;?:V
+M;)?.K!#Z9T*BL$/^-"$_BD=<_[\+D=(`_1C]8(?_6&;%&Y[R&L??,<7;_/;2
+M:SZR4,\BQ_K?].QP[$,N3TS%*!21)C?&N`"2QNYA!(O3I72#B)C`9E_$#S3J
+M<<P2:(5\<H&0%[N6+[]H'89$-`JM*44"?X/.*<'G./,*AE:6?OK0H9IA;&0`
+MK7)(2#!BJ6D@PD&9:,)%D@EDI)+)(L8VVQDMJ2R*JPM&PD@R*++)56K"*S69
+M59F5BH$OZL^N(][*\Z/#KOK#Z@^"<XUN`AI!1RRA&USFDRDL.'=@B1)")I_C
+MM$$Q:L6R13HTPFPAU!Z_TY,GW-A;89,55]SF)+[3$$4;0W__F*"LDRFLG8(8
+M)8'$Q;_#_SX%"+W______________P``@`$`0``$,3S?/O<78`!J5K[W4**)
+M!@*D&C*`<NAO>S#Z^Z?>!Z!KKM:DFE@Q!5(NQ8`!DE(!0#P:C!SCG$(`,7/=
+MCM#Q]??;R^GNM2O36ME7W,]GNW6)"(-OK>\K<-U6$"==P8#8#/H?<-$"$``$
+M*@-#Y.0`-#(`&C(`]<J#D```H!OCON\`.@```4``&AH``;YN@&)H`<I&=;R'
+MH.(`292:,@``:#0``*)'T/KH*?8WV?<:9F42H%*)%!0/K"!(^C(>3GVR9LCZ
+MUV-@]ST;F]&`.@-WQ!:)1"J"F@,``````````=``'T```!WH``"@T`R`H*5?
+M>-P"@``O4`````D``*`<:@?3EH`5]NZQRE4*7;NX;9NXDA2$N8/3HAUE.[.3
+M?*'T*"@````````!H`!?6/O@'B%=/&VJ]L3J^F$(Z5365[AW6``!'8``#.ZB
+MEON=4*4JXM%%?=EUPW7T?.-;W'?6IV4:499$MW!Q=;GT;:\'(`&@#H`,=]/O
+M6K%]\VOH^?+.\'CWKO3Q[=G#MYG#&[V\UVIZ#1<3S+*P":C[@HY\,``"@&@#
+M:7N>@!]Y]2\@#[ZSZ^PV8W3[X9Y4>^LY7WP????`4;3'WP+W*1)]&U][XWW@
+M%2JQR-U**"9SY[T-9/.\%WD5%7GGN>;-5<3H<]MF\"O578T:&@+[!>>X*?:9
+MU0".OC@`=X]#9H]L^.WNO.J6]?'/`G<,:*GN=[UH\S`!<^^YY0`#V/KIGAAH
+M>^\?>/H>\#[E[WN@+T^#;[SFG4^V\/>9GM(EJ@```^[`?60`>G0`=X"^@I[R
+M^X;@;[V>)O&<JP+QVP`SDP=L`T`-R<'2T:B&\\;@O/O#AY=SSWHHOO`[T+SZ
+MO'T1Z8`````GL`!SO;5TWASON'O(:C!C'IU;J[J%AYN/>Z";CG4=.KV-2WJ8
+M<KSWO+[?`^KT=K--<`!H`.S"A'U@`>X/%-[P`+RHJ'(>6M5NXQXXZ=]OO97P
+M[>^^Y\%D&,VO6%T86DF6E3&U1,-(=[A2>@90``*.CHZ%J]P`-\KWTX];[5N&
+M<+N`X((X[F^\'N8+AAO'<[T5O?7OO*^GD[WKK)%X]Q[YX'T*5(```-`````'
+M>Z>7GC2L@EOM6N/=WMA]\]]Y]>/=PX=US@V&!SW/O/..X=/&;$````>BAW.X
+M`'.>L%<\=?<;>PY:6D&&>SG9%PNV.N-[GW@]R?<SE7<'!#2<BI2&`]`"@```
+M&[;3``WH'?&U3%$`WCRHAR>Y`M@'F\T\/````#Q]SW@`7K[>7GB`>Q54<//8
+M,6C+CW@#./%N/&5@9;0RFU9LW;OG(JZT8/"JFV9<PT$@/)7KNPYXWL96C;:T
+M*H?/L[UI(E)I@)>VW,*][3Z=V@B%#FQ55;86VS6"@&(%Z]RQXO#ZWSN68`H4
+M&V`&C7UGG37``LF-H6P%)81@&RW==@KIE.M*1#-\38''-JW6!ZRO;5[LZ\H&
+MTDXMB[M0![;1XN[:!1-M=,76?'W=?6J4)&V:UY533Z,(BJ]W<=C$75=S0^L"
+M@4IZU`4CU@'WQ[GJI#+=MS0C7S=)P&5VRJJ2JCR#K/H%-`:->QZ;L&)]M]9%
+M#WL->)L03/'V!HJWVNP7TZIS62#TW1E.0Z.E>[N]8FV/BE]*Y`TT!-$$($T`
+M$R"9`!,!&HT])HF1Z4VD]1ZFGJ-BFGD@&IX0*2D11JI^*>IZD-`,C`@81H`&
+MF@8@TT,31IH#3"321$!$`28`1,$Q-&IIII/03-2>(F]4]3-4]HT34V)#TGJ,
+M$GJE(2:FA*>B:FC0`:!H``&@````````(4A$(0F@3(3$U/(IZ8IIE-F41GJ>
+MD9-3!J9!HR::9``T"HH!*4$T4V4U,0U#0T&1H;*``#1H&@-````?]CY_\/_`
+M_<S_Y;.@`V*S]R'R_FV?P/X,M$5$27$T211S$ZD`)B;_K*)7<DTFD_U-$?\!
+MO`2E@+;94LF3`V!.W[D__)_\%]GLH?T''_K_[8:@I.O)ZTF:E1.5!__88+/_
+M"?]__7I^-1_TO0)_,J)^S]>6_3^KUN?8X95]@;!I*]7ZWBWC]CW8Q`&6>Y*S
+M,KJ!$0UYO7^R8E$MMGRQ7%K%':65W&PB)4W$XP2K[3@*\NX%XVV?W;X`YZ2<
+M_^?K?[%BA]"5.TH)"'1G/CUUK?WL#[;WLV#_9(I2!2?80N2!2I2BA*``E``_
+MCZU!('4O_$\?VK&WFP\^5H]>&UZ.9ST0*3_EZ%%=@"4!`-,@'I*<#7>WARO!
+M@B3V./_B>T97%#?*H,E)@-[KVP*@]2Q$9!"A5%@5G_U60D`HDX54($E.!!V&
+MMQ8%!MLD]XZ=`Z(1OEMYUOS.^Y4<2N%SBV(=KAAZ_7_7^?]P]\]4`/Q7_C_Q
+MB/&!^3[L?/[$]VY'P4'%J#\63?92?%1?:U4@D_\E^+[J%>2S1_W:&)@22ZS'
+MROT?:_]V5``/7W#MW-_:P8CZAVH[."7K_FV)5,",,U!0K_T]U/_6?T.S?0M<
+M6DHGEZBU"1'BY<^$*&/^65Q^G$G?S+#[,[(EZU(H$>&M=W,?B1"F.GUY[X'(
+MD!4'?UV'>X^U!*['CIO^;8#B4UN4^[R:1!'=(_$_>8!'QGA+]7@SEQ1-'VRO
+MT_3_U^RZ3!3_W*$^@.[(WU[M]`#^GM@-@C"$<5]OHGX8`P?=WJ`P*#<H$3_W
+MTT<^CG[KL849(_6JG<1[7_I*H@LC?"X/I,D.JBE5O2H67;_H[LDD!+TL_]U_
+M+:CIV4(./;U]?'3\7&/>4GW7V>_KGJ^YZ>:!\^*'*"@>@_D^W_+2?2GA1_]6
+M"_;GXEQ_`@"`P/K_FOU'RCUL%^I/I';V#;[^X>`(_\#G\G4?SNOHY]_C@_'^
+M&>/7XS2?YQI;&C8TM8C:%9!8?T?8?G>[%"DX7^6LT476?<H_DEVE5@5"J1#*
+MC%0JE_-,GJWR`0?E_+VW[N.WYN_M=W=W=]>O>$/_M"'L\^H?0Q$1$1&>E/I_
+M2?;L^D_67/;Z?S7[?X;_Z?D1"%*C,**XAF8!!E%HUI+98(-MD1DME0`(50:J
+M-1J_^&U=FML_T".JZS5*BT6H_TW6IRS48YED?Y"+)_<16_Y'\_V]HG_<D+$"
+M(+UUT?9[G%'U*XH68HF$D4F+(8*1^K_75EDP%@!N4"AQD3Q(:E*%#:0AD.*2
+MC$ADTAA*FQ#$,0U`%`TJ8L)DF#O`74FG,$+`P5R2D,"%*589!A"0(E,LAB+$
+M:1B8C.L)&D:P:H81*1@93(3`)5(A7):<"$<G`)$R!-RFQ@&'8A@#",J0@PCD
+MX*A"(;A*$"D=Q#4E0U2#5"U;)FA*E&*%*Z!)`(123(7<F:`3!&65)&4R`,A&
+M(#<Z@`*0I!=P+L@0-2%([@'(5I!ID5!4BZJ0Q1*+(E5(S8F%0U1A*C-B8F,2
+M&2,XB2J'4NX#)-JRH;)=2IH`T8JP2#AB8:A<"`"+)0I<81\<F""*L$-RCPD5
+MR4.2)$#D"XC*&D44.U-*)H%)"$#<-82@1"!3F(@B[5DZ^6!J/7U\Y4&H*,"1
+M@HHQ%24;!K);,C!L82L8P0<N[KD8HHP283"65T+J*#:,AL8M@Q)#NN8*!-<Z
+M5N=FQ19EDT)E+0&QDTB&C9,[KIB-A*Q55#06MJP!FLTL&2.!(JY+VEZJZUY2
+MDDI3+C9<C3+1P,#LH(,<S(685?^T$D1R%!E(2A"AI2(@ZDQ=P8$LWN[*2DRD
+M2FJ^-MMS63:4JM%6J[B)C8*:#$BF9HNMJDJI];96ZE-M;5*6)DS4FM9*V"M6
+M+;:33):\74EHVQ*:DM%458JH16,"&$P*D<;<2HUXW,;%48U&*C4A5%8C&Q93
+M1:-:,%C%%HL5&O6E:N?,2&S#4NTD3Y\,%=PO"%RR!(E*7)R:24".X.0=`SR$
+MH7N'RFO$5&L:T%U4VCZ6O:P&Y10H2E2E'8QD#$A2`[A5R1"E6@$-"R!A,2V&
+M#J0-0)10_J@R':LHN2.!(LDN0%(TJ8C(9`.X'(4*%*4I06@1R!,D-"0(>%0!
+M2%8$$)1@!5%A&&4($A35B""D@&28B(@+"&Y=G:!R/$OZ42Z_/!*6A>H>2_HI
+MKZK]7^B0.[[T2"@"?2$.KQT'T?#-,@&D)!3T<;^S[__?IF^O@@0#5#E51$?O
+M,4R5<(R0:`?87$ZT`9LP0B*:AE;+!C-I4EP98L8A7^@WX__,81?(4#],%#,@
+MBA"R"!0T,#`4,@0#2M(Y\OO\>^E_7GNB>>SD_?^PC'`Q?ULN'Y/\6="H'7]"
+M?X_PVH@?>PJI_G_J(^=>Y\9;JO]]!<RJ>%JUJJV6V5*#!K-X3]YY$/HS].']
+M/($_%Y"PG_RP`((`2!Z!@?>-AXC[Q\!W`OADZE-\36M^_U^R7FNX[/XSLB:8
+M;-H12,4$7VI5!%1!(/:AO/Y_C\>Y^\?S'^C5[)G^N&3!F94T'LG]6_\IN_1"
+M'\CW'38?\%[_;WC[OLH_2$^UI_<6D^GZW_#T3TUC-E_TI.%DKCC.9H<,XG\J
+M1=C:S&%F9?,K%'G*_LSH_I?.8!6G=]A!RWE/1;W'-R+R-;"N5$O'ZQ]0]GFW
+MGZPL.('R^D`3/T4)@)&%#O%+#8^"8FF!"V+#00)!0BB+,BT`"`.:WL7/L5*Z
+MO`X/]OG_M"/X[VB)7OWD&QR.G//X_/;/IY])*)T.@4F>G'<@1D!YZS'=W=R&
+M)NYEEG;6>ST/YY=F=[P]UE'^;^NC=6_@Q@JHO'<>0R2<\^<G>'$G7MYT:)K9
+MAF\I@MSG"W^W&U?MI^AP/%67C7NX-:K5PTX,R3E+IA=)<87$XV9DFVV^8G*R
+M1%'SM=KVC^&SN3YSZ[[#M'U'!*-8CSJ`4*]7O!X;,@`1J`0SP]!]MW_AKW^_
+M/9AZ_OOOL'U&B'N#G>9E8!'6\!KWHQ@]Y`7_Z:&5Z#)\#TN@/OO@M2C:CQVH
+MEY=>Y/51!->KEJ\EA"4`OWO"I8L4(?&J"\J&/UO+KVVJ?@.&<*[/>(FVP`-*
+MRE^84`CP-_#I5WQS)QTV:/B?,$9]42L39O:#=#$XEK<]8@VE`8JGERT)&=+`
+MC).IR+JYP!7K57_5^'^?JNPL,(?)GR3`("0==&/J\_Y8^7!`@BUY!+R]R]X>
+M:#?>8\(MM7?A%"]TA#W9LKB-[`T#=SG6=Q6N[`]F]FKU[RZG2/A,EZ=I8D-[
+MUH07$^3C[-9%TP-%\/`X]J>-A!/*KV6\W,"/5LOD&U5^EYN=7L"Q`B;,.^%C
+M1V5HU361(=`\@O8_N/WG.'K,_#W\*OO`%(/$^F`>CVX?RR"LL?//'P01];_I
+M->]8.S-?ZZ8]YC:X?5BLZF^1GQK`;7KUK,#MDDM%(\"0+EW[P;\#MC<@$6:,
+MN`>&CP_LO>VWC:$],Z"`2HVC&``/#[@$"M!T"VX6@"`$3Y/W+G,GXFG=[;_3
+MVL6')BSC7>:@=W%*.RUZ8");HB"*11E@GI&@PT`E+B4I8RY"()1X^`H^\%^P
+M"\O6N-"Q2G`7Y]H,&VACH8C`&90(COUC2(@8@D!#%YAQI)(4@A\25[P!SO>%
+M;[3!YH8"/O`A^]<P$4KH(B#`$N:B_W\'PF">8WY4U]P'IOV,<?`.M6W:VD7%
+MO5@RA`PR9CKOFMK`VHI`)!MU==@@H,)'GO>XP,!@I#@9IB,L@>EB2$B"U>J?
+M4*VI]^D]Y)#DDL`078?;Z#!+CJ@)?U"M)E"QGMT<0%HZ7O"]ZQ[!RT6VO:Z$
+M,8\<>GJ,/,\[RO,3W?2?6):*OP5`_^%"@P5;>>]H$8WUD>%LN>]X1`@I;?>\
+M";H?:(NV2ZQ^7G?I,]G@38%>(VZSNB^Z<9^Q,3Y[YN8ZDSF)=UI<;?4>B>4!
+M'7U),84#SV0"KS5&BD`S(")HH@!(0#Q[N'"1`,5S&`+R0-!\4]13@H2C._D!
+MIKTU9Q&$&*SKX\JST$3?9MS&^@`B5*'>41/7Q0<.H19<7`#0MC).9R'IH#LV
+M`.D)88`04R@)",N4&O#N4;6.'SNEA(XX08V&T0I.Y*`4%1P,(\Q!X3!M@4M#
+M\-O,5,`9O4M\`#8FC/*GX"7?@F"!WMWP9@@'NWV'/;Y("_=]>`^`$"X,:5[5
+M-`\1(-F#\_]=>K^OO`>IZ$Q(B&A%49")ON"!L$%TXE\5(`1`YIZ`J51`T64H
+M4$ED0?"5AYFT!-I24PR@QC*1(B0$&]/@S6,((`PT20)@58<((RM8#<2.NPY/
+M=,[4"+?7`U+AU;8<$0N%(J$#B*EA^%+S`K`#6`!!G')X=T1,80:"L"4&$=TR
+MK9A-L#"9,`O#I%>'J=AG/6?>^\_>OP-9VX+^O[:8Q88>C4"Y6,`9`8A;#D*&
+MM-68B\"0X;$3*:T]0%TV%O>@]PH^T8[W+`0F=@!_TL**)BWP($#%%G':LZSG
+M#-9:8`D"YM&J<Q`2,60&"&VP("&T\PRLZA9D%0@%>FY&8AT2N_?+WVU?MM^]
+M_%F#O"A[?$C+"8P.W=8!BG^V#*!JX0B](_F^]MC"!M?'@(V)-L12WX"Z[#/L
+M=W]Y/V40M][P`D]Z+W@![V?/A],K3:S.EZK`0"L;"P$(09`3%,*38(`/BJ0@
+M[\>U:U=J>3HZ\(!R5%I+.C6PWC&I7ASU^A,H"&_"Z@5?8B?/[SF$>\-O_'P1
+MF;[`_$E_#U<^P>'P#GK'OXN^QH(`+X#?:_#RNQI[S?AIW-H3:]E>`^\T`/"8
+M!P"[-(P9R.U._CZ_CGA\^Z#Z]\4W"^O/LV^X72!!+R`JC:<671$&%242[,@!
+M-_#;X]WKCU+\7=/A_/T-65'J-GR];FWC/G6SP2.&][O>\LM:W+Q*^U\F^L)5
+M*^2[*,J'=548X=F6^,,/ZUT.1[<=)7W<+L-]/^GF73;XV%=>8@1&>*F#K"P)
+M6V_X7K'RK%:2PY\&VC&ZUK2YQ,+S#E,\WCI&GAF(;<K)&MU$YVZ+?CWYT-:<
+MJY[]]^7W_XGNX6QSI0><F2NW1^4.W&-E_1G,>*TPM5X63\-.W"[L.*B[S@BH
+M7)>I.7%X_Q:&&FP[5`N<E*!4C)'8R,;M$AZ#@BBIV,\NK7A^,6%Z:@8S-,_>
+MKYS#RQPKB75C1:=2[8+,&C?$"W^VV?DB\Y92/'EZUUQMB><C2G;?5)G\B9U&
+MVS.VPQO2CY[004:UW;V/OI=F&MOU:7O52AK..N%Y9<[\,:ELLM'[#AQ0;3O<
+M"#_345$5_(A3TVWU0,7P7PV&<,NO)V(P,5C.!.TJQYE3J#;X:&44RX?O#KO;
+M;/;9(AMK#%Y%/C.JAH.PE1BIB#A1U:_\EH9&\1,5M%XUJHBOX5]E/MJYG:>,
+M-R\K;2)2V<=G^UK_B:AV?2?#\AKRKF7GTX+LSM@T:$+)<+Q^*U:Y<TL-#4WK
+M2GDBZX?&)>7<G1)%,6V&HQU2VO^*V`7K;#C2Z;;&(5UVW)/\*J7LQLC$CO91
+M/]740W9>_\+%S*??K%TD!.0KD;MU_6?Z[S=&$CZ44X$`TD);<$N,,5%6L14\
+MIGC`P?';%V0LYT[;E5N&>=+^I$<=&?5`6O5VW_I7UK%NIA$)'2&10:IJ,*/9
+M55E42Y^(?^6\A)Y1VZ?\^D"/^%NWC4[3#T(#C4.(RT:J9=85:TKB"01C1><9
+MSAGRQOP+7%NV5"Q75/';3Y;H[#"Z7P9ZV![^7Y5S/!R[YOFZRLF,*V\YW-2J
+MG3;2QN<4"':VXA;P"QEPP9:$9B(<GLJF7X7YZF3DA;[WN-X&6-=SRPU+OAX`
+M95B%**32MDS*[])A_^C6\]TNY5UY[^[I/0\GTD;!]EY<$J1_]R/$C=>(S$[=
+MJD0+7IEW/<L8+[K@QX7>VM9UB\%S5,JQF3$L<K%1EY&%4SFY5]86C"+3%K?H
+M^9ZUEG@7B9GO/1T@:\>B_YGD\993L*?W7VWF?[2L3VJCU9_:!NF5XCGMF,>!
+MI@NRVV;C,+.N*J79)]&,"X4UA>Y1$1&,*BB>K==0M/HJ4Z_U;@;SO1(5_0[C
+M-:WM7ONQ.!%4%8>'YVL87$9L!;B3(I66SC8SS*Y,M!4VJX;NFO`M(C6/\7=M
+MH9[408;O:WB3TA]EN@TC+<,[+PXPNQ,:Z*KQEW?3-BO<CRH]'S5#-"2KB$B?
+MG/_9XP["L<_`('=5+D`NH1.2`'=?J*?<1?DOP_TK^,DIHJ<?G_-^;3?G>'_1
+MQ1G`_01#SZD]<>+06]9_!A^M0K6?>RT8;AD4AOO\Q[?/]E'?`&"0Y/U>KM[0
+M/>].:8]+8.65OJ'?C1_XL^]X\6.REB(YCF&7])EL.JX5:E37_+IKC9.&8]GH
+M(ZW<!05!QHN]9#!<MYYPP5VU-O/;\SQP;]S1[M.EJNGA%ERBE;JF9_:S!<+1
+M?79F+'VN#<E=NM:<O5U@OX;UK5X,MQQ$_7]9S!?\T(X$6XY_@$7ZJ-&-%OP6
+MJ)ES0:P:4J,2KC&T5U2NF:U1QJ+K\Y1=?^C1$:RI#EIFS9%.V+OTN/B$8#_Q
+MGC")8.$.E3U^@D0<6"4,=X[=BXX22BRR*KS)HF4S"$B'^!IT13*<E%+%V3+A
+M\LH<S8+U\I])AE6UVF\,7V*C&`V?T>3X6N=H?C;(+%PK!3IVYV5@0#`*[E;4
+M[,(?G\-1Q--\=[^K6!WG)&3CIRXO"E=,S%>G<L+#'-,O590VJ"ZV;;E1>,T]
+MS##:-O;[:K&!T*XV7;)II7]Q7H>A`N5L.W9[Z.K+T(48!"IPJ*Q=D"P.Y<DK
+MJ.2GW2/O=;L3HS$^49%'\<RFEY%)0ZDU+R3(*]I,B@4[-2>&3??1BQ>4HB\)
+M*"I#:-*%2*I?-\Y132+4K6>CPF9=);QFJW/-YU*`F<9*?Z+G%DKTXHOEA59R
+MRB$0S^>4H4OO^2O9^8<ES*]IH%GR']!9JTZOZ*3!Q>^EI&@^[_?3H63RU)'0
+M0B3X,R48PX=2Q(;]$/4-NJD!Y5NNX^H!$=\KC=[!,7#-*D8ECL7Z&3!@P60H
+M222[##.#S,&Z\VXE:"PH%_P^;,3F=.&#8+L5=E5MV#.FQ9BVS2CN).$L*"!!
+MT_Z,%J7+%(1-ML$%JJJO[NSXFX-/\E4(]49A"\R4V*/^3I[\%S[W?SY[,THN
+M,U`R`WJ+1K:@_U*[_B89I%[<E*#$5`20R?+4$&@(DX&1NPDI/U0K"SXVS<MI
+MIJS!?])5E=5"MAFV)6FGC*F<C;U:ONU:\6>DRLK5++#0AV7&B%7H[PBCVTH@
+MCCG=J?9M/6W1?*77&Y?<QA<<U3Y_0IUC'8USJ!3KQ'6VWA[WQMEI0F(QBM84
+MW+YQC613X.VZMG3!A>RY.:A:."F#"GG]_=Q<4&OI?.WYJPVZM9>LUEGSRQM>
+MDWJ<-)9@O7F9B!C"CI&[:V!7GB*Z;;8&]CEM]W.3NV!/YU4Q$=&Q#JT`ACU+
+MD-FL8>U7;.;B,]68=EJ#,+!U-P7TU(8S[;;$!64M+8W7NXS@O5:7G2MC$O0T
+M[O$&V#,_FRYS+=-WF94:V[UW?WRV_&MTH"<;^&T?#*R<W^,Y\>L_4".RF^[#
+M].:<@;DE-8JW*JNY\@V+ZV]D"2&RN-IX\?=YCX5BBGMCF=O#?'KL_OZ!=>*U
+MZG)S_[8N'%E!(GN+2U6)=4LRIJB?7;^)S_4$/W'P/JH!P7V=/X^OXYZ87J=3
+MV!^OYIPP^\8L`\:`/F)_2_A"P(^S;[`/A\O-'+_^P/[``.\"!(]'XT3L//K_
+MK$>O=$'K_AY`/[_.=]_O_0)]X1*E!'X,%(XR?@?X_L_H4WXX/8"?M`.A!_5-
+M*E+2@0%$+5LBT6G]4D?N?SB2BA_A)/C(0)9^XL(?ZI^/U'])[_[H!^%/:`>P
+MGJ0#VJP:Q5`-KS:A][K8__O!3!"%&E1&%"`6!!"`@)0E"9E!R_A+^)Q;!!?Y
+M2%$$_F^S]VE!^?V<SWP0C!A'FG7U=@2.RL65RS]5"OVCXOP0R0,H`)],0`^K
+MP?<>T0_6?44AGT^O'<B!\H"H>Y`H3NI,_?@"&CP0*H[NCNN?O';P\5.N<\OB
+M&9F7SST]JQ":*>3:9C?66<2<TS%(AV2F^Q$1&'AS1SEEXSK"+DKJ_3H[CUC]
+MJ)OMJR-CL3L[,20RL.)*OP(>)"W>"#(Y`1"*R"ZG`(5^<S`U8G0AQ(8[C9))
+M)?P!5DDDDE>V92KV=N1,D*V*Z_OMMVP>][WFV=Y%VA"84/BM)&@$/#A))=KG
+M]1/!JB.-!TQ5%V"PH>'A[SX/MP/C@0WONAYWIN7GG>/`22;';1"(L&9]]4WO
+MN^N?9Y#ZDD":A!^UK<(@LB(/1)B1$&(D06&%(2%&@5\P`/<`]P#J!^PS+/Q;
+MLV-CU#Y+]H'O8!"!X4>&A#!^^'3%*<N:AL$J>0`(U4`2S#6&$YGWT,L7J<>\
+M:R@1/+8(,`@@@D<<;;C>=;;J\5"BZ9:@*'CAE/NDR=NSN&<O#:+>WJRY6[W$
+M1*RQ#A>CQZ>`)WX%%$1$1-],Z/??;-<O$-2LK,*]G9\A-"A.NNJZK9#)!P\!
+MH8((((((;1[]%5/Z;:X=\V-J[Z^Q54)5YUVQKKN_?M^D&&52JE62;1&'!'-O
+M"J.@1[E0^5;8,P3#QA`G8#,':0UFKWUA-$U6>][K/KC?>?I!9)U$;=$9A(S(
+M/,,`>9@^OXX=&5,%WL3ZU7`6/M3@S*9^Q['S-=2/M0D?2)UP3,),HF60`!X;
+M"GM:>-#:VQMI8>K='V?=HR\[&*J]O!DK2G!]M/2:##V_O`>[;\![W#P\Q@(Q
+ME$*1EE()<ZQYFWN,<N=>SG524)ZKO*73<L;B:^VOO#PI#P\`0/"A8\@.:060
+M-&E%'7GASKS=557-^-=T2226)V'Z*EM-`C?AV5LVJD2.-H?8OLH00DDKY56"
+M'E`0Q7J)(Q*%&*X5HB9SF$E@TVB1,92"D992"?D_T#^W!R^_5+FE`G\7^%.3
+M?>`#?0>\`"`G1L4!T:A$D'V$38#M15WWJZ3`SV:=/HOD(9YFQMFA]'Q^))))
+M)/B=XYWMXRSW)[[#VO;Q^\D_22-ORHBPGX@G`'M15V;)!E`/84XH^P`](O0`
+M+WWY\/MGCOG/.555555EU=>>KKF-?:W]LC7/Y5]6XC'>_KAM82R!^)'LH^@!
+MZ1?0`+T=2L()L`>E'I$P#@<D"*[]WV&\^Q;;;;;;:`,7KQ]?7Y\]?2^>'=P`
+M`')$D15]K=.ETWP'G4EC1Q[+86?;AJ75)#-^VFA=+'-KJ<,UC[P`(A][Q'@/
+M#`"=D3\1,`^#Z0(X<J2R2&@<DG",20G(<1)(_.]QCWX[[[NL:_+C$+48D*XM
+M5Q-SEP6P@`VX3I\MJX"Z.207L#P_BE.3^9_5_UG1C^V?GF;L24:$,R\7/"5V
+M6\=AI#'R]<(SX>]*`PCWC[WO`<``,]Y]`F*@^4.D%4Z>B`D5VJ#T#D&092$G
+M"#@@<_+G'.W[W.3WV[&K#[,RAM+"]"J7?*L&=?VVJO,K-45Y=3FJ8IG?0:LK
+M9:4`EW$.(,T!%TQJ],SW.R_UYR[HC+95EXKK<@J+$*%8_AX>/N46))J2$\.P
+M9!E(2<(/A`XTJ60?`V0D^>@/$;!-(1'B#A'HDB;[[>+[\UG[[N/LA%5F73&#
+MD%)>15\!X/#]`CZCY%M57P7WA[R=#YA#XKMS[6*N1;\98H$]][P&#14L@X#1
+M"3SL!XC8)I"(_"#A'T21.M/1Q9*AL(VAJ$D-R1X2>0G((:D$/223J1TB-@V&
+M090'K[RW%MI)'VSM;[*+E8MJ3:VE1RQ5'6IE8XO\GW7GWVH2MQ3X?3:%`H!L
+M2<BF_;^\/"?;\^`6W?U!4L[(>IEFLSX;F?8(\^``>AB_/EDJ'`C:&H20W)'P
+MD^0G((:D$/I))U(Z1&P;#(,H#J:X>D[UB2DPB=DB.PDVDEI)(Z(>23I(](3T
+M@6R!M$BU)(\!Z#R21L-C(9@1`DBU+C#WAGY0"0`*G\0G%'5[,X&I=XB5W^&#
+M2]IU#/B#M6P2.D_G@/YX`/;WVGS/JAKM6YFG:JJJQ3KG?CLYK-G'<WDX5)))
+M))))E!QK.>)DF.BQJO,ST(`(*$]R#2#:\C%BWV86V``E(F:`A$K`5$("*(]J
+M)2B>!%XHC0J/:@4"/U23I(\1/20-B2/`>@\DD;#8R&8D3TF=.3I.Z8BC$1[4
+MH`#M1>`%`"]TB/A7M4?!Z14E2U(C:+8)/`](]$"!1"`"`'`1P`@&*Q11FD-6
+M*?M%7.^(BKYO]J_1>@^98IJA\UM"7(^'>;ID_.55\LM*]OJ-5`[KC<1)NSE;
+M.I92A,*@B]\``=M(V*RL??9LS,U[]<K<^&JK:6=L/!U<D882N\SYGY/[P][[
+M26T/G:\G<ZFSQ#\DYYV?A.Z8BC$2>)#Z1)N`#M4?*O:H^`#PI"R*G`5?`!Z1
+MZ(C#<&S1-20<\FN<=;1G1@P[32O:@]B)TB!V*/A?"J=B>(LE1)L@\'I/1$PA
+MN2;1`/>@\!Y9B.9\W!=O=Q[3U_3KL_6J@P7\"$#M]*`WGMWL]S(W9H[P\`A'
+M-V]ZX!VBB,[A!P`\[AW[;+Y%5STX_M^2#XSZ`'NZG/L?PKK/:#$>64X[!##<
+M:E@!GY.[\^;1G3"5-1D/D)\B.(+4'4B?2>DD=)XBBPDV0>#TGHB80W)-HT2:
+M@G/1KDX[.\D6[;K$.Q)Z%L,QV-CD2;).EJ2>@=CT2T.R>2*4&T'D>1Z),(V3
+M:,(TDTD-ZWC\\>WG>+)JF2.Q0TWL"W'R8^VP\RUW=M:,L74)W+-BM7MCN51(
+MP$6E:EZ:[W@/Z^_0G[GE8RH,2H;.Z#(0)T&8&2<*+.Y8LNDAV8YC=P;`?XWM
+MG6N&S"?YX?P>'GE(D$@XDN1_67GG7GAM.;?8[?'2E<.1B'8KX$-)VMCD2;).
+MD/`['DD[)Y(I0;0>1Y'HDPC9-HPC2320YY+MV\1@[6NV)G&&-G.8FI.QX]@,
+M6C4<Z8)N=/!V+490X'9Y+8>'I%A86C<'I/1Z2V&(VE>"`$'A/#P+S]M_5WWQ
+M1O!6_7'63L%YGEYX)2']?``?:/UY\FUQ>>\!PPDDU,A1;C+!,:B<*D2:N!TM
+MFC]I.YOZES=*J#^P<5HN#L^-@`54MDTBL90T4PR*E1R&).)QJ-*W"Y3*+*,3
+M,#::@4C$U?#ZB\AU6L^%]]S:JZ-9JO)55/JRK'S0YUR7U+I@;E#P'4:)))))
+M/B=BLDDFJJJO3&^/GQT=JW@;P>;@F!ZC?F29QAC9SF)J3Z/P]@,(U'.F";G3
+MT'4M&4.!T]);)X>D5%0V'I/1Z#$;3<8&D:B.7/HF6^VT]LF&8][#C#F$:SB8
+MW.]Q-1GQ3K,GHY#PX6G$.#@]:[TM.CL6SD>3SI@=CHZ6G2TS#@[/2T]/2V88
+M&+9-EIZ/'BV,39OR\(/3P]73)RZ3'-9E5??Y]^[!NKOO>&O[,/[>;@AJJF<$
+M=VQHM53W;RY;2,2))(`#'W[]=Y\````'Y"X]\NMT<\!Q=7VP#$\H:YR'&>^'
+M='VGW=>QDD%_?>`OA]O1?'[JHXM[,._;J(>\;65\1=[FW<-51XDDBP#;QKD1
+MG!CNO.&WGEL+1*98B!#O*N#+P@EC^A^\/?I2JKR]WKT.W'=1O6$ES6H3#GO$
+M.FPE,C\^PXPYA&LXF-SO<349\4ZS)Z.0\6G!Q#@X/'71T=1P\GG3`['2TZ.H
+MR.#L\/'DPP,(V/1Y/#$V;MQ&DU$YC#+T-)OL(`T4/#9"%=;,\5X-@"AD?G@&
+M`.B_&9]+,.I4].'K9PX.+7#S#QZ/'IY:VM>*>M>MGH\>,3EKFS)MIKFIHY;/
+M'C*WJUUV/>MG,LF8Y-)&^L$A"A17IZ>\^->HDL_4)]PKXR,!3CH'A%9^OG$:
+M3@NK7O[K[<#QLDZJ%#N:[P'M]1D_;7-OSC9ZP3/R"3(?OFF2H1V0KX#WJ0W/
+MLK)+ZK>?75+)?CK-V1WO>]\=^JS]<Z^/WUU$W+*WMO$.6OG0W^#W[P\.F"Q]
+MX"#W[XD@#A0\/G"5=;,\5X-@#;NLS+LZ9W<RS/E,.I4].'CD<MDX</,/'CT>
+MM>6MGBGCR>/'C$<<V9C>M<:FCAZ/+63IUT\]',LF3D>M\<,-ML34U)S#%LS/
+M#3U81[10]>RB?+V"]A&^IA^\I!Y"M%(P>@SR@%JR)XB":%Y,F[PF>GK]888L
+MG-)T:-&DC2=TH$V+%B$W1*%JRV3HT4-)W"=).Z3I.Z3HT6-)U$[N83C)P8,&
+M$S2=&C?/2=TG1HH:3NF:3N!^S#0K1<LD$6,&DO2=T;OMR009ZM!L6"+N43`-
+M+N;>LM&$DX+)5C5HJ?KVNN_%WPM2=8MZ"$,"Z)H$'X>`I&OC1P.2%-1&$&)F
+M*-#E3HTPRK;B,3)+IE$-*00E(7I;$)2%^RM\-%6C=_.=+NJTH'%9X/5&N`'J
+MC[.+5*!)$CBR"T$I4LT00=3^J^9XSE]]Z]JYQ)#1.>'O8MS?KV',*U$A7UV;
+MJJ>ND[[J]G7?;S8FC*S&EGWT1WA;PCO>]FG[`SMRJ%'!?SNQCR9*TWO7\1\=
+M^)LMBV-^K3QG,Y,TV;:!A7M1PNI9DY0W>?``4Q?M`ST`$'OA@]PH>OZ5X+V"
+M]A&^IA^\I!Y"M%(P>@SRU%W693/E=9-NLS,V;S;EUUYYYYX\>56VVV6VYBV[
+MN'GGFWGG3RO//////.//,'N../.NNNM/3UOO6Y>>>>>;>>>:>>ZRZZW-^YSB
+MJXT:&-`P9@EB0008*P"P18@@8&81=5NUG,TF(V[8\V<QYK9B.R:]HO/3DT/3
+MP0J`D!6-%*VZ`KVDQV!@;U(4`:-4PF,NH*W#3RC83>WF;>G=.YF[NC-S=R9F
+M,C1=%P96UMX=U;F;N[NG3>[JW=W:W3NZ]S-FYMWFO9FZ;&',F29NFG;ELWCR
+MQHITC3V]%XGAIB;@F(<%?>[6_M)W.;.9R#J:DZ``[XZ.#\$0*VK'@'G>';.J
+M:@ZM\AO@`:HWOS<]*JG*KCQ)))*L4X555557MVEXZ;ZTS5.G8":..W;RT[Q(
+MOOAJ:\-K,S6YOVB9F3-[-[>.U*2(%K;Y/O\$=0IPD_O#WZ]C:2[M2<'Z9]^O
+M:!J56]59)N=QKCQ1J]3".M2C69*0JX,.?#[P>+?AGOE7508BG9=?7IRB*%WM
+ML^41*S631G.9>6+0JX/C=YJ,M8T(4.L)*D.(--$"=IC6@@%;"+N@&9'"*@@4
+M4&A`$K\)1(7AGO38`;WU^@]/!"A`3Y6-%*VZ`H#1'?L\]!@H"O+$+&,8(+&!
+M6+H()YMIMYUIIIUUIIIQOKUUEUYYYMYIIYEUUYIQUQAUYIIUUUC3S#3E@@@8
+ML8+$@P$78T9D@@((@@8L80QHLT]*K&`PA0"]=P6P+V!!:+HT_:/4;RK`3&C!
+M!Z>CP80+\WNXQ5;5>(J@*]<8;QDBO("M4J_4PQ1%AK=F:WF9LO'A)NK:R7>S
+M5,EYL4R]P5F+)=[H+R[S958M@DK16[+O6]JU,=Y9UTT;R]V969JE7JQ;+O,8
+MO8TJRC4=)YMN#*VK.958E5MX+.W^H4D,O;VJR\=]UZZYVF?AX#KOXU?S<\3*
+MJGE7OQJT4=>>\!F&#K?-?#:XN5R%%:[P'Z?3N*^.H4[[P][Y[]7:W+\)=M+7
+MQ(4JLE/S:QB=X`;]!VG?GRGU]PM?%C*^!*K7R=8!X?;EW,>[F7\[0UCBW6C<
+MXKCWJN<4*U(`#,H=[,1IG1F:#HE275IT_Y!R[WA7\O6=T("!"@%Z@QB`JX$%
+MH^]%[1Z"LJP$QHS:'J]4P:",`;S<8JMJO'T\)8;#>!^SR`O5*OV,,4#7M#$%
+M06,0EL6(&&(+&C1!8L8,!##%B#`G77''76CCFFN^SG#CSS;;SS++2NO....N
+MG7&V-,,7;.6N-M^88>9:$8HB#-P;:%Y11).VMND%NU>L5YC-A#\Z@TOV8-"C
+M##$L4QHHFQ=8<\H?:-OU>E$25GCJ)4(:F:,H6+J42*RQ9P8+@86T();&!`;8
+M0@H7[2]/H+L6(&*F8JO*JLJ9F[E7F8JRI63+S,RKQ.:ZRZR\3IWE[F9*JJK+
+MLYMWBR[O<P7EW>WF9FYFYN"\N[O#=[>5;V7LEVW,<=51N\LI:]N].;C-Y>WM
+MB[VZJ9=4<RB!O*OH@;7E@15CWA\JA5&\\_K^VVY\_AM:0DMUSQ<\/F3"^!+"
+M7RFCWKZ$DDJ_G"RB,0_QX>]WAFV/OLWIO[1[V)[^^=+HVW#GO>W[1F'=$J='
+MS@N[K@`,8D"%?2M?BPX-WW@GQT/2I&6N;9YMS?$90)E[7`U*H&=M-"A<Y@%&
+M+]DFB6:VAH8>:,"MAABA5,:*(L70%C("=&V37J`?JWV@C`$,P;L%WMW8(N[%
+M^S!;#"VA!%[!A*VPPQ0L'6"87Z'3CC>>LO,.MMLLLL,,&&&\KAZN/,KUYQEE
+MAAAEEUEYEEYE6&#`P4-##&!C0PPPQE>888L8D$*#&-V-&90P6",&!A`A`X,&
+M#1CI[=51!)!IMF522TYM5A8-:-H809>LW>[>25LS2[P5M5EWLR]"W,.*P?:Z
+ML@F2MS!88RA>I!#-W<AJ\W,VS2NQ>VTLVZI#-)0NU%$V:1O:H*T:"H4*N,/'
+MN-TVR44KNJ1B2FZUJ;<>8VVRVFVWC>O0D4=IZ\UMMTWK>MZV@MW5KF9C=MTB
+M\O*PS'<)>.D@K*WUN.M;V<15RET.B8`+]7U<]``Q3[[@.[@`&)&V;O$:Q1?N
+M'=P54AHH#R[2'ZPG$^NLK$RT.%R8;)FW78(!I`,L+J[58R[J)&2%?(T4,Y"(
+M93(><T'Q374S)@9NVLXQ<K,2W$3X>]8N]*'WM,J?$7W7>WA3%>-1NVYBZ")D
+M`"YP!G.)"`L7E1.KS-"-9B92"REF&DI-HG:JFF[+Q>_`#\`+JL[A^,J8/5ZL
+M'Z@Q`01"C!\#E:1),B$#&#.(VPQ0T,;C@8J\O!0D$P06*0ET#`4,.CS@H1P:
+M*%@@C1EBP@X%D$%DX*&($;HT^L"M#VZ#TV2,C"M!76@6#X@@B"QIM5TVMNVZ
+MUYU557'&9EEE556W%55><5A7CRKIY7GE5YZ@V-&BQ8H6"""+]OHQ@L'V;NG9
+M:N&W1,NW<*IRJ5Y+Q&S,O%AR;DEF.KUFV*W-.@F9F2U(WB%QS7K>;(W)>[>B
+MG#+F7E75&C$:MRS;.XK1>I04D->Q)FLNJS,;=U=S<S,.2V]FDS,.K7DDL[N3
+M96WMRKQXMJ!N.TWI=;JL9X^.7+!E`B"A6Z"#5O#)`0<P$&M"Q'09IS0=TYNV
+MUN0'!@-V;]5@Z[V&\E-4ZH37A/ZY)R#,?.^^\!V$[IR$+6D2H'J0XOI8TYDO
+M*'W,C;!V^7P\U*"+))(L8#X8OE>^#OT0T+VNY\)Y>Z)130!?<LWZ3C?S^='[
+M(GTIF]J2W3WC7;415#P'WAXCP"S'>IKS(&&Q,\!]`3"M^47PW8!U)\`'GUKX
+M7\MZG]R\#/AX?=M8MVN`DDKUV\R2\+J/XL4:VMW[X>^?WAFF/X[ORW*2OZZR
+M][>@/W@/O+?OIFH?8.TD:*OV`BW@0@J`5*%-C<&!"Q=W=YHH7!A*8P;@;P;0
+MP98N[&C1@@P8*&L,:)!2\)Z$2F(,&"Q0-NA+&.LR>T:'HL6&-P,5!!!+]3&#
+M2102#T75C=<O,E`C1!OM&"6O((^`LRZT.^Z=,*='D\FVIJ-QEEF*\_/S]HP6
+M`]K:NMO7KW11U[@+K24LO'@FO,S<$R\931J\4W,S$<O:RYBA"S*24E7L=N]J
+M[O1AS:S*S<RKR]IRI69+VK**P0ZXHGFPV+IFKD.X9=9*.W6[F;5.9B.[DN9#
+M3S=9;M$O=N]S:MR\>9CVIIR&TDLM`8'5`4-T8&T,`WV>S*%"PR6_6+)RA1(H
+M;,],*/#W0/"!68.8+JY]7V&9_76*W\/!"2+=K4^=BR3+DHY/UZ-_+>0C-ARI
+M@@AO2)VT/(>+"=KWRNUQP'=WA8:I[WX_;[?R9T+Y&3YI![!#H83Z"2NU80A(
+M3R)*\5DVD'H(38D&!"('NAW55583UF`Y9B!JL5^%E.ML-JAE*&0KKS"5*F4H
+M\@@"`((?9[CZ_CG]`>_WY\3TV'1#YY[.GR(#U/QW+W0$'D[>';NK"NRPJDL6
+M5G+L5+PK/"D=YIAU40_G^Q5OX"]G,H_+-@A&E'Q))))))))))))(!)-YH$6<
+M=`\,0K5;7T[,VE/L]5K>>K:@>BTJZ7W4'@6X,3OZ6#,6<@Z31H5U;<Z/=/Q&
+M;+&HYU3=%"1#=M_>&76W:RZ^$DE6W\&/G][V7T^^V-59O7F9\&\C!SO7]H^&
+MY\&#8:N#@&,"$"&#."%L9@P5HL9XC*&@DJ6+""%AB*:+P$60AGB+%:2*$&00
+M0,98UC1!!#XUL61BL&BR]%X*I$[H;#8(N""$5@S4-H4%HP8,"P,`BQ;VA0P1
+M$4]>AB^5IBZ4KK;K4XZQ?.E>.\:FV)ED4`K@#$$E>>Z7-F5DVZNW0JI@,E6Z
+MJYFF]V/8G3W,L$E[KS+V$6WKQ(I5,&,K=J)%49FZ#(]@.4ZM6RWBDR7BV10(
+MK+K;<K#E)M8]S5+M);+--AV75IS,>UJL5*AIYFYB@6WNO-O%J:&XH\B2FU>Q
+MDV\RIM7@5,&22"6-K*&:4BAF$Z*P6KM)&*P00J$$DRK#&Z)L&4O>(^1?74""
+MV74#'==EP8ZX]0H<JOX#W"'UWS/VFQJRQ\"/</:I#[/E*@DZE]:[X7U]O"L8
+M)+:QZ:9"RWL4%HWG9!FQ2>PE+63%/A==_QEDO-^VZ_*OR3>.J;75LFY:<.(+
+M9>E82444*)_#P\"L!6=X_39\ZS[YO[Q4TJMI==<))*;&?6]ES2[5W\]&=LN8
+M+J=5\^@ZN6$51N\E#?KPW@Y7&.(5.HHDU1AE`T5"&2E1%_3`OMS*&&F>\`Q'
+M"Z/Q>6JDY/Z,_.]O<%SJ"&2?#WPK8&;^Z'GG94H4PG,E,3/FW".;YX)EUR9J
+MYV_`"W*OYN+;G5TV?7Q[X7Y;5ZMNOA))2IY>11^9673&+MZ\>M=)\7*@RV=^
+MB5/JMF;<,X?#ZKEBMI_4GM\GT/=JW@M!=%?#N$%C@Q@5#ZA!05ACZPQ@SX6+
+M$"#!L1M5HT-^I"YHT)H(07>MC:<!(,T8+T-L,6#!!,$$$T6-&BPP18I#'?J!
+M&RPE=XA690W1HST&@BM&N.&W66O/.LN]>::<575],-L-/$(,P4[%"P@H&*SR
+M&T-&4$AH%BP\RW@(T(8$AF7>@6PP9EN\.[C#I"\JJ6/+>9MJX&HK#;"J;NU0
+MS$\L)[DITZO(ZUW))8M56WBV36X\DE6I-O-I226*J&JRV+M;M^UJJT:U<VLW
+M<)VD9N2S2P3;UYDV6:6-;"M-6H\F.U&)68'5Y"VV[T/!>R[:T9F;4>9-2NY;
+MQK+S1M24$SWL<^,%6V/NV]Q5E:))*`T"WN;`UFGD@:$DR=$F0]G`/[["^=XJ
+MYB4Z/VJ$!VCE7OWWAI`W-YY[Y9*E&K+^JF/E2SZS5V<X%+8BQS<M[>H4J7P!
+MS5?V+KK1))27QV52FZ=?SWU9KSGFS)J$RI#6T=JL^]3JL^[4S<S/=3$?>5EW
+M7R#X2*?<E\]QIC.I\4*'P]B>(?;V_?<'.J#=E,*^%3:96N7M<#%%-_L4`QMY
+MQD]E\<MV+>-^S`@FLNS)>%NZLR>R\-70S$,O"THZS)!EMW=R"\R3,R09F29:
+M%#Y_06>F2#?%3$,SXNGG2`(`.\</58%4CC0D.%&6:A3:H3!^6H74$&A`9=W!
+M>WHS<&#!8M#`LU#,%B!!Z_,0,4+%#*H7H0P8+&@6,#L,-BLIY=C1N59##&;0
+MP+!0%!AZ(&-$(T5!`O4*6,6$,&6+9$I'!@RKL(6QAYZ5IUCKKJL>P\MX\WCC
+M;*L7#HV2KMW>N[VKW,S:O+K,N27,V:I,N[UL;;MPFKQ3=>WEBKF-Z;RZE4*U
+MAV[NLJKS7NY5EX)E9)E2Y=[N6<IY;:N[JF]W;V6+EY=V=5..FZ=7EW!EU<JL
+MDJ\2QR&G;U7>U<F0FUE[Y#:"F#$MT9M9D+P)+*DJ\&33_"/O>/SK=W[%UU@D
+MDI.5N',L25\*5]N3H7UY3V:\F:&KD"&O;?/2:-=?STDTH]%NQ-EW]1.TG:4U
+MAZ%LN`?;,X;AAVL+J9+776"22NK1+M+)6OVM#+GHJM4/G1S3=X:TK";N3XJP
+M^JMK[O6UF/[[>S?H(-[K%+*L5WWJL@\N+.'D-2AB;A9+341B0D:3@C4D4DA:
+M93D<A29$<B31\Y1DI*DS$0R;2:]$6GY$VD1J0JCC<,8#:,AN-RHC$U))(XFR
+MRBH0R6TYAH)"@8?02.NL,"_6`O6PPPP8H[2D;1C@AQ252CB3,#*9A)B;DMO+
+M-=J9-Y(`&D0.*)))))))%].``%BN<+\."!1XW`#1<X`!@`P"?&#&"31U_0_G
+M40B3H&*,PD1,?05-SYC=S\VF9-IJ-)R)N&QI-F'+69@P>H>SPSR]A9:L6+J"
+ME<NPO2[5EL+S**PJ45,P"@!!ZO#`%["TH6<B)+0:5$0T5"K@0@I4;B9)C;CJ
+M4_8/#`/4/#!Z`4%9+1809R",0U1*=1H4$(98*%4J.`7X7Y@6!80LMIXD92%!
+MC,JO3PKR%AY4;3+]0"%%E1T480*\JJG5(*C31I-")...H&=5HPHLE()H6#W=
+MK%RN^'/=NA,#JC=6))%]F_9782D?CT=Z??MZ\]<^/L``'F<``,^=>9X)YYYX
+M>=P#S+@!CLX`!``!/TT^/7M?;DD<AP8SANW`E@V?78^&WQ&CA`PPPPPKUH?#
+MX0?(:%H8@L7@:%B(;N6+$&N*VK2L.,Y999PQMIYAE6666&U,(-N!#;%$$2M%
+M"@P0LH(/UBV%HT,*(($(A8&'ZY0@1$&(7FA$:)H0P04+%@;XD0,@VQ8K!@((
+MO<UMMLG(-W=8-1TV3,6762UN.2K>-NFWNX]R4Q>8&+5MMI)WJ2;;;%!4FV*=
+M9B%4Q>18*)MZ\:$>-M6<R1/87K;02UH4ACJ1MMO;>V]TTY4K4Z*JQH)9(F#:
+MH$[KU`G'!M7B3W<-QT:[:/O"N'=#E?"21'!<Y8H_LQ?#YG;/PTZ2?OGN54UN
+M4K,WY9\`*NU1M"\^OA6:Q^QM>7/\X#=42V5HIG$.Y.;KU(CH&`0$)L`C_D^%
+MZ+K`36,<&-L;V*W-%Q.<1/L=&J8MGH+&!>5P\D80L(PZX`')^ZZFZJ&,=5':
+M^$DBM&K-T=(1JW5EM0T-BH=L,@R13DQ4Y,NUY:*+8HO?K]H1`$")Z!JHSNF5
+M.V9V@NLG>;J&*BQ@7%M#LYEC)_1["R<AQC=O=H7]AZM$DB:YLGEBJ8>0V>YC
+M%?$<^;SAS$AHU#5I.[O02WS@^!@@"`^@\QU\+O*JKX,$$$`V*I6'XJQF95:K
+M;:L,JL5^>UUW[>Y55:JU557'55G+?'9YWMZ[%(R2?-]0OE\ODDC>>A))?@XX
+M88>YV5I+L[U5=2S?6U56=V.\!E`@B7*()!!88+8)!UUNO/':E\"(B(HB].BB
+M.3#CA>>B)P<\\J*(BB/)RBKQLX$4S2Q%Z&N+QPW-9E$@T`8,]@6!$T8,<PD\
+M'$\5U3MIT'F-P\(JOONH3/I>>^SJ^$XQ4,O-?8MR1R7>IQ&ZR`H9@[3MP?X#
+MK[V!678T>G>'O5^!`0)K]6CM=70_1+7'F83'\TYN-*U=V^P1-::3I=*[5>5T
+M[JY67TKTR7-O,";4'PK=1O<H5HE:[JXOJND7+(M_+:EBI5W8L``@`?>\,(@X
+M5-L8=F=-Z7%V;\7/K72Y\"YEH8>C"5'`[[=S:+64L.G!SI0<N';VE8S<22WU
+M3CVT(]4EU6;9[VGT'WO).^8.8N,'BC59?K7S6BXYW@K]\\>)K3S1T_)Q\G&7
+MT.3&-CVWFG'G77F/1ASDG).:3+339'IE&8==C3TVZC/&66&SU'IQTXG)XYTW
+MS6_>&>O6U3T>R'9N9AW?$"Z'K'F1:'F9*`]O@QYCV$YX3PT"AOAA!BP1*QKW
+M:D-HHB*]7U^'UP=?7&7-2J[NM;&!$6+JH3<&@>_TSP<-X>^8?*OUW`3^SM)M
+M4US-3+5"M9@[K6H56J7N5PV^S\-W^,3\P57W?:[:<^",&7D5U7[<'Z/N[7^B
+MS'9BL=`A\#B0VZH9JA&]K3CLHATZ<\SB7B6:1\$DS11C4ETB927T4Q9=!4V:
+MQAO2C]OPF991>+SC'L'K&'*^5C=(I1^1:^RLQO5-64[>D`7ZA0'P81OW`70'
+M`;X;=;W&\IN9'9LVSIP:KF$U.1-QQ.)V=C4>-O98<.>>J];\F3LT:>QICP&@
+M8&-&`:;=4@,%V!E^#A5`/S\=P#`*K<3?A0Q!4?3T]ZO7X6-)P">&^%#2[$N,
+M8=V:JAP8@8P7Q8`7O]@`XZMSZ_='LF`I:?%U'HB`_J\.FCOW]_9B>U>#^#$S
+MAQ1(P%9G"O+P^$GI32&6P:P*6KE#*O+K$AMN@:H%,E2X:9$5&"'1$3O`X%PP
+M4!!9(0()=2WAJ<PJ3E>@J(HXE0IBQL*R(V5R=8#9?%D*`@R@\-XV<^207U=\
+MEFZL"NQV_5576CJ>:KS#F0=EP=U:4/;X,,#[R&C`,`P?""P-T:-3+VSB99QH
+MRR:;*7G6WHTQAX_;Z>]OM\+`S`(!OO4RA7M&!5HK?,6;]HKV^6:R-&#10H:=
+M@GH-%>O#ZZH.PV%=`@8LO0'Y>IS17L]8&C/8,&>GM\*:VP:5WQC#PR^ZX9KB
+M7!5:*Z>W!*JK)I$";>[O^^!CG..'SR>""R[LDH!,F0H8<%_4EM+P$S2ZRSC\
+MJIT%8JG9#_;*!:)7UGH<U]V2+2(P:*5';?8D"O>`^\/>WP^0]=31K7+I#OU*
+M,A,52%NHPVR8A1":")*MY5136X)15GA+8LBZ4D?D74#A1A9Z-^A19))!HRD1
+MVFT?3$*-(53:DB=H(@V4"22$:8I)FB&6:(1[,Q!5EE(R&:*`?K%>@P54]7D,
+M+@R-,-*1EE@TJ-4TBPS0H)[56HD1;IJ(DDHHE$R,:4HD&GP\!94ALL@Y;.M@
+MN7%Y6=,$C3"2)HG`R1A0;BDD*A3>TI5)N%[POT]/<$+5998SAHOV#/6-%C`-
+M0T04!`O:!L]E8(<%L/`V!!@#"&`:O/S&Z)[?4!HWV#!GJKV@7<L"B$&+TL5@
+MP;6>U%[0;&^W:TWFG,>MB;D+T:A!,VQ:N&UJP9F"JU&[DL(_ZA[W*]^`O9J^
+MTGT"FKR,^07A0"$,E1"A3B@O!GA/>GAGE[`49%A")$5`BD2>/JM&!W89#:<2
+M(E&54)]5&BHU"D26TS<3,3)-V&,CJ@PW<^=;:D\U'9,R-0Y(U$\C8VD'J\O:
+M#=V&+M;,39HD4J!J*&&BHV$(A"\RY+5G$(6%`@S2D@9I&I)2I1PMIM%^09IA
+M!QMFBC*D$$-+!GL]0]`*`7KS,RA@&>6`L6!?K`GH+0LLA1R0O#6U)09HA-(Q
+M-HQV&(::#E(@D%U$EE4,U)@A@0,:7`ZV,25`R1DC-Z0(CGK_7^<>91JB1WY/
+MI7.A0I(^9BXL,U2\2OM<-W4I"TK<0)\?K/IB#GN(L"DK*2)1-+R,^>;/K-':
+M&3ZMIA%UN#,BQW=XIRR4>H6R5Y"@:I+.@$`P#/(8&B'Y>9F4XDZ4)$5%"4Z(
+M,I!N)03"T]!0*^]X3YZO8KAXPAJ-=D@A!!2PU9+I2JL?;?V#3)"]P5L.&)J0
+M,HA&I0*D+3@,8E(.J2!AV=?U,3YBN^JJO7@$-WW>D/=E2S9F,<'\+`^%BQ@@
+MQ`C`P15#ZH[#RL&#1%!0KT$@L"A0JL&C102F[XA";5Z:W;A6895[,F+:O-CE
+M[F6;V\M4JNKW1EUMC,@S!ZOO@/$7NC!AQ%E.FTR'\OW[X;NL[@1-]^,RBO(D
+MU>W^3=']%N")U2:K;VW@[H4.@VG9O6W?1/LV.VPRZO*][P\/6/>`(]X#[P\$
+M7+-Z/GC?)8O4321A0:98,!J1LR9]52ED&)5`X'($*"]#'=;PSHKRR'RKF7VB
+M#:&RW,@P4*$]06M1G:@H[MNJFU4H+=SA_8_STRXQ(P#O!(#&P[;J'*DB3#+I
+M541MOB*HX0CU,=>V51'=W3+P]P`'W@/70)"`PT<009#+)/WU7@X4"-$8^$%B
+MPV+P04."5BQA&#1H@8P4,\D@8;JS,N\+E"Z$X6J-8PN%6<32L?'RQ(3Q\?;(
+M8^((ZGS_N'7IO7/,/OU[(`.QFD1K$#KW!U!>$B%LW,L,8PHQ%(Q*[WO?.XMK
+MR77=PS3GM#^-<@Y0J?;]V!<`=\!>35#2&;I'^X"QF4*_=559\;7TEU=V;``P
+M@D"^#&4Y#GZA)6(+6^`'A`/`(0((>@3V17R:-GKKV]<]HZWX,]551)))))))
+M/B93[>FWU55?DX\VSVR-95R4<'^X8%IZCAJ<Q;5$.!T;?HK88IU=W"+IP$6H
+M[:EBY4HIRI.OG/MC?%:?)48<(-4V<J,WUC*P)O&8Q*1:5R,5ZO2>^^9/?U>[
+M\UKS\````"4K@B^(8FCK'+!@S,K,&#!@P8,P$UZ96)B:JJFJJ:JIJJ)(K"Y7
+M&",,@O8#6KLBF0M1;B,T4U"Q.J>B1ETXJJ,_E1<R2A+<D5*LVA*!=;5>=U!+
+M_&A^\!X819^7>Q07Y#3AM*+$(-;LW`E#?I;K[X,;->L,AP(J3!JN??>'O>J/
+M9[/D*/$90A]1.VEA1][SU/.87R>AMC:WJ"7K6!!BX$XB"B>O0"!!FE&<G%07
+ML4QMYU;-.$U@NZ'31=1/J5*].U09HP[J#G&Y<"MJ9]J00+#"######`);*;;
+M;;:2=K63SV&JT7GL+TJW73S:<\7$RO7I>?U>?(!!HV,Y@!@VZ@C+2*WVB(EY
+MEGMPJL,/=LT*S"2$VLY>HD("U->L@(B1C-9(5QBQJ"Q=6))4@DPJ2IQ+PQ/`
+M1,BP,ZDT-,^T3K0VJAPJMZB7C>$XDN@TB[)@L-&"(V`G;7V(0\LDB?E:U<21
+MI,8]W".J%?J`1%)VPV"HG`,ZQ#4(TNW;I(<I5+@GOW]'Y&L?YNN_'++TXV@,
+MK\%RO$/4/+AI#L%4PB*`@KLR)]04^M=9Q%Z/41$1%%557K//K>X`#[Y`;X#P
+M@W]B''_6M#A1>QCY;^?-M_,Q;QM>[2Q5Q3Y-B@A]\]V;%"$H>Y!SX?>`S[#\
+MAP9.#LHPP8NR\7I@AHB&YD#P3#-*(-'(0(`VFN<B8C&7;M(JY%8N(B;Z$:DK
+M/A/\+3V]IY`T5L?F"#%S:?]=K[26-I((2DQ0>PD+VFX1C%I"A>%M3R'2:"3:
+M&*GPAY%T'6D.A.JJO$=0D`:/(O?QT.)T=^4Q/0A[(KY,^%$SMBW`6H)!V"YS
+MK#O6GJ85XG0J#H[:1``N%3-K17+3,G-@YAX9[.D`PFG1$2Q2I*(F909_/>^/
+M<VON\/>T_3?QVZE$+OR3^5<+>4>S\(N?U.9HGU;.8J':\DCR^']?>W]J`18S
+M41MA$"/6V=K8/(V#%WTPQ34,##,!#876!WZQ5;55>U3^="6)I20IM/J=1#CX
+M0*J0Q*YMXBC<I`[7O`?L]X#[WA[-OJ^M#J:-\A]M4LWHJ[G^>X1I.O,UMHJ5
+M%+_7@_!`FBVJ801H6(&2X34RM:=GHEQ9)OW)Y>WNZ]5]P7W%>>HYZ;<1V#@3
+M$OW=P0`=Q(0=TJN:S5(B"Y?9F_Z?HA-&&X#/S>%P2M(XF/$O=25E6WE,75Y(
+M;,3F%5B'&VP1$C2OL%2X7!F6BQ+7Q#-_?E\LL<3-MODQ-2T56CX7>DV/A>=B
+M)H,(%,,'(O@B+^Y*MQ!9_O[.-V[%/#`B705;]@QJ'=H2YM5N:9ZB4!JN+"#3
+M]2-D*L$:E:KT?$%5DP$+L8+'4(J%"JS$0TD(,[NNLXFW/?$?2?0)):EAUXPD
+M*=L*F'7V*%,L57I!AS+/MV5!E7O;8(@T*U>7<V^%&4,B)TR4U",:B(G,54K!
+MA#%#B8?BAH-UFP8<.#*^0&V_WX>'@/\>GEN=$(`Q-#_&P]-BE;9"_&?S]]#=
+M1=GAB<MNZY52=;`!`/5SMHN,G0V52X'!U&FPG_*"E+;'+@/>\B8J\?[K@I/&
+MJRI7@/#B16%+?KZ-ZABW4]PL;W$UQ>VVW]>2S.64.7:-_L_;NJ?3IZBOF2)!
+M<_>``?[5M2M#!LFI&+!;(S&!B9B(FA0DT\6MF*S>!,W;W:HRK6:7#Y0`)669
+M,0L'K[.`OE.>,G=@J[L4_[A851U[]X>&%N,J_Z1L%J]CL:\PO^M6/VM3338S
+M)HIN&V'Y:T>]X`&95J\/]_+Z9UR3MZX-LV-^`.C9T(?TP_$+X*M*%$Y##O`T
+M$`#$R@D6UWILDJ^L'&HN%#!SO0]QN09R7L$V&R222$4222<VZ\66<8)D8M5=
+MPNX:4UXSC_SE8%JZZP$E%=3%TZPNJ@()=2L%?2_AN#)G=1)A)MO4R.<J8[D-
+M3E8_>'@$U4)!)))!))))-28>/PKM&7U55@TVV[>V^J[S?N[LX*Z@$3<NMO,%
+M:R$"`;AG?5$6^X1,ZP75EK%A,!!((K;0=7^;S:JZ\_?O``#39E+:.U_/M9GV
+M8J[%]0^&]E%[>>M(AU\5+=<E\M&G.5YQ*SNPRU)*)A%EM5.67N7PT)07QW!8
+MT'VSIGWO#P^'U+[=ZQ4^IM?$'AMA,;@H?3&NG.X_F=1IA`TQ2N?70JW`D(R]
+M2?=CSKAVEI7K":W*=)F?>][P,````?;C[^_+YY6NO2(\23YE6+NT+=1,7\=L
+MRIW(?9Y4,4$%B%9@KPNJ`1$W,E@FS&]MB,7L\L1`U"C97L+%Z1$08$9D5.(B
+M)B)5G-'!C#NR%>?/=Q(&00.H]M#?.W'"X$`V_.H&!.*X1`!',&+,X6'FA0S8
+MS:OEL3`;&;!80F6@X#@UB)E:@QQ80#V6@OSS\1\8M_3];6A3BWGX=/ESQ8WO
+MRI+Z_A4S>S5MW/J%^4-C+6@G:F;L?54WLR4R^65E&"[MC52SX#P%C:&U])\X
+MGLO[+O/LMVQG+EIKK-*X;S18ABEA_>``6DCMW%\]RJZ[RN>#"&D@H2LEX;E\
+MN?;$G+3NP1TPCM)S'OK!%(SYSLJ].%P66%HB`3I5B2NA34(UJ(B73%89<1)$
+M/<R.F</)7&6AS#*1E$"#>)W=,U=OL#1+LZ[TFHAZ0@KJ^=41$0=W[KF$8[N>
+M.Q;>5+0J8V3:.9_)EX#DUKT[NRIG[P]XVJXU`MDO]7P^T1]$\&=-VOJ7U?6(
+M3]@:98;T$\(NU2]6\MXY>V^H$.KQV>%572JJJ\O':J.P_(71&![]O/,89"F6
+M&Q6:'S4(_9'+(R4:I%30K=!?4T6"*]1&*B_I'^\/>UN]*)))-"KX:KEZ2222
+M?0:*I6:JFI%,K73B=P,H@`QE1.1C$!YN(B7E*-1$>CS[NVVXK&Y.X;GI+R-A
+MQT%BP96)Y(F'#1T`""U!Y_(*BI[L^Z5]L!WWAX069\+-I:RSO9`>EN\>-MRO
+MY[PQYIM)DG5T=']^^?[N^I['\D"BH2K\ZQ.HE#8?W/)(JUD_RT#.S`0/A[P#
+M(J<@>*VI\?;0>=X[I]0I"JV<(@)604E`#V07@`ND'M7P*=CM>ETFQ](;7M./
+M#9Z5=[V;Z,1"X$(`YX6!?H+(?F$'4DEA!5`PP?-!`GQ1,3+L"Q8JB**1%E/@
+MW0$#=XDT%-<43"X[I;JQI=&7%K737&JK6KG%+E*QMEU2Y2O/,.9AK=U`U&&M
+M:AHTU<C)B9UJ&C37-0U&FJ@`@$$!?@&`@Y/02>A11HII%`%*K7,3G:AO3IJJ
+MUKMKC55K7=-92H-I=4N4HQM%<:XURB;&NE&DJ"A9%%,H&DBTCXIF)R3T<))E
+M(AH-H((M)J%0^A;2;9HH0IA2%&ZLQ9<XT5G/&HTUO0T:FMZAHTU:DG8-#4::
+MW4-PW&S;3N3+/,QDQH)<P,F<Y##-8&&-!+EEM*@U!1!-!`@JQ4E(\(B!8883
+M#T*JJ#9(@]^W5UK>&K5[HOO>'J$!^17U+Y/Z$1UI71CIKEK%QK%UQ7&JK6NF
+MN-56M=M<=8VE8VE8W,,RE0;2B-I1C:7++E*QM*QMEM+EERE9W=[[TQXYCVYC
+MQS'IS'CF/2L7&L5%K7&N-=-<:Z:Y;LNS&UVT/H1WSGVM/@01]:>&*K-\!X/*
+M/D1:[SC+JW7.]URUB[:CFY"&I"))#M!Z)&9`ZA'20?2#2'"9$'L\)X8!7J$D
+M$]!*;;2U^"\+`L"P+$J@/4`*`KU&>@$#$I(BVFT#I4))"4*3?BVG1##::*;8
+M<2D;/BT(RDS<;B5N.C1IXR%,UA"822R3`.0W!LVUSP.!&Y(C<B'9"<B34'8;
+M-S6]H:1)HDF41J)-238W&VKL)9('"$G(20VB1,P#40;0:0Y#9MK?')(V(;2)
+MI(FX&@X-FVF81!N)Y(L1VJ=H`=@+V*Z5VO;M[>'-7GUSQA:#T?9XKX<S>!B"
+M(0*G"Y[[X`>[+M?4OOJ))U+DB22222203%CN_*]MDX=D(```"'J[N?/GX\\]
+M?C?BOGK]/'L^'"B11Y#>K;[.J7M3]NX:65@H\D:\A:!P_O>'B$"8;/D?,A'F
+MZGWX?BRNC3L^H?!WJA-@I)L7V*P5B"?#P\-P_3/'[UP%/*H]*ITB]*]+Q.&^
+M<$3RHXB:B'B-0G)(R&B<DT.FV]4FR,)&Y&TV;FMWV<Y8U<UK5PN<>NJ)2<*@
+M2<)3+*JBPF2BRBF74C-)&+C6*JQ:UCF7'6:;B/2U.+=JJ*\E3\FTZ=RDZ+<;
+M913+(->P9#1=SUJX72X!(<-XS<^4AIV4!OO>`./ZRS!"(X9(4S"C/A0E;>^`
+M]7A[U>]Z>]0$1R&S;5@?@)N"&I(&8DCB)-@U!R&XVUOP2@S$A'4(CL@AP21F
+M1)-$'$&H.C9N:]J1$'$C:,IDV;.O//'GG77&C+#;S#3RL,L,)YMPZIIYQ6&G
+M'FF'F6U*\KJNMJZZZPXXJE53C:)F).AZ)#I!J22<`R#0>1J3L;F];X1Q(W!N
+M1J3:-)R-FVKTR1$:DB)N*(&@1#I0'BJG8KL$3H532B-1$[$F@[#9MIO"H81N
+M-S;;5EWZYSC#%N,YX#88@U)-DTG#<WK>PT-&4:1J-S>VD:&HU--70,A@FR32
+M32-IN;:WN!/20P$FH2(\A)J$.2$R0T2<B-2.C9MK?M"/$5#D["&8AL).PA/1
+M(:A)Q$F9!J(]!!X9X5ZA"#1PR(NH,O3MACO(V(1J0JT<;3_1]$_5\_^:']0D
+M^QG5-A\?VGROTZI(.?@=HE/W`N=K"U^/X>A??_E'N[Y]2^OU'#XCOCSO&/-:
+M;O./5L'$ZKA7VWXOUW1Z=?'U]X1/4/4H<'\:H><?CZZ[NO7OZQML?N\>B=@8
+M10I3@M)]:='4552B#V>S!L$>'XP.WU>7<!ZT$/<P^JTK+:#2RB%2JP*UJ5GV
+MK\OGC=X;RBJZWA6%2N*(IK6),D:I1U8&1#2+5U:AJW2`;0D58&XF2"X,E:()
+M2HEEW0H+%PW<,:UI#!%8/8S\]S'[<\@_S$_*SIZ_5U^\KF%RQ,[\<2ZTKS5W
+M=W=W$5589HB(B(B56<;9ONZN[GN[NUNZ*JJJJJJIM;M/.JS?=U7=MC&,8C&,
+M$W=W=W=W=VS,UW=W=W=Q`:J@1%507&,50N(@F:+N]4LWBJBJP3=W=W=W=W;#
+M&,8P%JKJHJL-C&,8C&,$W=W=W=W=V]W=D[B.7=UV[(M0.[MUNZ"#W=W=W=W=
+MP@[NX$$2QNK=W=[N[N%"EYC,]!GB("Q=AHJ7N[N[N[NJAV9ZJ:I<8Q5158N[
+MN[N[N(K,UNJM*]W,C,6=V9W=W=59F7%CJKO9!255O9=WP[MW=W>[MN[N;MW>
+MW=W=V-[=W=WN[<S!TZJKM69F968-W=W=WN[<S!U&NNYN[N[=W=[N[NS:VMK*
+MW%VL6K,UW=XO"X4XQ=X9;:[N[Q=WB+,1#U%3$5=XQC%W=O-&F%54%35W<W=W
+M=O++<2:)"D&J69D%:()!IU:"02S5-W=W=W=5+LS,9EIN\8N[N[>[NY))77W<
+MMW<QM7>+>[=[N[NJLQ4VV<QY=XQ=W=VZF[NX$$$$,P69F(NK1,."204+!2`/
+MA)S[N[M[N[I),S+ZQ>OMW=[NZ/C&&BXB+JEG*?P^0143S]'=XK_/YQ'^9//S
+M=\'V_8HT7&O8UM0Q^#3.X#?9]\8E,[G;'U]('`(]'D/+S;S\X\XAI9ID^KU8
+MF8G`QZ[N[N[N[MA"W=W%T%JJJHJDN[N[N[N[ML8PQ.(N9F+H()!`07=O=W=Q
+M:VMK:U35=69FVN(B'N;Q=K:F[J[MW((0.[WW=W=W<[(MCL(9RDM52::W+N\N
+MLEV3A>6F*,S2R0S8F[J[N[MWO]#]/R';TCT=/L[+XOX1Z[Y([C^<;+N/$+L.
+M$0!1W>B_9,)7]L]_;ZIH4X##V`>E`0A)2?'TH$V>XIQ-GQNS/0IV^RZUHY-#
+MGN]N#`T/''\*\^G`N;TXS*UH8%":WK"JWZA/@"'!.?`,!O?3NZCEFX`0>IDZ
+MD@,JRM,JK>I4JPA%C631^0E$'O(`^A'H*)*?+0;/*B!L51!V*<B//L.[W$"1
+MH=6]@`'QQX^W7>D?#XM\'B+]('X$?KZ#XPO1(Y\?9W#Q'L3X8;&@)\_M$L/U
+MCV?KY&0$$H%`_YG]O/(9&*=O'O[T140)VW[_HO6]`_(&?WCX>U^VNN?^:!`L
+M"QE0/;]R_:/N`0?$#O[Q\6^)"_4WGW01`DP7CZMZJL+5S,"F,[@UGGD67,$=
+M9G#-S.?7V)=FA=8(P&Z['G5N"5?<,5&WE;(+M#=FVMY[@/2FYS$Y]IZ<+O;&
+M$15CU#,?"O7MT>86:D8>V]OS4-E7*R3L9[U>[F]M*TS)WB6*=X<VEID-WMV6
+M.@U;'NF&4["OJX.SUR\YC(UP6.S@8.C+Z][,?9E+3JI\.<ICK?0;378=H)<2
+M7NV+-9=*[:.Y52NVJW!RK;-9O&YV`WA&[9Q6=O:JRBY'=6N.[,'1;6%TNPI6
+M(]H0A6=K;;%OEQYS5*WIE:,JYC;I,3H;.6)5R4W0V^3ER3,RPEEW`G*YFD2^
+MS,5Z-[35<*I-7TIY:!L2L6GKO+%,O>%C95VYL%/,G*M.;B)OM.UUUE&"+.EK
+MO/?3A5*&\AN#1-8Q=4)21/,[H?J*O8LE2]W"GTKKV<L\8\TNX=KL8E@I]T2J
+M(XZSJWN(+VC([)Y#A?9V7V:;$?#&TB&=JKVHXYP.U0U8[X1ZAE"*9D[,>RM,
+MBR=UOH>2E4ANFJ6Z:KL62]QY=GIC-E:>%V]0L.#:Q1EC#7H9;G94[NI]CF+I
+M6AXEJ/%Q"*TK--\\1I&\SM!XR[S+).]BJW6[V>UKLV@55N+*4K"AO05!F)4.
+MPG+3!EZ]QKW1R^!NK%+)?-C7(^FU,S3+<75CV\E;CSA>YM+":,Q6^62ZF$%=
+M@)UQ=DXZ=2&S:"+KF*FZGN5S2M]RY7../;I739G+>[M231@L[,*H07N/NW:>
+M4%<./-FTI8QU9?&7B+,ANP];W>R[8O-L],X+MWHEB.>LC+&S=''31:IEJA0G
+M4V^I&V2<;B[+%@U,AS"[B%<WC>8%>(X35T#AK8MJ:IV&SAL:[.WZ\5"\)J%U
+MEGT9IG+W:(M4*Q9DUXK%<)O1C&XVW,?2ZMC+2'`K.$O`5B=98?3:Z4Y=HS<P
+M:11O'!!0>2@3PF\N0HUM7J3<3N2QCNZNCDJ(US[JVCV/3G03!>)5F;JJYN57
+M+G6IM)"F1A%=&^T9>8)VG>&;IS"I3,MYG(A&V@*J#+WLL8KG7DF'.6;3XW,!
+M)X\Z-$TQRJ5N]A)63D:Y#KPWRDZZZJ2E"M[95*K;[+M-7AR8LQ=G!WP+M-UC
+MV/>7+8S#@4L*RM,O.W.Z9FXMR^W.B34S,KN+LG<!ZUF(9NJM<KL60U+&WMB=
+MW([2SG:JI"1#W7L4AIE89F=+.9I%-4N$/5>@[CU2<,N[MX<O4Y=RY4MZ]B4K
+M4H-\Z>#C>5=-YEJ^K;YZ7NZ'(17L[<K3O3JEF#I7&;O2:VVL)R\N-WAC):VH
+M*!XW0W%MG14J(Z=W##K&54RWDS3U#&>2@DZ34:H<.O31ZKOC<+J\VC.TF9SE
+MZ+.6=>5R.Y6\\SE9/924U$)X86LM&;0W;&2U#D<G=656YE=4O!UHVUVR+I*X
+MY>5*2OIUE);A[A'+8-6*[L1/#2J5$A9=M#J(NZE;2J36KE"7;JL5'0*CZU87
+M-[8&8[WB'V4-S>YY*':]SKG9N8YG-+#:I^TV.7;N&X'PJYDTG3G"MV3M4'/+
+M%WS>[MV*=0*/MD<".HA2NOK2N_:<JQSHL'U#=OH*E]V*S8Z"J/%E'3M85BP7
+M>+.YYE6A!PU\LKO==9=O-,5@A*]?:@;W.'4W=CEE[?/)W:SU0OAMU:E0G-?&
+MB=."KR/=SLOO.XXG=;,0-NK>9:5U5KNH4L%,MB..&4EKA.=C#UWF^O;7G:IZ
+M*1T662JU\@B^O.=^FX-&;W`N-8>2691V[''!MR\W<+>9H(X4V+P<,%>[A?K[
+M/#!@%UZM#7#=PX9'AXJK:W`@*]72F-:8V5#%M@\\-%4'A[L.V=.[Z.(G""Z=
+M.BDSW9";I+&+@U(.V'G.M0*7JQ4>F7CIRN/4-YC3HHJ/5#NAO7/8XN<YU6L,
+M[PM#KL*UWQ(EF`JYQ+R*+:DW<>T[)&QUM[S.[0I8>%H/U;>S>H4!5W3NT"Y&
+MF3O*#MP,]>"_6;0&*YWM`K/9Y#%EW@@NQ7:"*K+]`O=%>X(<[LR:O9ON/%![
+MHK!@RG*-,'A4R]O0->-\9<2[KK=RZW-FEJ5/33PS9F[5:S.E3&+=Q9%I3TM'
+M3V-N^?6=J:(6^6Z[[=NL8Y41TEZQ(5RLDYM,&FE4PP=BNL)-W:[$LJ:#1)[E
+M'(9ZM%O@21O;QS,M+'<T9FAZ<8I&Q9X=[AM6WG-6A0M>RX(\V#,LNHJHHVH!
+MV;#PVR4[]R9S6\DSGG*6=%7A,QGIJI9UGV'!8K;-FW5'JZL.S1C@MY18SM'4
+M*W)@F@V03+CP;,=O2E,L2DCV:RUVL6O8V#VAGC:SNHKI9S5TZS0VUSVHLM%.
+MT2+S!T%7V>::U@@@D$$@DUCVVYBM%7VK;D(417OWPO9*0Q[*D85S'PSJJHPA
+MREW,,?75H>O==Y+O%K.88=[%*'$XNJXMNCSUS9>WI9*K50U*6KO#9B/9J>[&
+MJK.?$3A7&8_=FY1Y[:GG5Z+M9&]U`.ZR3J%9BG<*PU5R20K;&J]5CKTNR%:)
+MDK7HRHSIW+NI>/3+E8GG70OLFXNTWF+N['$KHWZ,;LL+K/+VBQIBJ]!O:L42
+M\.]LP^X/LFVPA+U6G(O2,0[NKJ2]=U4H!U0Z^[N&-UI;/D^%*<GI5WLO%DU&
+M0\[%:>[',NC:XU%Y;.HT;)WJ(EZ#RK=R]Z*13MV\D2&1Q=O4X0:OG0,3-I3<
+MZCKV=`8RZ['ER)7HQ455HJMP*A!E0S+P$Q=&-%0\I'*)MDFJ=7E/JS=X*WUM
+M#%V-EDV'E31)PXZJNBKCD:5UMU;O.SD>FA5F/=HXS9ZT,++J9PQK=5Y2J>RA
+MQM0J526TEN08K<XW9D#=WH/:U0L5I[EF5+8K.8Q:#65-%R-R+>[9SP,WV)O>
+M%VQ-4.)\2+9#Z[V[RFT^U&2YRT&LW#VG":U76)YUR;=9>]TOC8S%,.8#!K'7
+M=5F]6]F7!O.]>8>7.[K$'3J'+=JJK#W.JW(H,RLJZ=RAB1MFS<-&<Z9\Z"%<
+MH6-\RO$$DDQ#JGO!HCT#;+"\$/<P'Z"`BKJ;?O(C#F;II:`<SR7B0!3S>RR<
+M0&":$$AHKT`0(/IY'Q`3L`%A!@FR6=A=-/#&O#Q-A;IP5OA[_CP!!QP$'P'I
+M[(&'ERO!&Q`'S^7H\P$]::U\,`>\A/3]JI#$]ML`T6U(:83K"!TDI\/]-\=_
+MP\8Z^P^I9'M14`35!6!`&Y3OG\_E]GKD1O\?JW\[`Q[+Z0OOA1\/<X7W>CW=
+MWHWNCV!_[=!Z@#Z5QTYPP?Q;Q\X"K-5,;H@H>GE0T(I^1W_O@-^3T>4[$$[(
+M0DA3TZ+UWRT\&L./O_!(X_!!XM/?W='R_!PK4G^H>"#/P^G]Q<%6O86"(^U%
+M5`R=>O_@[!QU\>>W89SSNP\FJ`'$')IPL8$P"[`V]AQ(+B`K3WLMK'?O^Z=:
+MG+FSL44'8QI6V:0XK=\OCR<:?7!2V6!&[W9C=G=Z'>PRYC(8;CI-S,AB;555
+M@VRK&&@RM8JG6U:>&@=P<=ED>!YK3!:3[,E@V1#?144L>C,1N]MGFQWL'GPD
+M+V=@/M+G04&]9=P"XRJ4^Q9;E]4P93'+;9CPS%;3G@>$3>XYSQSSLT"5W6E9
+MU/9=8#L'VP,/9O2S"G8\0-9EL$ZU@BUANNIKJJC8855]#<,L*K<+H1I)$<Q=
+M"1(E6->)&3^>UE>:R'&0I[NL;X48ADYX@=>F&JT"K6Y>W=6&#H5D)_@"<[>?
+MV>Y?FO3ZU^77=-T^'^?7]N?J'4>G'9@I&>K!8^V$9/K[V#(5'/(\AO'Y_5ZY
+M%<2IQ=ELT$CAQ\:R,',R38Z4&OOAO3E1O:CN"IHMW+PX]\=3QGHV\*@8@-Z\
+ML*E=NBC<QA<87*(O)G,!+.(Y4,!,"A[&):C4OSQK8SK4S1D<:K?>)'2`O"^]
+M,V&@$>YLOMZ0?VXEL+[BJ`BAUH86F&[B']YZ9AEJF#.&''3Z,-[A11\C<JX+
+ME!89YLT_AZ6\@(FZ3R@)Y=L:0#D9[^^S[WVNEK#;%-FAWAMPSC$O+;5$J9^*
+MYW]5C.-@:<;.*=H8[.`?0HAO.)N4=OW,Y`PJC'XPVNF&/L'BR@0HZ#S[$]1'
+M0Y#-V'&)Y,[5A:@C'(7OX`%RGUCPH-GIX9&ZSX!YC[?MN'/7VNP_U`\C.VR$
+M3WAB2P2(94#D?]GQ(4C"+*/]BZNA0BL$.$DNL"(=U9B6"C9WZNQ=RD@W=[O\
+M"-C>%4H2P8D@UZ'A`@HR-]E\8D64^W/X4.WAM0Y^DJ3I;DRWZ>A4D-T.O6_R
+MT.9#LO`V[<3UV4G@<J:;E[#`Y8:8J'I7#:(9D*WWAY5%^!$$3&52&\O2(SFA
+MNPPN/+9$0=Q1`)0<B3RRT89+:&3R+NH$VJ8Z_9[\_3U?#81/`ZX@9S;?,CN`
+M\2G3#A.H7OGN:!&WW:&_HB0R[\*/BS&$(("E4(<L;.5X@GX^,HY?/+E5#C?L
+MK#I&K&F)SZ\#!FJZ8;TD&F[VS27T5./92=#9VY*=SU^/^5V<'FG?HLHD$]4+
+MYW7"-ASE9[J5%>B8G\$6<=[RGM9`4J\"C!![IY&[C!1QK)P'Y*!N`-!L0OK,
+M%U4RH4U*1O>*C?#,=LVY>#"N1]"G0CR-C^J\_WC=C[\CN!\8TO=S]M5`H0C]
+M#S$)'@M@D]`13*A.Y!3MD*W@0(R30ZA1O`[PR@[>`;8C<&N-V_H>2H"[G@GY
+M%N]B--MJ^7QWNH(_L.,5`IC3^`ZXH%!L5.Q]1:QX[=HC9F8[CQ;P@%8L@M08
+M`8^[C/WQC+!A\H]KIL:2=\>_@<>7A",V,#R\U]`A0_WY;Q(Y0'`TGAO^@?GD
+MA)"(R2'ZCU]B>K]T[Z[?=3#.]'R<ZSI#[9#5(8MZ:`<\+,!^SI7;Y]_4?9VJ
+MMM-L3ZO/U.WA`9-CCN43/NUX0G@JX&;'8-X1AQU'@%]Q>C>7P5A6A2(\\0W=
+M#D:MVO[7;SZ]=^-R#UPJ'N&I\/APHZ\<4%?IWCL&P=H;'I6!UY;7+/MO+CD;
+MA1&\N'WO/I6,#[<>D.0%X&/L3G?=`@C*@60HZ7)=Q[5Z4[:4+/@I95+3H:/U
+M^S.=\TSXZP0Y)HM]\UPWU,UC\%=IIL0WF5(;6&(0%3S'L$3.^V'"CL2V]^E@
+M<.U(4PW`KF!A]6X]4`EAG\`<G:@I_0OE`)'F$\Q(S^JE`5(!SZ$^_W?/I[X_
+M9]'H?S>/'CU.D(?$_$P>R`3!Z%UW\!YF.QQV\&1-H&/<#F""NQ7T_\/K`.P\
+MG^PLS0V3I]!UAU?+#DWHXGJ9[/.I&FSE)[9]7+G.BT_3O.OG_#R'MSQ")UV/
+MW[0>2#1&K1119D6,8-1C$!$:*R%(1%K8VJ@L457:<(L?R;;^[V-,*D9%%`AS
+M/AZ]'ZY/9TRGY^V;)Q7Y><SSU_WG]E\O070=A^PI^PCW'IM03JN"<SUUS]GO
+MRF/1D=_E\X\^BBCM^#LGL+YZ+L>C#[.UTGL/L`([;;;#ZR?`=-RJ"<AO+`WD
+MO?W1MP"^-F'1Q/TJ->7SJAY&#P4X/2689].O-X\ATP&#E09T'V*<X"D4OGW\
+M0Z=2'O.W$<X76%K"K`5%R/?(ZOB05#`'`9H&V(J#,Y9\UMEY]7E8+DWVW)E6
+M!(/*S@;X?I^+:>3&S8TV\#STK?8O4OF@MPW8F7522#`\.=\=T)65E?!_SR-/
+M,MVYOVCB$:.Y5VZ/0FDHO9"_?X-@OX=L6E&#:KXU-XFWX]6HS]Y)_N.(7\WU
+M'VZ_<]']3_0HHQB+\K=L`_/Y^'0^Q01S`A/76XQH'^SN"B_1L,&MO!8V"EH`
+MV_,KV+::P66"MCA=MA3#RH+DI!E?O"@AA^0/C*K((W>84L4@X$B_"!B54+*4
+MHFF;B17R&8%?Q6_K48*>Q?CLKC>U8[`G<%1\C.J5A!=O]#+QD:=6&(HIJSW/
+M#OA;7#8+Q4IU-/5?94MS\-F\#<CC<K]J^@=R_V4,;J"O(8?H(KYOV.V(D/ZK
+MF(@C#/3^"&U+TZER/J*."+[*Y=_NYO;?IK>,A:R`R"4?A^`C=(W@6B`##4/&
+MEZ5[/AP4((0>)"?5^&WZ2V>V5<:/>-,[D3+=NE/+*%(5?<1W/[&]/@M1[AI7
+MW*;['$/(8L?E[,R[3S>(!#D:FG7^TR)&3O2BY].CR)6AH3\WSJ_UCAA_?IL6
+M..T"NY7GV=7?<-1Z=.E#8=+C$,>M-!CGOWWG>IS%./5TB<91IMQU]SB7QX^B
+M]OCI1<\'LV/?<;#80+CB!@LI4*$W98V('9<,&-)"O>5WAI^0_W<BJG;?&]/K
+MQ#;_(?`'[N@==OS_?^?G@X5>6OJPZ`ODJQF&8Q(=1W1X=J]`[3*&E2#4!=C!
+M\RI`F/BGZPJ<B-J/LYB5$<!Z&2!@>CKQS?IU.!'^C84IH0=E@>U=VAD+G<M;
+M+#T^\>VW(;A],[W^Y\'P_EWD?O^,_S(FKI1!9%1!9G^27]UII4&.PHT&[_YL
+M]*`II,->I.(^5!$AAHA4PD.]&4=:4U3!4RE,+ERX:T9B[&;3X^(M8BQ7K2I$
+ML)!E%(9$U$0X"C0L)^!(I(`OT?_/C7E@GK3(:M>MBPDH#"*@7J1!IAM$.H?6
+M#9$$1JV$@'7F&&%18:"##IA0/Q##7D4(P0HU*8S3`C2B:P9"(?>U5XF>I)H'
+M48+GI5+P1,%4R'&2(2)((_(J0-AAV+2-4*#8-QA(3QA,/F0VPDX@@18-M["P
+MCF7ZXE5[0KU((BL2!W8&C#87EJ0R`O2"@_,5XIJ@1&(2"\AC#KR(A%>K!H1%
+MABY(#Z'S#"9@L0^H)"R`4-BT*.CKP22AH+0:2%/RD]0B$KT02]/5F.5>0A8$
+M5FYX@6!6N@=69@(A`17BO:8@$$#'K0E`N@T((PWI"@H5'YH(R`IP*2"*"T4@
+M:2-"F$H(0&_1EAL1)!(6+8<L7Z*!2*-GRB8GFYZ>C8:4"0<]&_-^8$E>D>MR
+M@]EVC`%<1!!(M/S0R/S(4*@H,45/-A`P0E$:4Z#H0D)SR@=H4&*-"1A#5HKT
+M#O&#)IP*EZB*'GX5!AIBFG24HQ^`81\&-/F*)%I01NU=M`48@"!0H*12&@7X
+MD1,FO.4"+-L`AAC13%JD<=A!F#TP^H"@T+2#8R,03Q+8(?@SEX"Q=V&"IYA@
+MB"\8IB6B%[(J(#)KWD5[T`@E()MAXR&B&DL$J"Z=P.F_9Y4*"N,$J)ABG/6_
+M.PO)^;!%T&'4N!T$3Y`8@L&7=4:2(H+T$0$:A#]#5048+MDAL4DU$*+;)!H`
+MD`G24'K\BG[7"8Q&JH^(:1J@:IDAP5Z)((0,/?.:-"8/BA%$(3X@Q(&"J"2%
+M,D1T?2JS;N6PV\@)9&^TD-^##88:&J.>#07G`QI!?E*"KQ4")=(E`@&2@E*1
+M5$@RJS`76M/UGRL1"O`HV*8282:0:S)P<6;%YNM#=1-"9A2ZQ$P!QL7AEMPX
+MVO/`F<<&HFJ*+HNC4$=#6(^,N"5%X4H@P<(K&KB7C9?KQF_!AX2,$U57J8*T
+M2!-AZTE`9XRJ;%)B1E()BF_4&!-D)$7D4(?$P&R/.58;8<<5`HV$F0&P@#+H
+M(7Z>/BE!4#$\HPV*8W:R20RC0A5BB:T$2O6+"$\0[,<H("!H(`@[4@I"GL!P
+M0^D`(%SU^83"]"$Y[*]/$)50#0H&&-@L(AT!1\X`8(@D(O)J`QJ/TJ:9-UC<
+ML$+U`:-<`($(?F6SYU;:0/@),4(%0R%>9I($`*E7O*O"(T4!0##2JA*TV-2/
+MH8\"#DE"G7I=AA@F955*5@@EQ(0((B%A,9$#($&VV?5$_(,1LB!!A(A^IL&E
+M'2&>SUAD"_!"@E5V+H$UZ!12(^KTLT+%6$"?(E*CB$HUZ@3XF`@J@9"A5)SQ
+MJA20"-(($DZ%OI'069&"0,=!P^@5OU4$(BKD@CE0(EBALTG&7(UT5IC!QE<Y
+MXE%U3G(F^"VH-O%Z6?70OQ#2`,\A'[$&)$&0B@4PA0<9!%;5C`AZ_8L1>">6
+M(XRTP;-U2C6'R+""2H/`;H-P&!"F#3:%"O:*P'#-+1*)\&*9C]#>)G5A\2Z%
+M-W1::!;#1)3\+`HA5YH-E,&WYR)/R1S))-JKP.U$9XB&H\@:#&6'L$B%;B@J
+MAL8O<&S'M8*&B[)$(K0WE.H2-VG*FU4$V@B-".;-]""]1&DC2122$)`E^/G7
+MEZF4@4%O5]7E5YK2M&Q%C&VNAXM>"DV'-KSK\2Z\>M7!9:0TE,EW:#,<!PTR
+M0*G&S(+`R38#C4Q*I,15<UBTV_#1M1;T9W7`BH%AP@NKPE<LQ33@9Q=3HP2:
+M#4V7=C-0V3#6+ME+L+F4=#76MKN76LK19T+1F[L1R\8#P;-&E+3@'.-@F1O`
+ML$UQMMP=LXUN9:V-ME:99BF65NM%LQL9IPRRMCOC2%,-F[A=0*9$W@%-&J7"
+M%,+:[R2FQNMY9%9FL,BFEUC&169<&7+-VN65H\14Q<9T4,UDTIEE:;LQ3+*X
+M9H&996FK,<;&87)6FJ8.H9J*1(R0V$&0VD$O(L4WXM)BH%0KU3S:IA^82"@2
+M?D(PV(?-A(+!4`J)H*Q-W8)KF[T&S*9HA3"VNLDIHTTR:DNTBXQ)G$,F&V;C
+M+)J0IC=U'#QJRB[LPRUECQ:&C68"8T,EH)HR@S5E:99CC35+P)PY0YLG1CG2
+MQ*C@YT-\%X+LT<;EU-*.XJ6RJ:"J6RM,LQ3+*X99EJ;PMF-C*90R995-65QL
+M9IPRRMC%PMB90M,R8IEE9K4Q2V5I;%2V535E4RRM+8J6RN&\FE$%F,JB&LQT
+M;<,S$REPN\,,,S-Y-V5I:,Z;#B#((`=$F95@R8DHQU2HPQ6%02:&!C,:@IF&
+M:NM[F.T,'HS(CELF>&DW&JE#%AFR8J'-XU)H8JE2;(,&#&5HUK"%NK+:3)#1
+MB&6JQK&2L(Q4YFS8;!@AF*:&\X(4MBYS'JXFC&NW%V8;NF274@8B4\Q*<($#
+M`I42VB*\8_'P%$JPPP;DU3"FG9=VG2VF7!LM,S,04$O*J!8:8<<#@3?GZ!>A
+MHM)$!DZQ=MYG-[V5CC<REV1G59,FBJM0P,FL[;F:88:WMLZ,B8WMDV-!@V%4
+M6R6Q&=YNV$S(WM%B20Q%%4J=71T'0&A.@)()B(H#D)G-<=H<9*"I&W@ZFBR;
+MIFQ1A-ML8PP;Y$SMR:3)-.`T/),HE<.!P#2\6"8B(0ZSG'8\9B"G,#<F\LU(
+M40N":-M3',0V3Q#.9A,K+948ZVFY&1382)$I244#N0+OEO:;6G41LD9!FP&:
+MF:BV$F&=L[3NP'8I<536`NNLE4C<&2RI+.X#&HBF:*5=R`]<NLZ>EZ%Z5#:L
+MH2U`5,,0$J/7+>'':Z)0@A8D,G)D-RID)J6*0TAH:.-MN:PS,1F&:G,\8-KQ
+M7AQ6("DH$ZZZ.DV)T$41%46Y#)-8:-CM=C,$54CS9B:I;+!@;-&=8D1!A&%E
+M[&@'.308:%@BIB$P#,.7.;DU)Q),`'D;=C@&Q@F:@#4)J"5Q7Z.IB8=K2A?M
+ME$@'Q)$000@"JW[1[4C4"W31H9S30LI:M6I/8RNPU)N#+2BCK*$WE)B"B24#
+M`V;-FYTAN2`H+#&2<W1DT92\ZS+;!=L,0W8(P1<M.'$-LPS5R"Z0X2L=E*ED
+M*U#>4RDFU`TF]28<TH"0(X@8A7F6"*%,,4S"R1%[RD#-*JTF$R9VVNF-YTUK
+M3,]AK.59Q@RE*=,S,-ZFC1LLRT,4ME<'(J6RN&[,4U9:,-.S-VB*:<&RTS,T
+MB,)P0A>$000,80#018GF_2"1GT-UWU9T='?>FX/@>0-S9P-O`B**%P,FL<TX
+M:K>L:MC#,WEPR#?,-S=UA&R-"&M\QG*Q@FQ,$W"6+(U<+%I552&>-&AL-P;D
+ME0E@J()*H$.5PX.E>#`00TT2NX;KCH.2TM1#"[A-25#"-FVYSAQ.DX0RRPF5
+MELL,[RVF8&C<15D6QBL4FK!;W;Z3:T](FA$U&T80W`.!1(DPENP&*@0W(FM&
+MM+NQ7!&V*.@74@N2`N0"[N9:PS2\%VBX(G!6%H86H2*2&"&K:(;QG#N38W)M
+M22BI+8I4*R#"&0Y4"]0%UK".AVIU(PP-3#33*MHP`U`4LH&`-#2;8:Q$B#21
+MM'DR:-G7GGCSSKKC1EAMYAIY6&6&$\VX=4T\XK#3CS3#S+:E>5U76U===8<<
+M52JISOM3.>I&F-[-(9L.(=Z-;YK-.UV`;E:!H4V[#:&E4R#QS..UP#E#%$Q$
+M5`'?71LX-C@I2U94&`R;K=5S>)J53#9IWHXA9)<0IBJ+)Q=8:0:AM*QAI3CA
+MNQ29-IEFJ;Y0YV39#2([!#+4":@H*$3.\<I=B[$*$TH0+"0NL#`)@@J%,@I4
+MC?6]`6L-0G`7B`F3D(F0T@<E-UAIX1N&$>;LEEBUF,$E"1!(AUT=/29TIQ0@
+M8%LI)(%5>/#7K:\K3RJW,#2N2&H&HY:30)MU8M-44-$J;C,P'9"P.M9LEF"(
+MJJ'-:9A,=VR;%T%C<%L+4N,8D3?-X;'7*0Y$)P&H(8F8*4-QWRZ#-AN"4UT!
+ME;G*=V!-3#N5WF`[E*+(`H'>-`[`P-FV[O.MLFTW5L,1F:89:MTSEE[#4N=8
+M8-CH*;WMEM;G&(NLY:66.ZPTJIBV;:;UO#1P*8WSCC5;JZPU:F&6&L;TU)FS
+M$W9F:9SK#9L<`0P3%6<7B<5#6X*"@%"II&&C;3FWFX-P,=:P:DT6V2M8F)5E
+M<V;="N<=B&`.DV*1*4E!2#J&ZM&1P"TKD@&Q*;@@8F+B"E)<8Q*JFK$C;!WB
+M<)N!DN(P,LL242"<S,.!M#0;E!-VS+!=T2Q)RRA#6<X[3<$30$*WKV]^5O>0
+MU.W:\0.J63FYAI!8R&L#:(4V86AS!(0"2;L@ADN='=@:`X"/4J[A:ZNG0!TJ
+M:3I4B!H:U!D"X:WILU";2;0LEA2E5O&%H-[VR%46BVH;O<-QM&I$F9EBT334
+M%-$68+SOK..^ABCJ(9@H@J-0/.8O)"#),@W#)EN-B*)*QADX-&;O1F4VS1SR
+M^^'Y@0\)[F4$>KTP&)A(5.Y4:>H_8P?VG#`CV%N]`[+Y?7D<@[X%23`^'7L3
+MR/9/7>\DNBJ1)]AVZ1]OM"+%L`NDH(>\;[SC^25,G;?E^UK.J>L9V?5YLXWS
+MN_"1Y$6\.,['Y!^I<8"C\_*[CNQSTO>D4J-><CAET(,)EYTXZES)P<&9;N?7
+M['K8>ILAB#GN7.X[M.5(Y8=)=J*_$?'$;3V^?]&3R+J-E;GDV<G<PKEE(T.[
+MN8SVR0Q`5LOWC#@F>56E[5S'<S0D9O!XC")_FC14!K[T8OIK^=:GY/X?,3X8
+M_[P/X;YF.X.G5G6\3T^U?TF?="TKSF`Q)@]SNKNHY51YNT]=NE+'8#8A1S_B
+M`O)09X(H!<!MA!0?7\1]9]:_6S?3Z_H&22JA2ZK3?1R8K$,#,1*L"V&:HPP!
+M;._5=]UY8<D<EQW2K0JA@X7RAG*AP3#E2+*%-7=I,BT1I4BN"E)?_!.\'_KD
+M*?[R%[X*%7V^@?VC/^A./J_/?L!##\K#L'_`$=/W]>M]\CO)HI\[B$D'XD:!
+M]!0>-(P;!IU+\-%S$XE75'A\](5EMF;8JC;NSW`PH=WS;]=]]JWU&=9*[0,,
+M0KN[4=@VY<D*SY'#AG,%58J)#+,KA)6ROX2FYL9S-XDO/EP6VYA<A8,9@=1>
+M7,MDVPP%:%<D>5$A>H$`=K8AF"OY_U:K%6($D/_8D(1$PV8X[H4:^"Q6X*M@
+MA33DM1&6EE>&'H=F53+Q`P(4[X_06[DT&2=?6S=B?+P=_QJ+RHO0=?'S49C>
+M0QS8$Z51GS(,$=>X3<+F^YP_<%C!U`K\_2'UBE4D[Z9A!'!VPH.!BMP+M2P_
+M&%C=!T2Y_N]GZQ[;P;ZX=%X\M#OW=J>U^OY==?7YCVY?#Z#C@P(<KRJ,#]W#
+M-ZB/1Z.`LX=XKKZ5F-A+J85@1AU56J5.Q8PX].CT38>'WT![:&P_/U]0_5CY
+M`3UZW("PI^G\5:SIL4.\L&&G[H^O]'BS^1:5^0Z"1YP.Y5!GN)*[[>>)]^T^
+MG^&AGG?HC>;\R=AQ+<KT);<2J$&^@OJHHN3Y^(\CYGKWZ')V797/4?6)E]^O
+MK@!S]<J`6(4%7#*>_O40$'LOUAY%>EA_>0WDIOZ%B7+!LY<>CI(WWA=WSQ#4
+MS=&MJA<>?A`S[+WU]F=FK%AU;;V_7GN!^GFH2B/1G<5LR[=:XJW\?.1`"N%L
+MCZJK=,4GI*I0DB;@+K`DZ&MK/CQH5&=A^+&8)W92?#>^I#C1$D#SV4!R]A1Z
+MU76RI0TJD#/>?-3EY[ET1LI"A!KU/'FHK!G^<W,;-EE?EQW*%)L^/H<E8"VM
+M^CV-J;[FJY]&>$@HP^H-U](YGI9._!5M.*"AX5%(V(9;RL/B//W+BPN*&F:Y
+M*G]+/SWKC[AQ-Q6'1[.-^P]L=_N/[?>H?/4Y3P/1@>XGJKP04-<NX#DH>9^?
+MP@49/W*FMAG</'I<H2//@DWO&FQ!;0+C]9_&B$;O^5CGQO:LLRE!ML'R?8?(
+M-L]:8>DA$88#SSX@;/6W<OFO`7^L].,+=W<E\B-@_`8?0H#RX/2.>,XGA@*J
+M"-RA@J!!4O]38P%7=6&4E6[?M%\R-B+X4=^#3\]ZSC4[_.=A"T.Q[F9ATY0:
+M(%8/=$DGOM@F'P-P"GY`26F3G"X?@Y!&`X`([=E#&E*@QL1??L(.L>%=2QRN
+M<9X^(H!X4,DJ!@^JO_)NK3W.+Z%6?P;I"B`=ZH%@[*!BW@$&=P)LN89^,5=X
+M^)V&G]&L]R9QI:]CC((V0C!7M>N7@Z\._>)*YJK)W[3%($"EPTLG@S6Z>$_9
+MV?N/7Z9Z8$#/>E6SD]:ASD=9\%7/;MOASD!A)*KG'J;M.MM`VLZJGG+>GD+]
+M?*,`Q']JK9`[:?[*3KW5P%XI4X4.P(OFX]7R`5K5<*&ZEV7"MLW+H("?B78@
+M-2^OF&JF'?#-Z1T5ZVV'KC?06:*^;CA-_GM7*SM],]B`U0RIU7AH*MAE*[]-
+M.@W(E";H*0TLM6"%SQ/+G3AQJQ0H6DQMG`D>Y>%7.)E7#+6=^3CW'>LZYV&E
+MECK9]/`+0V9F5M;4D2\6H<8,_"JZ[YG=>".B8.;')(/$=8DR7#\UKIL94&:E
+MN@.V+V?;48QH1FSC8.H-X;67.<5#+5*JB`9EL3`L%6$=?1#';%SS(U4E.';C
+M=&^NYDT,)5:2UB>K"AB`E2JM7!FE67ZY$D8(<C[;XR['"\[.V5XTZM&`_9=^
+MP59&5'.7,]Y:'GAR&R'!VZT*XZL3R_.:N.%T8&.=+E-.>FPQC%+D0Q@:F^2G
+M3:\S1Q8D.QW7.%0@P1095UPL'2[<3X=-:U`V?GG2;E!SC!$Q".[67?98;71H
+M''MXV?%T7X?8F;._M?@C(@%,"74$[$`+EX<9RK<EO(<1$HL[8S7=4#.JQ.%3
+MGC?>\U&[O0VU&76"N!4+*6<0(V.'8-ADJ6W;N;.EGJV[T4W.8=5;2D"W4MNG
+M;IS-3AMTX,%W!.!Y;L3TX_?7;,LLJQ&_\$_9GND*$'8#A%']A77O/D1^3N2R
+M))I8_L=CK\;()!JO)5\'HLY)63U=N5#@$L>(`E(*=I:Y"TA`^DR'Q#7Y^#R"
+M>O\QN'!%GA6&]<RD%AL5X6L.&!Y%\MZS1D%5"K-AQAPH)HB6/>:<</TD.39O
+M`5W1F+;L(9?\P53T4:;MNKBU/?F(T49E6%++OPL'`H4R*-U%NL:*R0%/R+%@
+MI$!A%0P!(<Y7-#8?/U+X#O(]HV*@4"+Z!AY$<`H>OO4-'54^<*((!(-4\HW:
+M&_?\$QZMQ$UU!WK,O/00FZCR$EQG/Q^\#,#,?K;<\\;'N`?"ONC\A7#<\NP8
+MTP5S'XIX<$5[O]OYH\Y[4=L;\-PW%9C`JE<1>_I5:M(,"R(Z4)/PG2'1Y8>6
+MVXD7]IGC5<VVL-I5$WGB_1G(G''CM[M[V*^WXEGR-'A6510)%Y>#B%?N]3<S
+MK`-5F]P.]H<J:8)E6*9VW#[23UW'6_=&CE+U7<(SH9,)H#$PX\`V00Y<'IX\
+MX<6*4TH_,X@IS(FX'WNQ*'L[,1LC#&1Y0)(@6PIG,O(="951P4B%E5`W[!:*
+M.#^*AKJ5'@>]AZ&PP!\+SN/>8IN_B?I&0(P,6O9F/U?T7O#_4-]8>6"@>HC8
+M>3,/7[':Z7BEVL9D/U95;TT^3[P7@8'N%P/6OHJW^8CG;3#M^6FW8)IA)VE?
+M4!O\/X#E]]+L%(QJ//:O3TKQ%]",LY3D@>UH9U]BVZ3B1U7HS-&0RA<UZ=H2
+M95'[VE'-GN*/T/HWK6P47]:X8KB!D],[-`7W-K(Z,&C@?/<,#8/CY<OD^CGR
+MQQ)D69]'GY^B*)XKL4(''8]\B>OYO1^6U]X5-!%4-@=M!F[B5A55&VY9_6OC
+MK`'1^HK(]VD%`1[!5A>ZXI?</GWBS/H`8_!_[3`!%0%3]!_,`_Z7G_(!T"CQ
+M&&_'^[_.O;U#X^FA^L?=W_E["")'V"4]/GH^KNKW2/>"!OZL3$*)$_]1QTZ2
+MGX?W_^GAU^&.>X//LL4%B)(*'WVP_I/C@`!YK3_:U,J7KUJV_IO\KU_^7FJ(
+M;^`?3`"'^0['ZND3*?ZYJ?UX4!GY>_X?3_1[-Y7'I_V^_X?:'U7M1_3]7M]U
+M;BL:B.>A_O,[1O,-.F>FK,"LCX[\!=NV!_Y7W<<5H:>\SB#S_3QWCXKW'R@1
+MWC[N.6V/CNW#^"L/K=?XEM@@-_DV4?HZ7ZO+N=\HB)W`_(IY$!B@!I/]GU83
+M=D-6#_HO\'_2_UG]<_YG^AIW`EA!_UR#_8R82A2JT1(/RLE7W_J,!,90T0`3
+M33J#$UH<1,81U!FDP4QET$H9IP$QA31&:<!,96D`TV0)0`9"E"M"B4`TJ@3(
+MM`L0BTH4H`T"Q!$*E"+$@G]<(@9(C2@M(@4A0*$2H%*@!$T*%*(T@%(T`E*"
+M4)OKK5!M:*VR:HUJBT;6-K5ZKJ[6HVVIIF,3%%DM;1M6(U"E025JREB4"E&E
+MI:$H&D&)58A2D4)L@%,@%B44H!&"1:!?O_;AH(!I0W)C`M*I0@%"%*+9@B9*
+MD0K0($K9+6+6BM;:*BK58JFD4H14H!(A5_E_9_J_V?\GQ_Z/[[\OL_-_#\OY
+M88HBDJHS6]Q]O`_EMO[Z.<_4`@L:S`HB4]G>B`8-?<(9^=C\I0[A;U_YOX_[
+MO\>GZR%('@(1_A"']M[0&V1/\</B_W/Z<!/XP`;)3GZK`\I`\]33](@:(=/0
+MH9V?V?S:Q"'^EJ2=?'KA)/3=D/V^ZPF)(;/'KGL0/IX*0]Z!]@.,D/5`/PW8
+M!V9/Z^+/2$[V0\^4JSW,#"A+E$$D(GG[.?;]7U=O9CQ*(@ZZ4(-W4!I9@$X7
+MNT/V0'V0%*!]C*GYYY-`&X5Y*?63Y<<8$.>UY&0\,(@BPW]OYM^GM^@YTAZ,
+M#YE]D+Y@3V?GBK[?7*(_S$-@G?@P?D2!SVL#V('A(>$.&3RA4ZI+NPJ'*/OA
+M@NI`ZSQI0R3[9"^7\/6P7P>L0?J?]C$/JBTC2I^L_/9)[5Q#G&<P6H^K-?V?
+M\=R3/G9)8R!S/J_3]7U?7]9]6<<<]('TL(?#P4$^<I^F#S*?*`.2_6!.H0W`
+MO>L!_&Y)P@.0&M8I2)]_?Z-)^9>2$ZEZA+\OW:0?7,*1]I_(G4AN=[^F@`]2
+M'GZY_I0P@/I8<(/DH<O<_&%G5`1D.Z0J2"/HDA_#\@_6?7]8_E]([-G,^;)#
+MR">"G\F7K_K$]X<`<C]0V]WTZM[_]:JP@$,&'N'=WCXBB@=X:^/O]*'TI[XA
+M/Q3Z>F8*?@,)MD3WT#A'D`GZ$G"IV"KPC=&1Y9NBOW]N^'M>]J>GK.)A\(^C
+M?;[:WVBCL-G=-S;&[KT$X<]AP(8K6&5P<+C%.RM+U%16P[%`."GF0.I'YOM"
+M!4#&)]2^ET`\B/LV"_@:#"QZ7!/S*>G9$II/AE0GR.YK*\)/`D_^Y.O']Z&@
+M[GYVRN_A:SJEXM]WC1X0V&S[K?TYA`_ZV'MYXP#\(D_&^/K^>K;]_'G^<_;9
+M[#QXOM]W0A\P0/)/_0E^UA\")/I^CSCW3^?)H_GL@=T]'C[+(7H_KR!RS-V0
+M]8*AM.4]4A]X)('S\_IZ9\Y\?3P/N\^P,D\%``Q1R/+UE5*#,J/$KB_<""_B
+M=`A/H1Y;;,#UY9.XJ.SN67N^C]G^N9VPM3$16/&#%U:P++91$\P4\`?#J?3X
+M>`@($$1\/0Z!$3\@]:R?64"`?#S9D[=.K(.]?$^!\9]#*07=_+T6DGH/O]GS
+MP)U9T0\(*3LA/H0AJ;T>#T\:-<>/:-"!]0DA>6P/DP#EAUO3MF9FH'[D4Y?1
+M`G]=_N,D_I$#ZT"?D\I(_&DD]\@*25*Y7[L/VPIT2GR?R_#Z:^[\C?#G/M^[
+M\SKG6GSV@'?Y,H(D/35_GMA#]8)/<99`_,S[4F<[S\Z`>P'\/I*B8>GGZ#ML
+MD\&F@7M7NU']>\4Z_9ZS70P)_I_384GUC^,I_4R)'THHL]QE1^?4[;=@+/P/
+M>!F$"=/F6$/;SX?J;5#ZK"'J7SS\;K8H?80)HO'T^_2$..E`#R<Y,(3OXO[_
+MX:#"?@)/X_IZ^_MN$[,E$(>_]/PRI#T?02`?L9`1@&>__'A('_>@3YC<#Y^E
+M/I]WUDLS.?A]*M`GB.#\/J<?=_@J(B20@^WS%QG_!"3^'1H&_L:0GZ.?&$#[
+M1`#Z?R_;A/R03S"OOO^?0OW?W=:`>H3^;O?SVH_X)N8I_BDY_3O-(/O(OD@?
+MC]_/RUZXJ'MO%$_HUD<QD_:?(',)T/-`A4DF,`^7RH!\/X>W`(<]V`/TE#WW
+MBAW\OT_7_&>LZZ^F(?OO>0/]<J':C=?]^INI/*,>Q)/[4ARP?>[_R-20#'!7
+MI]F/J^GM9W=U96?^'SZ?`>'7_'[:^\$?:26/^!'\Y_-R__H?R9SH\7/Y.NWO
+M>!/C%QV_K^G]1<;\%0`@'CZO:WI9-,B*A!!'\"/%POV3IA&H'".C_?@:\G;/
+MZZ1)]S>[?[I]'$Z_3W_U>*1%_0H3L/0/YD1Y>K\/2.%._A\GV1$#T!W`>04_
+MF[_PD_U)/K0-1@A_Y;_S9#\R0GU=+.O\J0]Z$Z_Z\6(3J4_=/]O_C_XA8.I?
+M\HH&.)R?;^P/_Z^/W&`/BDZ8)`_K9Z/I_7_['^X_N$-'I/M[!^_(?ZR`$<#\
+MWX_N;X?4`/V?7^GZ%G#D#\7@/C]U_H/X'=5_'RJ>_JHF?[U'\S[O\9\"ZJ*^
+MU0-7GY/C'[MQT__F*9849%^S*E]L+^74,.!8<E]&15+,I%"8K=H;`:"][8<.
+MN(_4SP.57]LY#!L;;BG$?L:CQ6E678]88B5@+WJX.?Q8GX^OV_F6+_9[/U_+
+MX]P'PK^7K!?KT[0JKN%1G\5?T3[17]B(J=_I'P\`/)!\^[2+\DUSGP%=NGDT
+MT!&1_/7[_A<)*^D,WJ3.>#Z3Z1SZ+!]<CT^HYJRR^OX?RE\#R'CKTCRH5L/(
+MAQA/$=\^'3X='ZYC:O9X029..]T/\518SKZH`9R^PW:#3MI:IQ.&#/O'S<*[
+M7+QQPN?3]`>X#VC";;^G`MN1/>.I&&^?7UX^6M^Y?EX/Y@Z\!U7';3-UU/PY
+MY[>6?+5YZZ;X]J:A[`1/<OOAVYZB/#X11FW-@\X'G[M8VGJOGZQ>Z<>7EGC?
+MU=<#@WN.Y@#S[F]<4Z\[W6NT\VK8&`_R'K\!3]=^@$D=N"AY%'JVCL>\./&7
+M7GHW,*JKZG<->O'V7%^GCD/XQ/KZ[R8^IMNX=+YZ;7H:R1XVT6J^R>\>SO#>
+MF%X?#;\#JTF-MUW5L.@Q*@"96O4X:3Z[\KB19]6!69CFEXP/"O'P`O048YU<
+M=YVX"FK=PH]RM!@</_'"@>[V]-L^G/CM:D;=ZL1SGQKP.VPP0R^#7M'0%@PM
+M,M)'M"H._E&<?1D\!Y;<^0=`-_DJ-'O8"MQU/TXY1J?GS^!/Z09!]81`I_06
+M$*&3X9]73ZOAKF3C^BD/X"&AD#^7?NNR&PX8>/0^'KH)/V'_#6>T/N5Z8$/G
+M[2]C/_C/SY8&GU_4?[X;/^)\C]4#Z6U5!0Q+B)C_&FM)#Z/\=3:?[6H`B?3V
+M#[1QV0L@^_ZPQOE/BAV"?:,;(B80IZ`,.//8H*I,`#A$Z)24&$*`V]#[?>%<
+M9X&$R21::"#;2)H?+5/I10(88^>!)#<AAD@?`9X&1D$DTG?Y?9???Y1N?N7F
+M701*>.,?E^Z>[/XF4[)GM;,*,%CE%OKGK*:QTQW^V^G:...[A]E[M.".+/#\
+MF-+K9O3B*PW:5O98]KC'8RR_J.-GW9^2.W7JW3\JX?93GIBU#=(*GP/Y77?W
+M+5<[EF^]D7WO"#\Y5_^W+1XY+'_NV'\^?]S7"[JNS-B`8[E:!Y&W?%!S#88,
+M?'P4.0KJ*\>S.#,4\+IY&7*TV%Q&/^4>H*WT\OK]/2AK\@_T^#9/_;^W_33]
+M.[U__'A!)\OPV]31W>.0PQ[?#EX\_K_)'CO1^03UJG(([_2.0WL"GOX[_W^K
+M?]_PQM\R"?E/N^4?GWV$]1Y[?$_A#CU*%/VFI5OOYGQY]#-:X#'CMH%H]"O"
+MCQS=?[%JZW\E<?V87T+B!C[-X'8XERO[/6V?RY\;6%V^Q*7TNOHG:3O[6KT*
+M_I[0/3[!VX?3X7INOM^'5^(:[@N(8>]O_9A]5/VDU<?3BQQ$3Z9_A43#&.YH
+M&-JLXB#$8]+8?<I*L]O8.]+T__/V,][D>;AQ]KZ^7RE??23V_&S"=O'P;NQE
+M=L??^`/T&/+/@!2_B;H0%(A9EPY`4D@"3!UCJ/5]OFO?G](08^7'I/AW@YZK
+MUS,OAI-3\\NZ^I=W&RK^J5_E4/X<"0,[)EAQ3#O;[H&ASRQ*[_@W?WP(]96,
+M#XM;/K@K2%^/0X?R/6<Z>W]N?&^$[?$AU]?$R2?XQG^5D*0Q)EL#2)AM4Q/7
+M@-ZI#_J/B>H\?Q_GS0Z_YA,F!)#^Z6:-G[%`.`(0)*O"5H<1A3"$68_X<3?+
+M</4G5C90IU([9VTT!@:9'1W6P-[[)<;A%1R(KP]&HC4P8!AK)E$3MB$TTMNC
+M,A#.#"#$F#KN8&V,-')STR=-L'%FY33*YF>S.IDUF9F3$@DF3=L[SCP-SLQP
+M,.*;('&`W1X>!F(--3$DG)8F&C"35)$A.>R\QLK_*:=G<$Q+.N&&I:L@<,F4
+MW;EX08=.*H"NR!T<#%P)T986(;CK4L-`.K:2RRRJ&3"I$,0C1HV-C1HQBLOG
+MNO7X;WK9Y@P[A@J]6>E1Z6:EAN/F&;!\63$U.S4U)(`C4J0JH0`(GM\.":?/
+M#6D[-NPVG;/FY#Y.S3DVSPNG<XU.9V:6/BR3;LPDGHL0Y`[.@Q>/F<.$O.\4
+M4'4`#N!CXLC+.V7FGCTYG?_"UCAJ>$C\6$@UI-6%7L8,?/C$]J><G4D(<-2,
+MYF>S\;AM8>I,3TQ.J^>W/,<[,'&,(A#$B)!KQB$1Q1?8>E![2:#<:)%T0.R%
+MR!&7;"D081;8GTP8BH6V5XL01),&IA$$&_2S2;*3.W,Q-ET[LX[6$1%(<D#;
+M@<YTO!XG%,Z(F$S.3$[-&L3>9O9N=[,ZFV:4\T8+FIBU5N%TR7!B;GH$DALA
+MG;HT@H9#S&%4VR*"&D%WO;WUK3G)$G--3TU$ZEAG++,;G%P+-N/G#6\PB@EC
+M&=.`+J8BG1%33@5"DA,15K6BO$M#)S-7!%U+,CF&S4E-*+H90$&9TU-:H498
+MD93H9F4$!%PN;>.9HXX++`K`KACM\(BO>_6M2H(=&=F+V$HQHJM&8Q4\68=F
+MF9F-8GI<\:6XF*Y-/1T[>YYZ<[O$>`$?,&,C5-,@44&^/3MVTQ$140PRCD.2
+M[(KR<!7"10VR@IV2@@1IWMR..,Y215DR4C%-OLLJMLW*P)!/@E#+F'=:4'(J
+M)()A:#1S"M+PE4PGAHQT/<N1D.$O+HLSAHVS0]=F+HT8F/8H(EG">W,##["9
+M:U-S$IXW](A]*2)#N9V!G=<>G?*.."8P-K'QY<?#P4UIGWO#P\!K'O,._;L)
+MOV=XA@0V?;ZPO)ALMLZ+TWJ&MI05R(4"A:*X:7GG1UC=01U;.RN]2!,O"#<@
+M"<8559V]&ZL>.&&\S9UXTZ82?-HN;KHZ+DPZAOKP2]5I37!F`,IQ+C+9AEG)
+MC"M-8Q9<I[.]-LK>'#9;?33`R"J*[SB69-$$,G)AVWV<@]@9FPY/<.ZP@=5>
+M0/M!=H;X^&_>SWK]P%+`&@'X4O:'/=7H!!@?JSUBO$/Q]E!!^GO=Z@Y[0F,"
+M]?D,\_)@^!"HOS&`^%G*?L$`%@@>[SL7!Z(V!T'BA?G?I[O,,->@%NX&9)([
+M+)!U8TIMS&52S)QQSG9G9IPCR]<>>'!X8"+$HPP@E5!'VYB>TIN*J-K-\<F+
+MGT].ST&$B$86TY@,,U&4R%3.6E4C,%%%H42@0*MKS4\+9Q8DQ.,$D3ED,3-F
+M',&53Q9.S:(2&)2E+(XL:EGE&J=,#BQ,V5%F<##1@8LLEENFXS>?>MO&2D2D
+MIO`G5=<B`G6Z,MTR5M]9MK+I4UOPND@[9\LCH..><U0LD$*O"$50Q-I*9#,$
+M;LSS..F"E[DR0\D)PA#3/G#'S"Y`52K9NO=TS:JHE6RLL2J8FCQ[)OO,'L@-
+MG;@"[I@Z,*Q4JF)F\W;;<B"202*]_B7:\H/>(B"%A>7EZ##`BH$/9Y>WT]PD
+M#%^7+/3D!$P?3?OSTUO:5'EG93\^GYYF=F#N?QB&IZ;>;^B$A'HSXK=?5.@*
+MHD"SS/TWO;EO9ZJ57&;IT$58(>60U!URL33`3X[>G8$Z,V=:89Q.0L,&:C9T
+MFYD8A>CF'!;-7DUMV'?&;(T\<73`=$,'6+TRQYAM7U\98>MQI9F3T^3$;MP>
+MF60:CG9T17;O&#CCWO%ZV8/<G3/@DW+.I3W<#SLT?:E7:STZQ>X^^FSC4:?3
+M'5S/SC;-\R5N?2S\^S&83B@>ZO4,CKP7QOU'V5`_'PLL<.#\R`,(\-0\>W%N
+M!D=8Q=$Z\./`\YI4?)+,J"ASR[=.SP^-.]'3ID!73S3L[">@9C&^0?K'+VFP
+M]\[\_>GKGO0'PL'P4[<+#<O,\G'9QA\-H(ZU@=/B<>0=:9P.]NNMIX\/;PV[
+M/#T';QT0:>E5-0L2HH>3IZZ>^W0(B!U#O9SU.U-/?DR9LL_'IMH9LL23SJK3
+M&%A`0T%'3!C;9C089#IX;#3K?&*UY]/GI.=X9T^7R9L-N.8\UH58.X7(S-9B
+MN31F$R76,3Y@PC5B-3V"='9T^7:F2$2$;QSLP<-=Z#'R]N.HXXX='1KLGKCW
+MR.CM-&G0'4JZ9WP>G>@U/E@T;ZTYPQ?*[<X]]/1MZ(T4"#?CZ#022%/5XTQ&
+M$'Y>SU@;Z2[#]L`)]YC0('0/M?F%B]GL%^X3Q&>X2>6".G772>NN;>Q/3>O7
+MDZ$7U"J@<<=AO+<WC+\KYELL]-?,\9?'M,X.^D@XL1B6)!N$JSRAA9JP8I5*
+M"FBIG2C''`0%-!JE9WY<#3PP3LXX+CI,=B9).;=&''0KJU)@RJ''`T0O(7HE
+M%$=/?C-/&#$I>/,L[>FVIHQ)IA]J,V-U'V8]G#Z=?<V^NWEG'#F&B\6Y?'3T
+MX>'9Y7CVZGCT]FNA%5=N'7&CFSB\V'/"C`$D3/:'ZAP"H$7=>KU"@0;4%V9M
+MU$7FG7H4WNVUG0>AFV,1C,VB\FO>F&>3FVAF5PY,LS5J1)Z42$PS97'SPU-3
+MWSBW$YZ8AAESFBJ=F9EYJ?68E\VK#"UN69?>]YN-Q9/HIJ6,J2I1TDF*JDP]
+M<2/E1)]*@C,2T;FWIF2,I8CV,".+$R$JMY,00$Q$3A*(:.BL3;+G;G(#KRXI
+MX9.R7RR&9@.B'1+UX>:0YVX#A*<"!//6=L&>=OF:D]Q@\NK(]\P>7BGTW,S,
+MGBPQ0'P@(#\)X^\*\_;Z>=@G/9Z9[J+\+<&2Z91J<D1,#4Y.Y/.X??=FIJ<P
+MVN6^.AT]&&''GG3MX$V5Y#1H=!QTZ5Q++!,EEFSI-&3DH4-L/'\WUGV_N_E_
+M\?O_=QO^R9_C_C_+?_F?MGUI]O[/;"_@6?G3]:'Y?HC#\H?L/I^Q!%_8!'UT
+M;X*NOYOP%"01N.18(@0$N2B`F%4,R??_`[GL/6?UZ#^)U_C_K0&3QBMR)G6'
+MPD/WSX_%_91H4_ZJ>?0F]]_)/2?/Q#`-@)W/''B`5@?29B%$6LJ#/VGK_8\A
+MP?_0_G/=^S]^>C]_M_U=80F&G_+K;"A0[)50,^[[CYG_5X_?^Q^O@!$4M``@
+M01A/_,>L./B*%!D"!PHO0'P%\V+\1ZO<Q]YYG]))/E_*R0@?;GU?>RLT*<6?
+M3^^F&?7]W9Y[@_\!0G02@M84:<1D`*?TK(3*@F2H>F#24P)AJ9++)BOPK:L>
+M%?^QIG:+\,Z3S`\!Y`!I9`(=`QC<$X"#+7O>&A>P#P=<9[O>>V-[VB@3YHX$
+M.EBGL80"N0Z*.#:\//!5"L0OGQ$]6K8/#LX>R=X`4$;'O:;Z[EKA6UP%HFWT
+MS<`K%64400HA0RJUX(][SPVCR\._/>>D##WS#M5].MWI815/R4&`8$E1`=0)
+MX-\]O1Z]^%OV_(V_Y5U<8.RL]UC0]C%[5D.R.E5QNZ:&H+-T4[V(34JW3R\/
+M>JXN<4"*[%E8@M:S"]4.FIP6X.[+([+PO*F.+A4(W4[).9M/:XX90DM/S(FJ
+M,6R::"K,@EABYA!/L-FZ8[GI%4(K*7G006*IS&'U'U6O<CO6:]A[7"ME!38<
+MO<@)(*6"=0@.CW@IH'@UM:)3L$Z2?$';P@Y3)JS"BIC&YE4IF;3T$DZ,I5AN
+MP3>UH0Q=P55NC@0AJ.O:NX;(6\PI':01!VVO@`*8-('4CXH4:`\#U[GQT@_,
+MW`6W#7;)]\`H#[39%C"@8WZ+[H.></`?=1^6?=6_8/NQT+5:,(LH,T(\>5&*
+M+('PTKXR1"(B7-J^20<6*2A%B-8UE[8VB`9..J$J^$AL8].`S*_2E=^'O>]Z
+MPT``N^P9R1"2(X8![P'A^$V;\/O0Z._+12L6A/O>FM1W`QJ1"I,&=G<\58OH
+MC[V`"G<TGV<E=R"`_(&5OO`3WO+9>S[3=<?$Z44):[W@([!Y,C;D#2U4Z+5#
+M@C@6#]@8,W6)>7!\Z9!F&#/O2?04?7SUN,]>YE+`GG@=LD]XX#8S):J+`]^<
+M!JK=5?VLC,(WJ;X'KXRP;>%W5&J0S-J\2%[T=6S4!3);OE;*&'"[0RN3$SH+
+MJKT5E97X=N?O)(=\X91B=^V:3NFM4+<Q=ZUFTDE3U$(I4#\@D@E]5',N\PFO
+M6`;)7L;K/>Q9EM!62L(;)0#/CGC=*5>7(BUT42<*_+NFI##F/EEU<Y\1>=TX
+M'1M5[HLIY4NEONH7W#,N^+S*<L:;OEH,EU>.\UP;5)G=48JS95TH9BQSIG/;
+M-TD(LSGYSD9$Q6\Q6;58LZZF9H=8(:9FF,:D&DAE*VZ=%PVA2-(4<]Q&JTB^
+M4!W+LBHJ;N+*Z&_>SD3A[KQ82;WG7`5[L%7P[N%YVIU?1CCL[IMEW=7FY'1>
+M,75A6#B8]F-7H.%YHTA9@6A!5E0`Z=?$"9!V3`G(-Q%M3>V:G:1?<&'W/C=L
+MSAS3,Q-JTT`@V2PV1G"23*(`C!>G**"D"\BX_W`7C_ZJX!&WS`3.U\%='C?#
+M24D@=D%-5"`TRH&JVT-B4\E7XR%"2,E%51)>9A@E_MQ+\'1X>[YC\\7YD=L@
+M9"<?$](HB!5>;UNJX*:`,C2#3-M2S-L'6/S?F8<(*$#)41PE1-LJ)Z9!/`R`
+M)N4"8/#K'Q,A&)8GBB/*2-4<J3\HG(W@5[U"W/3W<(/8,]P^`@SUAOWA?K"]
+M1`GJ?2H3RPC-AN;XR]+&=F#Z?D"NCER>(2((Z9L,:1C'/4<)V:P]ABRFL1J5
+M5FI8G,OS*2`R]-GANX[X=)BBIO?64/6&')U&0NH^TH^A#&C$404B#?Y3[FS<
+MNC*J*HBGS>6ZW,T4?>L0.8HXXVREI;*1"1)Q:W$8O8D6#<80\%LOP)]X$@GA
+MJ34(&3/G#"T">%\>;XX=\[@[P1#<.,8Y0R2$AA^*&"**BC`4G^`K#[81-:"K
+MZ*+@(/NW/R=F95!=6=^AIE>`58K51$MC#_+CGA]LAO_Q_T1!!0!&(`R4((8I
+ML&8;PX7,_./7QAY'ZH_JD/,"/8GVC[%IHHH(158B/0PL/:J&S(62`&\2VRB6
+MC1BJ=$*:39=1H894#4!PM0NT637ENN6)YQ<VC,6"#J396TWH%VDFM%8$0$PF
+M0&@B-:T,3D>P)*&R>$@\EX;0<(B@WO0;VZPX"6E!2VNY#O4F5=_C6WG.:_NV
+M>&K1B8&$8F#$8C$PM8,,,,,,,8Q%67[OKMUSV=ZUK@U_3+E;?B1\Q56@@3GT
+MOZAP**-5Z@];?P0PFR$=MN_K5>,]?K!+B66V-*I-,N)O.$CSCZ?E+9/6&+%K
+M8-MZ?2MS#"`F9Q3:J!:BXF1H,,',-!*8*$F:*'0:G7IT+A.B"3+*->IDR93+
+MNT723=>.@MI0*)0N8ER<-PFK"9%@V`I94E)4)@QB1$R&%6#8X!EP4C9DE,3+
+M)3-V.KMK(+).ATLQ"8Q>-Y@33%(*`Y:@(ALI0I3>&.F!T=B&J;,,R(KF6PIH
+MS)F,SJ$K[E-%A)31NC`!J&^'60:]3XH`L#W$`$/D]WA/08>XJ]C][WQ]P:\/
+M>P^``GCX#[Z#801['Y,;\V,I.FF*^?S"JD006H^1^,2&;5):>62)&D:81MA.
+MG,5-;#-58H4%H=0:(4-4A<8B8621E4412$N&$@*3)4S!R-D0P,#,H,(A<A;B
+MK#7G,[WG$EZR[*!1J/4>8I#&4*P.8>.V]]!DJ$VDF/?IAH[4Q.^LX@*0.F&\
+MF]]W!>^\=JW#:WKR8OPX$NB.L>KJ`:98^^VS.0)Y69]\7U8@CQ^$I!+?:9]!
+MC25);]OMI@M3Q`9!K""4S2Q+7*(.0O+T>T#?#2!Z7"_`4/0+PE`VL*XTPGH$
+MQPMNG"J1C$$"-(9;*S*6&&`024@+;I((Y/&[-I;:X^IUY+E!2E"$0`B#:G(9
+MTAM),)U";+5K"C>"3K#1"P]8M)J%D@2R?$$@ZJ(8^!^R#IE?6[HQ77><ICQ\
+M?-!$%(ZKZ/"$5G/U2GY$":V(3)*#;V5;H$&H(2%R\\-##&3>W"21&E\"5K6^
+M];#:^7F&":^3(,""(.^5"P5I&/%H]1JH4MT93A&WC5[0(0#A41`Q(Y+04%XQ
+MH',WNHHI*MLME4JJMNA(@P:_,D!NH&:9],[F4:I5E],#,,L2VU%10+KH[S03
+M<42G$3;E9(:186889)4(XN3,$'=E30`AOF<Z#>(('Q!)]YL[SGT%(^#-+&6&
+M>,J&CA9E,?&L)A$!NW0Y()>)$S`DJQC;GV#BV4SOLLP?#4DY7NK[V]\$"0?7
+MOK!+'S]`3\O84R7B@)HKZ.4_)-Q!QJ&6W85[SG.+AT8I(BS6\R1!T^8)"-)B
+MK9"UK;"9-(DA-F&(B0VU),J,2EL1DK-"X8,8)B-2IG"@1*2V`AR6!ACJ8MB<
+MLFA49()-%30;)H,AEUCJ,A]5F+-26UO%)1M<R7VUV47F)0HB'3C.C44>E#3#
+ML[O7KQVD,82ZI@"`CPO*M?'D*#""5][,]2]@SWWS8;@T>(3-L3WD?F%,/B06
+M%B&O#]AH!`>%^+"LQM&9II,H#9-(^(!\"/*9@I@A`H_59V`;X@BU?!!K[6O`
+MY;/6@T)1,E4#/IS&DBI$AJ&Q)A(9:&V:)%!NP@:(IB-]O6WK7FM>NN=B;(5F
+MJ-HJ:EB*LLM%4U$J2T6W+=84M2O*6YJ/<R-+[,1RMU*X&[!:);+;84:U*ELM
+M%2DFB-F;#1L5BQF49*TJ98$6FIE&9J94)FC9M,%(1HF9)&::T6LI:Q++1;-E
+M5*30K%4J24)Z"0SUQ(@B'BHJ$)Z6V)?<W,KQ5VS?3LS-)E2SG,Z=BEI6E*[-
+M;I9-K;6VU-FJHUDRZZ.S+*JYT*(`!A%81!C&"FD[TY)4PLDXG#]M$FE7)SE>
+M"M9%&OBTEZR,5:IX$CRKKL,E7PP`FR:@[2).-4;A0EA)<^SJW=!2S/JJ7I.@
+M'[!5W]UA]M#Y(<ZN_7//GR8H&B@JD,!,,6J"KPTE!2><+Q8:)).$.F6A3U:X
+MX9(F1DLA4+!F[DN3#$*)8V80QF949"V#D0Q7`<LI#JAT9)LO59H"'45[Z!>/
+MC6-?"C[,L6(DK"%X:)"'$"J`HK<L3`+[O<(36WZO:"=QD6$5S196VN4NSL=3
+M@T`(H+#GK3!%*Z.CHT=L!>%'IQT)P(.IRW9IS"/5L-T[\QIW!1BF;L*1K"*$
+M"C78PAFBRZ*N*#(?&`1UIHB%@Q#*9)Q<)A"0\Y<,"BAWKJ?!I%(_."(F`_(,
+M*(L2F&S\J4@9$_+6-*\"ZB;G@+$$+]Y5%B@\F6Q[J=79\A8L$VAE61<%CY!)
+MT\0%C?&C#O#D:(+$@0KV(+4&RA9%K,G@_O5OTL^'P/Q;ONOU7XFJ,JK%BDK`
+M\.0@P\'8@(4882R`_*4#"ZMR[3LM@HL@H7Z`IE%EA((P@1KQ";\S"$"),IU"
+M#016G)"1:PX;KR#YA\EE<*&@:222?<"`WN:3Q+=&'/'J-(*XJ6P,<)%7N!5,
+M@=$1!1.8R2"!8XQ"@QO:A(4P!ZC,`P#KF274RX7EXBVF,!#F&6B,0"<`L1:&
+M],^KPIB'3>16+')"+7I]1X^?/T>A_Z^?I['@K,&I/`RB`]+G)X0/;[[Z!V")
+M(D2`B`G(3HR?>$,OM]N]>WQ/_FBYAV^%/^K\3TA"W'CTX"`+K/5*BBA4(B`\
+MNF!@;19ADQ0Q0(I<+SN-8%1U";MJ9R[`=]GKX3<&^.L<5X6@".]SC\`!K@]O
+MC=`=>2KL!8-[AW!=CNK(7O>"KH*I.T'5=`58!SUP6O08!EB["%V%6>;SPMCQ
+MO!`P>?@!N""#!XB,1(:8U@@2&'P$J*WM##Z<R(+X@+:,B(,#;M#!(`Q;/HX(
+M=(@,4D2=0KA9<H?)N[I-S;]7Z/1:,I"#%V6Q@95V"+L02BJ-K+RIJL\XR9K&
+MP2NOT"`L`^@/O>"T^?2H:-">]X$>(`\!=#%C&05M6^NQQ4"6%'#GCOKOOO=P
+MX=G>N]9VO2HPPHW>C>K#SH>"C)(!WYZYWSS'CF\X]&`5-=R'O=SW%WJXOM8\
+MGL=#,3/TY9#;</KOG<5>_=Y-<B7TXJ&VQN&-FINP\:FM<+7KG&6\YN&>PYH[
+M$V99Z;&<?8T<._,&7E;=5AAOO2M2$&8K+M>I5US:J[`%-K?#A>!`,<"*&`A"
+MV!?M'J\P-"L#<.O6('#6%"%BVPU&6-N^Y5E&KH$>SU@8%?N\-"0X(9!0P$0;
+MZ@&!/5K$OV^I/IQ,E-WIYEZ)`W:N\`P""AS&^L$0,8*!'.YH8W!&)HLT)HN]
+M2DB6\D;\2UK$."PQH@8E>L":`QPP8-#%<%@Z7>4'6:(3P(WSWNY)-TM.4[C>
+MU(TQPR@P6+:L'1HL:./!!#!>L[>'LOLO+85G-S-ZBLW(@3I0.*[X8!X#:IA0
+MK%'Y^[0Z+"]`*DB&T)?"GV-FWX@@U6ABA`,``(!#LCK>OO=U8\@G!G2+#&TA
+MC`(NQ5^0L`AH0,XA#1JNW<K7`;[NU!&M%F4F:$S#R#TFAU]S0T4K!T+JK<U]
+M74(D3C@3$&ABPZ'9&-#FA`C1EL[3F75]UR=O7%QHT.(V]=O;CS#<9RA?7E;1
+MDJ^W=N_;FLZ,.;@P,$(#@_&L,KLKC=\AUS9/]'!]!N!_?4S7QN8DB_HSON`%
+M$>P>/O&R,XQ(JDPUOM6[T?;5\ZXVKYIM5/H.'7PG8W=SLSBYNW<757=2NJ'0
+M$%WQJ3E9!VZH3_%KC\636P4$#T]5-#O<#+PF\^:V[MX'N=S1BOX>^&_(8=/T
+MP\%GV_06GQXP="+T;0H55!K8KKL&59!IR=L88JWC-8ZT6L[KXPGQI##X"L#T
+M2:0PAO;X;MY>D]4Z\+;SN$L7[5.$/0U?!#1DH,8.%L<,&9LNU=W(=VWE.4)V
+M]FD6/#B#@(\O`@DYR$$P<-%"JO')F9?.NNM8K2=FT,!*!T;S`L,,1F`C&."!
+M##(8891;+?P\_>7W;/$[Y'R'-^)!`E"T&#XH)$J]SA7\^JJ/[O!#/EXHL!-?
+M0CX$+Q1V@(2:5LIAA,U+BT5ZP0"2UKL:Z@OWL6?@QVAU8K"<]X!)($CCW9@.
+M5YM88-$85L5U$7Z$&&%$D$H)NRX*80J"J<%5(5&@5HQA48U@0%Y030)"5[*F
+M)V%`TPT'IC&U[&!X6\VJ$`MWLK7V]=@#C=9CE<\@L-$C;&$4JLM6T%3?I`R"
+M[K#TR8F@$?>]B<D$].N8F4&^9SE".)A8LA4`4(F`#(@9"CY1THXO6LUPUK,Y
+MC2R2.:1,`Q#/LYQB8L!=`P0<$ZR^5#0;LF)!+$3%002M"A8`+@+F`"XB9V==
+M;_'T=?KZA.`0#7H].OC9>RTS,7+E\)FJ6K<+:02?RJDE)`&?$QD<004424=K
+M+$`A\3&@:!3(33J#S]57!=I(E)$%>0))Z(`@0(DY2:7A$"8&HB>+4A2SZ#OK
+M#-!=JZ%4ZMDU-FO%1&C^.7?NF:.MW0&FYQL5737`T=:5U033<N.^F%UV75O9
+M6(9KN,(S5T*ZMN\R[)[D2U:'>CM$6*Q&[5DI4S&Z@DHEBE3NV$9S-X>R35KC
+MO5'7DN,#P51>P%<BJRV=\J#CV;G-S'NO-/FY>ZJ@P=7;=5U,W6#<F&:UTPT*
+MI[`^!BU;1OBAG<'M(6)CX*L6B;+OK[&[!02L.AJVIC2RG=0V0&4XP,JYR>XR
+M=Y^K1O;ND[O'JJP5Q5`GJ@<Z6S%V7M[WO`61#6T-JO>\OK(__H%CP#(\OVON
+MUON8;*TI2A^'8VNTT*S`U2X+,@QC)@01+DKZ#%,$H`IB%TP,DLA+DYK69<Y2
+M8AD@H2F8J!G-20L&($4JN`-+4(!GL)I73L(!@BQ)J$L0P2%61+(Q2-">:?BC
+M5ED*)+)#<I+450XF62BI`D"T"#`'79^@Z?'K+TG8@D:?KY82I@(&`0=:XW"P
+M4_^P$!6E%)(U@9+'_86!00N6;U$=+"8CH>O"6E#J'<8'<E91@@1%.WM[3MZ>
+M@[.C&8U('3`T#T2,2/V,'B3RP;\.,>.KM.#Q$`><?&KFMG#F+$('3*VS$<9$
+M(WC]RJHET[<=P.&&(N1,2@<?)B/>\0ZCQ`:-N.$!MB>W))H@)B">\$Q@@F8*
+M8-8XBA!''`XR3%4$$$I,!LG9,R<>]$VF'49,O>&GK'<=0;G3CUG<P:Z"8V.\
+M7HGH[ST'>+W*IX8/Y!>OTHH';6Y#P6<F$390#>72>G@UK=[ZT]^MSQR_K.+3
+ML*75XL5[=Z&0PKA7>`'>G$,@%Z84KB?CX/$AA2Z.VH!)*:4(&LF*O\Y?0OU5
+M+A`\)?_?+^IC80)2D$?Z#\].H+S-!?4$+\_M<VK0!RI$J*O6;7"D:5&:1$HJ
+MXCI@"BA.`9"&(98.3C\0&:15D@JEA4,!J23!(E^?EY)))"2222)^O7*E>==)
+M2"S4AM5\^M5/BO-K>I)))))))))))(22222220A!J*4`305$+^>C&AI`XCG'
+M&=20D&:J@$;5$DJI#_]8F%FK&+56K5JA]'#31S!HRLANKTJWDUHV*RVD;,#5
+M"F3"&):;;O=-<FU;S*BHQHU!05F1%$28B&A=!KC<38J<92"=EA!5*((JL82;
+M#,-6%WF&R`B`:%6F@I"`3<O%PVZS"Q`PD%=B4A15%+W@WP`\$_$3:A]T>=J$
+M@@$`E.V6''BST'5E,>4-'E$L'HHH<4Q/^Z(GBJ*\>XA#4A0H`5V!!I+9BS&Z
+M+)-/6TDF#.KVADWF:G_CRN?!`M<+V4*[J%^)M;Z0L('Y=55([<C4.918KQ-I
+M'#B-T:E"L5M&(63('_R0"/;_/P#(\-80>K!H(PL[+ZI\9]+3X>B$4E`!FC)P
+M/`3L$()`V2`K]C$13C&I91A0F2>6E5^*_&NMK\>^UJK)(H:Q6(VEB:3F*,<:
+M8F#@4(A0*CI`Y5VVK4]2VVJD"2$5$)`P1%!,(:3=#/IG@0>8.*`H=5$140;E
+MRG&PPS%)P@RL8#(*H`I%>@WOF8AF&T0D#8B&K26V*L4LLM:HL@;F%N4-,+J0
+M941$55556E69;!2%EHPJ0JMC`LE22&3P932H*.TJTSDM%($$.3D%C!0X8YDP
+MI,/-!N8TB;:B)3;;8!X[))=+5S:+2;:+3+;Q:W0A&1*(-4HT1UK(:!H$V[.)
+MVX;444.1!!:)44:)?/XW\=7W^*^:WW\S*`J@G<]-.C:*(!Q!(ZRUJN<52N7`
+M5NJ%J9@ZJ%P)XA87E2-@Y*A%!I)ZJO(KTZ","7SVNXE7DZF*)-[,/$:K'`DT
+MVP3%V^+PF\<^!]H2"^2!6L9NSWR0J'YBV`115Z+!&43HYDU0P@?>^^F]6LH;
+MD?P-$8K\02;GE<:[72+V_5I1HXUS0BZ^,ZUO6:^OW&.7E\B'+$;UYD0FOC<8
+MLP,19WRU7$VMO+FH7;,P"S:TY[6E$-D"HX^?H^>MG!!0)&`5K^`DFV)IELT-
+M%*FA*39H:KO-=;+SMK6MHD,S6DJ+%I9,Q!C4:KZOQVUXRS-%`6"PK6[\>[YM
+M>M:M;;W))&RR)E10HVKO$VU:NK3:K4\DA)))))"0L,EJC1IJ!,$10-1$%@@J
+MH:(I&U58LNDNQ%NXUC7)EN3JJY6NXLZM8LYVK$N749Q&(VG=JWFZ(RNUKR$D
+M%<E!9:6C9:DB@E&%DF;!8;C8F&#,J;`-0H*"12Z"7&I1BJ*6(4FCQA#G>IN`
+MH!UW11D8":&K1$M"V?J$LPMPS$,EZMY2O:UZ[=:WJ3)))))))"222;RNKEC4
+MKIUDP8TEV:KIRU<U+LS/5H<A,SG2C8N""0$SD`=4!0`@[C>CQ61S$L;3GXRZ
+MN!2EP'>!\(\HC)0V]GGRA][_.+P0/AK#%W,X9[S&#'X-MV+"\'=2>%BA_E@-
+MNX-$`20HW7]3?!BQ)7W([MD=9W/FIZ55.Y="N"H12*-JSY[/I%2-@KV/LH,$
+MT0Z!!+Y_AYW,&=!,T'GORXV+)&]FX'TK8=S,R[<UF4CCD=JT2ZC5YS=GH68B
+M+51AZ3`G'9`B,@3*.=]*04)"D)(1J;3Z\'9[?+G1V*@A1,2(9D#38M&W\5MK
+M6J2222$6_AG26NNNVN*EV=+<TE0;,<5`TZ"@/1B.D#=$1514GJSC7%RYFYC#
+MK2EFNG:,VW77+&<(17=U;>>5BV$`5#$65%%T9)[0:=9$4UA83A8KT\-IEE1$
+MADR9":450=AM@,@A(AI&@S,5#;I)MVM7DDI&B\="KLLIV=I*=K>7D45U67ET
+MD,E$P4I..&8#.&`F.)&`(-B8`HM"H-(`Q..)0%@JBQBV2,(")FA)(M+96`)#
+M+&D1`*&;,&G!44',@\XADT.LR"8@:1B%#BX-I@Y#M0V#32'^3`3;H>.E7?Z\
+MBV1$120DA`C6,$2L)MBHVDVEAB*A8+4:55554A)&1)!(2MK:PFD$8B@BH1F`
+MDON#P3>3K2D.M!U52B<;.R!`'@2\3L&XZ]DPXFIH8[2V2'TJSMJA0H-IVBJ(
+M_LQ`?P)`$7&-!,"ZG];?F""6:%A`5[#I7U5/8[]8VDE.T)+<WW\8JQ6[C4*'
+M>RV,(;2_U@":P"?`CQ)(S0<GEU:1Q;5.6KU\X3-Y#'(8RD'7O]=*((<)@MG0
+MNG4M-!6*'\["$D($D)(D@0D!`D))`@21IY_#S7D&BL2\:NA35UYC+JKQ)"$F
+M1(D@D20$))"2!"$A"0))))))(0DD@&-B5,U"2!IEHQJAEKKS;K5WE=;&FDEB
+M-C08XRPF>Q&ZT*BIM$IH(HQ;7>:7;:\VA&DVH9#9*S$D1"4HY,Z7Y0J`FG4.
+M`J`[3(*EB1B)*%E'1I*/*,\M<M)JBI91L3*TR9"+KF&I'=`DA($KO4E!]^5X
+MU6MKUB$L0F2A6O6>;QG0)L0U@F'L%DR15-?0/77O$[L@W*9A.7RA4AV0E0]'
+MAY0-/'%0U32LP,1N8IG-NB*:,E@8.6A4FC!BWRFD\V@8G/%DM+,=D3HG(/:/
+M`CUOB%:\)LDO5/Z%E([JJ$BZ$&=K3*S[5\(D##Y`T4"R4B#I2="S\@3Q,ZMV
+M<G5R<;WG$MG5J#!G6E[(8X@*+T:(JS3-Y07EZ95G5)41BS?)U,[(=+//%"-U
+ME0,U32`O!P?:>LZ4W!%$[DU2)$#,C\P:$B:22MWS&=6WE"T6E)1!1@&(8.N]
+M&!!M5VC04P%*4219JO/,G;:K:\P)(22!))%,RHU?T.VZ52QLE#1M#T8X6E#9
+M$3$1$41$)))DD220#())"$"22222!))D22222!)))))&DF2`_^G6+I2'@.*G
+M,H"`F.FKS5O4DDDDA"222!"$`A"29)3)21)19,VKR]6=K;R!,1E%BC6-BV64
+MHRJZO#+JKR``20BTT403)?+`Q4)D(D31N@YC#H`][DB")!04#%%$PM";E@7D
+M2??@!FBI&(H0]P<Y.`0.3/9YV3W(<`PTGNKXXY>F>MX,T6$9UI1?==:-!MH\
+M58)SS'FATJN6.MK!I5#@=6WMAVV^8KW]??'5/$;?,8*"2&X$"1WODK@+!*[O
+MU1T6+,_FMQB_E>5@4HO7Z68K%M>NG-Y1M)7XQEU7]']V'(")N22OQ&[<MOX4
+MM"-B4I,VH$H1`&#\EA,`=$R2T3+1*3&FJ-6O5O*C6]&)QHUY;>E-$T5$5I9H
+MH+440D56\J]%-=MOI>FBTU1@J+/^Y7)-MO6]FKM:U1DMJR2BJ2E&<I9A#*V%
+M:24J1&;7FO%9D7\?-JZ]1B%9F(32U!4PIBNXI1%`L1<511/H;="0E2PU!$!-
+MCUU*5&KW4\;(8HFQ)19);>7N,U;JUY4T%88BC$B]2I:/1/:&^PBQ/8GK3U]3
+MS[-NW1I-[XUJ9KVX9F\+25A'680]$)R!=KZ:P30PPC!G3&FD83$PF69^^'CN
+M9[!Z#`_,!O$"\S,]`,""&]."Q"Q8M\))/J"%56!MLL->207MA=\*7.?4/J75
+MMP+9U$KOK^"2^U?:2)5>2?K&H)*#XQY=L:.!8;(,H2*6EZC3J=<MP4#+%9J=
+M5<C!MT\I?4L-A<[!R0$V`K=EN;C=KD8QC$WZ?K8GK%?MG>C5`#E+U8JOWW]>
+MKI)4U(-+;QJ^0"AG6?38B"G&BBB*)I&F.0MMH/9@0<E`729(&"(IO"2$%"5+
+M1*9,44J4F'G;4\HVMGWT\O&BKU"20D($@2$VV$;9"X35`T$)HYMT+NEI6C>&
+MWFN6TIE;=MO($)"V33"Z!-E2&X9#2TALI*:([PR5I:)76D-HV3308Z4G>44$
+ME+0PD%!#IT\S&GA[&6.'G4243(C)HR]ZWS(2D12*%V0&([-+T5&)I#=%3:5*
+M(UHV1*,26_'W_.K[_'WT%D>]?(Z\47UUFH%0EUF_7C@.@G%**9F1O":%PYUT
+M=*E$P],S/929+P44'8^S.T6"BG(DXQE3R>W!HHT8$`@DK*8)6$(DNB[;9LK5
+M?C;%#P^\.)(\K^].\YS0P_C!F20A8W98)#D,?Q6EU;FI%J:,5$LM=^U]#=Y:
+MDU>HT#8,,2FI:PT)%8KI`B8%F4SJVIM7,2=B][,*()0A(:J!(7:["9*G9E)-
+M*I5%LA3(-5$9*;EB\M+R[1L;#)J5%IMFV\\U6*HT9=5>"!HH*/?,+]$[\='I
+MU@S/1]G0]Z,15$J"A:B%KUUEK\S?&\U?R_CODD$#2++',%,`Q>%%\C#$=#N(
+MFTDM(E%B/-G\=[_-[U\OIX7S"?3[/E]G?7F^AH5#K>(.Y7D'F,S"UG-AA!)"
+M@0:?]3U!!!,$W/0:$$I89Z\O+&B22=W'V?#!]\VW-W.]7B".%7\("?J@H$%8
+M:TRA12KP&7YH"`%,CJUH#P*)TCWX/.\7V-YG(P.$\%%4._L\^_N]`"*&_"KG
+MAL`^3"55-/WOSA:S_`TC5J55HHL3<^&4,H8DS!BKI9:H)B"B)"GUCLV1BFV@
+M(8FE^F&#K8:(#-`:66HBA@(J(@(T_2=RWV[$XP)++`23!0FSYIS0[(J3ZPX1
+M$-HHIC0O%O=77:*\:MJTQ:E=J\)-11FW6\0$D61%8L!'TI9;`IH#MO"$WL6L
+MC684,3],Q[VG:G4X.RHB(J)))M[%W4W8:YV52;?K_2[Z>?9#Y]_3\VS_^PX@
+M3M[*VLK8/P`@9@947Y4P_-6@!60#D5^4J07EAYP+=9\/AY_B?HX]4^]WAT:]
+M=`5!21,M*TE!!+5^'K]_N[U/73VU_J4\^&!2>5>#4GAR7K'"=GARN0;[WI[P
+M/O=YU0`$I=0'L.9H(SV@L/<\KW+X$'P@[*'A0LP>)RKX1`1>R_#UV+B\$1`@
+M!<\*?NA>69C\-X@#?`!@+KX7ZPMJ(J=7$/U">.4DQUO"/.>/$3W@-]OH-`[U
+M@YV>G=WAYSP[WA0"(\^`7\/)F2IZO?B^W0*"8HJGDHUOX4E^:*>Z`.&:P/9F
+MZZ$)&]GAF6+!(M2VVU6H]O7N9B1(/T?:S/NY[XVH=S+SX_6!@))!KP^J@P@<
+MHE_8;*$(^`G>MN?GYO3[&,;9_/#5?)%1S68)F)JA'WO&A>ZX![P=U!2IZOB5
+M;][PJZQR'MYE$-YGLYPM6V[WK/<(DGPP\]O<B0X37-S71%%%G0#JF[NW"%A(
+M;VN^1'J(E3:O?G>[L`'B19IQ#YU+?JOWD/`'W>@-C.NMG:QU:8BLA\26*IPD
+M`D>`GN&@/P#\SK6K4AA'C5!^9\"0'T^`'Y28]^'49GX^U*-1J:>YE^>B?6#V
+M=T:/4>/V^!P;9&YY;6>!J]\0!@$\@7[0&/0!^%98F^Y^0FA1FRKT9OM`8]`&
+M!EV*!EN!L6()YBW!0@@L&U7K)MP,0%D4%F=*&,4%S2XEXUG.V:WFSMQV`R!`
+M.P;"Y@V+%`0,#7`*$$%@W8J$4'"W;$8MP5)9L_"VBB(%X^T`40/?*U@LVL""
+MK;E>)YZV*H^WT!&A"[$"#%J6R`*]ALXE)F2I1K(K3#J,9@6G)<UW;&YOEO<J
+MFYZZBO,&&GCN[_AYMOR\+.>TB_&(*?L/R1^$66/P`^]]@^/@3])(S:\=>_K^
+M%'P,L`Z108T'T&T-O=_#Y^=]Q0MK)](T3E:/W@./@`3Z:*,S\.%BMZI-AVFZ
+MKX8&!KX8"#!P@%SVBQHT,$/A3,ZKW-RQM9"8.@N#K[6(I(;PBM$^][K/QVS;
+M\S$JZF/J8*H7UWOV`'\(J$X<($_:%0^&#X;\>?WS)2OZ=/MGS@M7.]SW=9U=
+M<_)M[B_X4`_"P.I4B:V<0;(`C#-8G3:U>C%6#+R,!Q@0EB0V!@4",&!,7H0Z
+ME>U&\?;E==&',5<JUURFX-]6Z,T(E>%"#NZC6YU@(^!.X14@Q7.!W`<I;!Q\
+MQ_+MCXBT&+!"\(>!0AS+Z:L;4P<FR*/%9XP$J-[BE?170O4^--#5Y(R]U8T%
+MXC+'!#1VA:/A7`_$8&+RH+YRL3D+FKK-V,F#EK7$P'6Y!:W@0M!5WKL[YXS1
+M24M+0T%!0%)Q@R"K?KV5"@`H=[EKAV,`9-`0BD$5"M<M0H*]3GK;Q.MPZ$DE
+M$]8H4/A6BOI/8."N]H);,M5LRA:^X9U78-$\Y=$HO%=\Z!Z8L=]>";!(%IE#
+M@QM#1A`[1PQ+NG=N\&Q=MUW09B+>X;8E'@;BPYBJ6:N/MR8Q@L0<.?F$$A0O
+MA0U`%S<W=82Y.\KDN8Z\M92CW;R],+NH*L!0U;$%557GB)KKQJL@,JJC2T86
+M8AHV\NCVA</PY4*%3ATEY:F.LQ_8E?(6UOB#X$^)!)H%`M(GQ0(HC&B@QNKY
+MV\;&A7:501%6&3:7>"9EYU=:8)M%T;'>;+79+QU2W,STY]=V*0Q8^ERB+Z7R
+MEXWNZXH]WX]L"'VA">11TJ$V4?$^6**J#IUZ\7C?D)(&$G1!\#N`@T"L6RY7
+MU;>66-TV/((;]D:/7>\.9EUU;U1WVK/F*JCSW@T:.?@^0J.H`<:NB`Q=MI&2
+MH`DX38T5XT=<Z,RYW[@(GL2.H$=]]&GEZ=>L#PL#`0022+`\#]6[KR_$ALMK
+M/>%NM_`#X?A7`BI8`!*XU7S@F<156LN-%J%Z$)$")D<!NDMJI(TG(@Z5,MD^
+M)_;GPVKZ!X*%-.GAZUR^^<=7>9#:P&VB4-Z\^`\GZ^UKE*H.K`]<]ZOKRO30
+M4X@3Y(?!H:``,6$;B1WN_"I^IV8X+_4;.A!U3?8/PB04&)B^:QUPRW^NNE[P
+M'L^^)S;S[O<!YVS'[+#*?JL!7>(P!W%Y.('N@NA$/2^@'T2@2=D.*+&$6:TF
+MI-GIPU+V(G8CP$Z![181@E1((19(11@@$((DB;7L`'3DZ:B*BCEW;KG+F^0D
+M.(2I+I-324/5[A.IV<18)4!8HDBF4;5^.OT;?JPTT?JZ\!V6"F2(9`F4DC*4
+M+**4++(2FA&B:32)-3[Z^_4?[[D@\![16O]H'*-D%()-$=^()!MW=U0?F"*2
+MJE5XZL@I84P\W^C!!:F;O!0H4HH[D=5E3.K;P_SL+S;PR"K-@XC#<RF=W;,O
+M>R(=J=G.X[BG.JLWCH8[)RFU2A<S5U4-Y+.MJ"P\@RDULFXO'?745Y,S75OC
+M3WBD19B2R];F.&I;O`NNPI;QQX.EB#,[VR5<=<1;NH3&JMSV<AIPP&BM+)!N
+M!W"7Y+V'(\Q^#(6!^?@@2,'#:/DZE!TG'P0%'.?#?=:2AUMP`-D,7*>^=AC8
+MNWMZ/<Y:P695OW.'",I)"S:JI85"Q$=R"0Y2+K2ZR'+[>QV*JZ%ZEVZLR[FB
+M4]Z95G5'AOU>\$1XD%2%WQDWH"SA.V_'3[_QP\S5Y,`\SF06`FQ*1(Q!(Q,D
+M2PFR;(6PE1L:2:;`1BF06/MRQI+15.V[6$./I86C(#6&+2Z(,(@U$42B:BN7
+M><[H"9*9(V$)EA(UBR4;MYU)O)9,4DS78VFN14Z\VE7C2[MKMO&33,19*BZB
+M7*BP2V%@B@C$5<S$3&=NF]FKF'&&Z.WKO'!Q:<16@'!,`&*DBHI(`.T[17N`
+M(808.Y1.JLJYZ][Y6NZ[<N#EI"$Z`Z485I1"8H`6A$(D$I%C@=41:4U`I$HR
+M:`U(8:5H:%$B$H070FR.SL]SH_5AIH^=<\"K(SJ:D,2"L4DPU;&LMC8LK+90
+M!IH*5'4(LB;E5B(9`H*!F!"<T[!)PVKN!+SY^AOOUZ^1[>I]X,#@`$,5#$!2
+MB)]86]\R,6TOKE2Q%:`R'C20P1HWV7F%PL#91*4HDH+ZLP3J0.`-A*A`B=18
+MT)3+0<URAZR`$1$<HB`(!(%B<!X=TQ/YMS4WLV<E_;?YN<FC:>:\ZQ*<Y''/
+M'7KPXG??DV^#PX/E[V=\/2H+`/<*_*DD.(SKIIB(=HAU&;0]('\/J`]W?XGM
+MZ^SVE`=U0*"-N(F2>9L\RKRIY55=8-4\E85B7]N7G@E8(KLY2=QA72'8@H#S
+M>>\ZG\E?+EOO=N^:;91M_)#`@D"0))DD(1(!"(BJB(:-'Z/YMFR80I:7J+#K
+MLC=7HA))#83:RHMH@I))TZI2F@/>L`-!LDB!%66IA9-&@VUZU>(I=X$92&%#
+M1C62P46H(,#5!4N)YVA8([`EC63(+(&L@L'Z,A`"%$RHTL*T"0L3$_3N<RCP
+M;3J@S2-,3%Q#%N$BP`^K\O>>S>R2#[1/9[S,T1FVA:%'N$*89/^ES'*D_TC"
+M_L!B(>?(?X+C#')6Q`0<0]G,43YF'9_>A-[-[!#?P;UR??>1&A"8(2<]P^$"
+M5O;]>?#;[-,-SX:!$/8CTPX;WO6]8:U6(GB%QZ#:GV2Z!1%.3!,'$R1/I4JN
+M%$_!D5G4R:!?Q^6[W`A`@$R))"0F`022$DDDD(2NE7J*@]UW>*ZM96\SS3;R
+MWI(```0``;:N7FWJFKSRKT9MKKUA<5LNC+JHVL-Q1M4H`:1A#.OC#<HDL-;D
+M1$,48>E`[A$/F<[#ECM<P(HL1'V]_%=^NGTIJX!X3C9F"GK"TH6TWF8=/.M3
+M:J@D4`1RYPL$6"&"P72$(@**K+]*%"!ML2EMT`4DD-(H0$BPBP#8@8^P221`
+MD$_6?O2`0H:>UJN!)LT+"2OVKQJB?U#;T_:ONX6"%X?3/+Q`7B?!?#6*<.B,
+M$U/SD7IU!'31\R[)0T/PC3F5']8A#Z(4P13PH8F[2(\%-2%.:"1&`"5),74(
+M4+:PPA,)DP,)!"`@A<(T"-0P.R4`YKVXAL1V9$6\5,E')H6@$*05R2<HL073
+M*"!"AIQB"!P>0([(D3YF"B[`TJ*$+*60H$](>KX?!(H)X>$Q,*"@H:6W8D>W
+M6ETP-RQ0B!,HV$'#$'`(V'K;)DD%('J"`@D[4P-)%`8KJ36BDML+2RS,XS19
+M5LJ\SQR*:-SSC&5<UK;MQ=N"/ZTIE=]?IV>9!\0?'=W1][&V/ICU`$G=^^),
+MKWB?>\"?>!)'WP26-:AMH`ZWX,275US#8"0\@UYS920U"TA5&"C:-C%BWKUV
+M\E)3\3511!%,X!.CK0=\KFC-Z%>_7C>XA=I4B6OC=^?(!)(>JKNWYB)I+RA@
+M$U0*L9<>D:)9%+0S2:TS3&I)D*L2IJ),VD9"DU146HBV2R204PK,I*KU?P_3
+M&Y$$D^IVR8,IB?Q@$&-A+88DK^6`F$,T?JJX3]=[M6[H-8BV"XY(E,1)BI@N
+M2^[F#H<P1;`0L%]APT@!_A-JZE\$6.^VA`FUNKUJ6[>"2223(F1,B21)""22
+M$)"0"!"$"20A(0(0(0)))$@AD2222$DDDA"22$A)`A"20DD(0DD))`A"22!)
+M"$A))(220DB22$F21F1(D24IE*4R)$DR03(220B20(!(BHBHB(B(D?9`OKA[
+M2_8;]/OX"=O.R'L]NPUR;`-ZY\^K(H7BSH9:JJ=86E)92RRE+"TL*QZI8[-X
+M9E-B>L(^V&"B:&`)B(B!"O:JRM.1@$YG)O(8FS<%@<0<G3WW6?H,]J$)R6(<
+M=QK*KZ8(AFL!4=[ZT<C<!G7MN'M[NNXI+88H"&?9Z<1-(AL1&@6OH1$4,())
+M)"0@9`220B2),S,D$3):&66&&22&&1D9"0@()992DB$D26666::9F1"`DA,B
+M"1,R(0B9,B0B0(212E2I99II2F00$DB1(3(F)$2$B)))`$2"$2$A(S+2TK*R
+MTM++*4D"2"21$()!)#)!))(B9$A)#2FFF2FE,F0B0)D2)))`,S33,D2$A,&9
+M2DB)"228I3(B0"`DDDD)))DDB1!)))"$JJBDT3%N*)K$#4GAERTFH0)C`3&H
+MP@R$QA`.1$KHT,18Z(B*4,-)@(J^+@Z3:+@NG!UDY.,.&1$,H%B%&(A.2MM0
+M0P+("4CMT?R_E^GYN)Y]<0+48I/>8/QIT:/B<7?P:%5.H$HM&J-45HK1JQJR
+M;57XXQ0"A!*$$I5#O,50I%>OEK2*TH%*!0AS,$*!OG8#0.XP+4M2V/,8BK'=
+M:(TU%4JE=C$WEDR888:@^TTTQ.9SS4TU,$M$4'P26[(PVWL`[^UY<,P0))C!
+MXCX0'\ULR`6`"'?@@*T<W3D\]0SP]X`P/_'O"WS`T6+2&_!B#G)(`(-!/\`\
+M"_`>`PCW@*_AW[*]^KO+Q*GP"#<?D5R\\SO7>D`Y*`=$'OX#(J9FHBB-^/+A
+M!3>W-'C:[T'4^NA10\D]'SXJHJ&<,#$E8='WXH?CM?E-%-$TQ!0>HI#)W\R#
+M2.YJC=$3(Z04F5N0Q"LBJB3"1,YQ;44I0(8!%#>R(/EN@4H7E9Q>'#FG8NG[
+M@N$5R4(1X-%4R?70B(OHM+X.9F8SJ<SJ`<=4%)3F4C**490YAC$&9@1,*?7W
+MFL[%5RYA0A0[@'GKF[OV>K[GC=Y+;J\6'#B%5QV0*0AE10+/"Y[+`40JQ$1=
+M#<SD&YT24)AP&THJK1^-V#$D/QS#NT?W#@=5C^T.)^7/?GP:23XH6?PL$N\&
+M>6:'Y+\@_Y$T3[7_((PDBTVO9$R,I`D`DG>_NOS;W^.^U%!$7C)KR4[=&D!1
+M^J$Y4'N`9$5U:T^^8BRZQ55H!0?L[`,4``U!0M(SM0_@1AI)P?F0@'[^E>>2
+M+,2!Z@G^ZYRR.H(XJ);!>*N)#`L&B!,214PA292E<A'(6180:5&,@UBW6$&E
+M36\^\%TG"DVK.2RF;%,-!5XQ/:$U&U>$1$1$1+A*.CLUDUHV10B>WW0C"5"#
+ML6+<L$`;MGN[.%[AQEG!:6$V2DDSG=J#0,TH"`A75-T*'6WUY*Y;L#&AMO&,
+MNK`8:\P00FQN!'&M>C^VNT>%9]HYMN7EL)^><*25T$17Q'2:U\`DA'@^23/X
+M`#*_+OM(22^5#O2V"8RO,2%>4@^"EFS2MJJ]0VH1*!1*#:8)*H)T5XL2H$#$
+M)YAH$AD,0N1Q)$_54"I,-KSQR<:.RH,47KQABX6LV7<R0A("8?<$@8^Z-ER8
+MKK6M@TFPE!1-`CK0:<FDM"K:76C4OS)4,-.@&9!=PT.:@*62Z+"T9<"UR$$W
+MAI%-S.9FJU!A9#^7W\LM_I\PC(1IW.Y*CC9XBYYF"4,&1"J[@UCF64B@U0HX
+MO:-J3,)L@<?>T@>RT;]=!D:0Q-N()AQ*,`XO#DFQ&4V4MXS.+SS>!*J$$X*<
+M$:35/W*AAI-8_,2!MO;IH>%@/#8=!?TW0'Q?@'!]00IO>@TT*)H[X>`&Y8T0
+M1,MKKS&;G_'."OU>`[/K'-5X"R/#WX^\![C[WN(MO)X".5T""SH'XPFZKMNL
+M$00GA<R.K:]W@-W:>#'J*WQJ0EP$3UUE!ET6*4B238RAE2Z-"@@H<=.FH[Z9
+M25E%I*%NJQLY1W/#T!]X8R9SPNS-$#$*(<=>22G52M*2VDUL]W$R'%BB[T@(
+M'9'K?/4/WZ40OF"(4]B84,+9EP8%*.#R:18FBH)BL'0R!HN@L4S!$9)@Y+I_
+M.5YZ$DA)MN]5Y37,O/!`DD@20"$AD`220DD).O9G=.O4:NKO+<N:_;WZ($@0
+M@0B1`@`!`@%"$ULXOOOA$1LB0V)(X:*B(B*1$15H>SR46<B0T2^O1?3L9Y]7
+M-AHJ9G\ERUHRTP8QG3\VFUB\_-OMQYS`D(-,\,T.>BM(/^@P04`!-P8"<KS[
+M`<@59Z_N`)L\JL'AX>08Q>''XDB4<JZZT=4>PSX\XXRI<SSU@9XO9">N<X;2
+MP%1B!$_B`<$]N=NJBG67HT&H+/(".J1-`TLAO$F%%N/W54?3Z!G`^):3W938
+MG1PB*B(B(B(GMW4D70-DEK=B9)L(H3#*3T5`U&!C0&Z3<Q4=$2>AA5F)8WR,
+M7@_/S%I#?B`43-QPMV$U:5@;+`R8NQ%(5F`<1^T[7K`Z3Z/NP\@<3]`3PQ3+
+M18B2YT`=N$^DHG5N`Y``A`GW*B@^*$A.RJEE$/AX+\AID_)7E>!,GH/QW]F^
+M'FK!>E<,T7>;5WM\;/NX+S@:#"3$(H1R601D!1O6AOIQ;UZ5F^%D(L7HKK/A
+MG2(((;K1O78E[U]3'D.H=I@X8(/>'AUD#P52^=>'@*?!BK&YX>O&R0:7J$&0
+M-D!BF+!!X7L`56,T4%`/+L'D-X[5^@&>'L#]*`GO#/-=*$9R=9WK,]S7F)E*
+MF6Y7WF>2"3Y!T6B!$`5DB[JPEA*9!B4L"VP`$CO8'7E7U<HJ`)PB`<(@&4M#
+M"!8#<;KL,;VSXQ16&=QPZ#<H`RK.T`!N@9<%N1GPCZC/`;@.==`#<"\/>>9-
+MPV`/#V/@QX#P#Y11MX_>!M[-7-L@,]C;V,=J^Y)))S.>Z2#2HB^SS7,Y[\U[
+MSJ(JHGN(WJ:@,2OGST="YXZWS7D[.$K!"UF\YUXYT!0]X^(`-;;13%]BC#KV
+M``@CQCKIC.=\L>QDELWSQJZSOHW)VLLN@4[O/G1>=]/=(=^+?D7?%VNP4Q2Q
+M)4<\7>X;]M3,JNRO>$[P/O>'BO`)#Q][W@[!RM%0Y2N]+G/5G3P%H>/O>\"O
+M>"7@#X>\[FEBQ@XH(97E8Y@/QX^\*7@"/>\7<\.S:RN\ZPX9P-,=6YT%07G?
+M"YI"\=]:[1\&UA;9LV)MVG:^4-+V;Y=GD'O>\6K;?/>3%UWH80P*1RA0X>&>
+MGA4GAD=:ZG9T;,ZFG3YXZ:['G&,W00[KJ`P4TDLP>SV@"P'/0:!HX#`-.GG?
+M)J;3:6Y::>>S/-:*ZU,OI\H<%PP#<IP$^/O'@\%[?O4;[.,W+P.>THWIRJNL
+M'G[![!XEB`0#A;&""`$8(&!HX5P7"VO">P>8!+$$&<^D"62#N2I=U%F6#'P.
+M>`L8(#6"ECKJW!K,EY5:\HWX/W>#`+&^P,6-&B#!@8(=0/VC/9`.#]ECFJ?L
+MKKY]%FL]6M@Z[MH.AG=5/;![.2P3V#@*GA@?KL6)00"&;8P00,U5RD,]0O`-
+M%>L,8%GL"I!3-7;5-]4&8&]M-:&AY'B4,3Z*\]0L0#H+#\;!%A8.%!@C18L5
+MHV@@05A%:W6^MZP1UE#9)O2-;VZ3DZD<.8J?&3L57.NSZ7SQI:+YI]HLCA@5
+M`6*"]F%^P4+&AAA1U7$;-%PAKN5["A+0>%HY*SHXZG312H9'3T77I1[3H'>J
+MNLAA=J%!BO3V4?0$(4,%NUES*"&._3U4?1*LOGM(26P:]08!][U`>'"#-P,^
+M!%GC53C5*(N.*46+DX<GPJR%9L07->^7F`14$K;%;(3HDPCH+>7.674?!!BD
+M8DH+1/K@/5@5PYCK).>C3XFNOCZL(H4"2%5,3NMM95"_(908H<."3"S?6,%8
+M,%#UC*,I4XZ@SM%[M@$XH,<5WAQW>>A>G7@S:=#*=39)("AW=!@.5@"'&##X
+MAZS<O<O2KJ&INZWK(.W1X^X2^S6-Q$>?WZ^_Q^//QYO<,1%8RQ).N["5(T!2
+ME,1WC/$!L//C1V=<>C9![A8[@?<-S.HP=5:49TW>(5!'!>+.SKL$Q;6":%MZ
+M+SMG:.1QDX((0A@L/A!H2"%#*%,2C,ZW5ZY@HI*JV_YF7GW9N8D81G?"BQ"7
+MAEH$3LKK#`@^?OI\154.^.7/C"%\B/BR`.!/CX(@'T'W"_:$-X5@"S9+VI;.
+M[=S,2AT7#9-*6YK$'AX83B1%H,T2=T$53'#=&C/4<.5E++XYZ791G&9U,T&/
+M09*Q9*K"*B*A'MY`1KPA/B1P(P<,&"!BE3JHQ:\2D5,M30-+2TLZ[\=[V0'(
+MP):ZZPVE)533O<6&@IG1JYG5"A$*BD;C)(!/AK7BU0!(!/D@B;G*6C6D8&*#
+M&A^44<>CVG`TL"NV2^.H*E09#P9/<"!.J3'![T!/B9`-E8,(JLH-6MVW%.%+
+MBR3<VJM'P@@/M67$:RN,AH[:W80U6`PD\*&$A#Q;A\T>.2ZRUAJB]KI3X3,L
+M8;"E]PZ#3QT70O!P)(>N='>8,SR8B<TDQW;F%SJ2(WV3<)&VML0R[OCL[`94
+MWNTV6M5D;$,]X<SHHR&[2U:>2@NQ?MMR>*%C0;*R=9.ZFF?0^M]@0T%]=VQR
+MP,S-,RW7:2I5G>*TU>1,67J@>>%9?6R:\*K28<QWGN:V]K2Z^VZLUW'<9D-K
+M)5)5M`^;)0PB$@``GWO'NA#`@'@NN\X=FU8`#X6^H\,LC,C8\2/`D>/O'Q)6
+MR(P(+R39T$3!&:PS[["3MTWM-=;CF*M;;#(.5\22NJCEW8L@GPRB38QO,OV5
+M1.86R4&0?R\`",G*SD_;]V5MLH?6E>#+5]"+X]>5DRECQL)9;756NM[D*NA<
+MWGI(FW9IW7B:.=F6*4N^Z;9YS0I@S-CB5EFK@[K%9+N^8//LU8E6R9.(N<>G
+M#9.:MKKI<]9VY-WLG=JO@LPNE%*K*&`O-730V&]"@G96'./6.&^UN_60CI11
+M'@SEK1H%=5<#1[%"&21X@P@:?`GS#&;LO2M&%9F4">[P\!Z<;L\7[D=K;J9U
+M$7A[LKMO;R^?7QRN69RPC8,2N6;5L:.NQ32HBN>8V!1@(9]H]!T@%`^],,66
+MCU[G7L@;D*0I6)/8BH6;(:Z[C9FE)&W-21MUET.LT[=75&C)*$E&R4B1JHTM
+MTDUS(DEKB1DTN[,M24IJ:*6+-795U*,RV-DIMS7)EIJ)BECNJZ72[697772E
+M\FVY:*E2T53+34U$L)3Z'P;(C1$'#GS/6_?OUT1U^J3((@VQF:;E!"!]Z3#%
+M<J!`!Q/I;0Y*TB!$"#YP"(S"A2JNP$4&#SI\&A#TH@*P`:E'Y0F,+2H],B!C
+M`*`?![^V_`J"$\*9@NW_W8FOF"B)FR??R\7>_'GK;M]LR?D8XT!,7O.-ACCX
+M,,6?'CXQVIOO`PF.T['V5\HT5@,-^@A&!W`*3`7*$#*"U"W^A%&711&R?+QM
+M?8X_`>SY?)*J*?!SWWT!T2Q`>=&,6B#CA!C@^Q(/ZC^/X^AV=_($&Q.U*I'`
+M`\FGK>.UOG-Z)(E'TTZ+A1!NH_Z?JJ5ZZ\K%JC544Q77]FV.80I#F-1$"4$"
+M00#][R0<?*J%`B`@-$KV53K<WG79SJNM0.R%8H+7L2U9Z!1IDL$B"U)4322`
+MQ,-,3^$M85(C7YX`GQ[O7U3LX5$5KC!L8-FS$-P:V90FV=N@-R;#[&O)SG3W
+MOMG</;A!QZ8YA7RYRN#N.$6Y+>C##,@-L;2$U,;(FG<=NM\#:F1.-<D]G34\
+MQ)`K!];)#LEL[4]EMU<R\)*A_?\A'^<W>6AB8SFK/==7/#;LL!D#!H8LSP@@
+M88&R0*K,%^NA8?F^F9?K!!!]@(:SPUW91/9Y:@I:66JJ\;:F30[_"@2_$,J8
+MCI^I8."20TC-QC$OJX7ND-(S8;!Y0=Z[E_>OFB0+)]*=5;=W7Q"-`4Z*DA$>
+M+^`>!EJFF@M(1*8C,1#RKJ14->-;V(NCV,4$3^0%V'5U<=$7"=CK==$OS?I-
+M?3J,=N&<;QS6I<L*N++^<)`^;80$WN>SLG&&B9$-H(3A"1#21+)M:(N8]>^?
+M+B$V#D#QMQJ<"68";%<=M+")WN$V[XA>(-.J5I2T`X*X$XC)M&)I*(:-FG"*
+M;:S@7C$,99!.(8_$PYSH&\.DNQ,HU>QQZ-9#R\:V:*$IE!0Z='&P.DQW^`"'
+MTP$\SX4HKXQ.@F453QOU[_M_'G\F/W]I@ZI^]><8U+,F6F<LZ9U*R%ZF'`A/
+M1"@_,-P::%#^#Z"223T%#&&V?AA(KW6#2[X,)*ZP$WPO[WD(AWB?,6"`5=$0
+MA5@L0(K6`LVP*]"O>OQ]/;N\X>KF=;\>>+N$44/HH@\]!I?@J8@F)Y84Q52=
+MX)@GL2*(O/MT%$\RC-1E8ET:]!]XZP?,[]0S5NS!$2I"[\[F:@(B+O<=..K&
+M:PV*FR+9YN.]ZI-<GI#F^1G0\2)NG>&W=R/!34`S1@5DG`@Q&4LRT7;)F(#)
+M'DF'&ACKKJUA]/I].N>!\F#@!`!]X`SO\'_!$+RMVT:55:CD]Y0+WA"2`/\#
+M^A;`88""0P=6X58KT4>D3`@O)5%!OES8J@XUD4\P055[F4$TE"QY#`2P^*.:
+M/X45S@P:(.#;>6]\.]82"VJP6"9(="7M6>OQ*@3%B[JA2L/XN8#I\\$RU*@<
+M@A.6@2*B56OWIX@D$`CLR)Y'.]Z*(HFA_?@"*#Z:#;.]6\_=UNR0(2`2#^'E
+M^=&?B%^^^=+X2$(29!#(DDD(20D@0=[VO5HTHB+@&][4#OP<*HJKQ-*;LILV
+M&]W3Q,F!V<JHB*JSC;HDWZPDDDA/F]_.]7RY-\/GK)"$DNZ^;SWKSUW=I>$D
+MDD)(22$!(DD(220D))($DA))(2222!"0`EVWHR]-\RKVI>X!)(9@$!)"$DR4
+MIF29DD@9F9("$D"$D)(9``$D*1(D1"20@$)))))))((BJB/T#D\],R5AB3)&
+M&-9QZ>*CZ7GOTQ///.%1$3I3?&M%T:B>I0>,*8)*F&&,%U52C5V'J6,^HXD$
+M`VV&[_HUN@60B!I^L,8E55]8P8$EU7H[.)RX@J8=,PU;K.SV[&&+$YMSL'=!
+M061>E*KPK3$*"15$T4.\0\:ODX0#E:2QJO/5KNDD))(0A"!).>;YG[4O?J20
+M"22$DDDH1!(D$($)(2[Y>,=[_:YY\-XNM?/D"23(D29F9F225,`B[SHY1B!J
+MB@UKJ=2;S'@AN9DT&H94V*Z!X0.,+-JDVX!DXAX&]SUYS>HC,A$,B)$FFE*2
+M"0F)!!()---FS33,RDD(29(D&2220DA"0D$))")DD2&2$A))"$D)))"2$A))
+M$DB0"4DB)DDDI3,DTTV;-IDD)"4E)&1A(2`@(88S3*922"20`3))$@DB&`21
+M(DD(2``!$R2022""1""20`D`0"09DB)F2&$2`22!("3,S++*4IID2!)*4PR3
+M)2F93,R1(1,B0`)"!2(F0A$D@2DD1(D!))(2$$541('0YU>MT(R1>EDKW\O%
+M[8=#R"""2"02-/KN4X/Z!!%?<*&A7=W!=A@NR0]RPA`:D<-)O`VWOE2\;Y*+
+MLS,V11XZZ(=)$D4"(DO4\#F7,N^W)HO4X*=LCF7.N[.4R9"#()(I`R6Q2MZT
+M<UWS:2J)`0C"L2B$P*Q(`$0HQ*TJ,0!2D,K$BI$HK/DP`,E(D1(B20*"8&($
+M(E`G8G-GM>I,)HFWB4)WI<8FWG@[#Q"0RE.BLFV35E&E4:T8PL5%A@DE21*5
+M$B0H06A`)@2`@)FA%>$J8RT`4TU8C6J+-_'RU^)36?M,#R(B(M/&,$S.SDU)
+M32I-1@5AY>MO+W.\O(5O;\J]^@2$!=6N>[]*[QZZ`20D"22$(20DA`DD`2"(
+MB(B(C&E$'HKCV5!PWP53H0DDD))))))5518J@#MUBNPH,WK0&59833@A98"A
+M9BHN98B#&8`ADHE*)F..,\TIJ%T2"9,TC9Z>:\H.5MO/`DDR$&9,D$""E*:4
+MS,F24S,R(@2$D2$@D0@)`A`D`C/ZGO]\XZLE@(TH3N>//?:;`)X0"&O/IDDA
+M))BQ$@9W^;TB#I4/8,(6+#&(P+*52E<Q&%+O69E5_3$\HI<WXD7&'@3;%97]
+MCY"P6TZNQ-0I[5#[#]1:J@N&T,\PO5>=8(8)HYD^%=!:!'<H.Z7*%_8SX_9:
+M_A%FF!3A\TM+/FDHG708`2$!"'Y77K2DQR(B,5$D)(!(0F>,JVV*VJC5DWV_
+M%^SKU9D@+W<(SM5MJWJBZZ\XD`)`($B)$B000A,@"$"1(DDD=;FO3O7273$*
+M-71N;F]-/M;G8*S/0PI@%>B/"-&3CEFV,K8!F,OAVY,C&F+GC>S6;1!/8,,8
+MB1LQ0ZC/F;7=[<*P8<JYQIUEH6UC9720M4S!A7+N'Q)@8O;OM&]N`\N;)W4#
+MY*F*.=1P'Q!S/#?>@H$U=6(,=70)T7P!(/"@"1;M4T"0;#4Z=4?]$]0%FRO?
+MFW&FQPT:NI2K!K*LHU:C%WD#H"Z!_;-,.[-%BQ(W6?MZ=-..'3J\N7G`X%%8
+MHBJ&^7LB,41B(5;2RFW@D/(;B>FR$\X\&["E,-09GB9K<$I-[,NH/Y$9H1$1
+MB:NKL+,TQ%8J(BL:S1PF1UH6/>N8\S%<SQA)($D#"2$"&;%KQ(6O%;S*(QR^
+MD3%48J+LG3<#("';FX1R6*#D*'0(B(G&^ML<)2!FAADBBXY5F:L"52M#\-?F
+MZ6^)23'CE<2#2RE,!*(Z"+T0X6O012(527>ZM&[8'<./P]X#:L8"4GI//K19
+MPZZ^!1>$"YY#7@\E43>K`J+O'DZ:2J8NT%.B!!/?67]^KY;5F9J3#)IEHJ9F
+MW0+(B"(HB(EEE#F^K-"`5,Y\Y$_GWWY]Z?4O9DD!)(R()`DD"229$`@```22
+M0A"2)$1$8BBJL>^9,+.XFS#SNK77&]][]$A)(28`D```DDDDS)!!`)`@```(
+M1)>>=ZWJPKCH]FY_AA3QUZ3D.@FS@Q3&50X89A88-8C>L):?OI)A^E_GYJ9*
+M)*_E7\C``_S*I%O_4VCNVB;ITK)1'X_Y*F61*O$("+JQ9!*C]9PF@P_["QM`
+M[="TI9L58;0,VJT,4$D%5]BL('%P0.Y3#6\2;W^R3U^X)W[2PY[I1M$\\8F#
+M'\IE>7A+-5,669\8MH;0&Q*98K;"05I`FTF?-WJT+]8!.$1J)!)$DD^((/CN
+ML,$A2WG>KU9)2=F[=17.RC"$<<5I9@H"H9%:99E:6BRF7=TS,DV9F*9)-4E=
+M-V;26DRS-,EF$K9+5=FZ5:F6F3%*-,H9C,E,TF:-RUV:VP1(IB"*,AC,R(?(
+MY\?;AU!OX<KT#TE/:PX#EZAG*\.2:-'31=C=!;ZMT&A:3'<>IF\&,"H;B&"*
+M,IO'=`K@AI171P$0(\([DH&O_?80"?5QZG]/=XBWUYPSZ]YC^0Z_FOQ'<GM'
+MK(%+>OCY^]^;?0B?D6P4,HFE`R4H'QP`$F"1$+#2D&W-8=1W$BTTP:#\K\_"
+MU3L3LM>\+8NK-V8/>J@.&WZ<!>#=@][)OO&>"&"#,N+5H8[D$!(8D>.;X^#G
+M(Z"0Q[O'AR\"/4/"QX5DBQG"S/DNO"1?IN1A=YC"P^>OW!8&'`,]".WI7#6]
+MKQ(*\.H!Y-7AM@=W@`/^)Z?Z?H-0`!\!E#[8&G97PI)IQ+U2)2_UX/#P2&6)
+MX>`$/AX>.6&/>\+UVP^;B'=.XS[&(AK%SFK$BPE@<W[O?T]]KV?L0EA*#ZR1
+MB)*&<<W;=ZZ8Y)'(DH84,22P<PWW6'K>,@X+(&'$P'2ROCK?.1B<!T!*Z,QB
+M3)2=UOGL9W78Q)TI,KDHRBI]]K._M]N,\UAOA1U%3*ZFC!J%#).7-@UMAUF:
+M,0%`("``^&5Y4$!0#%`'Q,]UUG;6V_:-"'M`8H`BIZXA!O#<8KRT8")C!@V#
+M-M#%`;WV-#1HL,7@L$2V"(*\,]`H!FX)FX9G1+-@JH+()9E%[NV@_#O6%P&3
+M0@+%@\&#;&>P6C/.$67C%U31;%[6JT-]KA($SL8,[%D$]G(\X1!UB"@Q8YV;
+MSNX6)J2R!@^,U=Q[L)[JN95^TCV70.S!PH:!GH&"*`@NQ8T$03A(+I=PRFEW
+M5GL$9H71O<)VJ"Z\4'-TM!O1U;2+'"@AS0R@@QHL/7UUA-\].W#4J^<ITQ0B
+MR=DCPZYE0=C:L'SK!L''AH.#1@-AC#K=D<((,'#AP@F!OS\ZD;VSUX-B9VM-
+MMV7UUW<\*I18(.][RRB-=/4&Y@H4."@H0$6SH[2L%RWCS93N]QR.GMSDUMY+
+MW>ZMMYXD9F9E886?6;PK!H@80&&8*%BA8P$^L8($$#Y>YY:$-8=OI>3D1FT@
+MB$SF6)[>FFU=<@3C/!G'>FKRX\O-S>S>WMY)%:";%7PT7@H:.MCA.K(>4MK.
+MOA?=;X41-=]ND*^T:P<VZY)Z?#W@W>`B^57%99$&@]Z"R'?`@AC=1K3I,6I:
+M]")XQ`RC>E:,FBQN#4#L5V[?=U9P/<9,[8Q0X<&$.IT\;JZ3A4BNJRN-TC:[
+M;N;5=5@X:N]CW1@$#L'PD&8,&ABJ;6YO8T?++SN@:++Z5M53.RGZ#8-8;&CA
+MHV!^O-UU([-3_<;[NV(;K[UC4-#&?-H$8'8T4,P5BC:..;FYM$%O#:5>X`V-
+M%P6>%4+&BCPJM-:=J;M'6_>\#A"!)`-:@P0M#3%@J1.!\<,.KSTD'Q)F0U"9
+MN/+T'Q(L[9J98-L=[`0002=&56\NK7=#JG#WL\`-8ZF)YJLW)*RKN$'+"SJ5
+M\]GEP*#J0Z'2>O*V;HEA*L%B..&&X[Z;+P5B[:3S>%7U"_6<][Z$G4DDY[[4
+M&D#L(@LWO-;OJVA>.Y).22(.N,NN,(LD1*2`QAN_D<]("\'-*6ERYA411RRL
+MMIMZ&002#T="J%$CR8AIHUZJ,$)!-1,&!=%$C3_('#_CWOJ@YY^=)=_+^REE
+M8U1@6E8]'[8^B"6HI/:,%%!"'<4A\<I#90?=SKJ79H;:'%RGUCN$OQAMMNZ6
+M>S%=:W>=3&96+"-HNU,+?55H30I+KNLG:<O,VZWL6;UQ73X:@]6YINJJ<[9(
+M5;#BFV"AM(XZ'9V(9BN>.K=[1,JA49#RC*F[AL8[D]@A?992:UR7B@B+V3G0
+MN%)]AR+R\.+\'61U1%3D.7;>GPAXQ=?7[>VM[,]%JH(2DD1U2B)5^?.5GNW,
+M`=#<EPCJ"J96RD1U-,2VA=JKLW@M&K/;FTKU2DH"\0$)SJGI=CM.YAZ;+[GF
+MVZ=7,0I:ZS*S$>JRB0>`:#SS`\=ZTC>CR3Q'U#`C)0P1*L41YG$P4#!18$E!
+MQ1$"R)8)!^-LOFV)*)"P4D4(*8P!DI_#D!]*`@NW"7NXRV=N4$I,(]-:9^TN
+MJ<#,PE<>;U^>M]JB?2`$]X'Z,$G:,Q1^_[X)XUYDTB$*?P=F#@!!!VRO"!T$
+M+[2GIATDR3.8,!N63!1/EM&"IZ;F3,>=8$!]\D`?4?K]`'[?1;X'T`ORL<!W
+MG[;,?3GLS'=F)W79E]^T@(QZ63:HAT_,!/9]^3N3DY/Q^G39Q/I4CLLG:$3)
+M`%\D`+CUBA@5YG&IGT>`_0>/VYSVT3MAY.R"@>#R=/.]&XF9K`TG"<TH^=89
+MVPS$%K*B\]+B5*BBBFF'+,110Y98Q17BYE\N<V&D%5$8Q--4$J:$XY+LQE3K
+MK,66=<&2`0T`5YL"V)BJ@O4A3"!2&ML-H4T,,I`3P_/Q\2^;^7A9&P**RP20
+M447///T\CJ1PJ0!B666X8EQ+%AN[=&I2R6F6D9LS3,C`1"RRP+;++&%8Q@<^
+MA@MM?87Y,UJGF7>3S!,9V0J104CNFYE])N4,TT6W<2QQ>0]);IE-;:8*`H+I
+M4,0QA4\6WQW])J<5[N&6&\/3TAOG@]A]X?,IWYP>^^:-PFH/CK$)Y#N.I[R%
+M*,?V8)9#$IOZ/VVKXB#0WTAKPB&CD$MWU@':3%-,D*DG[PT$ED4+!+TY'RUY
+MWM7P9CM@3O1%8+N.BH7'6/GSY[V+D%#4U)3'OZ2HFNLQZWT[B3=$>.P0#W\'
+M@NB:@F5$B%(A"):%A,80#H=?**Q>@S$[C=%8&LUH-0F65U/.C!5W-U<897(<
+MBS6D-6(KDAIA5R$0T&#U3IFUXA="2P7!;CQ=&%<9#T:S;K?G+-PNG`2&#*--
+MS)F;E-P!\V0AYPH`BL0?(A($.W@]'S>NNN_3MS1=K^MLM92L[&#"%;I&6JI&
+ME1DGXH/;8L50:MA%,5V"JZ[NWF>8O<$EU5`=G>8:"J@(O9-RQ`2(T*)ZLLOV
+M<2055`O2?@/`>`B,\"NQG:\[`\-E5I%T@R=JH+8,<-E&478EB>`]YU!PH4/#
+MPT6?B2:B*9I(LN]&5YL9!.CH$7LPP1Y['Z?WW?D1:41?)\KV1VZ^:_,JY.I,
+M]8CN$T3`3*1OB?,WM5*$7;)("@38Q8&8M;:DF6EB;8XGL=\.N+)PD/49#J`<
+M\<1UP4-P4UES9<-ZT&(:0TU4%!U0KC`NY=K->R99*W9JDQ4J<YLQNTN#[[?7
+M:.S"*+&R$@+Z'LA['1Z6CS2Z:)6B(B6Z\:/(D8FD:4,]#6$IK9R.'?6:H62;
+M!L!(+VP$OQNA_5C)2JJ<OP9$H?S6M[W<.9):F6)VY<RXX'9-HL0TC0&PO11@
+MD>)\6.!-0411`@RV)*5GPZ?.XQF/>8AJ68+NS##N3DT,/8-9PWKQZYUT'(*/
+M)'([F%O7O5%F!A$JQAVLIE6A&$R"2*_?&F,YR3"`B*3.6SV!5`W"H"2"&M;<
+M-3$-&.2:T!K-M7=&XXZ-C%)3**/TGA"+!)\+J,4"2/)B#R0@$7O/T+#5-1U0
+MT&8R8W4<F5">C.T[,ZXU*-!!`][P/CZ;^,8;K\/X9_5D>$03MU*8I_R"?U7J
+M$";>;9V"6-#24][V"$_N/:_<&,3$4CK*H_&TEW9I#!!V;(>S/3%[[X0)*]';
+M4#!)'O57'K;@/N\"<%?O>)\`1452/>R\Y;,@5F0*R^2YDSP!R-*9%L3?GK46
+M[.ND]^<TV9QU+>3LV]D4#US<];.0<G9D4GB'<;,*S"@V0&(_'OUKKH)Z`U,Z
+ME,A<A?%H=$(NR4B;6(F%2G&1UO%3)-J"VK7EY=KQ7J((5S&\/5VO'J+-RF":
+M2323&J0/)KA.W;SS(:@`<77:F=3C&O+8^=8<L!D?O(D$$J9/6O(<6PM&"ZJO
+MKS)8L*PVWW]00@$C<\,]6L"TN]]=1BJ'-O57O>'NP?!MN?4B1ON/57NT$[E%
+M+J%^``P"I)/%1BSQG[#J2IGF[G5<2:1!*H2A*`0C`"T`LD@`C;W@*`&[SWZX
+M:FZH@*L#OT(23(H`45`2*,BLC*@T@RK("I!(`O7C:JB]9T\#W#/B?@\D15$4
+MH"<D$0+F]@;36\<PJPE,W+FP-T!K1+0[;8&S9I-^GRN^BGA.LAI>9LV9(1UL
+MPV;`S8^\U8AO1L!+J:S*:F,676:H7,CTI"=-2QB0.EZX$*$4!DSOU\N<^$=^
+M=WSG5[7O1U56/S%,15+G$95FXSAF<QA&&^`;;%*Z0;#!+;9(#1/](??+"'2&
+M"C%(#VEA^\*`7'2*9WP]ZM#1R_(+V#Y)+P`@H87Y,D_C,`@^\1\:)'<V1Q##
+M>'7-Z+>&<07)!$?*ZZP"FDHW.2E'<&$@T+P1%/EA\H^.8GL`S%C-.F18B:*5
+ML2RQNI=686FM,$24L;PS<Z2G)S*-N!N2L1K>NS&&U)1W@&]:);J0:ZAI45`S
+M-'5,FPVL16%-M+0=%*AFA15&*!C,$B6V0N@A-!F&A&96YP7+3!8+47]+`Y4C
+M*'<8IP#$%D60.U*0[I!+8$4M\Y*X/4R[\;S<8C4X884MMAPX\9G#HEXT/^ND
+MD^C]>B#DA>81EGU,8&V&_>'\\$>>;XBY4+P=,`,RZU*`33).FUG741;9_6!U
+M&J^.KGQ%.;X(^$(&:%G@,X"CX4:BQHP7I=EDL;5U:M;$\ZGE#:(D&-/)W0"I
+M@L#05&0IF!6$R0-"Y8:,:&)4I7,&<D[;>(59J;S*/&2W;30.BRY*&"*$>%%W
+M*(N@!10`$3:I5R\!9\3_4O/D`6]^N2&@3K<4\\&O-F,,0>UAA@'C(<:_"Q])
+M'`9.&"22/;L,6-;>JV-R\(L+\PSHGP^^5USEZ/5YX$"<9^OZ$'PO:+ST7?=`
+MQ3CISAT.#NBD6*'5*HQ51$6_/WY^5Z,243,'M=&C7QV=&<5%$TL_$75E\.8^
+M!MT15"02)))))"220B(B?CGHJ=R=9SEFT=R*9/4)F$1LR]6;%*`.BNC'KEBO
+M)0I4TRA*7$\1,3AG1@8<'))]XF=`WEIB&)@F8-S>6"R)>9HJ9:-GFZPU,HV4
+MO$*P%3T:!(PG*=Y@'?I9>'1AAUUDAMA+WH<,GCEY.,T$+S9Q.*%EOO?VJM#G
+MK2:&!?-VAH+JB@KH#PW)FD_9GMP<AM#<%^N[N[M8`!:OV,9:^/U>P_3I)#LB
+M7IV>7#Q,+UUH.\T=4+.UYV7G*=P@D<PK(_>'F/G9A!D+"\0P(AE4Q08^R[W8
+MRYOFB--^_-3=VQ@S3>F#3:09Q@C*3661"9/T-6+%I;8OV:,%!Z<SCKFEW.Y]
+M];QM>0S,IRR:.QTQ``#\O?THB@=)U\>9LTFO+T-()QLCF,-(&7+QWO$T&S+,
+MB@4L#,PS<:R*C=S1I%FH=PC3K"JDJBQZ<P=94<M*`4HJH:$)D*!]X/M3X!YU
+MD>M**C\:A$XX/L$TG8*41>S0F>LT*>XA4G+:7?369"-WSQ;HMY1"[;8_7_HF
+M*9!7@.A7#O*LYH8/9U&7O>'7LT4-#8M3JD@6B>]9]GM`K<\``%R"M/WO.`&>
+M#(Z_;8TYZ[\!Z5K[/:.NEFX@:][W.Q@L8*=YOM!%6L!LT]]Z8![>L5/",2]`
+M2]T0"_LT_?>]\/H5BL)>)7S9)#@K*!JJQUXR,+[6&?K1*/]P+PA..Y[-"1AS
+M?NMQ!O>KAF(GW<ZKC<DC#-:D][P#]-0GI[W@(U[WO!_7=:"#F``#W2]8OC8D
+M,9EML6Y;U((R[K/-?.XF<=\0$Y(KQ`.O.&:RGKO#">=\[D5V"XL@Q()N\N^M
+M\L@T"7%0Q!#P7&\1VN5B^^[O7.^J&8(;#&:3,D#(]BV6F7>US3.LTF9(`X`S
+M%`LAD)((/3B\.GGIUR\7EF-O-5X\U`>%-(J0:U0X":$6$@SG-ZZM97,O6O3G
+MHI.`AQ`D2&)E84D9!4<PO.WVM4S>UFFNVZZQBQA(T"HRL98L=)F1J"Q6]<OK
+M,T-]7+6V4K#J.JN1V;3ADG8.E-B6-*?+-LY8-C2;A9S':Q?8WG%JS/VL\5NM
+M\?;/EGS.6#PTG45NC:&S.@6&F<!B;#B#E'5UE"I=/+<M,.LCJSK.C!JG8S6X
+MX5RIQ?6'PP,5PT:(%ZB-]`9R:(AGK)/B?"WZO/R&D8#1$(1^WZ[EL>^/H*T4
+M&/AHX,(0C!`<!\-(OS._:'P[FH=VJ-$1*[*#()B06ZPFH>QNRB$^<(38M@^%
+M@CO,C!00X8+%C0D0-I71%#4D+I[0F;F9IU+=?H0KI^ANTRR`C[<R0.+SE/`@
+M*!&0B<$.T8-#&P(!>VM?NR>HP0;`;OF-[K25P=2]J!\2S\DQ5/S*+38Q+Q)-
+M*!#2*U#X;/-BM"5B#0+#J!BQ\,%8-"T$"^[&IPMY#E>DS$LFBPZCOLK.6I"Q
+M"1Q0:98)`+*IIE:V#UMG2$?$EP,78>LOPD\1PT4"(,/^NK>A7LK;IO<S"$D;
+M=JS)Q^05E'EY$@<"&<E%44UU>F:1-EJHBNJ]=AJTX$YY(:`P!>H06-'(/Q?5
+MS:CN5=6;PN7RI#@@]W>4!=FFR"1>HR/0O#W#Q\`2?"`@`(>N`GQ)H,^.U)Q[
+MNN8=)(BX;&=/H#5H<%PX50"@?K!RH88UBF<AI6#!+1>&SO=[%X^SBF?95U?5
+M>'WI%VKU`C2_6L#2BH7`0?$IT#ZCM*7YRJM)'4A0--)KPXP?#-%7H^]\>]@H
+M+Z@O?.U]GWU]]MGX\?AU8]Q>QKW2@Z)BAI"V\2""$!P18"`>1*\02U6/I)$E
+MT[Q'9HT4-'98X+D.$!(L+;WQ%R^N\Y7N0[)?24(NY!##91":#$*#+*#\JG/T
+M-XAGO<@*H2;;08F-)YWV:-W',Q7#,)9:5:Q4I++!8BM+5E);:5$M+2VA2J6%
+M*6E:K01T\EG4L>_$>8/RHC%G`<:%,(#`@Q@5!ABI?UBY])F7:&IF$TU0'>/O
+M$&VG$++O.(/O#:35;MR`A1LV5Z`'B_'Q!JFQ4"XB%*@-U!"P0$&=2Z4T#KOG
+M95I9;JET>J;$HPX>$VJ;>BIG7>=73PK1X<A]NA-C1I"%$(/+&BJ@P!B5CLG.
+M3<3>WE5U<-K*/O9R`LHBE5RR`./`]XBF2!J[:X4-=X$$$+'#N]@[H][BN?,W
+MPS'O<,@->'`>%!4,ZQI&AT*!2DI*"KN]<W$WMR:T=4U0U;(LZ!2E+151@64P
+MT=3C9G)N[WO#?.<A:4JV2RJMM8B,$J5#I,@%F4M:T5HEMMW7(#ES#=MV3NW7
+M,1@E.EK.>5.,UPE*%%EBQ5FS>9JE0^!#W/+RN9[`P@PO)JW'>#$!:0D`KQ)\
+M23@2""\O''Y,EL/IJ\["2M97B!=K=7M!%QK'!9%;;FGU3U!H4F20F0"R)CGL
+M`M(6@,)2=2B(*&RI"$Z8``NEATU`E,DOY^8#9%9J'O4++F6)%OB#X^)-SWQ$
+M+)EELRP"DPA7VY[/&[!)-8@<@;(>OR-@KDCV-GR("]BM+A3%!+V!1_O-6L+\
+MSI[%2YXU$DT$7PQDB4@@T-/QIB]"(@UX]8C[E@JO=@=$4=*HRZ5GUJFR.!0E
+MAHBA*GG:NW>,`D<K8:QBJ*TPT8*/[F9F+*:^Y/O?8,*-'#EJS3&,;L?&PJ;)
+M!U:P-57!]8XIOG$E'XC!YAA9*LM6X886L+B<BB[1J+E<U&7=75RBZC4;NI3,
+M&&[NIW7#F7+FHJ-1<KFHN];YWJ4BBBBO5RN6-1J*Y<U&7*******)4]>OQ]U
+M]>_B*,J&(KVCDE.L:H*,*2C,(L*%1)`-*@XHJ8K@&`&^^XW):UKJ,-[JX@O0
+M)B!B!DK76%(TDB***&WSY+[\V]VKW\H#%5,5!P4%P56#HV:,/1LXA`@;%3$%
+MQ4,$4YK"B)4R,5)8"9$AA(8`8A#$0Q<.QQT-_XNCXYXZ4[B(UZ.(C:6Y177;
+MPA2"73+PW008-%557EV;)!2PMD(LG9!>@41H+K^?L9Q^^C>Q;IO,%!BZL/;A
+MP;\<>EW.I1VN845<W1<=;6"8#LIC3D6!FLR5[<+1*%[61"7+62J,X9CHFRN=
+MY=`YJ(WI0WK6ZD+?'+56Z)NO0.[M;4';!V=<5&SS%:3+R9V7#R)JE[<%MD%S
+MH.J8:KN-T3>!Y+KLY55<$55[M6E1)73HU)0LV6-593A[`LJV,]`4*Q^/<J4`
+M"`]X@WZV8'M"F>`ZANX[!T5PK(@;K,%K'M+M&\IN8ZW',EUL1%]CEJ^SW(G"
+M*@M@<I4WM-;+=RL@(K<S=[==USQNA+(W6Z"NT(4_'>E<31"!J2(R9TJ=0>W@
+MX-FN(Q%8(6PJ`H(QCI;=F12BG7<DHT8K%2Z=U=G5TP&3N25G=RB%*"V5*41C
+M&E"EA11I:-.UVYT:Z9TKM=VDR9N[=(A2VBV%L;2UH,8L&QMEC"QHBRRE*TJ(
+M#.&85(5AA:MI1MH-+%:6*54I+;!E+;$6*,:74F=";NW9===`3$%!&E*4:Y@9
+MBF87(XR,,(5BS+%>,[E=E.JY4E17=3JNVY)C,KL7=S=.F5<JY4W3124ZY4E1
+M4KE)144E&=U<GG%)HE+&106BR&9#!FS%N*,2L8P6D9$I19$BS"6L82,$&$L3
+M%K2B:TRTEI"M7-:6RMLU6(K<MJ[@YD[:QM72J6K.,E8[JBPVJZO"+G5U==&H
+M6)#&5U;RKJG"#`2(2EI1P8!D!L:S%,%,,!3%4*``P"1<%&&G-K-FYJ[($9C&
+MVM=4JD4)C!\TTP^:;MU@,!,48%I3(Q5=+4UE::NW,REF&$F2F01-!(8DA*`8
+MP*6V<EFMUU5U5)*S5BVK)0Q"6B"2)IA7"194S(65G*NU26US5UI33,D2&%2U
+M)2-SFF.WK^&?W+2.&M_GOUUOQF;#F=,\W'^KG-GD]/CSWZP8C#U))$&`",AP
+M[<381%[LL8+DOO#Y#3BGB!<DB!4!.R$!,)5!53;C\/R%45#'D+W#O3YT=!>M
+M"@B9/PY,?/FLFL13IGW9M-,8CBF)<E>KJ:_'GIIHW,4L]+OQR9<YJ9::?AMW
+MAUS3.3]I8FI?O+/RL/3\SEEIF2&/$^`_$!>`^O;7WFRR.>L$$`IU"+9[0/!5
+M]0O>6^\'$"S5WPI%FKYD`5>X*V!.:V?KI9*!((S`.O@222"0$0@2D5(B/+T3
+M-7C"Q*VI8Q%BD7!\TXA-!HSSSU\YP:F&8B-0987,F(NY46FS2YD320O'&G<N
+MI,KJE<J-7$7,WMR=8;4;-.9*Y^H_E$[Z^'IR5)B)$]>U"O9[\^;<8I#(GIUS
+M*V,$=>MF1(QTA2EE+VR8="V[X[&S?0MNLF@T_,8F-O,NYQFWV5^[QIC&.#XL
+MB.C$*M-=.F^M:D*V2,"%$%P@@DD@($R4")W.W?O'#KBN^=&C)($%"4Y11148
+MFDA`FA\7(*1?7WYKU[E%3Y^./IZ/'SL,AR*R*IY[&;DB5#FW:LBQ0HEW/.8T
+M2Z]`9B3;-8-BR!4$Y,,X@:9;9W+HW>)FS*.@TX]*;,YQSA;,0H$%$Y**J%V2
+M;W5)!F4AX$/&O+HT0+OCTWWO.N_%>=#:[7G]K[;."!'X[07Q;"20LW%XD(0+
+MQQ;%";'7]Y7GU8#^7[]@]FH%=X*]7ZXQIGX<.Z#AH4;\&Q^$"2]7U"_,D/U%
+MU5C"1E;3/*,+*U^`%$[EU!62*$'DE]K\]_5^;].MYQ^5=,1$1+(,^^*D%G9A
+M63??KA-;+6"HH\,H@YDC`UQK;>\HJ@XI,(Q!@)`"@H'A&8Q9249V99FVX2%W
+MR9)NB$WC$0;J#)9!4,34;VX;L"4JM]9T<-;XYHJ6Y@UXFIP3:PZ7B+@<`"%W
+MJW,R:2H8("0#SQX>WG=YL2#"<H2D8$MKP'V,/PNEX#\1[U33;G@+#LYCKP%D
+M>]5A`*XO1Q^:\!G]'Z@,L+V%`?+&)F980P8VT+L"G,I(?/:^;P6.8JD*JG5+
+MAH>"O$[/O`#Q]HW.]`Q_/$@L!`A)NA\=T>]H1_,$>R72&#B%GO`Z"+8P4YE2
+M(>&GKK'`!F!>A#K06"(JAMA6,6>'4FC5%.8&,<\:')3S+WX.R#X\`HB>ZLJ&
+MUZ+/C6M8KE9&.#T06K"8#H`?0,\SCC99'2MDTDJ>@N^29)LWIR:Y-5UN7'#Q
+M+<%EZ)>2+&=#-Z32P'G*S5.!,!,0*:%3,A9;%-'?M?#H--)&"1(GHNNYVO<X
+M]/&X;9`V@/-T@;0ZB6E%UE*K>G0YSL9Q:*!/4Q!HO!-H.CS#+KI='N6X3GDA
+M(/>\#<'\")2;(JUGC"*'P26@Z4!8UI)CW@[:J=00)\$??DWG0?A'D+L4O`#W
+MO>Q(CY\^8B:"JHF?4Z@\^K#B104W2@(=DJ_+082"AX<P)E#8GEL04\>:QU0;
+M#3X,U'C1O?/`3F<WUA%>\D@J\4`7GR(.YES`DB%2"8"RYF:L:T&P-N1P<DU;
+MK@6[TT*@@ASK(=$02VUIG2EB%!*B8#.X6MZ:79FF)@)B$.!"(]&%,+*6HE+;
+MK#;+H@.LIDXMGM7D)F=<]G;RD]F5'?BB<X$I%79J_6=M&#X#R[QPA`%<[8TC
+M[^633P8"0L](8#%2"76WUB[6%VDO*WXK\A+T6K23_?K.6#X]E!``1COA`:2!
+M(/CX1BHIQQ=\[Q54041RTX.R'G4+*K,I-Q0SX712>GX=:QS/`6&\-XDLJNH^
+M=75AJ29N9)IC@NGB8ZJ89C3"R&L-;WP(L-F[%FZXX"R6YK0;F6+'9NX"D3C7
+M/;6=MT,\M9%%)KI4_G[<KUGWN_JV`P0?"4V`@@@O!!"4()+K+1%"@PVW1%C\
+MEGT@!(%)"`)(5!N4`;'#!QH2.&7-H9R"3N8.%@GTL00$_7YM#FO0=\DIY7S5
+M$$&_U_=$&5@='3IG;AO4.I-;EC%@J(Q3I=9O.^%3QAD00ZSUKB"(OQ8]`L01
+M-)`D`-^3%L4!3R6N885@N(+;58BBGB4T:-!EM9@-&1%&V3+'1.@=X>[&I+DC
+M`+M@=$D4$/)'<K2OC#8>W771')K,2XN:-8;FJ313K3K'E@79:6B35*(SR<[\
+M&4(0K`A%!.*9AAAF9F>>-GA=&&PS<D&9?B`22+"]&V%F>#A'`E-U0]0H?!)=
+M_1EH<,!":9VOOKHVO@@DFCYJ@,E;YWR=TUNZSJ9F$F&P3EH+A4LJ#$)BDSOX
+MWH'A".,+$ROADZKXJL5BRG3L:\@ZW`N)<H+FQ;F2DB3186;8&LT)^F%"YQP9
+MQ$V"240]+75U`4A>J"SKMWU$'(Y:4Z>7-@6K,)-PUP:<#$UN\9<LC;.;)3@L
+MA2>^8"O/C7MGR\:^`%0WXP0$]2`IZA7SF(M(%"$R'.:=`0P0PP'07KN`""!#
+MR5D,>2"\$K?O40-2`L/9!*$@@L:,DD<I!+^/[F]L-NI4`O4V-'TS[$$3]0/G
+M]\`KWX4=SU</A28(**!>^X0UKJWBWN7NYSQM[[-HG<IJ!UBJ)<<BJ'1OO1MJ
+M"(UPX1;^788J")S-G!,\VH"C6]+B^95MMPE.='5FTK<=+4=3JS133;W=/-3%
+MJ<X`=:S4+O1CFLAWC.,.6R;=1PH6TI"I-4P'1S,P=%`L-LK!*,B(4<+'R]77
+M1M&22HR83JFT\],YUYQ6EYM7=A75EW=:YK.MZ!+>*H:D%=QW"@[B]8`ADBG6
+M8*9WWI79F!X8ZG5KB$*QM<A/Y*9!'*Q=JA5B@V]<`))!'QIW5ENE892.E&A0
+M"0/B+09K8Z!U#9H0G@D@()`V"OI01-"]02*^70$9^##;SA^Q"@,>$1M`FD03
+M^H`/SI(7!.Q@M#1S+`469UZ+DG.SICG`:U@BLIC2F$86[I_5Y79,/E"?54"^
+M614"K#:)*!LLR"SZ#%]:!\7?D.00_<WI"#QKD@[<44;958QF:XP-"L1%R!)P
+MB/G5)`(S7FT.]\S6CJTR:&#<&QP:H4M/(/$S0"F9,P9,$98[5P[H83`NB\R6
+M71-$:SC4JDGNRSKWUZ^.9YT/$`@H!SLM0Z>(Z.0]]>&SQRS#!(0E#**L5BF,
+M\T\_,LF78Z]S?O>:RYBZ/>4['E`T6*>V\(4`PCP&AZ*&'/4WHO9ZP6E?>*W3
+MOH%H#@M"3<H0/S\!R!3=^RUPMIW.]X;5^&4(!X:YQR@+!$'N$\%5!)J\&>T!
+MC!8K9[>&C;]81VT*8'KJ3P&YBBQ+C&\\GR.Z&^0EA+(`P*@*][A;``_H_/36
+M.B6<*[B]IY6#2T,OQIOYB!\J)&9TT4$=K)P`'G6$",A.!*#'LWG,A-@H+)">
+M^=]O%US&*#DD)9(2I"3F_;S[1NRNE0>A06!!801-\RZYXN@1)M"(XQ"2&)!#
+MW<ZW[MRU"2'9!#!A$B8$D9SG/.^]PXB1."2,3$`Q(DGWV_,]^SQOT]`,DDF&
+M(@P0;8YK%SK'W-X7*D&B#$P@P@[W'?O,Y^]/$-(-8,ONS*&X-8[R]A[/V9)=
+M8]O.^'7W)E#X-EX4*\,%^$\!8`=^=]F[G#4U[?#1GA0H>@`X`7Y>OL]GAP&^
+M]8&@;I4K4H+%UOM.'8X>3V#WGGGGFGIAI769\U9)(^RO<P\0OPFCAHP<!!H0
+M@(P9!K`3]?A3P;T'2V#:JENUL6]B0M7PH;O-;=BML=>[S?I?M\+?!"00,=P0
+MP34%GL`H/)N]<>9)E/>9!(5.ZMZ*P<N63O=?K`H/@["`L:!8H4FH+P6++8F"
+M6@ZW<.ZVPJJZVCIV!65NO-(P413$=BAQ(P<+&#1>K<J[5HVX[J:C,&X3KQ+O
+M*=-"11'.UPRJ&Z+]3M736"Q8P<,'#0018L<6L>\V]P7,6&@W=WG9VDMU>,W6
+MZT;"SH(]H=(=1:.;R$$F^T%#`AB&C1K!&^L$8"'R='NW"[K:-,FFL6+KQ@]Q
+M.'3(G1OK!&4+`@"'EAV\E9M/,&@6@=X,611%8,3@[LJ[I]TOE`>.8*Q+H%U'
+M-6<N8[1*M(ZO>1E-D[G<ZH7EF+)2O&A&*&A27@=`80@[E:-#YK!V"[YU6WPN
+MB,U.:9@V=O65'[&NO=@I8GDQN"9U@-]6[>]VY=8I8S=0*'=Y(:!MYMLY-AFT
+M$LWQ6+M2UUNZ#7:-[1>9?O`>5AR*2V(LJ%5$QSN7SC#>G6=-"%KVC1@H:+QL
+MS5-5T_5NF8\T4\FEEYB74[O#W@ZRJ%`C1`1AT.0,<.%B@R<2>ZM?/JRWG73Q
+M[[,EN$^'O:N1%G7MP+-Q+UBHN[@W#XI)D6+&!:B^@L*&$"\K*'WWU:?EGQVI
+M]\ZI_5>N4#*MS`!!8X/`Q\1&$JQN\N7G/*2H*'ACTAG18#'"]%YF#5K&A:'N
+M;D#5;S$P0+P]GB/#V!/-'@[/&'.HZZWUUG.N"Y"DI"T#0`@^\%B`5W<`\*2"
+M(`L,L8,X555516G3'F?#6F?`DW@K=.CV25>UNB1X=Q0:UXBCXBR224TGEC)G
+M72IH<"`28/'V=?.;93K/M7OMM/F'GR/BBI8QB8A]="*0Y8P6D0?)&YV.=+W:
+M-W5E15Z)I=:%T+=.G=KBJ"9PUI3.)!I#'"<?MICI>U9N5NU>2CM/:JKA.SF-
+M"-<;=O5=M.L`S.V^6<;VA=D42\<H44Q8MZ-Y#XDBI):A4,T1C[YDS%+$@P%(
+MM(M"!2`1/CSS=AWX[\]WGP/62U(J29YKNHV6@M06&'1V=FC@G(2D6(22!H$H
+M5806`,/=OIG/-I:]C+2MS.N==Z8M4HI.J4@I24FVE2!!,N5=&U+M-M<`;/C2
+M.+S(&$HCRWP5WNYA\2)J9)09_#\MI4<Q-51L+KNQ8PRJ'"P;3P[MVA;'RFBG
+MQ.G7O53Z\ZU::/3=M[WI,(KF%<I8<]+5MEJ5=FP@..3:O:1.IG-/*09<L757
+M33:IA'+<=KI<5UMW;/%V;>I[Y-)Z[N>#U,7$-KJ!="CBL@J^<'GE;UY<9&:P
+M8F57&"ZBK3H59K6UK]3S`]O8-U/`3=98/05E4(<[A7;91P,^BZ1CKV6NX:!2
+M[.-#:G33X#2/#-.)QNJJ+#N/;N72+0>Y>YI=TD4%T$WK5IJG)1.<"AG$&V-Z
+MO+7$+.F"Q>G+6`Q"S2/<>?.<CW]H\9O`$18_>7:B'M(JBE&)*-I:6E,5K)JH
+MUC5FLT6-:3&4M8V`I8FEEDDE@A&A`(1G6S0RC;-4I*HMJBU(+;(BIU^K3YEN
+M&["6*(JH*;=M%`!&FU3JZ.T*C7^*U#V!PEA(`P1P`P?LYAQ:LT$B%A^%8<-M
+MZGS]'Y^S7NNS,=>>@(G)^3HD(QSAB<3'IJQQ]NCSVG`XZ=.EI'H@PCCUX\*B
+MH=^NU[(F6-K8SY<Q&$GQ8$$J3)$P4$PYG/8YGQ[Y))/J0P+F3P@%>_F3)=3Z
+M#ZK9S]0TLCZ*;W'"+^3Y.LYZ.AQF@[[Y1-,05052=]:9?BX5;:5>S]:1XA$L
+M#^YNV)Z&H?P0?&]SUE90J6*7J^9HW,W#)-@8NI9G4IED`9"MCWK)M%U`F.#1
+MX:YQ3'1J&M0@]WU9Z9Z.\T5236=CX.L\[UF^:S?/;K;R0?,JIPD5?$B!+AW(
+M2T3^5Q*3/<Y,]8F]ZTT8,8/D(!`?&WT`0/@2+ZKL6!24)\[LX"$.!#:+2$_(
+M$[./UCZQX'/;EH6TM^0^!-G3/IEQ"B;^%"B4/")>8ZB.)+=)4WB5-,1ND3^D
+MN@F3SNOMN*5#@3KJ#.1FSBJKJI5#O=8(HF&SR133535/JSOK6@@J*BYTJJOS
+M/`._A6<%[SR!D-#`4%4--0K*+`S+3&4#&'C>H9HMHBBV6J;MI+N9HS4%,MK4
+MI!PL-S5)'(WIF\1C(,.[+!%&,)W>FGQ>P2$@%N_&;&Z=ZV:^.E0-$(F;WUSB
+MIF8@A=>_C:"SVMW*1'LO8]J)'M=7*1QOV48YO?=HJ&T(/0,;>U[\18ML%!)A
+M@8T"=+@*/I1$&YC]M>W91M^$"CJ`G@>-BZT$OU8V(\%])%*]>6QR%C@2;H:$
+MATI%:-3!8:=`9%N7[=FL[[+E48<0H3&V[F2F2_WD+I(7]OU_8XC4E+A8=D4L
+MO,7B0;^<%9J@Q(;4_=E@B[NJZO?081Q4MGXI\@R(KH2[CCTR\#"%_#3XD@@(
+MHCWB5VE!3C73SVD"3:<7S+00O;R4TZE#RZCO>94%"FA;,$AM@'BTS<BW#,.#
+M@MMA-S:C-I6JPP&5"8E2QB^3+8.@M&0=:1MAI$6TAC`K#[FN<\\3-S<Z]#/3
+M1B3+XS)Y:$&2`R%H`>'O?R3`\4+"?PA5/^TF*@-.W4H!728H&((FU+0@B1MH
+M=3>3'CJW5G+M"VQEF/+8K)E56+.:H*K;;-X$42:!]C#""22$O]#2Z!>I!)NS
+M#QG51KY5=98JJJ>7\Z.`V\+PI2N'K`X$^!`)U)T]NHQ0VAW]-=#I$.QDX0/(
+MS;#+6VV#%+Y2&M8(:%59JA6(DFL\S<QR7<J/D:*YHA@&8.-G$$LS!;F`+H@5
+MR!%`C5UK84<><PLS;&II-2-EMZXZ-T2&,20&0<.?!WM-"SYS("0BGAY]\7W0
+M:%'N!3><1&K$C%)G&#],L-:SJM,,8\]O;:T$T$N;\_Z%^8;;"X4V[O("&661
+M@,"2K+/EQ>]GJP@G'75O\QCXQ)$]7N=BEV/+$/:#S'??K5>,-)I(H.GMA*I4
+MP5BDI[Z_3U>O(C0:GN^7[:F2`!#@0V#Y:>*BR^.-B;NZF$8!),,.S1ZSF&&;
+MGBZ1!F!1)H$2WB93EWFRN.3`%REZ"%8&I;&^4Q-)QD+`FFB!D/'1*HM5HT9U
+M3;I4-#IAB3"YDJ"G(`.F>=5WHV`:FKB"26;N:F1(-[9U8T0C.6IWJVJ(:V3N
+M#2"GOAJZG..<0&=2UBC:-8!6E<PT3DF@\D8X:+"H:-"W%T-%D4,.7-#H%%!1
+M:6Z?%*8J"CJRN'!TZYF79N+!$5T4V7"XYABL8=5I04$3@3EX<<2:2"Q9AP4Q
+M,RJ9'JR!4!8"SH>,PS.,)#K&0J$VPX*=AK<W&F?4^('4H'J/$ODY8(\>>"LT
+M!2O=\?.\OI>Y9[<EC0;%,-JOON7KMPI,5@_+;A/SU<WY:Y1HU&\<L6"_,N4A
+M73<GWZM>_FOK,141HVC&+Q<,,&`J)*E&>6SS#KXDS$:#-=4U,%3R<<6Z,%WL
+M@EF&:F!4-:Q9DM,:+3)N.D&'363$=F%IQ;H::A6Y'9893.^3HF"#ID[N$.^_
+M$)`('E`$0-2@H6L``:5!I42ASQ\D$*04V3VI"TB:4=A)"G(44I)X-<_YJ#O^
+M"Y/S^NN+[0N2-D0$T\TH3R%#XEY6#?8^'$M#6PRR7KAPC5ZH(3X@HQ&+*\_-
+M25%,D,@!T9=T-X6(PBB4W.FO`;0LIX)EI<R%:SQ$UJNJ"P;W)+FC!;9XR$$<
+MU/,P+0(*A8QB(H*:D0>KC5:M.]FQ"2-4(B76]87-F-!!H<DS;8J`+0(*@=/-
+MNS/L/<\'C.>K4KJ<8]@7W^,]]%T"JB=P#K6`MO`#7,0+>"O-8HKK6](H:E0-
+M6223U!,LM,@RH5#&\@-"$)":WH30DLFN9I9))ZQ+&)X<=9HPPMXX-&A&VBFK
+M#SK?+UVLN[0!(:QH.@@D@`*(=VVRN?I'1%E5+3N""7R02#5A18)JRZ%A0)>[
+M1PV8:R"YZPV?&NDH'Z^)N/*5J0B(%84-E75]O+FL>UC>N:\\$D>[.Y(_,8DA
+M)&/=&F]\NNYKMYOSI"B$13QJ+%AVK:]<LR1@B&6`20AZ=Y?2,(Q%VWM+YSSA
+M@,V[`[Z,%)D:\,SSFQE[9D5Y=Y>>MY<I0C(--39MT77+Q6+6HNF\%N#K%V#B
+MN[(B::*:-R9:N`7%UOVV#FC%F6]Z9VZ^?&E%J9TUR$,8!"C))*@%\ZXT0QDF
+MHS+*CWYYU,8JS1R4M*(,03(_H?#:DBD!)1[@E+B\1_`K!;3[:P4"2228*'!-
+MO1'W(;XX13C%$.V\7@DUAE2]N<-":00\$[JK$41.W3-S5%58J@J@M./&@.0"
+M<!"^6T:CZO)2%^F\K]=Z#TPC>.+,;5HQC3<U?TUDTWQK@A,T.3')IP6K@`M#
+M:-F)8YG1\[5KB"9(UC&W-+2QH(W41'=SFL&]R2$D-)`@1NM1&648+.*%]+"J
+M&%LEO:UKH1^Q2*4BD0I*1!`P`##``,,J(S[X`HXP"A$`H1*JRH$JK*@0*%B%
+M(A8A9!*$ED$H2424!C`DP`LD+"%DA((0K(H0K(H0(D@N\!$Q!852$6%4A%D1
+M)0)$24"1&1-XB.(DBR!KXTBY@H5%@J+"QG`Q%+-8,3]4$/[OZA0%!((^0;'K
+MP.U]7L'9TD7:=(WT%FVQQOFT$-23VR-"2QQO*!(V$@GMO]UBPVW?P'@O'3*?
+MB"5@D-G52\/P]2"?H[1!2:\<^KNGKK<#!158.U5#MT[]R,?0Y[4T[S%>Y*4F
+M!F5W)GLX:=X*\X8K2HDDDY#BE"".AZME24O,R)F=Y3<'#;5<I<V9J:((7L9,
+M@$(`A7I$Q`)5U52@,,$\-@Z8SRGL$"^1->*$N412;4<Q7B,-U'5FAE<2D1`4
+M0N5$*HA)._0`>J$6`!M3R:VAD]X7[P\5X3?>+NZE_S4+!#JX/-W18;H#!X`+
+MPT='AI>YC@&ZF,#U*_&Z->MS.NZ'O7WKOS4]J`]G#N\F$((1/&5[WH)X'UE>
+M!M19@#NQ<"*@\`M($V8+`LLCJSP\=`T0`^G96(=0#']V![U4(/$``KPTZ*E;
+M72?7GTS;92N,^'VGLEYP[8DDB+83W,9UV_-!K&>[^!67@'K!D5D`.2G5`"R6
+M8;](D!N9#`(5R`(@V8J`W3U2EI?A8(\/,9FRR/>'M%6_#W@;L&VJM3,\!Y\M
+MVV]2/A[P&60^%H,+;\!X`;=B],`Z_>``%4\T2LU-=O<XW))-?(F`.=8[WO9F
+M]D38"0][R'@`J2>S;HY,V4P?71J[K?#WL'@!3?O>8\`'QH;KK#.F=$[X`#!X
+M`/S8#)&T=8=YW'6<8W[#4OATCR-(UH(!Z`"'.1EC*"&QXZEB$$>%Z!`/:`U$
+MU]#`W#8W'N[S>7UF]N>G9W[WNL-LQ.<1@?#PW&2;;C!PX<CD-&F1G'V%T&T)
+MESKP#W#@$/,#`.`WT\!?B+%B/R$%BP?4@0[=61MBQU4*@;3>=?&Q0FGAL'A7
+MB-'#&$(.&`@$4)7O4)$'+Y9=.YA15/:O5T*D+[/6^I$8JU/:K+P7E*NQ@^]@
+M=(0:."%@CA0O!*&@CC=$619S=Y"N["P\F\*H&]--N#JZ1VK>-4"*HAC`11W#
+M["T"#!!MS=&3QRUHTC:49"MWMXCLNKO!A]MO8(&+EGTL'-Y[Q(Z[%BQ0P,#0
+M1R%2UBMGNY%7=.ZR#N5X>CNY<Z"@14QFK1O.Y=J$%#D<6K0N%`'W#AWJ&C!H
+M8(L<_(YF[?+K?0ZTJ.:"Z"';0O<UQ)W9.'FQ773VJM&G7F,%+@QPA$'-2P1P
+MOA8H72OLN]ZZ%';N*M-7W9UG*3EY7">'>]Z#P@8]!A&W=]6[/=9\AH(>"AHL
+M&R1W4,"!(8T(Y#'I9]AVZUV;_PGDWGG-)0B+KK!D^@RI3RK#(GNF;.PBI$U"
+MWF/+>4=L(4*%![P(M@BQ!NAX(.%V@<OLT3N/,Y!MO.HVX+$.WPV;@6R'+TY'
+MOB!PP@^L"0^(GIZ+5(Z@WW6=EB(4*#'2@Q5$HW515791%6Z.X7?;HXGH.T^"
+M/@9/,/R#FX+'#!J`F8NOAJD4NK[.L5VQ"I>UM<KSBJ%'9->X;&'#)',RGMC>
+MS4!Q<C`R,41#AQD9$2+P!(4$9=LYG-7>&OLS*F7G8+1:2$L5E\I[@3FJMT@`
+M)"]O#7905/+L95UMA7=NSLZN,L;GNJT=\/8B'H@F81B0Z#21N;)>`]S<'&P3
+MN9+I*8:"5JPA-JJ$T8$+':.8D!'86LE76)S:6:&H.B!!&@C"H]?AX7A7O4*$
+M%T<P/1V[N[>G3PP'S50H+77O81E]<>;D&:@'[6$.'0-M.0U[VIOS-GA58K@3
+M%HU=BQN._220]::RMUO:U^K43);NL>H*H$%M0)(SU:62@-/B=,TG0-#RT'Z:
+MS&#F2;>[TDDRP7@(VA6=V"ZVQ.(VP*EFL;%K&.;JN"E!UD`F,"A6NA=BNK8W
+MG+72B>&CJ="H8J")`=&UC(0>]U95TZ;!G+=/,ZDB%2L$AL)I!@5RJPIYAMTU
+M:/5>94Y/FM)Y4K./;%(O6.VG9O:E"G6Y=F:P,@W:=$,(-RA3Q+UQ/((F3/#)
+MI,T!A7A<C>`@WG,5UYM=-IA]1Y=3=L(:",,\-(1PW;=,L]U3CF+R6@NXV0I1
+M[$*(WH,LJS,FU8N/30]W@&AX>'O#;JUXF8A57";MD8+R.JD,8'@035)XT/`>
+M\/:((,%@(5X>'O`3-FC:MBT$(V$XW+XR6RPU&&&PKB%535R[3;$$)&U1L7=I
+M72;=8O!0T?&")Y2\S1\R/8IF"A9HT0B2$T&?#WLI!RD_>8+($,(1!IC[ZYJ^
+MYM:[O0UVY\K]U[%-ZMO!QY/H7NMWZEPC2)Q[8R4TJEB:AUKMXH9-<RCES%'>
+M"GEC"RN!.5E4NLN9VN41I+8.ESR"L%>1P95'A5%K*YE!8FQ4)BLW)U*_7YYM
+M0:51!]@JZPN*MUD]B[<63"-OGEH"=1O6K-=*=C,$-HN;67UBK!$JWMQ5SZ0X
+M@_(=KX8%?5@)H\D:H$G5G9G%R56=?KZW>8Q,%S+,6IFTMM:*#Z0"%'KS;8/<
+M"7K!'12V[PK=DJH^"YU2%"TG.K6N2\.9<CFL(<:[<>R[@0.1"01@,$!B.L7!
+M@55AA05]C#1Y.PPXB!$1`XK,."@R48@5`V,*`E:QC0D>#8.`X)Y9/$3,DJS"
+M>C,)(E/8(#W'9CPEXW#C@?$:VHJ)AC%X"$]F->A(C#!Z(2$>DX:-RBS:NUOQ
+MB;-L[:_9TU+^S4Q.L8G6W<S4UAN,)UHTX..;155TP;3/`&WO3Y]OEOJWS\\?
+MX#P(/B"!7&CF<F6:(VA?R,HO$*Z_*J;(K[D_!1,GRI@I/E02JE<3E&M@5*UM
+M&[EN92Y8HW?8ZH=7E,$RE1'=*C!ZC5='NF1HS/CK[/9`HR)NDL2EECU$HY0%
+MA3,Y,TFMTVM&0JZ*AR'O,5`R1%-H,"!"YG75)FLEQ%OA+KE6;:Y2NH-$0RE!
+MJHZ#1/3TP1#A9$4$*&&`=:[\YP\2)[R.LQ!/4J'RAGIQ25#C>83#BE5&6TNS
+MKSX`=&C8=`WQ^H4$.X83H5X!\$4#X?P,MC#9!/O@2;0YM*KDY#L\H_5/(P8*
+M)0^(_`:0C;LXY#ME[=('/B=$-""P150KNE,%[TK(D`)#L>(XN6X86@A47,/T
+MX:9IK73Y@XDWJAO2>9=3"KJ&&3+#+@PX$HZC:FFQF*M+&6(-&XABUC!C"*1(
+M^6QZSMT[O?SK%Z=^'KJ'^M>!'<$Y+6.""\E53`,2#YCCU[Y7)+]^#8I012)>
+M(M`>'C5_#<R[\ZS1!9+@;C"!QV-7!%[F&BAFN_7P<>#..F(CV*+J!'-8H^2%
+M<1WYU%53!$HT;,@DD;:UKU-5?5-9T+&6U7NJ6)3<S,@66UD[Y,2&];O.T=-M
+M%K0G==;/'C>32PP8):49A;"2SNS2ZL6:;9VS'"T=V$(V6*6N\-[`R8V=6)J(
+M41(B,!B0!.#D>]/&DIK5K&YA:X\]28?@'ZH*D_-`#^4+8\R/$4+\*%T/4*"\
+M$*=>S+\+%BP_,?I,`KU`^/M>P0`D44"/X)DDG"LNYZ22/:]Z]4QMML"&\9YM
+M]7NP?6$?I,>;XRQZLYQ]R=C$H-^6L17Q`<9'D>BC9S=;M76.;+,=Y5QIVIAC
+MOK>#MTD))QA2$J1&9M3YKG?FORLEB&2:4HL>ZE7HE`8@];03HFN;<18J)]YG
+MB3#$1EU9JY`RA+&0M@6X&FL=3+F,TXER0T"HL%FA`RV)C67,@.4R7,@70:MC
+M<Z"N&6708J2H[A,NE$$C:5$H4/)?9L";[%"H!1"2$4HAHC5[M(C;:9<&%I&W
+MQQ2&'#VJ@8*"@_L*12'?K7(?%=`'Q%D'OG0"(WDD-<(0^'-IE'V3AE!)7[O;
+M5^=W3_>'TTE:-NW=,R4:(UKOW_%GE@TJ3]\%F8W'X?H%:TWF9:&M83%DU-:O
+MA<Q$\V2:!',2G!);'38+*)1C4HVBSB:=)F,I:&#J8:4%HFNR&SE/6M[-RP0U
+M1!">_MSXXZR>7HJOBU444455%>S1WQUT:T$A53NS!A*;85!MN^K#_$0OL7$=
+MS;K;T(6&RV11P?;@L`D+Y\</JH/Q%]K&`$;:&B]KU@F['>(ZEXD?O)`D#"?#
+MX>C4),),7+[/G5Z5L;P;F0?(Q]+TQA+$U$3!/9!\7K),;$YH=3-!ET)C$,6F
+M%)W9B.IT9A%,W:Y%+3,'+C(XZNF65KC'1C-:S58R8XJ@BHC$Q;3(%.FY-3#@
+MT9LU?&:U+HL(!6!,ZO''?LX)GC(0_IT9!3^39"2^P'R'1CSI>2;\7[&,@@Q+
+M0J2PQSP[+]T!#28;'>;F57J1'$KB:&R9$";S*T'\%3:P[GA@DNJ'78^#'-MF
+M30O7]YLD$$$DDV4.*!"2%J%^?.ZO5]+QZOO\>0(85^<1H"(D*6.\/&S,?$<T
+M%4QKLC&9-5^LXY=^KHJ-)+J=>='F)T2RW#KFA,@L!90:ZC)4%@(8H91M!FN>
+M_`2.PH@L0@F)>M[^#OOZC-M1?P_-RZCHLY=^F8,Q%^54BJQ07$+/K488)#88
+M9(F>L?P'*!%"@WJ0D)/OOFQ_!22$_5@)6"A^^/50X`_(*/2(NFJ9:0TWF_>X
+M_!"[`EC!/<@R_P;T;<#=TPHXC#OZET^NB`\3(?M#NJP05_`C[8B,+ZZYO?=4
+MFKWR7K:DK(R`H=ZKX"VRV#!+;SX76#.0AMDI6%J#8Y96-3<N9;*.B0,0IB9:
+M#@)!CF!:XJPQ*PQ*DMSHR]H!-DJ`P[6;8'CMQWN6CXR]-=.-]%4LS`"W^0O+
+MJ!*Z,#$"_D=*Z$VD6BRN@4&`Y1CPBN"2[KIT+.WQ_#`3Z3[E`'?U7H)H5*SS
+MHX,`8X:PVZ5U]GJY<0P*.[!W3;KW*A*J5OE0O;RNM"#4*CXS3#8EO*NTT%!^
+M3?J#8>1AY&2%$:2IHQP'T-$,!-8)!:-&TC8JFVVPEH]1USE==:UK71P/45,S
+M411'1R\M)11544+%OU@.I`Z4!P-*@^;"!C!5%B(D=;_7?]_\./W;?N8,\M%B
+MI>:[2LI-%HQ9-72N@PEP,+*6KJ.H%<FAC<2N@NAHME*G*CB%`*("04(*,-][
+MMP7VG=;56X<44H8*!)9I7?>JB5"PZ#\YU55>/B6-87DD]VE5$$WXW!;2@(9W
+M:]G,$$Y8OPTC2-ZUUL/$;/">@*4*"J")IZDWO?DB0F2]I"@;B.)A>Y=FI&MZ
+M'4U8:$P9C"&H9+7'#+EQ*\M,FK<[X0P9JPUP8@JZ+*K<UFN2;IFZ46*MM*?'
+MO`)TWSQZ??_-P8:XZOS)B**+]+WQSU#(0K=2JJ`.T('`R)&6`VD!TYH(&J<$
+M+2SP'K]UJGCHM@1=W@>:%^]-OP%0^]X5/8`2_>`65IP&5X5?N4>4F.T<`1%H
+MJZ6Z`!W9XO=DK.V:#E>$WP@Y`3PN>%L"_1S/2MDSWN/O8/=0WI[W:/E3%[]R
+ML;0@$Z\?=V7KQ]NS)%5[4.CW,]%[:]NL<!((R-A'\"W?UNP5RL40<K,L4!95
+ML$=KAE8F0SV7EE6+!5U6"]./6&1APD;PH-$=N3(,$4(J1D'W+CG(QC5<".)&
+M@8DB,08@UMO/-\S<>PD1B#(8D0Q(P3YW>,=E=65:LU855O0*'2G0.*#BXBZX
+M==86S>]O0@]+P%SN1=":%M^;QSO1;[H'Q\/>X>%CWDSX`,>8\)KM^\AI2(3M
+MY]W/MU#L<1B9Y#T,PW&TN^36NLJLM=UWVMRK:U.\'!D>3R=RG.'#)PY/:[EA
+M[VM:UO65Y74[XV939OK\^!][*L8+"!$%"@?$8)Z6K.\@/>Q!)+3HI374\>!]
+MZ9HX6$"(*%`C@B('A\*J\W&:NT%H8*?@.AK.F"41H86P($9@KKR\=GP[NP2Q
+M0H,8N%.:?7?MV/>@G+=S+YOFH4"#6HF8?3/&F,'!CA0((X8$1V\4#Z0''W/I
+M2RR=4AY+F)E#0R29=AC#@$@/F-`H8+%#!G"LS,NW>],J-#,I"M#VZY8CM9DD
+M&YHJ"Q[K55<%D^@Q"Z%"(4+!%!"#*`@@JN6/;M7)'NPY:K<M#4[W!(^\QP;S
+M[>F=?4O4Y\,(-!L<,L6"Q0H:,\-H56,HU+NKW=.0U5%9H&I#*3J+8/!^%B#W
+MT\/Y]\*C0HO/J^"&!O[1@(^%W77HX,4*%"Q8G+9)?9BS,O3D.2NO*JKJC@T<
+MA'7*:V>/@2*]E((^]=X_09G.];5\#J&V(Q`?4,$'>V)BC5N;H,-T^06[1U9;
+M>19,REFYQ[3@UX].QU<D&8*U"A`J8(T6'80WU4,6$:?8"#VT6NQ6SLN6ND5W
+M%>+K0@)-D-,CL=.IX#P+G?5X>]]?5PT6/Q#!%@\"Z5VI%+CW$M-4\K[3?7N9
+MW[BMS"*NL-@D<(AHP;ZX-:%"DA2O"I5HW,:E#&RY9.U@WZ[N:76P+NM"@MWA
+MB+N[<=2][JP8-@U'PT@:S0[S%270KC%,%V0@&J$KC!D%B!V-JA6U9[P>/F`!
+M[KNAB@@##VGDNQ%G@`@1[W-$^&GTU:?>D0;0]7JRQJ\N;#2";OQ(LG1[P"\!
+M0/Q%UQ'-?!D?`FFWJZ!ZE5PYY#=TOQT[R[P<L4U5**BAFKF-D5Z4IIYTHM*J
+MN,^1^\`8/5+EFB3!/]!?587N!!!)+/F)I@1>%"$+R6G`&/>G@%X.VCT%'<%"
+M_$DT0V]U&>\!7J25908=V[+K6!I@US-N"8TVYC98<V>`R<Y;AFV6?!-YB,H:
+M@M5)VK>&_3I<5(%FBXL;:(2!*B%P*#6Q4`..$F+UZX0#$4J-ELB?``J'%Y`(
+M\<Y6?*Q6F.E\`_OQ0GL(1.<O,Z8?OK?B7SP18WXD@+4W=^.M#&C@R"GE!VCT
+M;PB4JAVJ:D#%2+FMXP67',ZD32'V?9Q303+S+SS3;YMYH^;<=?*S$E+(200@
+MP@<@^GNUFMG02TN9>]ND1S,);8A9!211''B""D$LCR\+%$I`L%40FJ(J\=V;
+M)!3>)2$,DF?V-S];=:H:2_CZ+X%`ZJJ#[*W?5AEU-DI/@YE9VW6N8:K")5T!
+MV]!'2TCFL=[E8B$'C.10,,G*&W2#)V%V#S==N2[5AYFI(S*%YAQH\LJN+=UK
+MI;<4TY=9<P4##6(![C=IXGF/&1<H6*IWCK'4.T4%AK0J7=<VS+S7=K7?.7EG
+MH%4Q;V*V:!4X/UC/8+7/-@S@'8Y"X*P!71$W&R4$N[V"BNMB^%&K13Z#.YW<
+MZ_<2;`[VU:&S-LVLT^-H`HH)Q6H3=J7#=$]N<CV[*P[SIJ6U(N/DS+9?AC%)
+MBG#L6F]_H@`<)02D!B42B@V>5\`5*$,(;A"%V`XF@6FE)0T()FR(6HE0H/Q\
+MRTXTV_&WS1^-N.OE9"DB4L"V2I(2Q@("B*``B.Z@T*&1Z4Z<D`"[G&]QP>"D
+M%M!WF6L)N8_7(3?[S4^S/<S,_O$21MV98]S'<$]*H(>RHHFW>C>P[38:>W$[
+M+MGOR!BT]2IBCO'9X\&B>.!TWMWBKR4\`@B0:9?$O@G@2]^404#"$*3P2&,@
+M4"E/;(@8PA4S>7,8F?.$6$6_+CP"41]+L>F)B3V&!5M*59Y<*58[`%"Z$$4E
+M(C33!,'4@F3=]9]X$$6?(@@@^^P;?RWDKOW%G94!GH!X?Y'.OU@)B/MW[$1Z
+MAG),DDHDGR\=..1'E,Q[7N=%8C!2".DIS8<,Q4>YYT3#8V)/CU^?.S#7<\>>
+MGJ1&)D\%41:-$$JN+*5:O69AFBAC!=FF+9&F(2:H1;$A;`M@$R*6;&6(:,!0
+M4,91(+-76[H4/3AL:#1:(E]^OV_?\_/GI?624T`@/$@,/_$_N#>WAG\L(V0W
+MY218'(*7H6V3'"/UBPDC:CNV3!#\/A\"BC+?Q(UBSB%'OA0U)<&]=<TU\*H#
+MYED]`1&ZX('>X/`EMU@8E;G?&G.'=,D[+PZ"X:N[\>U7X;1`1=\^_->N8C$&
+MN^;>SRSPQ7&$0)B`&!"<&CPE+X<:5E*Y4056(-;@6((8XL5"HUP[+<UJ,KBL
+M4N3#,*B+:.7)D4+<%,RA23&95CCVI?7X9Z=>D#A%!8#&0$$)W[/CR;S^XO$C
+MU/^^P>/]`A%%:TL@?230%4%F*ND/=VE70)574RP37"1@GU);0JOP%;XO7MU,
+MNN>>W5XD.X;%9$1$*A1%*S"2J\:*U,_*?:,[]1CJ#8E*A00\"0`P80(Y1MNI
+M2L<Z$Q92JHY2#D`QAD%$&V#:+`S,)4*B<4=6L`')1HR$"D01/&_3[^!L$GQ!
+M!`XKPWX7]6[8=6=64![P_-(IX@%WSQO:HT`.]\WM5*1=Y@K$K$+,O>!@$^L'
+M>^N/.!@YAOQ@;H>I@H`KC[;E`0((#7G%T*\$.8?FWYC"AR9T$03^!_.$2=4!
+M(^/S3B\22222`.L?)(G#M+?9P25($_=YBT$/A\`AP02??3`I\Z^6[ZO4Q\MP
+MDII?2((T#6Q>-2PTF[#NY-='%*R$.._P)!!)<:L@B::K!8JG':=M4Y!/&(O/
+M,,,I8\9A2VSM+FM#,C`0!'$PADM&G:9,,Z6,P.&%&9)PHF$-ET;-V9O<V,V;
+M';9<9F1L1<HRH83"E+CK';:W6.\,#KQI?9\>??OE/6*9"TM#O?.U16D0]Y%/
+M``>.:0=`"R10LD4*%@_3`8@I+)$(R1D0F[)0G-`I/&8!A+0L+0L+2SIAAA2V
+MEI0MW@5G%O#L>S4'#`A"&V&+#8_ADS(;H<?$P?`Z""#A%C!B2N;4:6C1AKPS
+MV]J^5`CD49Y^^]X]/GSG`ZJH"=]'?CR0:BIF:B*$[P.5U85`4752R@("CTT>
+MG.IV+&+)`!EX?(T\3$H)@7,FJR<C=M8&U#(U9.32T)D%*F0&3Q&43D.C>.SV
+M+>D+/;F:>CXK.FE.0#R1462$13EL@K&T;W&DT9C6]-W:QP;-4\:Z\AH[6`:\
+M[[=O/4`\(#4BF\2,%(J,,$81IA(PC#"1A'YDS(S&M:-2-1DS,IF8[HQ-)ID9
+M,F=KH:FHRRF9F9WMN3<VN(K'YC2ZBM+@OLZ9T5]6"L9F&2[!HTZTQ/'8O.FZ
+MU=FPI:6$0#IVIPE=]WNWX34"(0BC!&D<.(?,$B`G:]\.[[[VF'8]G]'UFU(M
+M3%,7=W<VE6D<"6)$)X2&1G>/A,/!O-P=@[-74T9FE64N]8PX-S<-/`RIH25U
+M=&,LJX&8QH(PPF&6&I=8NM99JY2['1F-D:C*T8R==:9FF6F`7QHNM#76TJ2H
+M3.N804%BBK$MBQ-?Z#W\&'^5/,((()!AE`$UP9?L&I$K*8&!!I*]S<&?B%B9
+MMR$E?8/@3JH0?6&V^N+`1]G(6=]"+!+[HA[0`01Z81]ZSON-NSC['B&HGU94
+M+5OB^3AL)DE;)JM^O$?./S?<>O*]4.=HSP),2*&YDS+:ZH&IJ&:MA6R;9B#-
+M.\&H;$610J5S4=30Q=C<@410H-HNB@A+8*`-HT-8P6#[2,2&V6*#Y/`[?`>]
+MJ7AZ%:PP!L7LM>K(Q:2PM4[)Q/J1=^Q()O#O6ZE.A!W(TJI-^0@2"#(IA)5=
+MP.7822#-4?4A1PK'4%TP^)WN#88_8(DL/OO)&OOE43,7Q@Y21JBRRL+694M2
+M[=`PIF:&W=@OZE>#U)[)HO.8K3MUB.IN7L8HABJHE/-*09KS"J6^3@,)B%%A
+M:ZU-&3)%E!(7"UT0TVF%CJEP$+IT=UUKBV8$09E;0'BF6W,`HI3>\VNN>Y\<
+MV5*E`-!2._1R?B^``[S`)=XB#'Z;RB,T3%#-AQS$8<8$%#XMATLRQ?C[/5??
+MTB$!=-AL(0F:2:H8*$%MEIUW/UC#L),DTQ'][-!-"JT=5LT>+7@]%9UXX;RS
+MO<BJ;-F(JO.(>QW%"4-J<2J;3MH4%Z.C&!"'.^>]8Q6,?%1_Q=,SLE1$D!7S
+M.HM,W+YS<69PF'9+.ETXI9"["F8.FPC[=F7C>KCM,]&]#26VV^-!D@LDCD6E
+M<,//'!I"II`4[6RZ,P3*'QUYZZKO7=KI`43,Q!1-FL%`7GOUDDDTLD1N@=UB
+M";?O[&0<WB0BU@`D#=-RS0$2']Y,I"@3LZH":N+A>K,]MV;W.'YJRA$EWV3:
+M`807DOKU?0$W8P:/DD7G>IG`2_J$$2%>UP2T+)A()NY4%AB`WZHD$(Y.I`U\
+M72X8VH+""_`51=#G>:/CE[9P4=(Q)I:K#@8R<`+;UUJUZX5#-6036'?>`&H@
+M(AL\8*$IXS.)Q+1RQ$&B-1&BFVO8UC&E*+E&T+*B"XF28EFB3,@V44R:EFLL
+M<LS"5*+J&3I?7N>_MY\!A]Y^D^9YW8%$_'W>?:/>A[@31[G1O5ST)/[^FD^Q
+MM^U4JJ[.?CH%H`92USK>33E87`3[*%^U'O>A#4>4#0`]X^]-GKW%[PS*(<&Y
+MYP967/5/&_>%^'O3!W;=7<5C#4`H`>]5Z&:[P'`@^HX"AS%#I8I[2[W*AY/:
+M>^/9;LO3SRLM^UW.M2X/G;/XH%CWW`$CAY90RKH#Y55'.P!$EJ/SHKVH#ZD*
+M"%JZJI)$):8=P'6YH`\"Q<4`K-NG-"2-9N>X9]VWB0D8SFY!$UTQ[N-;6KZX
+MOEQ[:$D4D5S,X\V`H<!20`)$94#PNS%5=(C**,J$B'GS@(AI4(!`H24)-R3C
+MZ]]N03@241%@)0&K<VY]W.M8F-B3,!+)"*)"PA?9[C'V?;:FNXO9(:$A9(&$
+M%D4-&NNN_+T*]B"R*'8A"(Q"%A)CXSBYO/O9VQ[V,R'2(V@A(+@BPJF*#"+Y
+MUXS?*\@>?&==<[W`KX%4\*#"+@*R(F`BR#&><STPYW6;SF,^7>^YW(D]$1X@
+M2@8(DB.`LB9WYUY\=]5D=Z/.KO6]J)VB.`LB=BND7$72)(%K>,U[[?MYUSG=
+M7R24DY$FHBP>C4&I)D-2*CN_:QO5YG.<LZOTGL2:#:3T')%1]LX.#@W#@L?;
+MYJN<YY)A3O.2X]D\/(ZCPZ+'')PYX7X78!`/J19=S#"$"7<OJ>RPPQZP(!F@
+M$`^L"6(1?IZ`CAGL(Q#@@A,,R5=@A!))]ON0-LQC@[2*S,`W!"30@@(L8-!!
+M`X:$*]=+72TRJ6O+;8W4N8NO<<][8E5"JMT4KHT*)#/*Q45@52"$%@AAB"6,
+MX$+L`K`<\ZE;9%=<N87-SE:-:35D2Q@:62&GGH+G8!7`[YT,&`1`L2&D4*%A
+MH%BQ"NEB@1(N8-C!F)=]NI*@XB>Z^PXMS6"QUHT--7;#:U=!@@(H1W=L:,%#
+M1PZ]Y=;V:LDP4<)<H]>ZDLDCZ#@/!"WJ;::R;@WFZWKNKU@@FAJ`<(2X,<$#
+MF0'?5Z@LZS6IS3)59C,#&#;-"PJ=;E);!6Y>>X!,/%U.L+!M,MT.X/!3&LC+
+M#!OPT^X$0$]6R+N8:7**^IAYQ%$*DK1L'0`,0@`'&ZK4;>7BSL3PC`J*`L(.
+MO8")0T`B@QP6@B:<)L.,;`N57P.3LX=1SJ5PI[9%+F<K,@T'79X$Y=76)#J9
+M!W*N+(@J%:'!$`A@6&!?6;L6+`P"E"YH"&6U9^K[?M[[[X:1GV!C`365/65!
+MGTP-W\*KW6+F96S:DD@6"PQUD,0$T((+T/V#<W9MGJNESSLTU)U#<K@T#H[N
+MJ..Q$:C=*>][P6B#P]!:J-N'FQUV&/A=:@A/:1PL:!0FF9-2@VUV=$=[X\,&
+MB(R#YX;[6X/G@X4&MI:O4_7O5XCAA`(P06*]5VF89B=9A>4-YFA4UZW+5#'T
+M[E9+0YCS9-)TAPZQO#1PNQP[;%^NN[%-WK[JOLZKX.U>Z-K:&T4!0]R#(X5`
+M;!&`CAHT"'=%[B&UCFZ#%LP76[ZS6&$STL#P(%2L$9D$"8P6$.$]?'*E9BD%
+MWWNH88<NEL]X(<%M8Y>4Q4'"A@3%R[E55NLQC?!>]X,61KNVY*;#!(((A0*Q
+M,"7Y7JAJM@)C$>(LG#61#'9GHSSM90-@>!%A^'I6VJPJ\D*I!ME)'Q\ZZA1\
+M3/)(*R7?FA3D]9M6Z"4B3--S0.!\354<7-57M:Q4PHLD3"U&0-*DB*()D@(+
+MZG7@C@&BQ*)SQ#?>`L!UX;K&/EL4X;M0C1B,.G5;1HT*8NH[SG=+(7I@)5)A
+MA$D3Q-,!#:K2#7FL`HN[@*"N4Z@5!>LVJO*KU"!4+2I.Q)(ANT&0:U,;7!>`
+M3NO$A6E(]BEB>&F2D"PN6:E-3N`G"#*QY.&[ND4"RF/>PCVNJ\A;VPG@JX*=
+MAN(@F[-XH>M(8)%9(HJZI^HY`#BIBF%&'0%+5`_+<#"+*%^"9UV1!&5+:H6P
+MJ*(7B/>&T1Z3DB-.USO<V(["=0[$E`20(0E9!4(0E2`(!9EW@+P#Q,BQD@RA
+M1D1=.AURD(3@`'41Z$Q(9US4)I%@A8+((2!H(Z.'#H!Z57BPI#H!0TK),D1F
+M(H*E"Q*"HR2,Q$S"&9&69(,PDRC6I;K]6=!_Q/<GV`D:9('-020252B"Y1E$
+M$JZ0202_9;RE5$Y4)5R06;F.B"?PS7!3\(3^JFKH:'J6E!*APHN'&%=T+,%,
+M/LP<\HQK88F=Q%7TRU%G=?.F;1*TW>)7VZ]AP:=NAA]S)6F-DKM5*F]4QVF:
+MM%,TJ.U2.2XJ:Y$YL?:$_<T#$Z0*>I<^K,O=%#G-75V+AB;L5>,CK5I7$\-O
+MLS*%QH8DC?#G$R75YKEUUAH<X7?KB"R&]J;D@`Q<3:KV)X+T5#UY6X#"@?$D
+M1-\&1>&JTT`X2[168Z<PPO>JMTSM%*;@IN6N=99R4+-#:R)Y4>Y)D5S3)JEO
+M!H,9ALA$B6)M+NZ4I0X>-X$Z)'EACX&$2M#0NB-!I>]E<D2!H%"VF:=:%PT:
+MJ,6)$@JI1([78JN:IJ(I2I29*")0U`%)":5(:!)8*%6D20A$I666@$(E$"2&
+ME`)<%,%<=EB`4I#I3:KJ3*DA<=2A*0+`10@4"E(D0@08`.*Y`M(M("S.E=<;
+MCA%6Q56R3@&RK9(KKR@V!J6RFIM*HC157BJ[8V*5+$@:$T5M<JIX-4:M34JF
+M5-0`AP=*2R@3!55`FD#1"%3"&9(+#*HHDS&L>:[_2'><U5XW\C+G8)Z8VX!C
+M,!/`R8\XJZ6(85BLRP6D%+B8DQ/,1B*D33BH"`+,K0^SK`TX^SAD^###P0\)
+M-,F2IDZE3J#9`[97;>YNF>\NS>8R=T578B&2YUHT21UU==T'9=N*VB&ZNUKK
+M-^+K70-L34FW4.&L%Q@:9,8=R`:2B29NA=Z'7R[>>779OI79D622`$AIYNXI
+MOF7*1$5,S;ZEPHK(99O&OK6HLRM;%U)VP8QX!ZTZ>B].@,85`,$04-AAJ$29
+M1"D"(KILG##`1GR&`!@TQ0(%"B44KT1JT.YTZ#(1,L9!F'3.&F,HRPZ,=[<>
+MG,X!N9B"<)TP`>0GO6`<(QXXZ*DF4U#D),.M.+$`T&V#N0T[=Z7LEV0II@4,
+MHBNF#((BD\LADBBC.\YX<-*JNKI0[4,N8C%FWI](B9U,_Y/Q6[^YY:7A![T/
+M@`@65[W@??C]E$?7FW^RL%-&TJ`)"/O0@3$/&^MWEXB"?40(0G;?$#3J5G?#
+MV6`!1!/O$_=G`TZ\2/?.@QUU[^.,G`,/B63XTI)]C)#3[CM3S&F,N$.:.A,E
+MF,<6PL*S(X+EBP$(W^$`#@C\SYJHA`1$@VRF"?3U5YZ-GG?;H";]#@]F;W=-
+MI2TLI;-M!G;I[`H?YQ!4$JZ!@\E0)L0-<[!/U`>`8C8Y,MJJ\&?:1QL$04ZD
+M(1%,0L!M<*!R,7X7V%/=>@FIQ-_P</@DNP"B""3W4Z<ZV=LRFZ%[UZH:8%56
+M3.6W"S!E1!%@L[\80$EWO"2:/"CW?!EZ+A&DN,*%$H)E2N)J"G5=8(J+`W=[
+M*D66S(Z"4+FB%24A<ETFQ#<X9I70)2MFLV0A*6MBNYV.26MZ=XR*&Y0<7<[P
+MW.<SOAE.J22H=$ZY9AX[@=11#(CQ=<O.[J'1\('03E.W/5,\$!.!B+9"<=<T
+MJ*&"/55UYU7>^J]>"#%)$22221I6N>`G#=HW?J%/22L&@D^8?VL(N\L49B()
+MWX:$('])!1(!((/WP^'W]>6\^_KZB,1BDC)$4441,Q111+W?([,]?C[_3R^H
+M_'U]>01B"5?9'<"(5`9$(#(Q1$R&1>Y=2,9(H(4"22D9(&>EP%-`[WUXH]>>
+M7J:O(??@%@)!\X:6P,)@R89K51GB+JBYFZ])1!$5$4%BK#+MQA=W!0A1O3D3
+MSS[OH4:+;\+DA3N]+\?O]7XBDHJ6*QHPI*$HV9C$28*)H9I2$,J,E%%)%%)3
+M!I&3$U)D9L;+$D60T%-,)1A*+%-))3&*0S#9F2202DV1E&)90E%/UWR^?M]V
+M5AR?J')B;WJ#8SG3-)H,VX3.35);,R,65K(9M3#+6C-)IK.%0IA`JPN0TEM-
+M`,U'&:&*:`UAHQB7CS=,GF')I\:UF>-G951$1$1$,,K*R"D@I(+US2),HAK"
+M(8A)825(*D%1'C!$Q!]8@XKLQ7!??6A=`0$,,LLN&+B2=X-@V(6(6+K-+/PK
+M^JNK\#?HGXL8/2I0$`5!#!H)C!)[)!\6_ZGKN/WWXHKE@=)#^"C29E^K)/?$
+M?2/W?8"?H,]PUI+X1`5?FQ]G,&(6_C((0_BRPJ0?T^38@M!>9"(1!LA>'[W*
+M-`4/KN6^VOT^^_40RF0I22D6:4IDD322D))"E(F24DPI2&1)$DDTI)()DDR2
+M"F-*2(E392D@R*0!D2229&9))))))))))),B9$R)D2D3(F1(TTS)$2TM-*2)
+M:5*4D34J4LR):5*4D2TM-*2)J5*4E)+2I2DB4I))))))(DDE(DB223,DI&22
+M22222222222223(F1*1,B9$RDF1)))))))(24R222!D22$))(0))),)($,B2
+M$)),B0(9)"02$D@$)))"2$R"0DE(F1$TI(F32DB:E2EF1+2I2DB;;+;-4JE2
+MTTI(FU+4U+32E*2DFE)$LI(FE)$TLR)921-*2)I21$R)D2D3(F1,I)"9!))I
+M!)FE*1^F<&E\N%!KWA&6Q8"4#QB.'6.9-W<A=:R5B,C:<KLS26$M&AWRS"\9
+M!Q"W"S&TA0<+,M%ERA*<<88;C9#.<['9O0"/SNLS3Y6-EEX(4I+JD&\FH9MW
+M>B(DRK4&$O?TVP$010)R"#+Q?05?Q#')(C2#MBQ4"2%`?4GI!-UC?C8WO,0-
+M)"`Q`U7'C7FWV=G1R0V>/=W%#1109O#RD5]WNK]KROSU=)(20DD)"2222222
+M22222222222222222222222229),B9$R)D1,B9$I$R)D3*29$R)2)D3(F1,B
+M)D3(E(F1,B2))))))))))))))))))))))))))))))))))))))))))))))(&1
+M))'M!^MMHVU&VDJ!0N`D"@=R.7NSN]ZGJ!+=G16%F4(;PMBW1CAA,`A;%L!R
+M3(4:$%I4%#>C`.M:=FR"#]+`8E/RC%DNL(Q*5BS9,R.98&>*!1.*<WN^/!TZ
+M'&;-/CP5B,U,-\5*%UWFS+0?<'H@,759(8()'X,8HYXG.]80DQ^[WB803SP-
+M(_:#XDWX[E,5.7J\\[R<O5-=^%5[,*YJR.6/Z/.**R$)""/EUT`"22222220
+M;6EK3:S:RPPC`D"2!($"0)(,@R@$H!""0@DJA*H2*R*R@2@0A"$#`P$!##),
+MTTI3*2!)DD2!$DLTTTI2E*4D365E2I33(E,I2)$D22$))`DDR"20(20!))"0
+M))"0D"9$2$"2!),D@$DB2:4D3:S:RVS6S;*I4J4IJ5*45:L"@H10BR1%2(LA
+M"!0E!A!D619`A"0@((9BB4(0A%E%@5E%A$E$D6!96%@(22"(HD2A*"@LD)9(
+M2D)*0605"05"$4811D`"0`L04@J"D*A4+"BE"(HF)4E2`0E0(4949(E2)8%!
+M0H444I5"(1$"41`D9`(4E&4965@("0`D`(!8!85A65E999F9F8BB-AD&?"FJ
+M85LML!$O:R&8-MH^!S"EL(U2PM+`W<85A<P&7!RB@JIDA6(,AA:"6P/&9D0[
+MA0,V4MU@'71W=@B08]$O6A.W??'C/.LWXZ><S6Y,0#%3]CH^S70^!3(#]6XA
+M`@O?QMG$`C8J++X0G/A]ZS7WVB=][*"%@$T?#I6A#3X_AZ\B^VKY\KV(D4B)
+M?GZ18(LZO1[ZG3.R8P>/,PPMH$@0V89M-&7P%$,2H80!$QQ@810<LRI8TS`<
+MRDJ%06$[%T8#)1FF$<S%ED$,,EJ%MAFM:U4K(:`F<6$[)D8$4.^AUHSJCV3)
+M8%MDFTE\60)>5&#]2]1_>5B`@U*\/X@@D;KA6!MLV,(D!/I0.`HH[@UU4]NV
+MOWB+#)[!ODCBX*E4]UY$2/B4BK*6^X6!/Q/B"![G=F)T0HGKHY.9RP.#SSH"
+M0AF&**DDDDZ=))'<YVOVM<KR$S+*8*V&)*%0K2'!JR"D34J!4UF!4N-6BS,H
+MI!9ELA")CCD&5G@\&X9WO5T#`FGMCVX\]V!Y2!3ZJ7B!_".4'S#<9\DO=S$T
+M)(5MJ_$:A!)-"$27[=['N`VDJ5U";^1*SU@#AU+>QT=<]=G?NJ11$4)P]DY)
+MJQ8I*>'GP:]R*B"**D4@4E1E1E4E4D6%96%E@)((BB42$2491A&$8$@20)%(
+MI%A+"62+)%"A24S9LJ5*4D$K-I6E:6TMIM-I9933(@D))`D(2$)(0D($A"22
+M2$)"29)))$A"2222222222222222$)))))(0D_&UK.@2220DA"$D"$D"$(0A
+M"0OA;W7+BU[U==K-&9[$[=@I2@-"@THH4.YC,9338`JL8.M"J$XZYH'9-'4S
+M5B84B:EG;*:J42Z"LPP\2S41X(NU%$WJ:,@#9R3AUQ=F!'+7$*]B:V'?MG?6
+MEWKHZTUEV!4)6!?&'$H^NP*+#XK%@O^&YX@^S;,$'!)2Q="A?D$@I[[?UB!+
+M[E!\M]]I-HGX?<%%J2X$$S]`!NHT?$CX?B=%;=PAI#"^0)1AFLNFEO&].5,[
+M7)JC6L@!F%QA)('7$AWP]I2EH**]>-XNG<AOL5=;Y^MZ(222$"2$DDDDC)((
+MEK-6:V:V;9;-E2E+2TU*E*2)H4%!*"6"%@A9(%D@6)(L21426$E!06"H6%18
+MI56K!*$H*"Q094&%!84%A!$A!$E`0E`0@%2`5)16!5@04@J"H+!0HHI4LJTI
+M1$"11`A2%(2$AA@J4I2DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD
+MDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDJE$L26)*%"PL*04@I!2"R22R22@4"@
+MH%4JEI:;-FFF1$UI6H4A20)`E)266$A(9)5*4JVK%*1"D0H$H`941E1&`4(!
+M0E5956!$($0E`90&`6`65"5"%85@1($2%4A5)$21$D1D1D618`D"0@(*DI)D
+MM2U+2TTTS)$C(B0AD2$-5*J0$`2!($K*P,###!),$-4JE2I2EI:6EIIID1-I
+M:5*FFF9(:J`H4*2DI)22I*DJ*BC#,Q%$BD"DB,B,J$J4)*$E@)8"42%$A2"P
+M@L@A((2@R@P(0(*V5LUIK3:;2I4I21$U:5:5I6E96669DFV%D@L0L0H24)*`
+MH`D$)!"10D4)!9!818190)0)$D20)`A(221F2)"2220P@][KNT6<`A,,J%JB
+MQ;.\N4"W##,&G<!DS,ZQ7<X:QG+9MV3O=F>76W1^LF(P9\QF3-JS%4+.'98U
+MD54!!+E@HY(3$#X.JXRG%:[CR6_C_O_R_'^TGW^Q3[7\/+//]()Q8Q_!O\FA
+M@3_&G#?^/ZN\E^88XK_-+M_3#55'+-CMVY_Y]5-U2G`F&!"K^WBZ=?N_P[:]
+M!/IX+.@@%?N(UX]/)]7?CX"$.1/:'^W>'1WRT?;W@D.1L84J%X[!RH5->NH=
+M^SKWKT-2'SC*R(>1WA`/C3_J.*YUQT8>'LIA_RCI_Z(TZ;:@[T^[O[%6#!4C
+M[W#_W8"CXZ"]^.BXC=17\C32N%,$-,MC`C*EUSK.=/MM=*9?X?/Z3V!Z__(O
+M_8D,_,=ND*FB3Q2G\R/V4K_0'8?^8\="_9IBW[_-@8B%^%[#QXF\X\JR*PP^
+MI#G1L;>WG[GOV^K.`ZN_HH=/H^0I(?W?Q+C_<(?9:A&D?R@_[F4!_LO^_O$'
+M<9G^[O8O[/</H#_NGRB+AA])\0/TA^HY.3@G/[MC@8XH)(&4RGY0$#<K^T^[
+MU>./Z<3908\I`+.Z)_+]ORS_R]'GX_FL[?P/X?V>L_]O^SW3\48:_WL]Q^^[
+M?^V_Q/_`AKZ3+J"P"$/^0?\3_NSQNU_O]FOVFK^'R.<4=4&"'!91]:?]T")O
+M525M26IK\\`*0"$B2!^:I$I!DD0@E4"D$9H@0(I95D:BE$6E1D)!0H`4@I(1
+M:(F!D1@E12E`8@!(:9!:%4:0022*I%4I42A4"!)1:`HHV+1M&HM&HC$48T4:
+M(J+8T6-DL:,:*C4%BBBQJ-:B@V39-!L6-C8J-8VC&U!0"B4`##"A2J+0*THK
+M-:T:JH-K6BVBK+$&E5*:1&A(D%:`0DIE45K0Q,EM%;:-5)2+)`LD*M(-4*I!
+M0E$*UD(('2O76/\G_(AX[\W_R/!O6>R@D&<==ZT1_LU5'/5+A0_/_H)`/^J$
+M/9(&MDE,I5TDR22AF(*N=$$E$T03$E(X_H#6G08A,852OYSAK]"ORT9""!T@
+MK_G^_@_H#_.'U?1V&!UHP?P]N2GML'O:S;&*@B^]O2U?P`3!V)IDG0DA]$*6
+M(AE-GTF8GNG_A4/OD^T0D[#65T?6_:AH-U--4)_>/WV)(]?*_VD?F94A/C[@
+MP9/#T]G<>`#_^OL"#ZAI`@^0&O)SY`1D=?1NP41YR_[6R&`ZV%%T4"@-_DJ`
+M0A)_B/^]#]P@6MI4HQOSPQ!4GZALI\/R._3N(5IUW`(0]-*F:#SK@RA4)41A
+M;*/[NJ_B&:C$$^@@A1DD9#FT).6"(4$&6DL8L14_FLQPMH1/#VTZ3\M?Q/S^
+M3QHZ+Q(&D62`C0FK`2:PBDADR0(02S]`S_PO?+\?JS]O_?_]3]0=H&_"193\
+M`??A9`8&EJ6*"B?=25^0NOD)CJE0=L9QG<U+!8;O[/V$@9]$(:/SLX(SZS]2
+MG^%ES?^%^+R=4I]@:^LZ_I#2I:8@B(X,*;ZW1KYG\>I]/O*M+6LX)W_\1:']
+MHDY'X%XX>H]WT,J?!\]G[`3VZ0#G]$_0\3)X_H0>@K^4#,DI!M'U'Y'&C0D?
+ML?U/33O#&?]K/[OCH,^$#[`T!(0^D]QP,/S@6<L#\UJJ(FD_4?L/:;U/;2D)
+M@T/TTOLJ6%M:_`?Q">OU[]/H/J/:?9`_0'MY_J@:IW/T000/4Q%7T1;!M\D`
+M^'_CO[7I[/QZ2`?K#_G/;(?OD"'2;@^;R^L^FFT%_-953\$#^X.EQV9O'INF
+MDU[3K^8]X:/<<$A08B)K[0O03_`=P7/D?0>@0K"#K:[P_M`DI'_LB/^"1J(G
+M^J_L?R?ZV,OE7&G^+2_2()$?ZA_E_UQ(C/J1^$9/P0+\^O3[X&=.CPQ3\VK=
+M2Q+^)<000%V46S\V7A*ZK2G!G!309JR@R_GPHX$_U1'S34U/Z/W9C[6$?L(8
+MPEVW/\!/Z0,`@7#\^^(2+Y[9!12*JL0<:G.Z'3!&1BZ[+7=UUSG3J3',I/G<
+M8.$K65HK*(K/`0:'P`2D"PI*(/_.8NEN49TB?N_SFFU;G\^:_/U&X6$_K_?#
+MSE_?F/V8U&4]C%(K]UJ>VV99F`&\&V5C+6,8RH5J56M[E^L_:%/=N\7Z_P/O
+M=EOT;Y/D?@'&O0^DI.I%AW'1,+D#_7_M4,/_F9@18?ZK_TX9AM3*_JE7B_9=
+MS-`9P?\'`TZUFM//$^CO2:9M_B*_WK_'OZ7E\!Z[JBC4&BAI5,VC"%&)*BD*
+MDB2#ZMDPOZ-Z_SG\G^[_;ZOU?X_/]'YQ/?V$A??M^+GZ=G\Q[O1Y;?O*=O"&
+M#<^GSV7KV'GZ^W@UE,'ZE_M9?%>X]_ZE'BR)/"_ZQO,_YEKD.1U\/_'U^=>R
+MGQ@2/%J_B=ROU>AG@>.WG'X>L+XW9;M_7S&>OO[^Z?1[N3-U_P^J_9[NW^_W
+M^/]GPD/U08HC$8*24A-$Q#!4E--4A?\7S]_^GK^/[/N/Y?I2;.'Z=6_KRA+*
+MM`?JT,RX^H@?2%=/^?H;YCA8[+7DO:-O]M=;'IQX_C5R@OYM\?_+UD\#RP-J
+M<-LIIN>5CV/T]7K_9_3[OQKSZ`!U0`=O]114+C[/A/AE?&65`V0L^,,)R$0#
+M[#.T_/@'A/?_,#_2A_P<A^Q_,S0:7^>U?/UYG3@;/QR4!_0=\D,15&?]_^O^
+M@^!R'S@?1_J_J^G\OR#0#_?_3^M?/^M^CVT,(`P>B%]G[CT1%^"#_%D#H%*N
+MQ#"!4E+'2X9HU/\XZ3%A33-AH7#,W1^]$_I/N_P_>?E]LB#T!\OK\\="/^V:
+M4Q3\HD4)L,]V?U_P'@UQQQ)I&^R(7VW7[#5A..OI:4GXY/BPPRREC:4;1YG;
+MM[M`=H<!OX)W-!T/![!/\W0DX.>^]>]'X>-)%%%DXJ#H#/>JMY(OVGZOP&`I
+M[P@0"H!0X1PGW8_=^7U?HWH(/@JI`_G@]I7V24^)71`NI6H0-L)1FV2>GI#^
+MP+OH_;]5['-/;`DRQ^_^T3N/L*KT'[@[GE!B%"S_(.''Q^J>XNJ(I#\L>].@
+M!LTY:PM/A2PR'Y=`.4UT2?>,YS.2:S#63KQ!ALK$<A3\`\:[W./H\K3,`@P6
+M?*'%QD58]CN('(D/[;89]OR(?Z;85E/H@AU_1/[Q#KU'T%]BLHU"C"*P6,E)
+M:0._^XPFWW<PO];/O$O-F24*!OVEW-G@T/K(?:"18>J0&VJ(RV)WLXDL_RHD
+M&!$44D,!3^W_AUHME)Y).O_V?GV*KODS9HK#7HI0/M_`<)H/1(1]5+'Z[O)O
+M/F_>FQX?R_AF[^:[_U`F'T3_LF$DG7W[ZSR=#!PXXZ'">`^[#U!SZ`Z"L_*#
+M,)!AAKQ)/Y\ARF1B)E+A:8Q^PQ$O.E`VPR:Y/Q_PSZ(?)EAS`[6VUMMEA8+3
+M))ZF?3?OI\U1?:9ZFSBEM;FRO/&#Q+&VLR%I2@U+W^QE&\[19'?\.#]JC8IL
+M?:R=[WE_MCZ/S(\OSGPT6+]Q9C(KP3&[SXF7?\!_I/1&Y(9'Y_='\=>_20E9
+M)$)UW_)P8J(?!*SI:+Z(2LB*`D^6L_;U+QQ+#R##V,#G*%/(GHU6(A1JR"DH
+M+_3V8>3%JIA?K9'R[59"B)GJG7(5UVW=H*E0KES)#@B=%6F:A,C(HB"J7Z_=
+M7U`=IL'V@,FH/=^BI[\U#4/,\0DAW]@6,T(H-:):%H)_M#!A#V=_::4VA)[O
+M[W2A__.G>T7:K]@IO_8^GI`Y\(GS6[40<^WQO1&)+W!E85B*S!)6"M8E@9G,
+M?'ZN@0SG<Y/X;ZB>K"@`B,2<>]^UGGH0X,^\LYUV!&A0Y1BF2!R00X_=@AN!
+M#J_.2A.H7-XK*=G=:CG0)M'Q^C>^'H^<'9V2/Q(:_XH#ZO9M>OZ_9W%]0?@?
+ME/_?Y.@!O\?6>_,F?4GLW#7!WG2=.=!^!M9(5)4\0\%4%0%"L6<AGLZY#$Z:
+MO5!]G8.AY(OOJ"QMJ=F]LR4)H_=+W'EO)V+#ZC)"5RY@T1*KD4U"TUZ&H:V&
+M?(A^23[S`H3<8@'W=R>?,VGB!EGO)WDC!?4_Z-#[Z#Q=@GTP\2\#/>W.R5I*
+M6@KJ,D-1D-"_C'(`NUV:FH!D5$?6%"$+;=T0&01^+=#@3^0@F0$[AXS\])UX
+MB@KP0_<"/^N&D>![01`?N@_+,.CYWF`OT_,_M^8_GK%^HX5%?SOX(?>2OF#M
+M/AE(+%#WG[?Y_S[X&<`KT#L!\26_3[I^2'M0GTBD5G5"-"B*?$GR0'YRP/H9
+MCB48?)J!C-+;X.D/0@4D^$P&V"L?0:!A8A4LA;9C,'5*C!&*CI;:X7]>SS#^
+M,/9/M@.FHMLE"T"G;^.B>O?V;U`]I/IB*(*SZ.)"Y0]?.C,1=>.:;*6>OY>Y
+M.-AS[I4Z@"0`P21462$41!^9P-*.CDG)35!1,,-0114DUP@,2E6W'W!_R0)\
+M_@GM0.V`_+\/R]NW[[QXCK'11S%S-Z,F(5U0H_\!F?06"*W-HDW^58&D16T_
+M/G*H,T<#U5%^'V`G%#GL<R)TG=].!C\@Z83H'E"`R,/HUMZ,)HQOE[:R^.@>
+MC_-.*/-'!`(<O$A'>>0&4TT&R4X2O-C#X5%'*V*D&#F'."CQCYT8"8/%89!9
+MR48C)0G(;Q`T*@JHW,%+'T(_U#Q1%`/?[_'JG;03E`@_X;H/K/J@4)[7N>%8
+M^RU2^X_-)/YV2%9'#Q,/UISS#MR<3R'?.HI15?M`]XI!89,P'6@*HE-W0S2[
+M2A$PH5#>&SVW@'9P<&!+IK(O]S,!#)$7[&G+14?Q9_LCW?Y_I\&<"O>B!P1^
+MW[B"/YB/W?W#R%@9_D/,;@0I^ZA?<31`J;_I,1/S_N+#_+^XWAT]O4^';_K/
+MC[I`+/_[_(2?@S4'_08Q"U(MEI,I\S@T$0%#@XN"$/^3ZZ'_CE39%%1`+.]J
+M_C)G-9HU&`@>3KDPGT>OZ@/[0Z;CT%UV;*U^C[C5'W!S&/9%/>1_UP,2KD((
+M7CTM+!%4!D1.9BX038L:"W+IL5HT9UU?N;O2K@&A=0M,26PXH==O%W+CT`M?
+MMP3E4@$B%"T#!_,Y"&!G^,DG\['^[4,5:'A_N62/3\`[[^K#F8E9[;^H]8=1
+M.U#V!D[A..K`35*2,!+V36M*D%(LSZPSZTPF<%_F3H/N1PJL/F0PE"3C\/;^
+MCX''#\^I@D0/!,/]A]AJ;$((K(\\R'@9GH3:9G\O:OKDZ"<G!*7TZD/E/V]E
+MW>+3L4PR-U6<9##T&'QA^)0ZPD^S\?A_X^FMDUOOL^0#`TS$A)[6^T@>T_Q@
+M?UY('E/]WGW0)/D'QXP2/VQM9!C\_;H'#_1(&-^LL9(BF`8:7]1F'TS;Y'!3
+M>0#@W[9,T^-&IKPU#DT,_VAZZE*6(JFHHM&YZ#),S\`/<0ZH1/^C\)]<_%`:
+M4G8GGM\3[C[A#AG/JZJ76M(L)Y=)MWN7!89JAK5+0T99ZLQFK:)O(V["PT-S
+M,A%@2L!0P8<N0VV73A<.P3\RG2AO47^;?&M'</;&/MLMYRP-9&E$SH/`33'E
+M<R9?!Y_%[AU!0ZIC>NA05FC4R(L$%PM'<<R6W,E9-LT8H-B4:(7#,38@9ER[
+MPX.\B]Q+&'>2U$YM5/1%O[,"JK,;^#.DOZ\[@\`DB_A/C3\Q^:2%-PV_>VNU
+MRW%F7]%PHBWBXR9EG(N4PYKKJM/+-N6Z5=*T+0&+&$$$K$F#MUJ)?DSK]4@>
+M</<NBK%2%AR<=_:!310Y^!0^/F_XMA*!XAW.BORY-AP0=3JT$Q"IC5$A%C!4
+MMF3"L]1)40*9F"`2)2BA'6&0BTJT(1(M))@?FH8@\6:9`/'L/[["O&_]6M"Q
+MX[P`_))OEZZZ4("@`J2&&`HX-U**'O]9GZAFIQ&Q%6HT8@H5*(U]2,(H[,,2
+M7<%6&)E]DII8:6*3"E8Q1V;,P34DI9"@U[?YL-;<"((*B^[,_#R8?@I#SF)$
+MC1$R^W+[U-TDMOQN[4)1ELK+VV68:?VPS0A@PX,`VGT80-?"#PGPGU(I"\%M
+MP3D#NR!:B(FC)7\4DP4AUCC10)D%/FQW8F0Q-#0.13,4J[+`A`R-*8:75F.G
+M:C59-$D.H=$NHH2S"Y9*D#!U@4F,J"R&FL;3$-&CU=VB<[7/7G=B-W=)2(2V
+M$Q,,BA8T#2/3[!KM/"Z-/DUB'4ML%GMA!)"_T649:&`N)U3'+6=W2#!IE&8C
+MK^7SQYU<W3]8:X9-C:WJ6*=<\KKEV&@RJE&AI*_9S7<\,S(%R5*`+E7)U=[U
+MB@H(^E[JMYJ/VY_']%_#FG`'>K26):],&E=.)CU[4X=6R%IO,EKE,9%4%XU(
+M8F%VRP@Q`6##A#'3G!9#&"F#4-\!A80Q$0TRINDS%#!,]!FX85#L(<,,2#KB
+MX+!55]EJ.K1%8#JN89(C3$S-VNE^/*WB^;J6)>RYU=";WO)NS>")2T$=4VF2
+M*:M59\$IB5.6*8XVE@H"(AB1XS!X&ZK:*+*S'$=H6B#:5A5;H+SO<R&RE0@K
+ME)6&)-(8!I*F[C)QHU;)C!B@"P%.*&C!:$&+:504<>!"8:XS`60=M632+`R)
+MT9K"PTS%5,9*S;*BA62N6P-'&?/RIN8@I[#C.*I)30<IC_V%Z[T'68$TN`F#
+MCKO$3\V']Y]YM2FF^#VX_Z^!]_\0.#_BE/Y2%?>R2DPA,)*2@H3R"NH,<?SG
+M0A8J9DFH2F8X5F(D86F(4P*E$*Q8*07&!<L!$)8'<Z_X,^T,HOL]F9&)(B(B
+MD/T(>Z;Z=_;<->,S-&&:U,;O7'_))(0D[,K<S#J)V_5W,8)CS;XI^K"X1"PV
+MRN/G/-FV0<//TZCJB9F3+235'#V:H^J&%Z`;1$%-WC(=HDR(L%?7?T_N+T;(
+MZP.?\`?RHGTX$\Q^G[3V=$0DRT\A.G('78;PS!0L$$$+U<J"H#Z?URP'GP`F
+MA[P4E/F3(I]:#M)#1)Z;4)TI,?JP77ZO(ZA5])7][_:G^BSM15BK%8^IZ=\D
+MT#`;_-3(B#A$L*'F$!\&CC)"8DBSS["X92`&86>B=NA3EA-^>,<UFR%L$G8X
+M:LJYPQ3F/F/\^0YI\!\KRO#![8Z.GQ]?K]V9F'GZK_>=`(?.5:!6E1J@$2D5
+M"E:B40B4!*5`5I!"(0B!$IJMBJMB-5M&JJQJUBU6)-M(05MDS*+&*DHU9(R:
+MD*MJ-MK_96I%I0$7(*&EH`0`"A40(B(2B&#*R*_GC^0#-W95R[@G"@D=#G3?
+MB#?GVQ!PM'<6;4J"54<`[&_.3:\;D\PV2\1E;O.)J&!SR6A>+U6U<0,.M`C*
+MJ#"OF8!<!67^18H2*5=(22I()31"R,\5>*>&=-A-JMJ8D;[S06'S/BI/U""/
+MS<0_AG^1^+P=R)$E_F49J)(M;@*MA4I3S4D086F8D%#/X!$"<I0%*^\_-/$(
+M4&&962-]F(F0LER@"P4BPBYTLF)B5%"M0]4#,I6%8+IKI/^AD*F*A6+(VP`0
+M_*`A$$DT_,L_<+Z$M$U8IA,-JA#,D%2.A)5\*P$-A8<#WPLN,LY92[\1VVKN
+MP-I&Q$PJ4U,;7#3W(U+NJ40[CJU0=F,RP+/2VHUMLM`I"R'30:W[\W^DM5X$
+M:FU_I.>.QOL\VOH.W)S[PG$3D1#3)W5FF/F@<ZZ=+H,\20\?O\_/D.KRS3B'
+MB1"H**;$#+Z*,AA4X#),X;A8WN<TC##AY@7E5F^31CHJPH@EU=<`N)\-N]V2
+MLIH%CX.&8#7=C6J0G!T-!9.N[9<)TX6P1NT#'*KP1'+G.[-'!M%"A"4H.-XK
+M<+A6WINC<6`,FW2I[]IY*:`U;#P(??,.!SRO%*@)R0-#C$HY3-N!0<]1@D#!
+M)7"<W>';-P`^@91D)3AA@H`L6"B[OT!0JJ*%TD)LBQ+"]QJ4WH(PHJAJ*5^W
+M*AM`K`H%0.Y^(=`(WRW)04)EF"MT.H7`YIQ,)LP@\<W@$T,OT6L$[R@0,B9@
+MATV=&(9,JQ#6J":+#HQPZN._=D-3EO=%@2>_/+LY[#V]<[C>SG>QP)240<@&
+M%52-`W>SN`>"O2W#"&8!RL3G;'"QI-MA9(&PW82/V!^M5GIN<NN=NRJ^W`<8
+M?MNL""RJ@!!38=;:4-KL43;3A6>71\1F680&VG-:5-"R,E,Q)8#.)9-$#?HI
+M!%RHW(Y-=^V;/`=:=".S$W,@O#X36K4SOI<>JZ1]8??8'M-Z&977'=MK&V`I
+M9%5`>6<BW&`UE@`VE12;NMA0`3`*60+K=Y(65[==H:'W$CI2CMFP1VP(<G*G
+ML<:=E!MA,O'`UF*?ME0A.%N5<E+*KL[A>5RRHX.@:Z0"W8B#D@"55"1CE;*A
+M^-.Q#&@,J$:I9,Z5$0.40:E0,34R?]<D?H4V.+90C##%_ZDC[WC^M^\;5D3R
+M\=-9T2>,#/!T]-<!RDN=\%;8=6:0ZG%/0E`@[+(<CDZ!&GQV<LNCZ"D[KTZ:
+MW=!;2H[+RSGMU407),2_2.O;LK4'?M<LF0UT[`U)%=+Y.JPZLRN%W>UC$52+
+M<##OD'"Z-:TTVL-PE+LNE09N23"J2(I\O<#M+.KJ"%D'A7V,+RUTHHC<T.3K
+M3Z0XVZ\[!D`Z`@@HN$V#5R[*J@Q&1T5G@,-=0L`RB]`TH,$"FAL;ZCE#`P09
+MW#BY=BBZ4A\RH@D@FZL$[9G3-3K+#9QH'@+(Z2U;9+<!5>30B@)5.:?>%@_Z
+M.@2!HY()!()"%"@P1OE[3?:.]3UW(X[L4Y@P4ZKADC94V>@)!.RH552,`7J`
+MDD-"O&[V6$.4-FV0Z9O_573"04D+,;O77\5D\J3_;GAW%!>7FPP,'"X#*=&J
+M)N$UQ&7<:ZATC8.R;IH:BFBU.UE5P7:A&(L/,N@@\Z6`_$^P)I,\/7-2)MRH
+M9=EFNFJ;&W$#6%G+*=Y6S'.RD;T`YOC.:],UF^I#]Q^?]L%_MOTG0DJ0T)Y#
+MCZOK,$#]X(WI]F'GNW,^($]&&/(,`@\!0,>5NF`8,>/]?T_4_%&3&5D^GG&&
+M^-PC%B/TT\=P2%\B+51<B`RDZ-D986@2#.-X#C$TR"AF^D6)X^R'W0G,^D#B
+M%&I2HJ(TBQ"E&R@LDY10!>;8>,L(S#RH']_2NOL8^,<^B&&O>VWOE;0]+G-M
+M:_O"#;Z.<VB;_$9_VG\OIC\P/]$D>QX/V(?LSYK\E\I_VG\'Y%',3^D`E(8^
+M"R?TC_G6%#$WT?ZD3ZE>G`=$6LY(TH4O<CDE&B>3GUQ3<O5N31"T&6$I4(<0
+M>-E;YPPVS==\I9;0.3:&P/EO@S(PNSDI,AN1<E'AH.N]'T_W!/77J%]GJ/K'
+M=(CD%2L!M<EE405RK"54#O/U--44'?NO0%$<C11!DAM8I\/+MH.9PH@C@Z8+
+M/K]D;0T:*CG=`!!`R5DHN-$#H$3J1T.2:Y^*YR"0;\FYL+VZ8'9T2.5WQ'+Q
+M1?&&<>)Z5W-!7JK<[\,P*R'K@H$T@0$7=FR-U5(#K+4-WH<OAFT.V:<Q#;/W
+M:[:<8TO''L;>Q)W'A0DG<B"-\KB>D@"K4=1KFZXQSJ-\HQNUD@=*6Z4&*S#\
+M:%`II25XI,]7R-:@GH<,L9<=",G8F"SNB2-E.5%R&,,(&=]@ES`+C<A2`Y0?
+MO#`1X1'&;E'':(G:1QQ)%PP[9J=H;(N(%'#XJL8UC59,OA2!@X=7AAJ,2^0O
+M-89Q@.\C??.L1BFV<,AO2L&-7.A)<@*B!<!._CVY[@)D`%,D)T`3V!4&X(1J
+MJ$HF'],-AB1[X"9(?48/CW`%4;]$(9C.+(%ZC-N8)_LL,P9T/?`^B14:ML@B
+M*N'^SX"@\&3A/:/L(JB_LC!?ULGZG\/ZXPBJ^S#/49%>YX4V'?Y&?(?]^7=S
+M\D^?W:]>SP.T]P?`#Y)-"+`3R-\U('5*4(/2!I-@."8`]J8!1%ZJ`J:\!V;A
+M,C(1-=CA`B3(`Z%/^K!^18O0'!!/8A4T$/B+'=T&4(_EE-?@>?H@")X^O7H]
+MWGMT/>9P[$@L9"'9TBJ>X>MHM@E&V"5K>6Q7+A-KC_+F`R<1\=)$'ZXQF@\7
+MB!TFNF\=:K3@G;H$_YV0`Y/AV^](>>L*6R@AP$ZSN@_90JLV?7S`R1%'26HM
+MY]]TS453BF.-MF4"Y1YNM3+CE6(:HMF98&TE2=WCV>[#UXL.IV\3Q*!VGV=+
+M+"9.#>I??\#?R_MTB9^Q.+H3520)F>IAML,`AJ,L/4!Y($3KUC2=`5=Z"<C;
+M(#`I[*F@QUOV"B^W1ZIAJGZV!Z:*::>E-:X-ZR#^9,3L<;PT':AF=;E9U-49
+MU2PZ#I,0TG9#:2B<HL#T0K/$WFX&S-FYP=7H);:'74AOA!183D*>IH_.3`^,
+M4/!^"$\2>9HL/I19(<'M#^OOSTX14#N:YGN$A[9)["0^EP'UI]GRJ>X0\9Y[
+M4@=-EUMS1[WV,Z=JZ>@<X.YD.8P['@DA0Q@OCC20@SB5,K@^#IY6I*9(2>&#
+M("?AAD,APJ%@^CV6XNWOZ<<UH;0VPZ]-X1ZV]B5=,]'GK;X(U&!SVIB)Y2=/
+M&G#R\IOQP86]N1221:VP"[J!9$D(F"2BE%+%+XECN\ZX[;Y:QL48V?7"B.=F
+M8C8BRY?94R5;A@YX0="$7J]EW=87U>7;.N<X9KC#$[VF(5D]-E`X)[!\24R1
+M#]-X)\2:!U$PQ`57)RU!S7L8^13W(I")6*@8:J6J#Y^=^>Z*+G?2"<T<2\)_
+MJ@*7J#B)S6ESO\<:/&OB_9X##OI;T9]TNY2^PL#J//_2?,^@^@+09"QG^A(5
+M-AQZ3K\\-?19)\Q6`H;M*^RYE8<)4]]NF8GL]:8@*<,X>(]$4]J&)I#MYL"D
+MG8[WQU1.H(#`,!(*P&R&"((8>4ZKC@H2,+A)L<!Q'G$5&^4"5M@^3LP];*F5
+M(/ZB1Z%8@ERS=$&Q("!\#1BH$9A=N6YT^)7I#<<Z9)V*?'0QGUBG).`N&Q+#
+ML9YB.M00A1E"]LSB4TLA=^S81(O<:R"NF&JE[57Z:#FHZV-B75^P\*7.N-XQ
+MU?I@M+:#(.(W#PP?.+,5%!54:(UT='V!E@O0*,W##;+PKP#J0[`@N@1$`"]Q
+MB-3(?B4I:XLR\VPL4R5D*N'$;2`@8HB#0<N4%8F9UU%"T#W!3V!/_#7\\'T1
+MV_L53\W%][W<,'/G%K<%:%BCC,RQ;2I;(=Y#)*&RT13W60+)OVGL#5#W>,^3
+MO91J9;#X=J\+[</E+X0^G'2G@]ON<22H+Z9_AG01$NK,`C=;0?Q^@]8Y2J0)
+M*`%$33#"=Z!H1@D>1@/Z0D_T<74]_/;^'^4_Q;O'Z?VFF)#$'TS)@0WZ>O/S
+MFZ2>HZ#8?DF\KX/R^=/VIQH/`3[;KT<_,L#S]/VPZ189SAF2_H9?TC)Z/R8?
+M8.CUZ]@AAH2(2"!M[UHD3!/[3]^L#J62Q$$4$]UBE5AR&B("&0P7A$_MS]'U
+M6WJX\2Q@J]/S!V3RA/RR!]7N)_3^8DA"3\8'4/`]\<;\_?:3_.*L:$A6!#_0
+MSL['?VAVP6>?\5S;0+VH>[,+<.XPJ5DEG7SDAW2'1(H*8@<"3N![A.[=10'4
+MI0F2+6\*H`JJ2I769%S$Y36F-T>F:-!SP9485%))0G`3^O]=G!0`;_M_C^_V
+M=//&>4_Q'<$0`:`>OL.GM-R*LBD/]+"'\6&"0]Y4:?RA#_KGLGP/@?Y.>8>Z
+M?<@%]80XS^#XC/SV4941C@L'Z3CY\/`V?>T'^C\O^7O\OU?C[I[PDWR]E#W#
+M\@VNZK:/QHD,7B#\CYZ')/Z#0'_E_MH>_@/8#(=1#ME*PDN?5^G7ZOHKQ4&1
+M91T>,(G3"_KI3,*\J8N*Q&88Y65_IM4$2&OIHT:-@(B\3W3?&5%41)-[@B,6
+MO]N?]O$C:"BEM3`M)0)2D]]ZJNP#]0?708CM0S@P/PG<_?Q-\D4%_<SKE4]_
+MZ+[O.Y/JU(>U:D_S;S^#&$I12?KL*5@6MWM\T(/P_HO^/P#_3YVB=?V>79K\
+M32:5+YDN2'<X"+%`PIY,*049(+!1$/%N?=(=DIX^_W*)/4@_HD!=$`<A'Q".
+MH4_:2HF2"-``>8!?Z_.!,/8#V>L<$Y04_69K`Z,ZC$X['M\Y.X71+.J8%Z@7
+MR*JOW\3XJG_2?GV!Y[G64LKYM3*1110M]<R.`MJUAIA)#WY\&.NN_4P03,4P
+M?)^9W#3'1)(]KUWVG]F:7V+??LCX2!/4D4$R%!3%0'H[D'$X>BCXVKY\R00<
+M1_+3H6K]8<7VFJ*\J'Z(3[#M>X*#R<PU_2/R?PA!]K^O2#]*!ZEU<OWCO=_[
+M#C^/U.(04C^?]^-'X8;?W8)UNXPC^<6!Y/*>?J_-]\/S9,R@M23B1<DK$15%
+MI+Q74R7C=E8DDAKR[K-4TT3(E)MXJ=R,L+EQ%N=W<TW0\1N%7EXKF)!LGREF
+MG6K:*)C*&:A)WN3W!D6W`#Q"AI#S;%AS)!9.*8B+/`:A_=4%+-:AO+_*7;:3
+M8EKX_S4"FUC;%DT2&JC5#S6\M%:_?F]5\G^JMMK#1M,J!I(MHU8V,1&QHU)1
+MHBQ1BV1*L;,VC1HV(LPJDBHJHMB-%&3:L6"C6R9-8QJ(J"8B2D&@I$H%-D(8
+M:/2!]L]W1@_B5\/0@OM("2D@,2+0TJI\1%Z'X3O$=*%\*?YW%+",%%*^:5@J
+MQ3"X9B(Y1`4FDD)B&@JHL33@;"_)#-B@-TX8CK)>9/?GN]=KY;?.K`&+24G0
+M9C%%10=Z`77?OU;/#V<XAB4_;?4VJ::H,EC,!#,R*H:&)`-]<#S!U]7I3[M@
+M=:&3])U[G9WCU$G(PE@('NV!QH18CA_S9GZJ<D/UA&NSXU/V?K^]88Y_?'^1
+MA#P4H_X_MD_8S_PA=G8X*?>_]R.!V^Y/\F;$";!(RTT^0?ZD'^3K[\5`OX?:
+M_D1;0<!'"(VZK91<V9M`@:;CA^+A4!$'^=_FS@`'$XXI%_48X"ZQ#4B4M`?T
+M7\4D%_OOTD/7'L:#2^_\V)^-\X[/S`6/_.WE'R)Z[#^A[Z\,5'RG'^[I%QH#
+M0/E'^!Z8.88Q,7GSPS[/NG?R^FD(@V9IA)`\_0D))%&RPB`!*(@=!(]XG<;0
+M@P$W/E^S1[-8V4_!GG%HE(0#)2"V0:];='XZ-FRL4=T*@>F>Q[G\/$#P*$CH
+M]"'N0(^GQF>'8E)X=TJ-SQFIK2&O4A<.GXN[[G#,%Y_AV;"33DI2R778>$^W
+M[O:\P)UY!@G-(=H'N^</FPV'I-0H,O=-DQ*9AL5M\Z+%;M7[>835".DH7?>&
+MD_2OA!U)Y@B4I@L4@LDIGWRGQ#_1N=I/!X]T3N>/?F9WV:/C\/?[W0O\)5B]
+MYQ$E@5`@Z7^X^WS'.K#'<@'3KN$Y3`QBRU++%!.OTV4EHQ9@R092,8LF*C,H
+MM%L*QBF'BW)_/[:NFBBL5"R$J0E0QE.F$RW)];[@Y*&K#X3X^]1'W!^KU]#U
+MB+(OI[.__*2&5/WI1A.3U\PG_9(&_X9\RUW-]0-?=]R(@"`7V8O_-4I,3&RV
+M1:NAL6!?B5M:E;0I\3]]Y<!/GH#9$!(]/X<^`#>*#Y^9=++HZZ`^'J4'?Y5E
+M5FO8E'%2JQ&!+A/<0B,0A(4H/`B#15UR9KZIG.':^R*.?WU;XO=^B5UTDR>R
+M[.WSN<,3I.Z*5*/>[;D.44:;KK(S$2[,[-U:0S4_6:3506SR.C]!A)!V)1^9
+M*LC[`M*N&X5I(@IH\0B@@@.M%N-V:I4)T?;(>5A9<`7EFP1SH2G7$(:/9L<4
+M&;8<EH=2,!46$*RN(EG-F1"(.%'*D3UJ+2$(XV"OGMTZ0TGBATXWS468'+-Q
+M('._,#C"Y.[J-`HC@CF5&3/4JETH22)(`E]V%%>[&[X=FPYG!Y/Y\X/[)/[O
+M7DY!0?,AAMO7P'H_46-^C]Y]13ZD_ILO=$5!15(/A-2D8L1X#,7W3R?PT'!@
+MY+16,8,@T-!,'^2<BOS]1$GR_FX\+!'T=R;AK=UFC#-`CS=EPQ'*-F<69K6%
+M#/V<9^C9OJFIUC0S"AP*5_E:=W@#<'TN`(EJ`D+%`++8FL-"U(MWFC<C]?\!
+M]8N/:7W`Z#]8=(?C%),&U%H3)6*+;^97*"HBT6+9FQJC7+<M4FU%C6C5)L6D
+M9J(QK1$/O!D4-([3VD_,T?MOU^>O!BA#^X/)R'Z_!^UAUP/>>0^LD/U((%]I
+MU3L>X"3`)>:HM"D4DE<W-BBDIK)M,DI?T5MWIRE-AX=KF2AHPS<MRQM(V*7K
+M=2B&DGR/$\I/<A^`>_[73[0T?S?$H>_?$Z3XR<<F.H@-:`?0%$DI/7T`#G`I
+MR"0%21CP.P&475=<^/B[_"1[S`/IX<7WO6\;>][5WO#S!RPG44ZGH>L]@?!#
+M-*@N6B"$H7Q.#L\?Y#$[?"?X)1I0"E/LA_)#^VPXI2=80E^1WL.3XHI)E]\]
+MYL0]_J-]%5YS#0BAFX>_H=CH8?%-JS;<[>?!]WO#@[?-[(QHG;*&+&YK,5!T
+M'YW/;2]87V^H<].<0T6)]?YS`G=D1.6#%('Z!`Q,LJ%;:3E`K,(T&*`(,GOG
+MP/A+/T6'C(4_B?R]F_V["!^B#""@L"?2A6$%8(`L6`H0L22!]OQ^/?G[VST&
+M'<^H]WFR'O]*LZF6:VEV[2:=.D(7+)6&Q74'%&?OI1&W@^F=@WRZW7FG1UJ@
+M;V9DJHZ]^SK_;P3*I]QDHCS_C]BR*+!5)`6%FCT^L`6D(E"CVE'!!8$\ACP;
+M0=[(L,#AF\.MEF/"0F'&`]41BR8LD3BG/+)=XSDP?'51UR2>T+UC'+*];06T
+M-E\!K9@3]W-^>@A1@H?$8N0#T85"`HK*BK^<='XTW/>:^<R<[I'>7>J*X,DJ
+MH+SM=F6)>G:?BK3HRE>^.`X[<^.-J+Y37MO*8:;)&*E2T6A>^W%%CQWC=G[+
+MNM%/2G&*61WQK1J.L<ZNEF6FBDFT9#5%!=\3W4<_D5P-_Z7'[>#'L':?`*L_
+MB0:-C.?\^&V4;V5W]>76/Z_O9J\;(_?95R)0YF>J<7LEZ&^K)RAV36$3<$XB
+M$@/9ADHTCC![F8&]&]RMI#TSZH_'5PZSWVRS3%6*-A82@@<088Y%*5LWDN0M
+MB<,HYQ2E;.[*AH9RXQ<WFIF43632+!LD^E,K3*6"C_"AF4&V(6MK6A46/-AB
+M80E*V\Y<RF(?K?2?GYD^`>_V.S\6?/X&U'RSM>;<8^;[4TZ1&""1%K%/T:XZ
+MG^/8?=VH>C[((G\R#$9T#^![@>3X#$'[YB]N#HS%473IDH,17(330^<MQQQ*
+M50+E)1BF.9*N4OV3MZ#VF7>M9.4D&(4?X2P,'XT-IOPBGJ,C80[AI^'/A3^@
+M_/V/7>&,#$P,@?E8R1'E3Z0+[@D>\.]+\\/!&CX?TOF>UY]A]F<"XN:/2M6U
+MVR$"!IO296BT%!0<HIZ'WWZ&;04^!?GRH70*6T]OD?:>^-39U]\=]I,OP?4/
+M$H?8<3[3I9I6X/<[R4L@1@@']@P^6BJA%52?R^=S)Y=W#?R3B;8D/YF\8TFA
+M1G%A4$`02V39,"BBCJ@2HJ/!A26U8ZH9K<R&HPPM(6-!QYI/QT.*KU(]1(A0
+ME$22CJ5*'E0T-K%#4)\#YS7S+07SS\0'I!/DNA(,'*A*DOH'D/+_E4ZXQ9;2
+MR@*'ML"R",C!E$+((6_C'C^RQ7]^"ZPN,1MA@)9*CHU5)"H>T[6$J#,+4KIC
+M2005('S#<%#DAZP?I-%$03:1B@^Y`($^Y<`[O*N[5(+&#GD^OX?CL]X_/U%B
+M%D)$?Z:26L@<3>_X=/_S:BNB8%@'C:][FWVC&%0<3Q+PI@V6_^;5D$LBK"%H
+MP?\546-0LM*PC2AWZ/C_+F%^>FFF9$#.A<N3G98H=[;@4K[*H.%$FI76EH.H
+MI[5A&9O;F]]>CE:F]9AQAZ`?!/8^>F*#Q'1)3;M#<3\`(B]=;8WCEF.9E$11
+MBMMWUT8JY=8\RY;ADL4M+8#;0K=FKOYK3YY<3"`B^.S.]W1&>^-_D@<]2(+&
+M`O1^^`AD2?/]33(2%SW8GW]WCUU@%4-^LQ\=K[HBLD_82:G'66?="&`63W%K
+M^L&P;O//6!U"'1%MD"0_Q0F2L=?58'^""R?4\$B"W3G6$11T+4LH66-M4HP:
+M,6ZFLTDY8;=36#;&M*I44BRA&C6E=]E5),\\[IS`WOIYU\N<^OT-FC1!@LD#
+MVM$!$C:80YGM/O#Z>QW/=ZYH^NF)Q;(49J%H8EP19;<.AHP8&).PEWJX".)4
+M>LDV?=0[>T0809UYS$1&P;C`"!6@<$_J];,(-$^Z)TNTMNQ>D-L%]KY#VSMZ
+M#A'2]QS'24:4#B!='2FB`D*-G$E*93F!VH3(2/0LP`AGU")D6\@ZF?#)2G4_
+M:=_[P\`2&GIHG4%&,5%5(+#=C$A302S5+1)1AI=YJ%/F%F'Z]]=UQ8T$NZZ2
+M9W=F)SI#[/LTP2'YF.4=%'JZF1/R50%UVI(36DTHL(OV5>N:+V9]J&F5ACCM
+M^6S2CJZ&BM:6*J;MBK)MA4AZ5>EJZM?NMDR9-B-$(3E!<M'$HX@Q3&JKE/[;
+MWQ9!4I+KG?X1PJBH#)<U;S%$'I$WK.*:\^EQ(=GCG5Q&]MX!@[HM!$4NT`.=
+M,(FBXP*E4`8PD20BO1ACS]XVT9Z((H?PI@D!`3UY4A")ISSMB.GX9@W%7,NZ
+M%&&FLLXF4IERVFY,N%D4*K^00V*P`H@@D>_:W_/<'?D5/>/L4S'%Z88F#.6&
+MT-.APF.2<(1H-Z(K#*$,EDDQ`G"2O/Q6$(GS`56F(4YF5-Y3C1DYT5$0.'FY
+MK-"AI6(D65*S2+F89)B40%#!,:W=(O:\.5V[#@EHWF^W1L-XF:(='_?^$G#Y
+MCP=?NP8_@SKWNA&:3^&=^2PJ)."J-SIJ/12BAK=C<R'CBF:I1BJ!PQFMES63
+M`_E8S1NR.2K9BDO]&3/B-&]!K&5.TW;]5/9OTXYF^F^_<FB7,,N,$N#FYQ#9
+MWF3];"]T4^&I:?\P_1#IU@>%$[`GH3OMP6-&")X,E%S+3*%*-L-8Z9:D`RB$
+MP@QQ.E0-FY!W+._Z$T?]IULTCBC2@.'0X8*8N'1J-5O>PTD40+2B6L7(PD<@
+M'<"4KD(4KDE;S`"MX8AM4P:R7*$4(4U:CJZF75*"XRLQU&`Q@+C`H0="9ED*
+MF&FE-:N!VY+J0WN8$&!8@.4.1EQ+S6(HR<1P(P#1^/,2E694#<9NYI'<*52"
+M.];Q00!`,))(I_1F4+ME<>$Y!2[G)J*`U!D2`@P+^7J=]/M#$P)Z#R^X9W,L
+MY@'()$5CL+"[5TB\T-,>:,_E_GYZV>3RZ]IAD#B_GRH>I99^C_?\^/2`=9W>
+M\I4`['PH/*E*!5@JI$DGV(4,E5IE:TA*5;G-HC8VQ6W\H,48[_7.M!BB:81C
+M#4_;^DU'])Q6.+#VN'=PP6%-9<&@;9N!3[2,FIY%4=_">=(\@V!LL1_2?&,@
+M?AF"]Q,0]]!W&^;"6=.$E4-@/S!^0Q4I'](F)\$*O[CY'GHW$$>&#&)^9+K6
+M8QMR-!6C5&-3K6?SQ/HGYH2_3Y(6'#])2PJ*PAG4.WE^W5^0DFT`4]HR\%A"
+ML4K#.*0QDU:35L*@;9/]/-)@Z9#!&X&<!HM@?,C%383)M31D:K9B*8D!A-8C
+M!"Z64!3)%L)*(#DIRU!F)A*4&Q5(<DDB(J+4XZE*9D`A"F0`9'.]F+'5FTML
+MR,QHFTMH4&"E$HDC!1Q*!DLC3',9<@$(4E;!&S"4J$R2?8&!F[<IA@G;!NI!
+M$ZY8ALA74%H,"M*BYFY1C:9F=:Q#-2:-0M`TK,,\,Q-"X21O.6J&TLEHR9U_
+M9F1-WW]9^YCNT\^8CXN1.SP"'SD/J_L^T/RGZQ]2?ZI0'4E4`4FC1BJ(Q7]H
+MXN_H>+MW<HUS]]*FOZMIF4]G]@KOLZ8<HJQ13CP%GA`F,GR9!>Z3,L#A"3HR
+MO>TN50BU)DIEHL]:_`?0\5ZJ#V[,Z\X^HX=M$[87;)4X&04Y>#>MV>'8;9TV
+M7@'T=Y>HGET\7MAP93P%W@3;63RSA`WO6]10_VH'+@('=\,`,8(UC$1#E#$%
+M`>G?.D[%'7/!I$?VEK4/5?'GR1P*%CT4^Q'19U[-DM*A$5$V8C!4,@(7R`3O
+M].3?#%.0.@1>\_[?VZ#00^1T/;^B>Z7]%OX!289+!?R(Q-!:Q,')&S$'5AF(
+MS(:C0)&D-8X0T@Q*'\SCS7D/2KO59F@3U"_?'LDB/1R>@`X;#^K2=G?W_AP^
+MU%;[T2A3)`B`Q)AD"F0ET'8&O\;]W@I:I7W0_:7R$4A<"5`P@18)H;^MR@\)
+M'S_D",%/'C80`^D/:'S_K"<OD]'^))_6D)(DB!5(T4"4(^4#[@8)/JCA()&8
+M>WF?[D0//T+!>?(.OVMY`^C?L5'GX_.O'8?:D?9,6>$^<`=24+^Q(G^Y$5D.
+MD]YF[L"*(H"]B?R-"[TF>\]$B?YB0:$"($H8E#NS[0!\$B_DI#GW&#,-(9.2
+ME-`,AUM)"MPK:*-LNDBV`OW3T/>BS0'(>X*7J"B]_WD!H3CO$IH3A+$AT?KP
+MU)^,]'2?`?#'^P$TD$GY`P!=&R=I>*6/UT\./9)3BV+V_\L3KU"@?)^$#,TE
+M!SPI%"_RUL.CP*I\I:2E3[?EM]2+J5,C]/]L"HOAQ$1C%JP1&$RDP:Q-UO]/
+MT5D=H_$'Z?+)?U2YXQ#_>(B(HI"2A`HK#W8>9Z''UR*$E2L*T2!9]/=04+Y*
+M?YOG@120$GGV]^U\>C?,D](G;X"01&"H@L5G'(![2_T:AY^#43J6'9*VB9U"
+M&@D4/F^\4UP#O502E.-!2345,LO/TF&TT.V]$XR-AT<M8+.FN-'/(TX$6(H1
+M1!$=3-71R<MD<FR6%RIRU04QYR5_%A>*%!%/3C.AHYG!M>C54@Q&:9X*3T^M
+M$ZG5%;P?.'^5Y)E@L*R6$$*%L"L2QM#G3Q1VA\E^9%8(G_1_3^+[H^TGY>WS
+M@^@E1?'/;V2'%LGZ!K-^MX>!W/8`'1`)U.-VDL6?-G9-?>V2<3RP?H;,+ZY3
+MW0`U*C^%]T*ZM7Q!YJ$(-\^J?>\GZF31$4LT1!LIJ]?/T_J0\_M5/^9)"(H&
+M2BI$BJG^0'[OE"2T_!GP?2M_0K7A*Y<NFDZ;<4BSN<7T.C\(DOQS0_F[P5_C
+M$T15+0(PQ!!0@!S[A'5/C]_DZ^I#5L_F];'!6[<\P@'YH2!^1U['-GC^BA[4
+M]2_U<$R8B*^1$\YDPJ?PWHRC[:41)V^S3O)A94(A8&S8>$&@458*L%E;HT2<
+M-/N_P^C[/M$\RI1K+B9]P]-Z3(6THJRK2G&2LPK;MM'@-:QX9.#$H$T@3+9-
+MEAW--#"M$S2T<3&%_-S/U<G\?^-/D9^)[<)?WH'T)=\9(;9"_Q)_'I3!%'^[
+MISSTI-D(B#_9'(6Q&*@"A\TV`4*/R`4%8RB)_!0;%Z%*1@I:N/-","_S@C0N
+MQ"*/]#AR4*0:(*='GZA&`07/8`,B9MQ?40"CLR?IC`'$`'6TI!A0X'R3'5!]
+M:A/Z!+`&`Q!)[D1/TUA>?T[O=\E)8I$TF3UKCDA9[;1407L#SP!?SP\C%1GF
+MU!1[0#B0[IY"/.]^K=3FYN>:C)S."Z.`/\J*_"Z&BB"Z765Y/*<_N3G#V]'/
+M<.S.=2>0D#Q%#R9NP-H(RB6OB<9'`Z@>F-+^<@?!&0@52>2'41Z3R!HLB'!T
+M]WNAO:'3],\14G*Q*_^7^/[-@?XV?0\B&G/Z#"BL`/SJ$:6D=PYLWO84.29`
+M<L?@#,5@`J@@@B1^9/ZY71]6'L/E[8(BL,,,GO0^Q]]+L[\'MR%,E['@K^:0
+M/GVO]K)]#,$"C$160&0SB<CT@L]+`1OCN/I(&>FRC%[QI\"P^@]AG<U]L]Q_
+M#^C73B]SM?(%A2"@HQ!5*8K7\+KIF6S:T9*3;YUVLQ9630V4H5ZW=G\-U*11
+M$0N?0>L)[A>A9MQ4]_0Z`_#CEANJ=IVG[)I%ZNA^!\0N/7XF^=&'KXG&SP-U
+M[X"?0`C_"O#<''RG\FX0$$@@#9HQZQNX4$>8&Y^C.=POPV_9`?="#`0S4R#Z
+M84G^?1/Q2'R&_VX`_&1-:!%PRUI%0G-,P4FC=SNV,5V4&BY%<_K%>*R;E>#7
+ME:=VMC7@T\\ZX9<E.UH:E9(6%0"*"K#2EN-@I--J-'CDO'-2C-HYQW5TYPPR
+M\;I%Z:\>8,S16]=TT)SFD\.\\UT;5*$").ZZ265/+M=1;QTW3I9,2F%@6:UD
+MFD%"S16):68RF,C<9AC2I,5F("RTJHLM!$A<I(H%#`84B\6P%3$TQS;@E?:M
+MD)SF][8W@9)2E('F=0O)/ZQKB3:199+`K%+:AP?=H,-,>I=QJS18I84^JTP0
+M_V$_TL/U[/C/^=(T[)'Z8D(_!_F=JJ5B&4)_&OY/N_+B/9^X/">-/]*AQE"A
+M]YI`_3OYWR8P9;XI=<;]<MN32D4+&2(BHI'Q_EX>P_X(1ZE.8/4OXGS3XD2-
+MV*)M'1HFP3[2,DHFR<"*=+Y7G5>NQIC;VKJ4.\`I7CM:5WA,!>1SS+QG;@JH
+M,&86C(-F0I*"1#+80:Q2H8F1,C<85!ML<+$1&[M12.KI%4Q@I*,&,RY@V9C"
+MIE,%4Q@5S*6X4P"N7,N5,S+:7,N94_UB89:5)P'B!_2@*,_I`]I#^D$F]B*R
+M)_-3DZ)[S-L^/Q/@;!$1*S1]`PX1&>\]P@92L5R9U[?U4OM:+&6MIT?ES>ZK
+M7G]'A\A?LY^43-!)^9F1$T,?A&+9)CF)DU2025]"<'<)]!P.>8O0'Q8#TA2'
+M=#TX*L//'LZ]ZD.#G%'M(:9S,@C/"[\*TO68'LEA.^_AZ?WXAA<V-/@Y?,'Y
+M%_F35BRD&0-YTH7SWHB+%%'9C?AH#\!F(Q_,!@8/._QUI8W!Z\]"GI4H7_#*
+MX(RH&(-VWV`'Q]4\=X?(]L#<CS\CI?H>V$@=H'`DE`Z?T&OR_9\E.8>GJ<`=
+M>\C?DS"^[;B!2\'\Z@37>>"OU?XU_XI7D;!H>\8=\.3IV]NO3RE11"I08;;%
+M`W@8F&&A^1+FU%EH(,\:A@L<<R*C$F8!<%HA1;*R'8R5G<T/8#[90/T0_0D@
+ME8(/8B@`PE0%BA(4#"?P;\2$/98GH&$]/9P=#Y#/8$AY-IU-!]H'2?2<>YZ9
+M>)"7+Y/:![HIS)`_.7RCLM@R8A_$E0UK$V$N%@0)CF.B0U--44C24F0:94QA
+M%BED1$<+`I4E6%0$]L#4(:("UIR399."1)$S2XC*6TP+D`<+*HRM5-6>SH`!
+MZC#Y_(VE20-^F'Y:69;CZ79)Z/)AB.0%&:,@Y"I<,<0M1MRY*5N&%DPF629C
+M4C@PMPS,2B;C4U;$"M!01$&(9A_OT>IJ>P3?/Y[/WY-:Y-[_.PCX+74B3%#\
+M&^QHV&3!"%U\RN*Q<!AL,1'Q\'ME2;+-Z:.V^!`TH)05TXR[EY@?[74(C%$T
+M1W'$]R=8Y86>A]%O2EM]VS1IZCRJ[?3)4X3G&SIDZ-XN]XS)/<GHA=3T:[19
+M:W18VWW-9S74,-WJTN&0.S_F;K1GCY>DDA\056+&1?5G/U)9#76W$*XE1$BP
+M,0ZL8J_&6TZW,!8I72V<6YC4WK&+K.C?ZY[_;;]>W^<#U0U9(B_FOYM0<ILT
+M:@25"&V!*FT*R'3V>??\;;X/'0$%X&^W-:Y#A8BK9[8/<,(-%Y#,6`9"P*J"
+M"P*278=T4.\[U2$"I4>.E1TVCJJ*2-URJL*P.E8VQ<\PUJ3A_V%,_Z_&W&+&
+M1L_W_6YJ$&^!B+.W7EY(@6`+**%!P53H1EG#*%7<5AH$8T`&(0.4"(%WF&*9
+M67.&3O&]9D2TAU"N12N1AX9F[R-21AG([\*(54DDCE@EC9=9L(?`8`H%LJ@:
+M>,+M32F]=!78-R*H5+<&6Q>.Q<H8=@57`N.)&)?&$BC8+SMM&!P,7LJ@!]U'
+M`[U<['=EQA-Y5BQ'<4#:(V%'F!V&%$'/KAF`OT*;_3^+X=B(H$=//22#$"2&
+MPH8DA%4*EJ^RBME&"(D[,5FBNU]'K9(DR-X5&AHD;Y=))CAQ@=:7I.'=LPT!
+M54@E"X=CPE0.C.4]AW:IT$Z[WSK%:[1Z]\WNC"N1T+2J8;!#+>[/<49B!)QT
+M6W"WX6V-M!D9\LV2O9V#9PZLQ"\%M9CUD:!&4>"!G49+0+5<9.>`IS&A=["*
+M@2&(,DAN,:WI:WS=NJR2H"E2-'N+:>)`O:EBB[`/J1S4((F&",=`%$7"NRA9
+ME]P1L&IDIIR^`^&19V:'+A@O??3>-;97A^$!W?3HX?EN.X#-MA7'^'1-N1WY
+M!Q\V`E(GQYZ%-CO14NHJE'7G8>[:.UP0U.IK.AW1&(DM.3?^P&VD)\RPK_T:
+M8E?Y2:B^)O70*_R*DCOF"Z[PYWBLTP'2E_20$1`!L$`(R<X5F5IY=MHTX]3<
+M87CZL='17\VG**2#H+P_W\IP?%^+VF\E!)[B[F86U#&0L&+(LY>GEL/9APBJ
+MWH?B'9ZY3,"J*;9QGGD-F\FBF^>F6GRNZ:X\B@(*F0U<*$0:,W-N3T=7L9;_
+MGN!N,B6D+[Z&X->_YZ#N^A<@_ZOFHOV2#7Y)`GNNO]OO'ZJ^DW(>=Z#013I@
+M;D=&CT$A1^[YPP,!&0L-F8?M9/0`TIUA#V<RS6KF!]64=##&!_T%WFR4E4\W
+MC-[B@N:IH1CIAE:O[X89UZI[$1EI[GLG=K)A;J4SB=-E-G/-XXO,ELWW.P*(
+MR(C24HEC*[AZ+-T*@<\4Q--QH*!P<"A$1!D`?@?E!N>O6N'8.[UKW4I-<TH2
+M2GK`F^$4R8TE@6%@%-]V8X)9RX==B%>U\3[H?1WH/U?0$LVKDE"@=3R=2G1[
+M^:+#N:+[OM.QR3F]CC7358:!?[12W]=.Y/#`XOQ-<%Q8(E9"=.-Z^GO,)@MM
+M=0NR8%F4E(L1$0.DGP^&QID#&OP9->G).8<FIHWW=33%&#1&YC3)A=:R=CXA
+MI\OGS]GKUTT9LXP,2_Z4Q_1H?E\1'[.;\*8925%3X.+UISX4HZ-="'L.%$Q0
+M14!21?)T8/X=Z/R(/!<ED(E4UUZ\T#.D%.>>2EED"PD$*66HS^1EP5@.RW"4
+MO^QL_L,/VFX'55$4F8HQ?RMOX-O&=VYJ1-62,0,:),G%<')E#^?+%]:T0<WR
+M$8;AJYK'X2-R@[-S(9ZF8;,X,WQ,RXBP*%AUXDQ0*J"(5)PBRVD#=-`PSA+:
+M71P]_`QD#WB'],`<(DW#:0AR;=TD0&D\.)J*7_GPQ%SQK1A^E$Q_H?B%/CRK
+M\!^3U*_'HTQAU3')^=G%O.%B>4MM05^1J>H#LZ\AP5I">_F&L\-ZCQ@D3VA@
+M4*)S[LUJ3VM?YF\?89#H.O\A\/&C&A-B`K$4%V9!48)Z^?<\3G#[/L']>MU$
+MQ$T!+32;_+1H@JN(=DFI-:501101%T=:VF/>64T-5BP4A_E_&+QYI<1LZ93S
+M9`)#[.]))H>QZ89EYNL-1FVF_+^[+EUKFG.GIG\X*P%1Y0-=/!D6+M4SGNBG
+M-N87/'3,$0RBET_N86QT&%$;';2HQ`P0YH:"#_`DI.+EKB_?^MI7Z3]*<[[C
+M`#)(LQK+;;:EX"<.F*9>F0J"FVHI60IQK,8'A%"\V7U/TVOHZ?7TS)9!ZRRH
+M;[79:7<]AKRKALPO>>W\.FDWSS(%["T(:PI']6&0";XHVTAO6&0]<UK;@="H
+M+*&3!Q"+VM?74`-)3>ZL61#O@2PXFT@>[#'*>Y+.>EW::UU(;8=%?(G;I)#H
+MZUS<G]VS_7EOWMP<P:%UEQ,<H0#[8N.M+L/P7&QV8J'+UW=0:/+`[H1W];H>
+M^P(`C^KS,\`/#P0W%3=5P"T@BTLVO([^%Z<7O`]$@H<;NO;$IQ;T9G?#FFN^
+M5X#:6\<T\]+3??"^&6O%\X:>$UD.J=!!['C/`AK.YD!())@@;\J),G)E=#AL
+M9[MA424QRQ71<+@QE_D"@Q:T+_#":]>R*,?RE8A)L^YTZ:S?/U@VQ<E#C$?!
+M_U03(A_F[]A1\,LF"^8$_JK_PH7!?."ATB]XV#!2_`!A`@='4<'%"T9(I;=`
+M4DJ023SB&3DR,*'-$.0"-VM@.7B2$!`;.+H0+M0_>ART!WIW0"<TRCM=/.U.
+M.BR,6A.E=N(<,`J@E`+Q3IR9>.-@H&)5'X&S;3S4;Z0#4H((UC*B0>DX1R^F
+M6NIWOOFC!YWX?KN'"2^#RB.X&FD,-R)78CH1AKWVM_TDTO?<J@#(#U9JGJ%'
+MH=2M"`CW8@*HEA@8;('1>0I!@PRUL<HKX<+J`0ARS;U-7V>)W]V9ZNZS@.A9
+M/'HZLRP*B\V6"J3)^OQQY\P#WH';U6:OD#;#)/8YK\[_>\JTD2+[ITG[>PT9
+M8$%AC@2?DAY8JO&ON\`_>J$FF`'U('@D^4^0_PC&"<),C(6@*2DB)P>LQ$4L
+M_6'X>+_+&%51C1R<*$/"<3CDYL*BGXFHTK;5BU*JHZ'IA.-T<U@/%-)C.&Q%
+M=TWA2VB.+&4U@33JPXDF=CHIH,%$.0YZWDZ;%<M]Z&T.+3#,P'S2NJ[S*^W-
+ML-Z@],ITW<.@P]J9R[SJ1YZ;D.#T9#8GGS9<Z)T[C3!G7!"7Z^#P!HC/F(WY
+M&N`AGKSO2/T\<>':XI$/C>*_2??IYZ-&WJ$]7;P:H'QY*;$ZF6%:F6R5.B3J
+M@9S9UY+TVJI9#H@'6-U97H/#B0VE&*&6PZ987*!\/63JY*K"TE#F>GI"9IA/
+MI'(`B]0.3Z@]HU'4(\+4#[^\\SPRL19NF9/9D[L\I:B_BA^)FH>XU\GWX!*<
+M?0_A*.$G_1"'_3X,!/<D>&M9(MD7$GA_%,`61"U)_WJ,!0K5LU1K8J+:-HM8
+MW]K`AD@A2K2A0C0K0+2B:M%C5C:Q53:D_2[I:5&$6&7Z^9TGN*%;2\H=D_M=
+M#4$W<<G9<MU)V!Y`V:ZM@[6AH9(#A]IMUF8&Q`E&@4FBF':GA.][B"^\<*,N
+M+9%-+Y]?3ZNO&NT1PS2'F"^>(94(51$$Q(+K!]C\T@B.M;BBP'L]PLYM.IWX
+MQ9>[[CX4^!.["7BQ++!RM+\Y`.)Y?H\TO-[]?&>);)AW#P:&`J"60RB"<0_N
+M48D220<D*0O&0P&DDXMZ%JHL@I:!:)**((+JASA8(K'*40=4*@LQHC>;M]7G
+M<S4O;MG8<R$7G;HE[FJTM#JU&)KBDF01RT6(<"6C9)\<,GIP'OKFO?78HY<=
+MW"*4;ZS5!.AH,$VG+BBN=/H/W!ZD/__$GW^TX['7V)V\R>;31JCJBLJLMNL,
+M,^S#9]F3[!U-5]55"Q6:*:$B&9H!JD<D<A6G)%R'4!Z)J\8VWIKFC9*C>2W*
+MQ0TM(3+10E*UM-IT?;M.<?W9]'[@?2!Y.TZ2*K:B/@]X@"D6_@)),#)-=3[3
+MIV)R_Y!)/O`[]/IM4D4G&GY%L?E3A](Z)+[0VZ-$,B3#$E_/@=]\+Y?0Y]X<
+M!P^>(?6H2(:'D],$DB!L/#W^Q*;!2);1GO^?:]/J\<:<L#N>SILU@<UU-93F
+MF]62JUHE75QG+'5GS2NMY;F864>-7`^%:M8:+>=W!!/8@=4F(>VT=V30X5ZP
+M/!-'7/`#!EB.C+@.3>[S:F*<')S.(\/3F8"5[II(C+FXCY^]G[VJF&&"UJ(_
+M'O[1%U!S1XD#\,)Z[]!N3UM#0U'7KS#I$.&L1.,Z^PDD*<?^__+[B&C7@/XQ
+M,2MQDAO#3J*6[AQ#XK5'VGW=AZ3Y2[YO\8'V$S/\C*W<:Z[B\_R/O7*H9C6B
+MU?IJPE_Y?M7X70P,&\SN#3KY;UL+:F3^&P_4/[B,63Z(.RJK./C_@-)_O0[3
+M<?,@/$'Y)X/S/TA]\/XQA_?\E1/L?ND[_X([O#7^K`[>=Q"C6RUE0^B7`R_F
+MG)_M&;#W!Q$E]Q^8]'#T(&O4M?J9;WGW62"0%4@@_I"R?]HOL%?ME5/*,>^(
+M;ZFAHS])"22?[I_+4_YTG^MAX.DH(GK"#TADLM#W84G>EXS*@8W_-Q[?=3GZ
+M7G1M(I$15O;[^2']E@K^O]^8@Q'Q?/\C$_XLU&(T+,73#^#,U9%L<B0X-GM(
+M_I1M8;\Y.`BFP9GR/F:GO]2_/\;C,I<UFC(:[PAH/R^PK.2#UR5TPHDM$"I4
+M^S8:,82VQ1?_>.1GB!QDF$-H7'L0['D^[[H@HJK#\O_U,/_D=#L&SH>$H**(
+MP5K5UV75]O-YRNNI_;M=+,(#D48H(Q%,#3<E?:Z+X-;G@^J7@V*C!IZ0$X2)
+MQ#W?".C7O)^P3G^S/J`T/M_AQ#8;]R(;^4I]&#0%A]>F%/X?W2\0&$RQQ(6`
+MHJ9N\7P^6^7VP8>L#"DV2*1K06VRMF-(P88DI5AF62[Y_N_SYN<]*GR:'7J`
+M+N!@(6*11W>UK_I@X05-0!?V><#4J]^/=YY@R<>CODIN&R4Z-3L=GMV+:]L@
+M2=3^H/AUZFH"%!2"VBXA1@-0##U4B9`>PPVH4L9*LBE36>>_7?/*F:RM+T*W
+M9"8V$0H::1@-G9HYJ>OW?JZA#[DJKG^P`R'+(QA%ZV!9"TI_B6VB/IIAQHS>
+M)1%0G^S9$Q^J;@RR5:RVK,R!26&88%0JR#"#"VLHD_AE^EI$I#$(1*T']N.+
+MWF/,0<I3Q(I_LO]8?9[(#]/)?V^?']AK[0-)L1A%IH`@@H>P^=2C_3Y%IIWX
+M(.H&8D200\I1)#CD+^6@S!![IB%<1<*6LNR"D^4^7\FZX^D.3^PS6E.FZ<1Z
+M<_[,G<X]CVG$G^*O]P2?AVSOV>I_IT64CA53T&#F1!(!I95^R4<@0T^`_3^@
+M]GKG[?ON`_JOPSC$2IVPOTBFA!%WYLV!M#65FD^*&3:%52*H?M2LFW&?K=*B
+MZQON\20\\#W#J28?5YZ&C;+$-VW2PR7_8<:@#VI^Q2P?#^P@PSZR,\"12'S"
+M5O^8-?PPBF+,"(!][^_-M*B0<B"@0R)[E0B''YFX0R&U)!-IPR![E6")9SQ>
+M.NS."5L2JQ3KNZ=+ZH7"AVWI7TV0'S2"=^8G@0AY>`-</OU5Y%HS<HGGGF0(
+M=.BIXO2Z2TX2RAN*$@I>D$F84_;Q3ML-KAEX*98L[:+K5[V\WFW[>:N'4!AV
+M(T+G#A4L%2,`[3,"!`&@8+C*J@\3I=&ASFZU$5$0]7`88D=9D.4TBJ)K5R`L
+M4VU7I2FJV4;9O#.]<.4XZ2T00K!2JJ-$G9T;&T(CZ=@V@LE.WI''O]GLAP=%
+MKU$]/Z@GL$A!0]L*'L@=^Y(0%*A"0EZ[`_D87R:4?N^U/(OM/V*'S>I/^KX]
+M?P_0B?+^)8*I]"`/KB[HB@0C/R8*;D&:3E/\SGQYA_^='Y95/^OM,F%LG_NF
+M,$!D!_Z*4/]CGF$O]__'^__5TAN?^CGW_C]_Q_\_83_]F*"LDRFLS;?OC8%.
+MVK_____________________________________________Q$0(7B?7'V`\%
+M"E$)+V``&!0H&J`#`1`D5]&.J`]:=>?9]]W/(??<YT/H`!0I;--*HIZ:G;*D
+ME[4JJH#T`![PU(36]#3;WV/27-HE[G?>WH?=]V]]G?:^=OF]*CP`VH```(+8
+M-7D```!D`````````4T```#=@``!H`$@*``?0W9Y<@````"@```"@````$0`
+M`*`$@````````H`"@`::`?2[=P7P&7D6[;D@^`QD$*]*![N[D:`-`!30W8`:
+M`ITU!%4T:0Y,,TF)1$4:;9$1C%$@"@````````````?0``!R)```4X+4#3$)
+M4B0```@`M?&S+*E/9@#7KYT][V`V%826O`T>G76@I3(.[`'1H!10#[AY]2V'
+M75+M0?8Z',/3BZDJZVMP/2I5*C3IPBHB%45154*C2S45)$42*0#>+U0N1)I=
+M*-W@[=HSBPM?!2%)M@"@1`5`J+,-:``#T*````"J`````>@`].<"NHJ%%)*Q
+MHU457V:[95][N]J<D[8;<92-E*6AUTM[N]UQS)0ME14T;NYUNN[NT=\`1Z]L
+M]'7.W3N;EFQ=W?3/9P2+6`-KM[=TEW.=?6D%=0`-)`>=RJ?1KZ-%<``TTV%8
+M38``!D`6FE5Y,.W9N$^3KT\5F,`!5$0``%````;W%XZYVWE\FX;[#2^]KN[,
+M`#IV[:X!VG%L38S2NA]=];T[X``[WN``.][@](@``````````!3UW8V=;SMS
+MNWDY+F9[?(&D`!+WVP`!A`-S@INYH="63[W.[LI0R]L\X8][/6[9N\\X[.^:
+MM<#U4```F$<FKELDSL[C[<KM['GL>S/.YW=O,^<<O7J`<GV-@`-)O:O7@#SU
+M[:FD`WEJJK:V=/IJJ`]]N[+LV[K;9MW=V6[C>3P=;;8`#;[@.;FL"V]P'0+S
+M1GV8DQ3MFS.W3NWEX(!U``4!-=9(7+?6YFQ-F^QT"SMG;X]H`.H```0U78#$
+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
+M(0(D9DB`D#)(2!$@9)D22222!)($@YK6N7"$`AB23)`YXFU<ZR0`@2$A`DA"
+M3,DB3,R(D)"!"0@21Z=6NKJ!G-LM;6MQ)($"0DD,N;7.,0A(DB01*2E-FRRR
+MRRE)$2"0$A(D2$@9,)"!(S)))DD!2F0220D3)(A"$@$```DDDDDDDH0A?@OQ
+M\-#[#D>DDN9^8V78SWO+PWREML[.0G(_`\#P?@>D=-:YZZ::U\]>GS^97&,8
+ML8X43^O]C,S,P1`",B02,RI4TTTTTTR))DS*E3:;2TVE39I9D1,EEEE*6::9
+M$,F9,DTIII999IF2(D9FS9LV5*B$A(2$)"0L+`P,)*0K,B9*4S),R29)!)),
+MR2(F39LM+2TL2DI",(R*2*0`P`R*2*2*2*0H0H0H0H2(2(2@2@0#`,H2A*0D
+MD-D2)----*4S---34LLI21"1,D""0`))))($DDDF223(B22$)))(&1($R9E*
+M6;--*4S(2`#,TTTTI33399II2DB"D$)))(222$DDDDDDA))))[6O9+<Z)`D"
+M0R0DA"&$PA))"0R2(0DF02!`9D2))$*1!)"222$)($"$8$DP(`0@A!2$&$D)
+M)(0I#,*9F92F$RDE*1E(@)$DA"2&9)(D0AF2))2*!,B&222E,R12DI3,DS))
+M`TTTTLLV;++++----*4I2E)D(FD21D32,S"22D1S2Y$2E)))(93,*92"2)F2
+M$@2`%,R,(20I3,I!$I$A"9#)2E-*9(B4DS(D29F9F22222(D@(22$*7+R;77
+M4,B2220AB0@20B024III2DF9F9E-*:9B(21"(0)$F9II9999F92229$,93)!
+M,()))#)A(3)DC)))"2($D9D!D3)&1#))!)($`DA(A%F$DA(20)(2,B1))(B&
+M$@$3("$A)`"!)`"$DD20@<KESESDA"!S;NZUU$)`A($``DDF!)$A"$(20(&D
+M!)")))-,`D`DDF1"(1(!,)`29F9992E*2")`&9),D@!`A#)2F29(DS#(`222
+M4I))(2!FF::4IF9D@)))D$F$$`B$2$"$DB$)$@*1)=6KG$B$D@)DDDDDF!)*
+M9)(B9)($$FD9"F2"29&8B`13!2FFFFE---,B022"$"2`S,B)F0(4S,S$I3,I
+M$ADDD3)2F00!(,B"4222$DB)`I)(0D-(R"$"3(B1)))E(12E*4TRDF23,R")
+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
+M"1PH;)A.)80-T2:&E-UK=-$J:FF[+ZWEXB%F54KY,N>J]^^;?6=5'I&Y;RL)
+MR90RZ+;>SH]U]+WAW)V>80YZ9[^[)B".8OOF%#F#S$_9+^F(J&9$OX#^F`%`
+M"1`"1*+0*T*P'ALT5;&]MANINVV&Q;MMC<MOYR*<0B(8W%#@40W#BF"(M%EA
+M98XM1=EV,AL;<-C9=%%57T\&(=$TL3:P^RZ.3M78[4AD=))T%7(H$HR.O>*C
+MJ]7?;N[[ZQ:^O>W[8`#4VEI:664I2E*22222222222222222222222222222
+M222222222222222222222222222222222222222222220,R2U-J6J:J:IJFI
+MJ::93(AM+3;+9ME4J5*4D$TI(A%2)`D*0I($@2DI++664RE)$C4U+:I;5(&`
+M85859!D&0R&1B9,,8S&3#"1A(P"P`&5$941@%"`4)5655@1"!$)0&4!@%@%A
+M0A0D21(6%A6%9!D&!(M*RLV;*4D1,EJ6I:6FFF9(PDDDA"22$`R2229$@32D
+MB))I21-J52I::4D2V6S99E)$I$D2-I::69$399D21*1,B9$D2220)))),B22
+M222220A2)2)(FI::4D2TJ4I(EI4I24DI2220DD222223)))))))(DDDDDDA2
+M*0*2(R(RH2H0#`,65EEF92E*9$23(DDB2;*2(EM+:;2TJ6FE)$UE9JM*K2VT
+MVIE#$,AB,C!AAC&8R484849*,`RJL!@,U2U-2I2S(E(DDF01#()6EJ:I:ELU
+MFLME392DB66;4M34M-EE*3)$@2)$I$R)!F2)DD$0DDR64D1*E34M-*2)92I4
+MI9D2TJ4I(DF1,@2(FM*TUFLJ5*4D0R"54JI5E653`8&!D8,,,8S&1,$@2!(&
+M!AAF8B5`E0)$R1@5@5@+*J8%@6*RK*RLLLRDB29*1$@))$!"2"]>U>MF4/F0
+MP/T68+,*_&M%:-:8">UI@4MN87`L+"AD`L+3$*(\V10,55$GV,D;)&,D:&FY
+M&F(W1.:[K[\[2[:6RB7LW=WX<PWA'E^&)ZB*=O@>0[[/15&>N>H51,]\/?.S
+M$4`46PC8@'AUP>"3O.\["J=H5K,R$,R$`7$!001'!%SJW)0813&RBB0DF3Y8
+MXLF2=N2^QMY5UK?WQHE]B.F9BO%55&_"/@:/X1T1"$(4":`@2EHH:$&([]`"
+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
+"VR``
+`
+end
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tests/general-test.c gcc-4.0.2/gcc/bounds/tests/general-test.c
--- gcc-4.0.2.org/gcc/bounds/tests/general-test.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tests/general-test.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,563 @@
+/*----------------------------------------------------------------------*
+ * Bounds Checking for GCC.						*
+ * Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.	*
+ *----------------------------------------------------------------------*
+ * This program is free software; you can redistribute it and/or modify	*
+ * it under the terms of the GNU General Public License as published by	*
+ * the Free Software Foundation; either version 2 of the License, or	*
+ * (at your option) any later version.					*
+ *									*
+ * This program is distributed in the hope that it will be useful,	*
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of	*
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	*
+ * GNU General Public License for more details.				*
+ *									*
+ * You should have received a copy of the GNU General Public License	*
+ * along with this program; if not, write to the Free Software		*
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.		*
+ *----------------------------------------------------------------------*
+ * File:
+ *	tests/general-test.c
+ * Summary:
+ *	General test of validity of GCC with bounds checking.
+ * Other notes:
+ *	This is experimental at the moment. I'm not sure if this is an
+ *	effective way of testing this.
+ * Author      	Date		Notes
+ * RWMJ		June,July 95
+ *----------------------------------------------------------------------*/
+
+#include <sys/types.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <string.h>
+#include <stdarg.h>
+#include <assert.h>
+#include <malloc.h>
+
+#ifndef __BOUNDS_CHECKING_ON
+#error "Compile this file with bounds checking"
+#endif
+
+char *progname;
+char *results_dir = ".";
+
+void perform_test (int i);
+void call_test (int i);
+void testg0 (void);
+void testg1 (void);
+void testg2 (void);
+void testg3 (void);
+void testg4 (void);
+void testg5 (void);
+void testg6 (void);
+void testa0 (void);
+void testm0 (void);
+void testm1 (void);
+void testm2 (void);
+void testf0 (void);
+void testf1 (void);
+void testf2 (void);
+void testf3 (void);
+void testf4 (void);
+void testf5 (void);
+void testf6 (void);
+
+typedef void (*function_ptr) (void);
+function_ptr test_fn[] = {
+  testg0, testg1, testg2, testg3, testg4, testg5, testg6,
+  testa0,
+  testm0, testm1, testm2,
+  testf0, testf1, testf2, testf3, testf4, testf5, testf6
+};
+
+/* This should be the same as the number of tests in the `test_fn' table
+ * above. Notice that this line is read automatically by a script in the
+ * Makefile, so don't do anything fancy here:
+ */
+#define NR_TESTS 18
+
+int
+main (int argc, char *argv[])
+{
+  int i;
+  int test;
+
+  progname = argv[0];
+
+  if (argc >= 3 && strcmp (argv[1], "-$") == 0)
+    {
+      /* Program called automatically here. Process the automatic
+       * arguments.
+       */
+      for (i = 2; i < argc; ++i)
+	{
+	  if (i < argc - 1)
+	    {
+	      if (strcmp (argv[i], "-test") == 0)
+		{
+		  i++;
+		  test = atoi (argv[i]);
+		  continue;
+		}
+	      else
+		{
+		  fprintf (stderr, "%s: Wrong arguments.\n", progname);
+		  exit (1);
+		}
+	    }
+	  fprintf (stderr, "%s: Wrong arguments.\n", progname);
+	  exit (1);
+	}
+      perform_test (test);
+      exit (0);
+    }
+
+  /* Program called by user. Perform the automatic tests.
+   */
+  if (argc == 3 && strcmp (argv[1], "-dir") == 0)
+    results_dir = argv[2];
+  else if (argc >= 2)
+    {
+      fprintf (stderr, "%s [-dir <directory>]\n", progname);
+      exit (1);
+    }
+
+  printf ("Bounds checking GENERAL-TEST. Date: " __DATE__ ".\n");
+
+  for (i = 0; i < NR_TESTS; ++i)
+    call_test (i);
+
+  return 0;
+}
+
+void
+call_test (int i)
+{
+  int line;
+  char command[strlen (progname) + 128];
+  char inputfile[256];
+  char buffer1[256], buffer2[256], *b1, *b2;
+  FILE *pp, *fp;
+
+  printf ("Test %d\r", i);
+  fflush (stdout);
+  sprintf (command, "%s -$ -test %d 2>&1", progname, i);
+  sprintf (inputfile, "%s/test-%d.res", results_dir, i);
+  pp = popen (command, "r");
+  if (pp == NULL)
+    {
+      perror ("popen (command)");
+      exit (1);
+    }
+  fp = fopen (inputfile, "r");
+  if (fp == NULL)
+    {
+      perror ("fopen (result file)");
+      exit (1);
+    }
+  line = 0;
+  for (;;)
+    {
+      int j;
+
+      b1 = fgets (buffer1, 256, fp);
+      b2 = fgets (buffer2, 256, pp);
+
+      if (!b1 || !b2)
+	break;
+
+      /* Compare the actual result (in buffer2) with the correct
+       * result (in buffer1).
+       */
+
+      line++;
+      for (j = 0; j < strlen (buffer1); ++j)
+	{
+	  if (buffer1[j] == '*')
+	    /* means ignore to the end of the line */
+	    break;
+	  else if (buffer1[j] != '.'
+		   /* means ignore this single character */
+		   && buffer1[j] != buffer2[j])
+	    {
+	      fprintf (stderr,
+		       "Difference at line %d:\n"
+		       "  From command:    %s"
+		       "  Expected result: %s", line, buffer2, buffer1);
+	      exit (1);
+	    }
+	}
+    }
+
+  if (b1 != NULL)
+    {
+      fprintf (stderr, "Command generated too few lines of output.\n");
+      exit (1);
+    }
+  else if (b2 != NULL)
+    {
+      fprintf (stderr, "Command generated too many lines of output.\n");
+      exit (1);
+    }
+  printf ("Test %d: OK\n", i);
+}
+
+void
+perform_test (int i)
+{
+  if (0 <= i && i < NR_TESTS)
+    (test_fn[i]) ();
+  else
+    {
+      fprintf (stderr, "Test number must be 0 <= i < %d\n", NR_TESTS);
+      exit (1);
+    }
+}
+
+/*----------------------------------------------------------------------*/
+/* Replace `printf' so `%p' is replaced by something more informative.  */
+
+int
+my_printf (const char *fs, ...)
+{
+  va_list args;
+  char new_fs[1024], replace[64];
+  int i = 0, r;
+
+  if (sizeof (void *) == 2)
+    strcpy (replace, "ptr16-0x%04x");
+  else if (sizeof (void *) == 4)
+    strcpy (replace, "ptr32-0x%08x");
+  else if (sizeof (void *) == 8)
+    strcpy (replace, "ptr64-0x%016x");
+  else
+    abort ();
+
+  /* Replace `%p' in the format string. */
+  while (*fs)
+    {
+      if (*fs == '%' && *(fs + 1) == 'p')
+	{
+	  strcpy (new_fs + i, replace);
+	  while (new_fs[i])
+	    ++i;
+	  fs += 2;
+	}
+      else if (*fs == '%' && *(fs + 1) == '%')
+	{
+	  new_fs[i++] = *fs++;
+	  new_fs[i++] = *fs++;
+	}
+      else
+	new_fs[i++] = *fs++;
+    }
+  new_fs[i] = 0;
+
+  va_start (args, fs);
+  r = vprintf (new_fs, args);
+  va_end (args);
+
+  fflush (stdout);
+
+  return r;
+}
+
+#define printf my_printf
+
+/*----------------------------------------------------------------------*/
+/* Tests follow ...						        */
+
+/* ARRAY REFERENCE */
+
+void
+testg0 (void)
+{
+  char a[10];
+  int i;
+
+  for (i = 0; i < 100; ++i)
+    a[i] = 0;
+}
+
+void
+testg1 (void)
+{
+  char a[10];
+  int i;
+
+  for (i = 0; i < 10; ++i)
+    printf ("&a[%d] = %p\n", i, &a[i]);
+}
+
+void
+testg2 (void)
+{
+  char a[10];
+  int i;
+
+  for (i = 0; i <= 10; ++i)
+    printf ("&a[%d] = %p\n", i, &a[i]);	/* This is OK */
+}
+
+void
+testg3 (void)
+{
+  char a[10];
+  int i;
+
+  for (i = 0; i <= 11; ++i)
+    printf ("&a[%d] = %p\n", i, &a[i]);	/* This is _not_ OK */
+}
+
+/* POINTER DIFFERENCE */
+
+void
+testg4 (void)
+{
+  int p[10], q[10];
+  ptrdiff_t n;
+
+  n = &p[5] - &p[2];		/* OK */
+  n = &q[2] - &q[5];		/* OK */
+  n = q - p;			/* bad */
+}
+
+/* POINTER + INT */
+
+void
+testg5 (void)
+{
+  int i, a[10], *p;
+
+  for (i = 0; i <= 10; ++i)
+    {
+      printf ("a+i = %p\n", (p = a + i));
+      printf ("*(a+i) = 0\n");
+      *p = 0;
+    }
+}
+
+/* COMPONENT REF */
+
+void
+testg6 (void)
+{
+  struct
+  {
+    int a, b, c, d;
+  } *p1, *p2, *p3, *p4;
+
+  p1 = calloc (sizeof (int), 1);
+  p2 = calloc (sizeof (int), 2);
+  p3 = calloc (sizeof (int), 3);
+  p4 = calloc (sizeof (int), 4);
+
+  printf ("&p1->a = %p\n", &p1->a);
+  printf ("&p2->b = %p\n", &p2->b);
+  printf ("&p3->c = %p\n", &p3->c);
+  printf ("&p4->d = %p\n", &p4->d);
+  printf ("&p2->a = %p\n", &p2->a);
+  printf ("&p3->a = %p\n", &p3->a);
+  printf ("&p4->a = %p\n", &p4->a);
+  printf ("p1->a = %d\n", p1->a);
+  printf ("p2->b = %d\n", p2->b);
+  printf ("p3->c = %d\n", p3->c);
+  printf ("p4->d = %d\n", p4->d);
+  printf ("p2->a = %d\n", p2->a);
+  printf ("p3->a = %d\n", p3->a);
+  printf ("p4->a = %d\n", p4->a);
+
+  printf ("p3->d = %d\n", p3->d);	/* error */
+}
+
+/* INTENSIVE ARRAY-REF TESTS */
+
+struct art0
+{
+  int datum1, datum2, datum3;
+  char text[1];
+} __attribute__ ((packed));
+
+void
+testa0 (void)
+{
+  int len, i;
+  struct art0 *p;
+  int base_size = sizeof (struct art0) - 1;
+
+  /* This should run without error, but in fact fails because of HtB's
+   * array ref. patch.
+   */
+  for (len = 0; len < 20; len++)
+    {
+      p = malloc (base_size + len);
+      printf ("allocated structure at address %p, size %d\n",
+	      p, base_size + len);
+      p->datum1 = 1;
+      p->datum2 = 2;
+      p->datum3 = 3;
+      for (i = 0; i < len; ++i)
+	p->text[i] = 'a';
+      p->datum3 = 4;
+      p->datum2 = 5;
+      p->datum1 = 6;
+      free (p);
+    }
+  printf ("OK\n");
+}
+
+/* FREE TWICE */
+
+void
+testm0 (void)
+{
+  void *p = malloc (10);
+
+  free (p);
+  free (p);
+}
+
+/* FREE NON-HEAP MEM */
+
+void
+testm1 (void)
+{
+  int a[10];
+
+  free (a);
+}
+
+/* REALLOC NON-HEAP MEM */
+
+void
+testm2 (void)
+{
+  int a[10];
+
+  realloc (a, 10);
+}
+
+/* FUNCTION ARGUMENT */
+
+void
+testf0proc (i)
+     int i;
+{
+  int *p;
+  p = &i;
+  p[0] = 1;
+  printf ("OK\n");
+  p[1] = 2;
+  printf ("bad, but passes through for now\n");
+}
+
+void
+testf0 (void)
+{
+  testf0proc (0);
+}
+
+/* ARRAY ARGUMENTS */
+
+void
+testf1proc (p)
+     char *p;
+{
+  p[0] = 'a';
+  printf ("OK\n");
+  p[1] = 'b';
+  printf ("bad\n");
+}
+
+void
+testf1 (void)
+{
+  char a[1];
+  testf1proc (a);
+}
+
+/* MEMCPY */
+
+void
+testf2 (void)
+{
+  char buf[3];
+  memcpy (&buf[1], "ab", 2);
+  printf ("OK\n");
+  memcpy (&buf[1], "abc", 3);
+  printf ("bad\n");
+}
+
+/* STRCPY */
+
+void
+testf3 (void)
+{
+  char buf[3];
+  strcpy (buf, "ab");
+  printf ("OK\n");
+  strcpy (buf, "abc");
+  printf ("bad\n");
+}
+
+/* STDARG */
+
+#include <stdarg.h>
+
+void
+testf4proc (int nargs, ...)
+{
+  va_list p;
+  char *str;
+
+  va_start (p, nargs);
+
+  str = va_arg (p, char *);
+  str[0] = '0';
+  printf ("OK\n");
+
+  str = va_arg (p, char *);
+  str[0] = '0';
+  printf ("OK\n");
+
+  str[1] = '1';
+  printf ("bad\n");
+}
+
+void
+testf4 (void)
+{
+  char a1[1], a2[1];
+  testf4proc (2, a1, a2);
+}
+
+/* COMPARE DIFFERENT OBJECTS */
+
+void
+testf5 (void)
+{
+  char a1[2], a2[2];
+  int i;
+
+  i = &a1[0] < &a1[1];
+  printf ("OK\n");
+
+  i = &a1[0] < &a2[1];
+  printf ("bad\n");
+}
+
+/* CHECK GLOBAL VARIABLES */
+
+char testf6a[2];
+
+void
+testf6 (void)
+{
+  strncpy (testf6a, "xx", 2);
+  printf ("OK\n");
+
+  strncpy (testf6a, "xxx", 3);
+  printf ("bad\n");
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tests/Makefile gcc-4.0.2/gcc/bounds/tests/Makefile
--- gcc-4.0.2.org/gcc/bounds/tests/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tests/Makefile	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,156 @@
+#	Automatic tests for the bounds checking library.
+#	By Richard W.M. Jones. June - July, '95.
+
+# You can use the following make targets:
+#	make all
+#		- Compile test program and do all the tests
+#	make clean
+#		- Clean up object files and program
+#	make distclean
+#		- Same as `make clean'.
+#	make veryclean
+#		- Clean up `*.res' files too (** NOT recommended **).
+#	make results
+#		- Remake all `*.res' files (** NOT recommended **).
+#	make TESTS="0 1 2" results
+#		- Remake result files for tests 0, 1, 2. Only use this if you
+#		know what you're doing: eg. if you've just added another test
+#		to the program. Check the result file `test-xyz.res' by hand
+#		before you use it.
+
+#----------------------------------------------------------------------
+
+# The directory where you compiled GCC. `../..' should be OK if these tests
+# are left in `bounds/tests' subdirectory.
+
+GCCDIR	= ../..
+
+#----------------------------------------------------------------------
+
+# Command used to run the compiler with bounds checking.
+
+CC	= $(GCCDIR)/xgcc -B$(GCCDIR)/
+BCOPTS	= -fbounds-checking -fno-builtin
+
+# Other flags here. `-O' or `-O2' is recommended to check there are no
+# problems with optimizing bounds checked code.
+
+CCOPTS	= -O2 -Wall -g
+
+# Include files, if necessary.
+
+INCOPTS	=
+
+# The complete list of flags.
+
+CFLAGS	= $(BCOPTS) $(CCOPTS) $(INCOPTS)
+
+# Object files making up program.
+
+OBJS	= general-test.o
+
+# Program name.
+
+PROG	= general-test
+
+# Libraries.
+
+LIBS	=
+
+#----------------------------------------------------------------------
+
+SHELL	= /bin/sh
+
+all: tests
+
+distclean: clean
+
+clean:
+	rm -f $(OBJS) $(PROG) core *~ *.bak *.BAK *.old
+
+# Don't use the following rule unless you know what you're doing ...
+veryclean: clean
+	rm -f *.res *.res.old
+
+tests: $(PROG)
+	@echo "Performing tests ..."; \
+	GCC_BOUNDS_OPTS="-no-message -no-warn-unchecked-statics \
+		-no-warn-unchecked-stack -no-warn-free-null \
+		-warn-compare-objects \
+		-no-warn-misc-strings -no-statistics"; export GCC_BOUNDS_OPTS;\
+	if ./$(PROG); then \
+		echo "Tests OK."; \
+	else \
+		echo "*** Error during tests."; \
+	fi
+
+$(PROG): $(OBJS)
+	$(CC) $(CFLAGS) $(OBJS) $(LIBS) -o $(PROG)
+
+.c.o:
+	$(CC) $(CFLAGS) -c $< -o $@
+
+#----------------------------------------------------------------------
+
+# Remake the results files. This assumes that the program is currently
+# working. Normally you should never need to do this. Use the following
+# make command:
+#	make TESTS="3 4 5" results
+# (remakes results of tests 3, 4 and 5) or:
+#	make TESTS=all results
+#	make results
+# (both remake all tests).
+#
+# Commentary (you will probably never need to know this):
+# The rule for remaking the results files is a single `sh' command which
+# automatically runs `general-test -$ -test N' for each test number `N'
+# and processes the output with `sed'. In particular, we delete specific
+# pointer values, since these will vary from machine to machine and day
+# to day. The important thing is that we recognize pointers as NULL (0),
+# ILLEGAL (-1) or ``other''. Notice that `general-test' writes pointers
+# in the form `ptrnn-0xpppp' where `nn' is the pointer size (16, 32 or
+# 64 bits) and `pppp' is the actual pointer value. This is so we can safely
+# parse these pointers here. Also we convert 0xffff -> ILLEGAL -> 0xffff
+# in the `sed' script. This is so it doesn't get mangled into `0x....' by
+# the intervening lines in the script.
+#
+# The automatic processing done by `sed' here isn't foolproof, so you'll
+# need to examine the results by hand if you add your own tests.
+
+results: $(PROG)
+	@GCC_BOUNDS_OPTS="-no-message -no-warn-unchecked-statics \
+		-no-warn-unchecked-stack -no-warn-free-null \
+		-warn-compare-objects \
+		-no-warn-misc-strings -no-statistics"; export GCC_BOUNDS_OPTS;\
+	if [ "x$(TESTS)" = xall -o "x$(TESTS)" = "x" ]; then \
+		tests=`grep 'define.*NR_TESTS' general-test.c | \
+			head -1 | \
+			awk '{for (i = 0; i < $$3; ++i) print i;}'`; \
+	else \
+		tests="$(TESTS)"; \
+	fi; \
+	for test in $$tests; do \
+		echo Making file test-$$test.res; \
+		if [ -f test-$$test.res ]; then \
+			mv test-$$test.res test-$$test.res.old; \
+		fi; \
+		./$(PROG) -$$ -test $$test 2>&1 | \
+		sed -e 's/ointer value: 0x.*/ointer value: */g' \
+		    -e 's/ddress in memory:    0x.*/ddress in memory:    */g' \
+		    -e 's/ptr16-0xffff/ptr16-ILLEGAL/g' \
+		    -e 's/ptr32-0xffffffff/ptr32-ILLEGAL/g' \
+		    -e 's/ptr64-0xffffffffffffffff/ptr64-ILLEGAL/g' \
+		    -e 's/ptr16-0xffff/ptr16-NULL/g' \
+		    -e 's/ptr32-0x00000000/ptr32-NULL/g' \
+		    -e 's/ptr64-0x0000000000000000/ptr64-NULL/g' \
+		    -e 's/ptr16-0x[0-9a-f][0-9a-f][0-9a-f][0-9a-f]/ptr16-0x..../g' \
+		    -e 's/ptr32-0x[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]/ptr32-0x......../g' \
+		    -e 's/ptr64-0x[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]/ptr64-0x................/g' \
+		    -e 's/ptr16-ILLEGAL/ptr16-0xffff/g' \
+		    -e 's/ptr32-ILLEGAL/ptr32-0xffffffff/g' \
+		    -e 's/ptr64-ILLEGAL/ptr64-0xffffffffffffffff/g' \
+		    -e 's/ptr16-NULL/ptr16-0x0000/g' \
+		    -e 's/ptr32-NULL/ptr32-0x00000000/g' \
+		    -e 's/ptr64-NULL/ptr64-0x0000000000000000/g' \
+		    -e '/IOT trap\/Abort/d' > test-$$test.res; \
+	done
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tests/README gcc-4.0.2/gcc/bounds/tests/README
--- gcc-4.0.2.org/gcc/bounds/tests/README	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tests/README	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,5 @@
+
+This directory contains an experimental test suite for Bounds Checking GCC.
+It is rather incomplete at the moment & may depend too much on the
+machine architecture (ie. on having 32 bit ints).
+
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tests/test-0.res gcc-4.0.2/gcc/bounds/tests/test-0.res
--- gcc-4.0.2.org/gcc/bounds/tests/test-0.res	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tests/test-0.res	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,9 @@
+general-test.c:281:Bounds error: array reference (10) outside bounds of the array.
+general-test.c:281:  Pointer value: *
+general-test.c:281:  Object `a':
+general-test.c:281:    Address in memory:    *
+general-test.c:281:    Size:                 10 bytes
+general-test.c:281:    Element size:         1 bytes
+general-test.c:281:    Number of elements:   10
+general-test.c:281:    Created at:           general-test.c, line 277
+general-test.c:281:    Storage class:        stack
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tests/test-10.res gcc-4.0.2/gcc/bounds/tests/test-10.res
--- gcc-4.0.2.org/gcc/bounds/tests/test-10.res	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tests/test-10.res	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,2 @@
+general-test.c:439:Bounds error: invalid pointer passed to `realloc'.
+general-test.c:439:  Pointer value: *
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tests/test-11.res gcc-4.0.2/gcc/bounds/tests/test-11.res
--- gcc-4.0.2.org/gcc/bounds/tests/test-11.res	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tests/test-11.res	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,2 @@
+OK
+bad, but passes through for now
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tests/test-12.res gcc-4.0.2/gcc/bounds/tests/test-12.res
--- gcc-4.0.2.org/gcc/bounds/tests/test-12.res	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tests/test-12.res	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,10 @@
+OK
+general-test.c:470:Bounds error: attempt to reference memory overrunning the end of an object.
+general-test.c:470:  Pointer value: *
+general-test.c:470:  Object `a':
+general-test.c:470:    Address in memory:    *
+general-test.c:470:    Size:                 1 bytes
+general-test.c:470:    Element size:         1 bytes
+general-test.c:470:    Number of elements:   1
+general-test.c:470:    Created at:           general-test.c, line 477
+general-test.c:470:    Storage class:        stack
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tests/test-13.res gcc-4.0.2/gcc/bounds/tests/test-13.res
--- gcc-4.0.2.org/gcc/bounds/tests/test-13.res	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tests/test-13.res	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,10 @@
+OK
+general-test.c:489:Bounds error: memcpy with this destination pointer and size 3 would overrun the end of the object's allocated memory.
+general-test.c:489:  Pointer value: *
+general-test.c:489:  Object `buf':
+general-test.c:489:    Address in memory:    *
+general-test.c:489:    Size:                 3 bytes
+general-test.c:489:    Element size:         1 bytes
+general-test.c:489:    Number of elements:   3
+general-test.c:489:    Created at:           general-test.c, line 486
+general-test.c:489:    Storage class:        stack
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tests/test-14.res gcc-4.0.2/gcc/bounds/tests/test-14.res
--- gcc-4.0.2.org/gcc/bounds/tests/test-14.res	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tests/test-14.res	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,10 @@
+OK
+general-test.c:501:Bounds error: strcpy with this destination string and size 4 would overrun the end of the object's allocated memory.
+general-test.c:501:  Pointer value: *
+general-test.c:501:  Object `buf':
+general-test.c:501:    Address in memory:    *
+general-test.c:501:    Size:                 3 bytes
+general-test.c:501:    Element size:         1 bytes
+general-test.c:501:    Number of elements:   3
+general-test.c:501:    Created at:           general-test.c, line 498
+general-test.c:501:    Storage class:        stack
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tests/test-15.res gcc-4.0.2/gcc/bounds/tests/test-15.res
--- gcc-4.0.2.org/gcc/bounds/tests/test-15.res	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tests/test-15.res	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,11 @@
+OK
+OK
+general-test.c:525:Bounds error: attempt to reference memory overrunning the end of an object.
+general-test.c:525:  Pointer value: *
+general-test.c:525:  Object `a2':
+general-test.c:525:    Address in memory:    *
+general-test.c:525:    Size:                 1 bytes
+general-test.c:525:    Element size:         1 bytes
+general-test.c:525:    Number of elements:   1
+general-test.c:525:    Created at:           general-test.c, line 532
+general-test.c:525:    Storage class:        stack
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tests/test-16.res gcc-4.0.2/gcc/bounds/tests/test-16.res
--- gcc-4.0.2.org/gcc/bounds/tests/test-16.res	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tests/test-16.res	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,18 @@
+OK
+general-test.c:547:Bounds error: in <, >, <= or >= of pointers, pointers point to different objects.
+general-test.c:547:  Left pointer value: *
+general-test.c:547:  Object `a1':
+general-test.c:547:    Address in memory:    *
+general-test.c:547:    Size:                 2 bytes
+general-test.c:547:    Element size:         1 bytes
+general-test.c:547:    Number of elements:   2
+general-test.c:547:    Created at:           general-test.c, line 541
+general-test.c:547:    Storage class:        stack
+general-test.c:547:  Right pointer value: *
+general-test.c:547:  Object `a2':
+general-test.c:547:    Address in memory:    *
+general-test.c:547:    Size:                 2 bytes
+general-test.c:547:    Element size:         1 bytes
+general-test.c:547:    Number of elements:   2
+general-test.c:547:    Created at:           general-test.c, line 541
+general-test.c:547:    Storage class:        stack
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tests/test-17.res gcc-4.0.2/gcc/bounds/tests/test-17.res
--- gcc-4.0.2.org/gcc/bounds/tests/test-17.res	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tests/test-17.res	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,10 @@
+OK
+general-test.c:561:Bounds error: strncpy with this destination string and size 3 would overrun the end of the object's allocated memory.
+general-test.c:561:  Pointer value: *
+general-test.c:561:  Object `testf6a':
+general-test.c:561:    Address in memory:    *
+general-test.c:561:    Size:                 2 bytes
+general-test.c:561:    Element size:         1 bytes
+general-test.c:561:    Number of elements:   2
+general-test.c:561:    Created at:           general-test.c, line 553
+general-test.c:561:    Storage class:        static
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tests/test-1.res gcc-4.0.2/gcc/bounds/tests/test-1.res
--- gcc-4.0.2.org/gcc/bounds/tests/test-1.res	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tests/test-1.res	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,10 @@
+&a[0] = ptr32-0x........
+&a[1] = ptr32-0x........
+&a[2] = ptr32-0x........
+&a[3] = ptr32-0x........
+&a[4] = ptr32-0x........
+&a[5] = ptr32-0x........
+&a[6] = ptr32-0x........
+&a[7] = ptr32-0x........
+&a[8] = ptr32-0x........
+&a[9] = ptr32-0x........
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tests/test-2.res gcc-4.0.2/gcc/bounds/tests/test-2.res
--- gcc-4.0.2.org/gcc/bounds/tests/test-2.res	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tests/test-2.res	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,11 @@
+&a[0] = ptr32-0x........
+&a[1] = ptr32-0x........
+&a[2] = ptr32-0x........
+&a[3] = ptr32-0x........
+&a[4] = ptr32-0x........
+&a[5] = ptr32-0x........
+&a[6] = ptr32-0x........
+&a[7] = ptr32-0x........
+&a[8] = ptr32-0x........
+&a[9] = ptr32-0x........
+&a[10] = ptr32-0x........
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tests/test-3.res gcc-4.0.2/gcc/bounds/tests/test-3.res
--- gcc-4.0.2.org/gcc/bounds/tests/test-3.res	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tests/test-3.res	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,12 @@
+&a[0] = ptr32-0x........
+&a[1] = ptr32-0x........
+&a[2] = ptr32-0x........
+&a[3] = ptr32-0x........
+&a[4] = ptr32-0x........
+&a[5] = ptr32-0x........
+&a[6] = ptr32-0x........
+&a[7] = ptr32-0x........
+&a[8] = ptr32-0x........
+&a[9] = ptr32-0x........
+&a[10] = ptr32-0x........
+&a[11] = ptr32-0x........
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tests/test-4.res gcc-4.0.2/gcc/bounds/tests/test-4.res
--- gcc-4.0.2.org/gcc/bounds/tests/test-4.res	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tests/test-4.res	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,17 @@
+general-test.c:324:Bounds error: in pointer difference, pointers point to different objects.
+general-test.c:324:  Left pointer value: *
+general-test.c:324:  Object `q':
+general-test.c:324:    Address in memory:    *
+general-test.c:324:    Size:                 40 bytes
+general-test.c:324:    Element size:         4 bytes
+general-test.c:324:    Number of elements:   10
+general-test.c:324:    Created at:           general-test.c, line 319
+general-test.c:324:    Storage class:        stack
+general-test.c:324:  Right pointer value: *
+general-test.c:324:  Object `p':
+general-test.c:324:    Address in memory:    *
+general-test.c:324:    Size:                 40 bytes
+general-test.c:324:    Element size:         4 bytes
+general-test.c:324:    Number of elements:   10
+general-test.c:324:    Created at:           general-test.c, line 319
+general-test.c:324:    Storage class:        stack
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tests/test-5.res gcc-4.0.2/gcc/bounds/tests/test-5.res
--- gcc-4.0.2.org/gcc/bounds/tests/test-5.res	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tests/test-5.res	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,31 @@
+a+i = ptr32-0x........
+*(a+i) = 0
+a+i = ptr32-0x........
+*(a+i) = 0
+a+i = ptr32-0x........
+*(a+i) = 0
+a+i = ptr32-0x........
+*(a+i) = 0
+a+i = ptr32-0x........
+*(a+i) = 0
+a+i = ptr32-0x........
+*(a+i) = 0
+a+i = ptr32-0x........
+*(a+i) = 0
+a+i = ptr32-0x........
+*(a+i) = 0
+a+i = ptr32-0x........
+*(a+i) = 0
+a+i = ptr32-0x........
+*(a+i) = 0
+a+i = ptr32-0x........
+*(a+i) = 0
+general-test.c:338:Bounds error: attempt to reference memory overrunning the end of an object.
+general-test.c:338:  Pointer value: *
+general-test.c:338:  Object `a':
+general-test.c:338:    Address in memory:    *
+general-test.c:338:    Size:                 40 bytes
+general-test.c:338:    Element size:         4 bytes
+general-test.c:338:    Number of elements:   10
+general-test.c:338:    Created at:           general-test.c, line 332
+general-test.c:338:    Storage class:        stack
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tests/test-6.res gcc-4.0.2/gcc/bounds/tests/test-6.res
--- gcc-4.0.2.org/gcc/bounds/tests/test-6.res	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tests/test-6.res	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,23 @@
+&p1->a = ptr32-0x........
+&p2->b = ptr32-0x........
+&p3->c = ptr32-0x........
+&p4->d = ptr32-0x........
+&p2->a = ptr32-0x........
+&p3->a = ptr32-0x........
+&p4->a = ptr32-0x........
+p1->a = 0
+p2->b = 0
+p3->c = 0
+p4->d = 0
+p2->a = 0
+p3->a = 0
+p4->a = 0
+general-test.c:372:Bounds error: pointer arithmetic would overrun the end of the object.
+general-test.c:372:  Pointer value: *
+general-test.c:372:  Object `calloc':
+general-test.c:372:    Address in memory:    *
+general-test.c:372:    Size:                 12 bytes
+general-test.c:372:    Element size:         1 bytes
+general-test.c:372:    Number of elements:   12
+general-test.c:372:    Created at:           general-test.c, line 354
+general-test.c:372:    Storage class:        heap
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tests/test-7.res gcc-4.0.2/gcc/bounds/tests/test-7.res
--- gcc-4.0.2.org/gcc/bounds/tests/test-7.res	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tests/test-7.res	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,21 @@
+allocated structure at address ptr32-0x........, size 12
+allocated structure at address ptr32-0x........, size 13
+allocated structure at address ptr32-0x........, size 14
+allocated structure at address ptr32-0x........, size 15
+allocated structure at address ptr32-0x........, size 16
+allocated structure at address ptr32-0x........, size 17
+allocated structure at address ptr32-0x........, size 18
+allocated structure at address ptr32-0x........, size 19
+allocated structure at address ptr32-0x........, size 20
+allocated structure at address ptr32-0x........, size 21
+allocated structure at address ptr32-0x........, size 22
+allocated structure at address ptr32-0x........, size 23
+allocated structure at address ptr32-0x........, size 24
+allocated structure at address ptr32-0x........, size 25
+allocated structure at address ptr32-0x........, size 26
+allocated structure at address ptr32-0x........, size 27
+allocated structure at address ptr32-0x........, size 28
+allocated structure at address ptr32-0x........, size 29
+allocated structure at address ptr32-0x........, size 30
+allocated structure at address ptr32-0x........, size 31
+OK
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tests/test-8.res gcc-4.0.2/gcc/bounds/tests/test-8.res
--- gcc-4.0.2.org/gcc/bounds/tests/test-8.res	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tests/test-8.res	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,2 @@
+general-test.c:419:Bounds error: invalid pointer passed to `free'.
+general-test.c:419:  Pointer value: *
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tests/test-9.res gcc-4.0.2/gcc/bounds/tests/test-9.res
--- gcc-4.0.2.org/gcc/bounds/tests/test-9.res	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tests/test-9.res	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,2 @@
+general-test.c:429:Bounds error: invalid pointer passed to `free'.
+general-test.c:429:  Pointer value: *
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/thread/pthread_init.c gcc-4.0.2/gcc/bounds/thread/pthread_init.c
--- gcc-4.0.2.org/gcc/bounds/thread/pthread_init.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/thread/pthread_init.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,97 @@
+/*----------------------------------------------------------------------*
+ * Bounds Checking for GCC.                                             *
+ * Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.      *
+ *----------------------------------------------------------------------*
+ * This program is free software; you can redistribute it and/or modify *
+ * it under the terms of the GNU General Public License as published by *
+ * the Free Software Foundation; either version 2 of the License, or    *
+ * (at your option) any later version.                                  *
+ *                                                                      *
+ * This program is distributed in the hope that it will be useful,      *
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of       *
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the        *
+ * GNU General Public License for more details.                         *
+ *                                                                      *
+ * You should have received a copy of the GNU General Public License    *
+ * along with this program; if not, write to the Free Software          *
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.            *
+ *----------------------------------------------------------------------*
+ * File:
+ *      thread/pthread_init.c
+ * Summary:
+ *      Init bounds checking for pthread library or signal handlers.
+ * Other notes:
+ *	Signal handlers are not turned on by default because it takes
+ *	a lot of cpu cycles. Most of the time this extra overhead is
+ *	not needed because the user code does not have signal handlers
+ *	or the user signal handlers do not call bounds_checking functions.
+ * Author       Date            Notes
+ * HtB         2/6/99         Initial implementation.
+ *----------------------------------------------------------------------*/
+
+#ifdef __BOUNDS_CHECKING_ON
+
+/* If signal handlers are used set this define to '1' instead of '0'.  */
+
+#define	USE_SIGNAL	0
+
+/* If pthread is used set this define to '1' instead of '0'.  */
+
+#define	USE_PTHREAD	1
+
+#include <stdio.h>		/* NULL */
+#include <sys/types.h>
+#if USE_PTHREAD
+#include <pthread.h>
+#endif
+
+#if USE_SIGNAL
+extern int __bounds_mutex_signal;
+#endif
+
+#if USE_PTHREAD
+static void bounds_mutex_start (void);
+static void bounds_mutex_end (void);
+
+extern pthread_t (*__bounds_function_thread) (void);
+static pthread_mutex_t bounds_mutex_object;
+#endif
+
+extern void (*__bounds_mutex_start) (void);
+extern void (*__bounds_mutex_end) (void);
+
+/* These routine are called to protect static data in the bounds_checking
+   library.  */
+
+static void
+bounds_mutex_start (void)
+{
+#if USE_PTHREAD
+  pthread_mutex_lock (&bounds_mutex_object);
+#endif
+}
+
+static void
+bounds_mutex_end (void)
+{
+#if USE_PTHREAD
+  pthread_mutex_unlock (&bounds_mutex_object);
+#endif
+}
+
+/* Init routine to set up bounds_checking for the pthread library.  */
+
+void
+bounds_pthread_init (void)
+{
+#if USE_PTHREAD
+  pthread_mutex_init (&bounds_mutex_object, NULL);
+  __bounds_function_thread = pthread_self;
+#endif
+#if USE_SIGNAL
+  __bounds_mutex_signal = 1;
+#endif
+  __bounds_mutex_start = bounds_mutex_start;
+  __bounds_mutex_end = bounds_mutex_end;
+}
+#endif
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tools/find-objects.c gcc-4.0.2/gcc/bounds/tools/find-objects.c
--- gcc-4.0.2.org/gcc/bounds/tools/find-objects.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tools/find-objects.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,661 @@
+/*----------------------------------------------------------------------*
+ * Bounds Checking for GCC.						*
+ * Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.	*
+ *----------------------------------------------------------------------*
+ * This program is free software; you can redistribute it and/or modify	*
+ * it under the terms of the GNU General Public License as published by	*
+ * the Free Software Foundation; either version 2 of the License, or	*
+ * (at your option) any later version.					*
+ *									*
+ * This program is distributed in the hope that it will be useful,	*
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of	*
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	*
+ * GNU General Public License for more details.				*
+ *									*
+ * You should have received a copy of the GNU General Public License	*
+ * along with this program; if not, write to the Free Software		*
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.		*
+ *----------------------------------------------------------------------*
+ * File:
+ *	tools/find-objects.c
+ * Summary:
+ *	Look for static data in libraries and other object files. Write
+ *	a C program that will add these objects to the tree at run time
+ *	automatically.
+ * Other notes:
+ *	You will need GNU's `BFD' library, which can be found in the GDB
+ *	package.
+ * Author      	Date		Notes
+ * RWMJ		27/8/95		Initial implementation.
+ *----------------------------------------------------------------------*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <malloc.h>
+#include <errno.h>
+#include <ansidecl.h>
+
+#ifndef PARAMS
+#ifdef __STDC__
+#define PARAMS(args) args
+#else
+#define PARAMS(args)
+#endif
+#endif
+
+#include "bfd.h"
+
+void process_file PARAMS ((CONST char *));
+void process_archive_or_object PARAMS ((bfd *, CONST char *));
+void process_object_file PARAMS ((bfd *, CONST char *));
+int compare_symbols PARAMS ((asymbol **, asymbol **));
+int miscellaneous_deletable_symbol PARAMS ((CONST char *));
+int excluded_symbol PARAMS ((CONST char *));
+int add_excluded_symbols PARAMS ((CONST char **));
+void open_output_file PARAMS ((CONST char *, CONST char *));
+void write_symbol
+PARAMS ((CONST char *, CONST char *, CONST char *, CONST char *, long,
+	 size_t));
+void write_table PARAMS ((void));
+void close_output_file PARAMS ((CONST char *));
+void do_bfd_error PARAMS ((CONST char *));
+void do_error PARAMS ((CONST char *));
+void usage PARAMS ((void));
+
+int quiet = 0;
+FILE *output_file;
+
+int
+main (argc, argv)
+     int argc;
+     char *argv[];
+{
+  char *input_filename = NULL, *output_filename = NULL;
+  int count = 0, i;
+
+  /* Initialize the BFD library.
+   */
+  bfd_init ();
+
+  /* Process the command line arguments here.
+   */
+  for (i = 1; i < argc; ++i)
+    {
+      if (argv[i][0] == '-' && argv[i][1] == '-')
+	{
+	  if (strcmp (argv[i], "--quiet") == 0)
+	    quiet = 1;
+	  else if (strcmp (argv[i], "--exclude") == 0 && i < argc - 1)
+	    i += add_excluded_symbols ((CONST char **) &argv[i + 1]);
+	  else if (strcmp (argv[i], "--") == 0)
+	    ;
+	  else
+	    usage ();
+	}
+      else
+	{
+	  if (count == 0)
+	    input_filename = argv[i];
+	  else if (count == 1)
+	    output_filename = argv[i];
+	  else
+	    usage ();
+	  count++;
+	}
+    }
+  if (count != 2)
+    usage ();
+
+  open_output_file (output_filename, input_filename);
+  process_file (input_filename);
+  close_output_file (input_filename);
+
+  exit (0);
+}
+
+void
+process_file (filename)
+     CONST char *filename;
+{
+  bfd *input_bfd;
+
+  input_bfd = bfd_openr (filename, NULL);
+  if (input_bfd == NULL)
+    do_bfd_error ("bfd_openr");
+
+  if (!quiet)
+    printf ("File %s:\n", filename);
+  process_archive_or_object (input_bfd, filename);
+
+  bfd_close (input_bfd);
+}
+
+void
+process_archive_or_object (abfd, filename)
+     bfd *abfd;
+     CONST char *filename;
+{
+  /* Autodetect if this is a library (`archive') or object file. Other types
+   * of file will be rejected here.
+   */
+  if (bfd_check_format (abfd, bfd_archive))
+    {
+      /* It's a library. Go through each object file in the library in turn.
+       */
+      bfd *subbfd = NULL;
+
+/*      if (!quiet) printf ("This is a library.\n"); */
+
+      while ((subbfd = bfd_openr_next_archived_file (abfd, subbfd)) != NULL)
+	process_archive_or_object (subbfd, subbfd->filename);
+    }
+  else if (bfd_check_format (abfd, bfd_object))
+    {
+      process_object_file (abfd, filename);
+    }
+  else
+    {
+      /* Unrecognized format, or miscellaneous error reading the input file.
+       */
+      do_bfd_error ("file type");
+    }
+}
+
+void
+process_object_file (abfd, filename)
+     bfd *abfd;
+     CONST char *filename;
+{
+  long storage_needed, number_of_symbols, number_deleted, i;
+  asymbol **symbol_table;
+  int symbols_written = 0;
+
+  if (!quiet)
+    {
+      printf ("  Object file %s: ", filename);
+      fflush (stdout);
+    }
+
+  /* Read the symbol table from the object file. This code is copied almost
+   * directly from the BFD info pages.
+   */
+  storage_needed = bfd_get_symtab_upper_bound (abfd);
+  if (storage_needed < 0)
+    do_bfd_error ("bfd_get_symtab_upper_bound");
+  if (storage_needed == 0)
+    {
+      printf ("Warning: object file contains no symbols.\n");
+      return;
+    }
+  symbol_table = (asymbol **) malloc (storage_needed);
+  if (symbol_table == NULL)
+    do_error ("malloc");
+
+  /* This actually reads the symbol table into memory.
+   */
+  number_of_symbols = bfd_canonicalize_symtab (abfd, symbol_table);
+  if (number_of_symbols < 0)
+    do_bfd_error ("bfd_canonicalize_symtab");
+  if (number_of_symbols == 0)
+    goto end;
+
+  /* Now we have the symbol table in memory, delete undefined references
+   * and sort the remaining symbols into ascending order, so we can easily
+   * find the location and size of each one. If several symbols map to
+   * a single location, we ensure that globally named symbols appear first.
+   */
+  number_deleted = 0;
+  for (i = 0; i < number_of_symbols; ++i)
+    {
+      if (symbol_table[i]->flags == 0
+	  || (symbol_table[i]->flags & BSF_DEBUGGING)
+	  || (symbol_table[i]->flags & BSF_SECTION_SYM)
+	  || (symbol_table[i]->flags & BSF_WARNING)
+	  || (symbol_table[i]->flags & BSF_INDIRECT)
+	  || (symbol_table[i]->flags & BSF_FILE)
+	  || (symbol_table[i]->flags & BSF_DYNAMIC)
+	  || miscellaneous_deletable_symbol (symbol_table[i]->name)
+	  || excluded_symbol (symbol_table[i]->name))
+	{
+	  symbol_table[i] = 0;	/* Mark symbol for deletion. */
+	  number_deleted++;
+	}
+    }
+  qsort (symbol_table, number_of_symbols, sizeof (asymbol *),
+	 compare_symbols);
+
+#if 0
+  for (i = 0; i < number_of_symbols; ++i)
+    if (symbol_table[i])
+      printf ("    Symbol: %s. Value 0x%08X (%s) Section %s\n",
+	      symbol_table[i]->name,
+	      symbol_table[i]->value,
+	      symbol_table[i]->flags & BSF_GLOBAL ? "global" : "local",
+	      symbol_table[i]->section->name);
+    else
+      printf ("    <Deleted symbol>\n");
+#endif
+
+  number_of_symbols -= number_deleted;
+  if (number_of_symbols == 0)
+    goto end;
+
+  /* From this list of symbols, derive a list of objects. This is not as
+   * easy as it may seem. For a start, we can't generate pointers to
+   * static declarations in object files, because these symbols aren't
+   * exported. In that case, we use offsets to global symbols in the
+   * same segment. Also, symbols don't have explicit sizes, we have to
+   * guess the size from the position of the next object, or the size
+   * of the section.
+   */
+  {
+    long next_i, global_symbol_in_this_section = -1;
+    size_t size;
+
+    for (i = 0; i < number_of_symbols; i = next_i)
+      {
+	/* Set `next_i' to point to the next distinct symbol after the
+	 * current one, skipping symbols which point to the same address.
+	 */
+	next_i = i + 1;
+	while (next_i < number_of_symbols
+	       && symbol_table[next_i]->value == symbol_table[i]->value
+	       && symbol_table[next_i]->section == symbol_table[i]->section)
+	  next_i++;
+
+	/* Try to compute the size of this symbol. If the next symbol is
+	 * in the same section, then the size is simply the difference
+	 * between the two symbols. If the next symbol is not in the same
+	 * section, we must look at the size of the section itself.
+	 */
+	if (next_i < number_of_symbols
+	    && symbol_table[next_i]->section == symbol_table[i]->section)
+	  size = symbol_table[next_i]->value - symbol_table[i]->value;
+	else
+	  {
+	    long section_size
+	      = bfd_get_section_size_before_reloc (symbol_table[i]->section);
+	    if (section_size > symbol_table[i]->value)
+	      size = section_size - symbol_table[i]->value;
+	    else
+	      size = 1;
+	  }
+
+	/* If any of the symbols pointing to this address are global, then
+	 * they should have been sorted to the beginning, so `i' should
+	 * point to a global symbol if there is one.
+	 */
+	if (symbol_table[i]->flags & BSF_GLOBAL)
+	  {
+	    /* There is a global symbol: Generate a pointer to this
+	     * object directly.
+	     */
+	    write_symbol (filename, symbol_table[i]->name,
+			  symbol_table[i]->section->name,
+			  symbol_table[i]->name, 0, size);
+	    symbols_written++;
+	    global_symbol_in_this_section = i;
+	  }
+	else
+	  {
+	    /* There is no global symbol for this object: We can still attempt
+	     * to get a pointer to a global in the same section and use
+	     * an offset from that symbol. If there are no globals at all in
+	     * this section, print a warning and continue.
+	     */
+	    if (global_symbol_in_this_section >= 0
+		&& (symbol_table[global_symbol_in_this_section]->section
+		    == symbol_table[i]->section))
+	      {
+		write_symbol (filename, symbol_table[i]->name,
+			      symbol_table[i]->section->name,
+			      symbol_table[global_symbol_in_this_section]->
+			      name,
+			      symbol_table[i]->value -
+			      symbol_table[global_symbol_in_this_section]->
+			      value, size);
+		symbols_written++;
+	      }
+	    else
+	      {
+		long j;
+
+		global_symbol_in_this_section = -1;
+		for (j = next_i; j < number_of_symbols; ++j)
+		  if (symbol_table[j]->section == symbol_table[i]->section)
+		    {
+		      if (symbol_table[j]->flags & BSF_GLOBAL)
+			{
+			  global_symbol_in_this_section = j;
+			  break;
+			}
+		    }
+		  else
+		    break;
+		if (global_symbol_in_this_section >= 0)
+		  {
+		    write_symbol (filename, symbol_table[i]->name,
+				  symbol_table[i]->section->name,
+				  symbol_table
+				  [global_symbol_in_this_section]->name,
+				  symbol_table[i]->value -
+				  symbol_table
+				  [global_symbol_in_this_section]->value,
+				  size);
+		    symbols_written++;
+		  }
+		else
+		  {
+		    if (!quiet)
+		      fputc ('\n', stdout);
+		    printf
+		      ("Warning: Cannot generate a ref. to local symbol `%s' in file `%s'.\n",
+		       symbol_table[i]->name, filename);
+		  }
+	      }
+	  }
+      }
+  }
+
+end:
+  if (!quiet)
+    printf ("%d objects found.\n", symbols_written);
+}
+
+int
+compare_symbols (sym1_ptr, sym2_ptr)
+     asymbol **sym1_ptr, **sym2_ptr;
+{
+  asymbol *sym1 = *sym1_ptr;
+  asymbol *sym2 = *sym2_ptr;
+
+  if (sym1 != 0 && sym2 != 0)
+    {
+      /* Order symbols according to their section, then according to their
+       * value. If they have the same section and value, we favour placing
+       * global references before local ones.
+       * Notice that we simple use the section pointers to order the
+       * sections: it doesn't actually matter if `.data' comes before
+       * or after `.text', etc.
+       */
+      if (sym1->section != sym2->section)
+	return sym1->section - sym2->section;
+      else if (sym1->value != sym2->value)
+	return sym1->value - sym2->value;
+      else if (sym1->flags & BSF_GLOBAL)
+	return -1;
+      else
+	return 1;
+    }
+  else if (sym1 != 0)		/* Deleted symbols migrate to the end. */
+    return -1;
+  else
+    return 1;
+}
+
+int
+miscellaneous_deletable_symbol (name)
+     CONST char *name;
+{
+  /* Delete certain symbols which may cause problems because they are
+   * built into GCC or they don't really exist.
+   */
+  if (strncmp (name, "__builtin_", 10) == 0
+      || strcmp (name, "sccsid") == 0
+      || strcmp (name, "rcsid") == 0
+      || ((strncmp (name, "__CTOR_", 7) == 0
+	   || strncmp (name, "__DTOR_", 7) == 0)
+	  &&
+	  (strcmp (name + 7, "LIST__") == 0
+	   || strcmp (name + 7, "END__") == 0)))
+    return 1;
+  else
+    return 0;
+}
+
+/*----------------------------------------------------------------------*/
+
+/* A primitive hash table that lists symbols which the user wants excluded
+ * from the output. We hash on the first letter of the symbol.
+ */
+static struct
+{
+  int nr_symbols;
+  CONST char **symbols;
+} hash_table[256];
+
+static int some_excluded_symbols = 0;
+
+int
+add_excluded_symbols (argv)
+     CONST char *argv[];
+{
+  int i;
+
+  if (!some_excluded_symbols)
+    {
+      memset (hash_table, 0, sizeof hash_table);
+      some_excluded_symbols = 1;
+    }
+  for (i = 0; argv[i] != NULL && (argv[i][0] != '-' || argv[i][1] != '-');
+       ++i)
+    {
+      /* Append this symbol to the end of the current hash table list.
+       */
+      int c = argv[i][0], new_size;
+
+      hash_table[c].nr_symbols++;
+      new_size = hash_table[c].nr_symbols * sizeof (char *);
+      if (hash_table[c].symbols != NULL)
+	hash_table[c].symbols = realloc (hash_table[c].symbols, new_size);
+      else
+	hash_table[c].symbols = malloc (new_size);
+      if (hash_table[c].symbols == NULL)
+	{
+	  perror ("malloc");
+	  exit (1);
+	}
+      hash_table[c].symbols[hash_table[c].nr_symbols - 1] = argv[i];
+    }
+
+  if (i == 0)			/* no symbols defined */
+    usage ();
+
+  return i;
+}
+
+/* Test to see if `name' is in the list of excluded symbols provided by
+ * the user.
+ */
+
+int
+excluded_symbol (name)
+     CONST char *name;
+{
+  int c, i;
+
+  if (!some_excluded_symbols)
+    return 0;
+  c = name[0];
+  for (i = 0; i < hash_table[c].nr_symbols; ++i)
+    if (strcmp (hash_table[c].symbols[i], name) == 0)
+      return 1;
+  return 0;
+}
+
+/*----------------------------------------------------------------------*/
+
+char *prologue = "\
+/* CAUTION: Automatically generated file. Edits will be lost!\n\
+ *--\n\
+ * Initialization code for objects in the file `%s'.\n\
+ * Link this file with programs that use this library or object file so\n\
+ * that they can check objects declared in this file correctly.\n\
+ */\n\
+\n\
+typedef unsigned long size_t; /* FIXME - can't include `stdio.h' */\n\
+\n\
+/* The following table format is shared with `lib/bounds-lib.h' too.\n\
+ */\n\
+typedef struct {\n\
+  void *address;			/* Object address */\n\
+  size_t size;				/* Size (bytes) */\n\
+  size_t align;				/* Alignment */\n\
+  char *filename;			/* Filename where found */\n\
+  int line;				/* Line where found */\n\
+  char *name;				/* Name of object */\n\
+} external_statics_table;\n\
+\n\
+void __bounds_add_static_objects_table (external_statics_table *);\n\
+\n\
+/* Ensure that `init' gets called automatically at run time.\n\
+ */\n\
+static void init (void) __attribute__((constructor));\n\
+\n\
+";
+
+char *epilogue = "\
+/* Constructor function that stuffs the above table into the checking\n\
+ * library's splay tree.\n\
+ */\n\
+static void\n\
+init (void)\n\
+{\n\
+  __bounds_add_static_objects_table (table);\n\
+}\n\
+\n\
+/* EOF */\n\
+";
+
+void
+open_output_file (filename, title)
+     CONST char *filename, *title;
+{
+  output_file = fopen (filename, "w");
+  if (output_file == NULL)
+    do_error ("fopen");
+
+  fprintf (output_file, prologue, title);
+}
+
+void
+close_output_file (title)
+     CONST char *title;
+{
+  write_table ();
+  fprintf (output_file, epilogue, title);
+  fclose (output_file);
+}
+
+static struct _table
+{
+  struct _table *next;
+  CONST char *filename, *real_name, *section_name, *address_name;
+  long address_offset;
+  size_t size;
+} *hd_table = NULL, *end_table = NULL;
+
+void
+write_symbol (filename, real_name, section_name, address_name, address_offset,
+	      size)
+     CONST char *filename;	/* Object file where this was found. */
+     CONST char *real_name;	/* Name of this symbol (may be static). */
+     CONST char *section_name;	/* Name of section where symbol found. */
+     CONST char *address_name;	/* Name of symbol used to get address. */
+     long address_offset;	/* Optional offset to `address_name'. */
+     size_t size;		/* Size of the symbol. */
+{
+  struct _table *p = malloc (sizeof (struct _table));
+  if (p == NULL)
+    do_error ("malloc");
+
+  if (hd_table == NULL)
+    hd_table = end_table = p;
+  else
+    {
+      end_table->next = p;
+      end_table = p;
+    }
+
+  p->next = NULL;
+  p->filename = filename;
+  p->real_name = real_name;
+  p->section_name = section_name;
+  p->address_name = address_name;
+  p->address_offset = address_offset;
+  p->size = size;
+
+  fprintf (output_file, "extern char %s;\n", address_name);
+}
+
+void
+write_table ()
+{
+  struct _table *p;
+
+  fprintf (output_file, "\n" "static external_statics_table table[] = {\n");
+
+  for (p = hd_table; p != NULL; p = p->next)
+    {
+      fprintf (output_file, "  { ");
+      if (p->address_offset == 0)
+	fprintf (output_file, "&%s, ", p->address_name);
+      else
+	fprintf (output_file, "(void *)((unsigned)&%s %c %ld), ",
+		 p->address_name,
+		 p->address_offset >= 0 ? '+' : '-',
+		 p->address_offset >= 0
+		 ? p->address_offset : -(p->address_offset));
+      fprintf (output_file,
+	       "%u, 1, \"%s\", 0, \"%s\" },\n",
+	       p->size, p->filename, p->real_name);
+    }
+  fprintf (output_file, "  { 0 }\n};\n\n");
+}
+
+void
+do_bfd_error (msg)
+     CONST char *msg;
+{
+  perror (msg);
+  exit (1);
+}
+
+void
+do_error (msg)
+     CONST char *msg;
+{
+  perror (msg);
+  exit (1);
+}
+
+void
+usage ()
+{
+  fprintf (stderr,
+	   "find-objects: Find position and sizes of the objects in a library or `.o' file\n"
+	   "Usage: find-objects [--flags] <input-file> <c-output-file>\n"
+	   "Flags:\n"
+	   "  --quiet                           Run quietly.\n"
+	   "  --exclude symbol [symbol [...]]   Don't list symbols.\n");
+  exit (1);
+}
+
+#if defined(linux)
+
+/* Dummies for `libbfd' on this machine.
+ */
+void
+hex_init (void)
+{
+  printf ("hex_init called\n");
+}
+
+void
+_hex_value (void)
+{
+  printf ("hex_value called\n");
+}
+
+#endif
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tools/grab-statics.in gcc-4.0.2/gcc/bounds/tools/grab-statics.in
--- gcc-4.0.2.org/gcc/bounds/tools/grab-statics.in	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tools/grab-statics.in	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,72 @@
+#!/bin/sh -
+
+# @w@
+#
+#	Grab the statics in a library or object file. Write them to
+#	a object file with a standard name, that you can then link
+#	with your programs to ensure more reliable checking of
+#	such objects.
+#
+#	Written by Richard W.M. Jones.
+#
+#	Usage:	grab-statics libfile [libfile ...]
+#
+#	Examples:
+#		grab-statics /lib/libc.a /lib/libm.a
+#		grab-statics unchecked1.o
+#		grab-statics libstuff.a
+
+tools_dir=@tools_dir@
+lib_dir=@lib_dir@
+output_dir=@output_dir@
+gcc=@gcc@
+gcc_flags='@gcc_flags@'
+
+# If you want `find-objects' to run quietly, then swap the following comments.
+#quietflag='--quiet'
+quietflag=
+
+#----------------------------------------------------------------------
+# Check arguments.
+
+if [ $# -lt 1 ]; then
+	echo 'Usage: grab-statics libfile [libfile ...]'
+	echo '  where "libfile" is a library archive or object file'
+	exit
+fi
+
+#----------------------------------------------------------------------
+# Exclude symbols in libcheck.a and libgcc.a.
+# The reason is that these may take precedence over symbols in the C
+# library. We would end up with a pointer to a symbol in libcheck.a, but
+# with the size of the symbol in the C library.
+# We need a cleaner way to do this. Perhaps reading the final non-
+# stripped executable is a better approach.
+
+excludelist=`
+(for f in $lib_dir/libcheck.a $lib_dir/libgcc.a; do
+	nm $f | egrep -v '^$|\.o:$|^[ \t]*U ' | awk '{print $3}'
+done) | sort -u`
+
+#----------------------------------------------------------------------
+#
+
+for f in $*; do
+	echo "$f:"
+	tempfile=/tmp/statics-temp-`basename $f`.c
+	outputfile=$output_dir/statics-`basename $f`.o
+	$tools_dir/find-objects \
+		--exclude $excludelist $quietflag -- \
+		$f $tempfile
+	if [ $? -eq 0 ]; then
+		$gcc $gcc_flags -c $tempfile -o $outputfile
+		if [ $? -eq 0 ]; then
+			echo "Created $outputfile"
+		else
+			echo "grab-statics [$outputfile]: *** error ***"
+		fi
+	else
+		echo "grab-statics [$tempfile]: *** error ***"
+	fi
+	rm -f $tempfile
+done
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tools/Makefile gcc-4.0.2/gcc/bounds/tools/Makefile
--- gcc-4.0.2.org/gcc/bounds/tools/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tools/Makefile	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,62 @@
+# *----------------------------------------------------------------------*
+# * Bounds Checking for GCC.						 *
+# * Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.	 *
+# *----------------------------------------------------------------------*
+# * This program is free software; you can redistribute it and/or modify *
+# * it under the terms of the GNU General Public License as published by *
+# * the Free Software Foundation; either version 2 of the License, or	 *
+# * (at your option) any later version.					 *
+# *									 *
+# * This program is distributed in the hope that it will be useful,	 *
+# * but WITHOUT ANY WARRANTY; without even the implied warranty of	 *
+# * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	 *
+# * GNU General Public License for more details.			 *
+# *									 *
+# * You should have received a copy of the GNU General Public License	 *
+# * along with this program; if not, write to the Free Software		 *
+# * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.		 *
+# *----------------------------------------------------------------------*
+# * File:
+# *	tools/Makefile
+# * Summary:
+# *	See README file.
+# * Other notes:
+# *	
+# * Author      	Date		Notes
+# * 
+# *----------------------------------------------------------------------*
+
+CC	= ../../xgcc
+CFLAGS	= -Wall -O -B../../
+
+SHELL	= /bin/sh
+
+# You will need the `BFD' library which is commonly distributed with Gnu
+# GDB, or you may have it installed already. Place the line needed to link
+# it here:
+BFD_LIB	= -lbfd -liberty
+
+all:	grab-statics
+
+distclean: clean
+
+clean:
+	rm -f find-objects string-subst grab-statics *.o *~ *.bak *.BAK core \
+		statics-*.o
+
+grab-statics: grab-statics.in string-subst find-objects
+	cat grab-statics.in | \
+		./string-subst @w@ 'Caution! This file is automatically generated. Edits will be lost!' | \
+		./string-subst @tools_dir@ `pwd` | \
+		./string-subst @output_dir@ `pwd` | \
+		./string-subst @lib_dir@ `cd ../..; pwd` | \
+		./string-subst @gcc@ `cd ../..; pwd`/xgcc | \
+		./string-subst @gcc_flags@ "-B`cd ../..; pwd`/ -fno-builtin -g" \
+			> grab-statics
+	chmod 0755 grab-statics
+
+string-subst: string-subst.o
+	$(CC) $(CFLAGS) $< -o $@
+
+find-objects: find-objects.o
+	$(CC) $(CFLAGS) $< $(BFD_LIB) -o $@
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tools/pack-up gcc-4.0.2/gcc/bounds/tools/pack-up
--- gcc-4.0.2.org/gcc/bounds/tools/pack-up	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tools/pack-up	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,126 @@
+#!/bin/sh -
+
+#	Create a tar file containing the extra files required by
+#	bounds checking & the diffs to the main sources.
+#	By Richard W.M. Jones.
+
+# GCC directories.
+# Assume:
+#  GCC in $HOME/$GCC
+#  original GCC in $HOME/GCC_ORIG
+
+GCC=gcc-2.7.2
+GCC_ORIG=gcc-2.7.2-orig
+
+# Place to put the packed file.
+
+INST_DIR=$HOME
+
+# Final tar file name. Contains the GCC and BC version numbers.
+
+TARFILE=bounds-checking-2.7.2-1.02.tgz
+
+# Files and directories that are not in the GCC distribution go here.
+
+EXTRA_FILES="c-bounds.c c-bounds.h cp/bounds.c bounds"
+
+# Files that have been changed in bounds checking GCC.
+
+CHANGED_FILES="\
+	c-common.c\
+	c-decl.c\
+	c-lang.c\
+	c-parse.in\
+	c-tree.h\
+	c-typeck.c\
+	calls.c\
+	extend.texi\
+	flags.h\
+	fold-const.c\
+	function.c\
+	gcc.1\
+        gcc.c\
+        ginclude/stdarg.h\
+        ginclude/va-alpha.h\
+        ginclude/va-clipper.h\
+        ginclude/va-h8300.h\
+        ginclude/va-i860.h\
+        ginclude/va-i960.h\
+        ginclude/va-m88k.h\
+        ginclude/va-mips.h\
+        ginclude/va-pa.h\
+        ginclude/va-ppc.h\
+        ginclude/va-pyr.h\
+        ginclude/va-sparc.h\
+        ginclude/va-spur.h\
+        ginclude/varargs.h\
+	invoke.texi\
+	libgcc2.c\
+	optabs.c\
+	print-tree.c\
+	stmt.c\
+	toplev.c\
+	varasm.c\
+	Makefile.in\
+	cp/Makefile.in"
+
+#-----
+
+# Some programs you may like to change.
+
+TAR="tar"
+GZIP="gzip"
+DIFF="diff"
+ECHO="echo"
+MAKE="make"
+RM="rm -f"
+LS="ls -l"
+
+#-----
+
+cd $HOME/$GCC
+
+# We need to make GCC (so we can make the test results files).
+
+$MAKE
+
+# Pack up the diffs into one file ...
+
+cd $HOME
+
+$RM $GCC/bounds-checking.diff
+$ECHO -n "Packing up diffs:"
+for f in $CHANGED_FILES; do
+	$ECHO -n " $f"
+	$DIFF -c $GCC_ORIG/$f $GCC/$f >> $GCC/bounds-checking.diff
+done
+
+cd $HOME/$GCC
+
+$ECHO; $LS bounds-checking.diff
+
+$ECHO "---------- Making bounds/lib clean. ----------"
+(cd bounds/lib; $MAKE srcdir=$HOME/$GCC distclean)
+
+$ECHO "---------- Making bounds/tests clean and creating results files. ----------"
+(cd bounds/tests; $MAKE results; $MAKE distclean)
+
+$ECHO "---------- Making bounds/tools clean. ----------"
+(cd bounds/tools; $MAKE distclean)
+
+$ECHO "---------- Cleaning up bounds/ and subdirectories. ----------"
+for d in `find bounds -type d -print`; do
+	(cd $d; $RM *~ *.BAK *.bak core *.o *.orig *.rej *.old)
+done
+
+$ECHO "---------- Packing up tar file. ----------"
+tarfiles="$GCC/bounds-checking.diff"
+for f in $EXTRA_FILES; do
+  tarfiles="$tarfiles $GCC/$f"
+done
+cd $HOME
+$TAR cf - $tarfiles | $GZIP > $INST_DIR/$TARFILE
+cd $HOME/$GCC
+
+$ECHO "---------- Result file: ----------"
+$LS $INST_DIR/$TARFILE
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tools/pack-up-bin gcc-4.0.2/gcc/bounds/tools/pack-up-bin
--- gcc-4.0.2.org/gcc/bounds/tools/pack-up-bin	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tools/pack-up-bin	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,87 @@
+#!/bin/sh -
+
+#	Create a tar file containing the binaries for bounds checking GCC.
+#	By Richard W.M. Jones.
+
+# GCC directories.
+# Assume GCC is in $HOME.
+
+GCC=gcc-2.7.2
+cd $HOME/$GCC
+
+# Place to put the packed file.
+
+INST_DIR=$HOME
+
+# Final tar file name. This must contain the GCC and BC version numbers, and
+# the target name.
+
+TARFILE=bounds-checking-2.7.2-1.02-binary-i486-unknown-linux.tgz
+
+# The list of files that we need to pack up (excluding gcc.info* files).
+# The `crt*.o' files are needed by Solaris, but not, apparently, by other
+# machines, so ignore warnings from tar for these.
+
+FILES="bounds cc1 cpp crt1.o crtbegin.o crtend.o crti.o crtn.o \
+ include libgcc.a libcheck.a specs xgcc README.gcc-bin"
+
+# Use `gtar' on systems where tar is broken. Use `gmake' if necessary on
+# your system.
+
+TAR="tar"
+MAKE="make"
+GZIP="gzip"
+CAT="cat"
+ECHO="echo"
+RM="rm -f"
+LS="ls -l"
+
+#-----
+
+$MAKE; $MAKE doc
+
+# Make the README file
+
+$CAT > README.gcc-bin << __END__
+
+This is the binary distribution
+	$TARFILE
+
+Please consult the README file (in bounds/ subdir.) for details about how
+to run this GCC.
+
+RWMJ - 17/10/95.
+
+__END__
+
+#$ECHO "---------- Making bounds/lib clean. ----------"
+#(cd bounds/lib; $MAKE distclean)
+
+$ECHO "---------- Making results files in bounds/tests. ----------"
+(cd bounds/tests; $MAKE results)
+
+#$ECHO "---------- Making bounds/tools clean. ----------"
+#(cd bounds/tools; $MAKE distclean)
+
+$ECHO "---------- Cleaning up bounds/ and subdirectories. ----------"
+for d in `find bounds -type d -print`; do
+  (cd $d; $RM *~ *.BAK *.bak core *.orig *.rej *.old)
+done
+
+$ECHO "---------- Packing up tar file. ----------"
+tarfiles=""
+for f in gcc.info*; do
+  tarfiles="$tarfiles $GCC/$f"
+done
+for f in $FILES; do
+  if [ -f $f -o -d $f ]; then
+    tarfiles="$tarfiles $GCC/$f"
+  fi
+done
+cd $HOME
+$TAR chf - $tarfiles | $GZIP > $INST_DIR/$TARFILE
+cd $HOME/$GCC
+$RM README.gcc-bin
+
+$ECHO "---------- Result file: ----------"
+$LS $INST_DIR/$TARFILE
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tools/README gcc-4.0.2/gcc/bounds/tools/README
--- gcc-4.0.2.org/gcc/bounds/tools/README	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tools/README	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,93 @@
+	TOOLS subdirectory
+	------------------
+
+`grab-statics'
+--------------
+
+If you wish to use unchecked source files and libraries, you can still check
+variables declared in those files using the `grab-statics' script. This looks
+through the unchecked files and extracts the variables into another file
+in a form that the bounds checking library can read at run time.
+
+To use, simply give `grab-statics' a list of object files and library
+archives, and it will make an object (.o) file that you can link with
+your program.
+
+Examples:
+
+	% grab-statics /lib/libc.a
+
+	- Create a list of statics in `statics-libc.a.o'
+
+	% grab-statics /usr/X11R6/lib/libX11.a unchecked.o
+
+	- Create two lists in `statics-libX11.a.o' and `statics-unchecked.o.o'
+
+Assuming your program uses libc, libX11 and unchecked.o, you could link your
+program with the following line at run-time:
+
+	% gcc -fbounds-checking check1.o check2.o unchecked.o \
+		statics-libX11.a.o statics-unchecked.o.o statics-libc.a.o \
+		-L/usr/X11R6/lib -lX11 -o prog
+
+Run the program with unchecked warnings turned on, eg.
+
+sh	% GCC_BOUNDS_OPTS='-warn-unchecked-statics' prog
+csh	% setenv GCC_BOUNDS_OPTS '-warn-unchecked-statics'; prog
+
+Installing `grab-statics'
+-------------------------
+
+`grab-statics' is a shell script that uses the program `find-objects.c' to
+do the hard work. This in turn uses Gnu's BFD library to read object files
+and library archives. BFD is not supplied with these patches, you will need
+to download it separately. It is usually distributed with GDB, so one place
+you could get it is:
+
+	ftp://sunsite.doc.ic.ac.uk/gnu/gdb-4.14.tar.gz
+
+Some systems, such as Linux, may come with it preinstalled. Look for
+`libbfd*' in /usr/lib.
+
+To make the program, do:
+
+	% cd bounds/tools
+	% make grab-statics
+
+I usually run the program in-place, so there is no `make install' as such.
+Look at the beginning of the `grab-statics' script if you want to install
+it somewhere intelligent. There are some directories hardwired there that
+you may need to change. If anyone has ideas about where this ought to be
+installed, mail me.
+
+Bugs & limitations with `grab-statics'
+--------------------------------------
+
+You have to link your binaries statically if you want to use `grab-statics'.
+If someone can approach me with a coherent explanation of how DLL jumptables
+and indirections work, I can probably make it work with dynamic linking too.
+
+You can, in theory, do:
+	grab-statics /lib/libc.so.5
+but in practice this doesn't seem to work (on Linux). I don't know enough about
+how DLLs work so we can do this. Use static linking for now.
+
+It doesn't deal with multiple symbols in different libraries with the same
+name very intelligently. So suppose you have `ctime' in your C library, and
+you've redefined it in your own code. Then you will get `ctime' marked as
+an unchecked object with a pointer to your own `ctime', but with the size
+of the `ctime' in the C lib. To get round this at the moment, you need to
+hack `grab-statics.in' to include `ctime' in the list of excluded symbols.
+
+Only tested under Linux/ELF at the moment. Your mileage may (will) vary.
+
+No `make install' rule yet.
+
+You need Gnu BFD.
+
+`pack-up' and `pack-up-bin'
+---------------------------
+
+These are tools that I use to make the final source & binary distributions.
+You don't need to touch these, unless you want to be really kind & send
+me a binary that works on your machine.
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/tools/string-subst.c gcc-4.0.2/gcc/bounds/tools/string-subst.c
--- gcc-4.0.2.org/gcc/bounds/tools/string-subst.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/tools/string-subst.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,56 @@
+/*	Substitute one string with another in input.
+ *	Public domain.
+ */
+
+#include <stdio.h>
+
+int
+main (argc, argv)
+     int argc;
+     char *argv[];
+{
+  int i, c, posn = 0, in_string = 0;
+  char *find;
+  char *replace;
+
+  if (argc != 3)
+    {
+      fprintf (stderr, "string-subst <find> <replace>\n");
+      exit (1);
+    }
+  find = argv[1];
+  replace = argv[2];
+  while ((c = getchar ()) != EOF)
+    {
+    again:
+      if (in_string == 0)
+	{
+	  if (c == find[0])
+	    {
+	      in_string = 1;
+	      posn = 1;
+	    }
+	  else
+	    fputc (c, stdout);
+	}
+      else			/* in_string == 1 */
+	{
+	  if (find[posn] == 0)
+	    {
+	      in_string = 0;
+	      fputs (replace, stdout);
+	      goto again;
+	    }
+	  else if (c != find[posn])
+	    {
+	      in_string = 0;
+	      for (i = 0; i < posn; ++i)
+		fputc (find[i], stdout);
+	      goto again;
+	    }
+	  else
+	    posn++;
+	}
+    }
+  exit (0);
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/treestats/Makefile gcc-4.0.2/gcc/bounds/treestats/Makefile
--- gcc-4.0.2.org/gcc/bounds/treestats/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/treestats/Makefile	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,43 @@
+#	Makefile for:
+#	------------------------------------------------------------
+#	Various programs to process splay tree statistics files.
+#	By Richard W.M. Jones.
+#	------------------------------------------------------------
+
+SHELL	= /bin/sh
+
+CC	= gcc
+CFLAGS	= -g -O -Wall -I. -I../lib
+HEADERS	= readfile.h misc.h ../ext-tree.h ../objects.h
+
+LIBOBJS	= readfile.o misc.o
+ST_A_OBJS = st-analyze.o
+ST_L_OBJS = st-locality.o
+ST_G_OBJS = st-graph.o
+MT_G_OBJS = mount-graphs.o
+OBJS	= $(ST_A_OBJS) $(ST_L_OBJS) $(ST_G_OBJS) $(MT_G_OBJS) $(LIBOBJS)
+PROGS	= st-analyze st-locality st-graph mount-graphs
+
+LIBS	= -lm
+
+all: lib $(PROGS)
+
+clean:
+	rm -f $(PROGS) $(OBJS)
+
+lib: $(LIBOBJS)
+
+st-analyze: $(ST_A_OBJS) $(LIBOBJS)
+	$(CC) $(CFLAGS) $(ST_A_OBJS) $(LIBOBJS) $(LIBS) -o $@
+
+st-locality: $(ST_L_OBJS) $(LIBOBJS)
+	$(CC) $(CFLAGS) $(ST_L_OBJS) $(LIBOBJS) $(LIBS) -o $@
+
+st-graph: $(ST_G_OBJS) $(LIBOBJS)
+	$(CC) $(CFLAGS) $(ST_G_OBJS) $(LIBOBJS) $(LIBS) -o $@
+
+mount-graphs: $(MT_G_OBJS) $(LIBOBJS)
+	$(CC) $(CFLAGS) $(MT_G_OBJS) $(LIBOBJS) $(LIBS) -o $@
+
+.c.o: $(HEADERS)
+	$(CC) $(CFLAGS) -c $< -o $@
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/treestats/misc.c gcc-4.0.2/gcc/bounds/treestats/misc.c
--- gcc-4.0.2.org/gcc/bounds/treestats/misc.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/treestats/misc.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,130 @@
+/*----------------------------------------------------------------------*
+ * Bounds Checking for GCC.						*
+ * Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.	*
+ *----------------------------------------------------------------------*
+ * This program is free software; you can redistribute it and/or modify	*
+ * it under the terms of the GNU General Public License as published by	*
+ * the Free Software Foundation; either version 2 of the License, or	*
+ * (at your option) any later version.					*
+ *									*
+ * This program is distributed in the hope that it will be useful,	*
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of	*
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	*
+ * GNU General Public License for more details.				*
+ *									*
+ * You should have received a copy of the GNU General Public License	*
+ * along with this program; if not, write to the Free Software		*
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.		*
+ *----------------------------------------------------------------------*
+ * File:
+ *	treestats/misc.c
+ * Summary:
+ *	Miscellaneous functions to deal with the splay tree in memory.
+ * Other notes:
+ *	
+ * Author      	Date		Notes
+ * RWMJ		28/5/95		Initial implementation.
+ *----------------------------------------------------------------------*/
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "misc.h"
+
+/* Delete a tree recursively. */
+
+void
+deltree (tree * t)
+{
+  object *n;
+
+  n = t->root;
+  delsubtree (n);
+  free (t);
+}
+
+/* Delete a subtree recursively. */
+
+void
+delsubtree (object * n)
+{
+  if (n == NULL)
+    return;
+  if (n->left)
+    delsubtree (n->left);
+  if (n->right)
+    delsubtree (n->right);
+  free (n);
+}
+
+/* Count number of nodes in a tree. */
+
+int
+counttree (tree * t)
+{
+  return countsubtree (t->root);
+}
+
+/* Count number of nodes in a subtree. */
+
+int
+countsubtree (object * n)
+{
+  if (n == NULL)
+    return 0;
+  else
+    return countsubtree (n->left) + countsubtree (n->right) + 1;
+}
+
+/* Count the number of hits received by the whole tree. */
+
+int
+counttreehits (tree * t)
+{
+  return countsubtreehits (t->root);
+}
+
+/* Count the number of hits received by a particular subtree. */
+
+int
+countsubtreehits (object * n)
+{
+  if (n == NULL)
+    return 0;
+  else
+    return countsubtreehits (n->left) + countsubtreehits (n->right) + n->hits;
+}
+
+/* Calculate a measure of balance on the tree. The argument is a percentage
+ * and we search the tree breadthfirst until we pass more than this percent
+ * of the nodes.
+ */
+
+static int atdepth (object *, int);
+
+int
+calcbalance (tree * t, int pc)
+{
+  int count = pc * counttree (t) / 100;
+  int sum = 0;
+  int depth;
+
+  for (depth = 0; sum < count; depth++)
+    sum += atdepth (t->root, depth);
+
+  return depth;
+}
+
+static int
+atdepth (object * n, int d)
+{
+  /* Return # of nodes that are at depth `d' in subtree `n'. The root node
+   * is at depth 0.
+   */
+  if (n == NULL && d > 0)
+    return 0;
+  else if (d == 0)
+    return n != NULL;
+  else
+    return atdepth (n->left, d - 1) + atdepth (n->right, d - 1);
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/treestats/misc.h gcc-4.0.2/gcc/bounds/treestats/misc.h
--- gcc-4.0.2.org/gcc/bounds/treestats/misc.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/treestats/misc.h	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,28 @@
+/*----------------------------------------------------------------------*
+ *	Bounds Checking for GCC.					*
+ *	Written by Richard W.M. Jones.					*
+ *----------------------------------------------------------------------*
+ * File:
+ *	treestats/misc.h
+ * Summary:
+ *	Header file for miscellaneous functions.
+ * Other notes:
+ *	
+ * Author      	Date		Notes
+ * RWMJ		28/5/95		Initial implementation.
+ *----------------------------------------------------------------------*/
+
+#ifndef _MISC_H_
+#define _MISC_H_
+
+#include "objects.h"
+
+void deltree (tree *);
+void delsubtree (object *);
+int counttree (tree *);
+int countsubtree (object *);
+int calcbalance (tree *, int pc);
+int counttreehits (tree *);
+int countsubtreehits (object *);
+
+#endif /* _MISC_H_ */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/treestats/mount-graphs.c gcc-4.0.2/gcc/bounds/treestats/mount-graphs.c
--- gcc-4.0.2.org/gcc/bounds/treestats/mount-graphs.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/treestats/mount-graphs.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,148 @@
+/*----------------------------------------------------------------------*
+ * Bounds Checking for GCC.						*
+ * Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.	*
+ *----------------------------------------------------------------------*
+ * This program is free software; you can redistribute it and/or modify	*
+ * it under the terms of the GNU General Public License as published by	*
+ * the Free Software Foundation; either version 2 of the License, or	*
+ * (at your option) any later version.					*
+ *									*
+ * This program is distributed in the hope that it will be useful,	*
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of	*
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	*
+ * GNU General Public License for more details.				*
+ *									*
+ * You should have received a copy of the GNU General Public License	*
+ * along with this program; if not, write to the Free Software		*
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.		*
+ *----------------------------------------------------------------------*
+ * File:
+ *	treestats/mount-graphs.c
+ * Summary:
+ *	Mount tree images generated by st-graph.c into a single image.
+ * Other notes:
+ *	
+ * Author      	Date		Notes
+ * RWMJ		28/5/95		Initial implementation.
+ *----------------------------------------------------------------------*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <string.h>
+
+static int verbose = 0, N = 0;
+
+static void usage (void) __attribute__ ((noreturn));
+static void do_command (char *);
+
+int
+main (int argc, char *argv[])
+{
+  int i, Nx, Ny;
+  double x = 72, y = 72,
+    width = 8 * 72 - 144, height = 11 * 72 - 144, x_inc, y_inc, x_orig;
+  char *graphs[argc];
+  char command[2048];
+  char *outputfile = NULL;
+
+  if (argc < 3)
+    usage ();
+
+  Nx = atoi (argv[1]);
+
+  for (i = 2; i < argc; ++i)
+    {
+      if (argv[i][0] == '-')
+	{
+	  switch (argv[i][1])
+	    {
+	    case 'v':
+	      verbose = 1;
+	      break;
+	    case 'p':
+	      if (i >= argc - 4)
+		usage ();
+	      x = atoi (argv[++i]);
+	      y = atoi (argv[++i]);
+	      width = atoi (argv[++i]);
+	      height = atoi (argv[++i]);
+	      if (x < 0 || x >= width ||
+		  y < 0 || y >= height || width <= 0 || height <= 0)
+		usage ();
+	      break;
+	    case 'o':
+	      if (outputfile || i >= argc - 1)
+		usage ();
+	      outputfile = argv[++i];
+	      break;
+	    default:
+	      usage ();
+	    }
+	}
+      else
+	graphs[N++] = argv[i];
+    }
+
+  if (N == 0 || Nx <= 0)
+    usage ();
+  if (!outputfile)
+    outputfile = "output.ps";
+
+  unlink (outputfile);
+
+  Ny = N / Nx;
+  if (N % Nx > 0)
+    Ny++;
+
+  x_inc = width / Nx;
+  y_inc = height / Ny;
+  x_orig = x;
+  y += (Ny - 1) * y_inc;
+
+  for (i = 0; i < N; ++i)
+    {
+      sprintf (command, "st-graph -a -b -o %s -p %d %d %d %d %s",
+	       outputfile,
+	       (int) x, (int) y, (int) (x_inc * 0.9), (int) (y_inc * 0.9),
+	       graphs[i]);
+      do_command (command);
+      if (i % Nx < Nx - 1)
+	x += x_inc;
+      else
+	{
+	  x = x_orig;
+	  y -= y_inc;
+	}
+    }
+
+  exit (0);
+}
+
+static void
+do_command (char *cmd)
+{
+  int r;
+
+  if (verbose)
+    puts (cmd);
+  r = system (cmd);
+  if (r != 0)
+    exit (r);
+}
+
+static void
+usage (void)
+{
+  fprintf (stderr,
+	   "mount-graphs: Mount trees from st-graph into a single image.\n"
+	   "Usage:\n"
+	   "  mount-graphs wide [-options] [-o outputfile] dumpfile [dumpfile [...]]\n"
+	   "  where `wide' is number of images across page\n"
+	   "Options:\n"
+	   "  -o outputfile       Name file for resulting image (default: output.ps)\n"
+	   "  -p x y width height Specify size of resulting image\n"
+	   "  -v                  Echo commands before executing them\n");
+  exit (1);
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/treestats/readfile.c gcc-4.0.2/gcc/bounds/treestats/readfile.c
--- gcc-4.0.2.org/gcc/bounds/treestats/readfile.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/treestats/readfile.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,180 @@
+/*----------------------------------------------------------------------*
+ * Bounds Checking for GCC.						*
+ * Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.	*
+ *----------------------------------------------------------------------*
+ * This program is free software; you can redistribute it and/or modify	*
+ * it under the terms of the GNU General Public License as published by	*
+ * the Free Software Foundation; either version 2 of the License, or	*
+ * (at your option) any later version.					*
+ *									*
+ * This program is distributed in the hope that it will be useful,	*
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of	*
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	*
+ * GNU General Public License for more details.				*
+ *									*
+ * You should have received a copy of the GNU General Public License	*
+ * along with this program; if not, write to the Free Software		*
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.		*
+ *----------------------------------------------------------------------*
+ * File:
+ *	treestats/readfile.c
+ * Summary:
+ *	Read a particular splay tree dump file into memory.
+ * Other notes:
+ *	
+ * Author      	Date		Notes
+ * RWMJ		28/5/95		Initial implementation.
+ *----------------------------------------------------------------------*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <string.h>
+
+#include "ext-tree.h"
+#include "objects.h"
+#include "readfile.h"
+
+static int getsubtree (FILE *, object **);
+static int compressed;
+static void close_file (FILE *);
+static FILE *open_file (char *);
+
+int
+readfile (char *filename, tree ** t_return, struct ext_tree **et_return)
+{
+  FILE *fp;
+  struct ext_tree *et = malloc (sizeof (struct ext_tree));
+  tree *t = malloc (sizeof (tree));
+  object *root;
+
+  fp = open_file (filename);
+  if (fp == NULL)
+    {
+      fprintf (stderr, "readfile: error opening `%s'.\n", filename);
+      return -1;
+    }
+  if (fread (et, sizeof (struct ext_tree), 1, fp) != 1)
+    {
+      fprintf (stderr, "readfile: error reading header.\n");
+      close_file (fp);
+      return -1;
+    }
+  if (strcmp (et->magic, EXT_TREE_MAGIC) != 0)
+    {
+      fprintf (stderr, "readfile: dump file has incorrect magic number.\n");
+      close_file (fp);
+      return -1;
+    }
+
+  if (t_return != NULL)
+    {
+      if (getsubtree (fp, &root) != 0)
+	{
+	  close_file (fp);
+	  return -1;
+	}
+
+      t->root = root;
+      if (t_return)
+	*t_return = t;
+    }
+
+  if (et_return)
+    *et_return = et;
+
+  close_file (fp);
+  return 0;
+}
+
+static int
+getsubtree (FILE * fp, object ** obj_return)
+{
+  int present;
+
+  if (fread (&present, sizeof (int), 1, fp) != 1)
+    {
+      fprintf (stderr, "readfile: error reading `present' flag.\n");
+      return -1;
+    }
+
+  /* First word is a flag indicating whether this node is NULL or not.
+   */
+  if (present)
+    {
+      object *obj = malloc (sizeof (object));
+
+      if (fread (obj, sizeof (object), 1, fp) != 1)
+	{
+	  fprintf (stderr, "readfile: error reading tree node.\n");
+	  return -1;
+	}
+      if (getsubtree (fp, &(obj->left)) != 0
+	  || getsubtree (fp, &(obj->right)) != 0)
+	return -1;
+
+      /* Zero out entries that aren't actually present in the file.
+       */
+      obj->filename = obj->name = obj->alloca_function = 0;
+      obj->line = 0;
+
+      /* Connect up parent properly.
+       */
+      if (obj->left)
+	{
+	  obj->left->parent = obj;
+	  obj->left->left_of_parent = 1;
+	}
+      if (obj->right)
+	{
+	  obj->right->parent = obj;
+	  obj->right->left_of_parent = 0;
+	}
+
+      /* Return object with current parent unset. */
+      obj->parent = 0;
+
+      if (obj_return)
+	*obj_return = obj;
+    }
+  else
+    {
+      if (obj_return)
+	*obj_return = NULL;
+    }
+
+  return 0;
+}
+
+/* Open and close a file, even if it is compressed.
+ */
+static FILE *
+open_file (char *filename)
+{
+  char *t = strrchr (filename, '.');
+  char cmd[strlen (filename) + 64];
+
+  if (t != NULL &&
+      (strcmp (t, ".gz") == 0 ||
+       strcmp (t, ".Z") == 0 || strcmp (t, ".z") == 0))
+    {
+      compressed = 1;
+      sprintf (cmd, "zcat %s", filename);
+      return popen (cmd, "r");
+    }
+  else
+    {
+      compressed = 0;
+      return fopen (filename, "r");
+    }
+}
+
+static void
+close_file (FILE * fp)
+{
+  if (compressed)
+    pclose (fp);
+  else
+    fclose (fp);
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/treestats/readfile.h gcc-4.0.2/gcc/bounds/treestats/readfile.h
--- gcc-4.0.2.org/gcc/bounds/treestats/readfile.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/treestats/readfile.h	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,24 @@
+/*----------------------------------------------------------------------*
+ *	Bounds Checking for GCC.					*
+ *	Written by Richard W.M. Jones.					*
+ *----------------------------------------------------------------------*
+ * File:
+ *	treestats/readfile.h
+ * Summary:
+ *	Header for `readfile' subroutine.
+ * Other notes:
+ *	
+ * Author      	Date		Notes
+ * RWMJ		28/5/95		Initial implementation.
+ *----------------------------------------------------------------------*/
+
+#ifndef _READFILE_H_
+#define _READFILE_H_
+
+#include "ext-tree.h"
+#include "objects.h"
+
+/* Returns 0 on success, -1 on failure. */
+int readfile (char *filename, tree ** t_return, struct ext_tree **et_return);
+
+#endif /* _READFILE_H_ */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/treestats/README gcc-4.0.2/gcc/bounds/treestats/README
--- gcc-4.0.2.org/gcc/bounds/treestats/README	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/treestats/README	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,2 @@
+Various programs in this directory process the tree statistics produced
+when you set SPLAY_COUNT_OPERATIONS to 1 in `objects.c'.
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/treestats/st-analyze.c gcc-4.0.2/gcc/bounds/treestats/st-analyze.c
--- gcc-4.0.2.org/gcc/bounds/treestats/st-analyze.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/treestats/st-analyze.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,88 @@
+/*----------------------------------------------------------------------*
+ * Bounds Checking for GCC.						*
+ * Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.	*
+ *----------------------------------------------------------------------*
+ * This program is free software; you can redistribute it and/or modify	*
+ * it under the terms of the GNU General Public License as published by	*
+ * the Free Software Foundation; either version 2 of the License, or	*
+ * (at your option) any later version.					*
+ *									*
+ * This program is distributed in the hope that it will be useful,	*
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of	*
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	*
+ * GNU General Public License for more details.				*
+ *									*
+ * You should have received a copy of the GNU General Public License	*
+ * along with this program; if not, write to the Free Software		*
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.		*
+ *----------------------------------------------------------------------*
+ * File:
+ *	treestats/st-analyze.c
+ * Summary:
+ *	Do simple analysis on a list of splay tree dump files.
+ * Other notes:
+ *	Command line usage is `st-analyze [list of files ...]'
+ * Author      	Date		Notes
+ * RWMJ		28/5/95		Initial implementation.
+ *----------------------------------------------------------------------*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+
+#include "readfile.h"
+#include "misc.h"
+
+#define print_div(a,b) do {\
+  if ((b) != 0) printf ("%2.2g\t", (double)(a)/(b)); else printf ("*\t");\
+  } while (0)
+
+int
+main (int argc, char *argv[])
+{
+  int i;
+
+  if (argc < 2)
+    {
+      fprintf (stderr, "st-analyze dumpfile [dumpfile [...]]\n");
+      exit (1);
+    }
+  printf
+    ("INDEX\tLOOKUPS\tNLOOKUP\tADDS\tDELS\tSPLAYS\tCOUNT\tHITS\tALD\tANLD\tASD\tALSD\tAASD\tADSD\tDEP5\tDEP10\tDEP50\n");
+  for (i = 1; i < argc; ++i)
+    {
+      tree *t;
+      struct ext_tree *et;
+      int count, hits;
+      int depth50, depth10, depth5;
+
+      /* Read the file from disk. */
+      if (readfile (argv[i], &t, &et) == -1)
+	continue;
+
+      /* Print some simple data about this splay tree. */
+      count = counttree (t);
+      hits = counttreehits (t);
+      depth5 = calcbalance (t, 5);
+      depth10 = calcbalance (t, 10);
+      depth50 = calcbalance (t, 50);
+      printf ("%u\t%u\t%u\t%u\t%u\t%u\t%d\t%d\t",
+	      et->index,
+	      et->look_up_operations,
+	      et->nlook_up_operations,
+	      et->add_operations,
+	      et->del_operations, et->splay_operations, count, hits);
+      print_div (et->look_up_steps, et->look_up_operations);
+      print_div (et->nlook_up_steps, et->nlook_up_operations);
+      print_div (et->splay_steps, et->splay_operations);
+      print_div (et->splay_look_up_steps, et->splay_look_up_operations);
+      print_div (et->splay_add_steps, et->splay_add_operations);
+      print_div (et->splay_del_steps, et->splay_del_operations);
+      printf ("%d\t%d\t%d\t\n", depth5, depth10, depth50);
+
+      /* Clean up. */
+      deltree (t);
+    }
+
+  exit (0);
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/treestats/st-graph.c gcc-4.0.2/gcc/bounds/treestats/st-graph.c
--- gcc-4.0.2.org/gcc/bounds/treestats/st-graph.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/treestats/st-graph.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,294 @@
+/*----------------------------------------------------------------------*
+ * Bounds Checking for GCC.						*
+ * Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.	*
+ *----------------------------------------------------------------------*
+ * This program is free software; you can redistribute it and/or modify	*
+ * it under the terms of the GNU General Public License as published by	*
+ * the Free Software Foundation; either version 2 of the License, or	*
+ * (at your option) any later version.					*
+ *									*
+ * This program is distributed in the hope that it will be useful,	*
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of	*
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	*
+ * GNU General Public License for more details.				*
+ *									*
+ * You should have received a copy of the GNU General Public License	*
+ * along with this program; if not, write to the Free Software		*
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.		*
+ *----------------------------------------------------------------------*
+ * File:
+ *	treestats/st-graph.c
+ * Summary:
+ *	Draw the splay tree graphically with # hits marked at each node.
+ * Other notes:
+ *	
+ * Author      	Date		Notes
+ * RWMJ		28/5/95		Initial implementation.
+ *----------------------------------------------------------------------*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include "misc.h"
+#include "readfile.h"
+
+static void usage (void) __attribute__ ((noreturn));
+static void get_max_hits (object * n);
+static void draw (void);
+static void prologue (void);
+static void epilogue (void);
+static void draw_rect (double, double, double, double);
+
+static FILE *outfp;
+static tree *t;
+static struct ext_tree *et;
+static unsigned max_hits, max_radius;
+static int xpos = 0, ypos = 0, width = 0, height = 0;
+
+int
+main (int argc, char *argv[])
+{
+  int i;
+  char *inputfile = NULL, *outputfile = NULL;
+  int psize_set = 0, box = 0, append_mode = 0;
+
+  if (argc < 2)
+    usage ();
+
+  for (i = 1; i < argc; ++i)
+    {
+      if (argv[i][0] == '-')
+	{
+	  switch (argv[i][1])
+	    {
+	    case 'o':
+	      if (outputfile || i == argc - 1)
+		usage ();
+	      outputfile = argv[++i];
+	      break;
+	    case 'p':
+	      if (psize_set || i >= argc - 4)
+		usage ();
+	      psize_set = 1;
+	      xpos = atoi (argv[++i]);
+	      ypos = atoi (argv[++i]);
+	      width = atoi (argv[++i]);
+	      height = atoi (argv[++i]);
+	      break;
+	    case 'b':
+	      box = 1;
+	      break;
+	    case 'a':
+	      append_mode = 1;
+	      break;
+	    default:
+	      usage ();
+	    }
+	}
+      else
+	{
+	  if (inputfile)
+	    usage ();
+	  inputfile = argv[i];
+	}
+    }
+
+  if (outputfile == NULL)
+    outputfile = "output.ps";
+  if (inputfile == NULL)
+    usage ();
+  if (!psize_set)
+    {
+      /* Set paper to 8x11" default. */
+      xpos = 72;
+      ypos = 72;
+      width = 8 * 72 - 144;
+      height = 11 * 72 - 144;
+    }
+
+  max_radius = width / 17;
+
+  if (readfile (inputfile, &t, &et) == -1)
+    exit (1);
+
+  max_hits = 0;
+  get_max_hits (t->root);
+
+  if (!append_mode)
+    outfp = fopen (outputfile, "w");
+  else
+    outfp = fopen (outputfile, "a");
+  if (outfp == NULL)
+    {
+      perror ("st-graph: fopen");
+      exit (1);
+    }
+  prologue ();
+  if (box)
+    {
+      draw_rect (xpos, ypos, width, height);
+      xpos += width / 20;	/* Reduce size by 10% */
+      ypos += height / 20;
+      width -= width / 10;
+      height -= height / 10;
+    }
+  draw ();
+  epilogue ();
+  fclose (outfp);
+
+  exit (0);
+}
+
+static void
+usage (void)
+{
+  fprintf (stderr,
+	   "st-graph: Draw a splay tree from a dump file.\n"
+	   "Usage:\n"
+	   "  st-graph [options] [-o outputfile] inputfile\n"
+	   "Options:\n"
+	   "  -o outputfile       Output file name (default: output.ps)\n"
+	   "  -p x y width height Specify position on page (default: 8x11\")\n"
+	   "  -b                  Draw a box around the graph\n"
+	   "  -a                  Append to output file\n");
+  exit (1);
+}
+
+static void
+prologue (void)
+{
+  /* Write the standard PostScript prologue for the file.
+   */
+  char prologue[] =
+    "gsave\n"
+    "/line { newpath moveto lineto stroke } def\n"
+    "/node { newpath 0 360 arc fill } def\n";
+  fputs (prologue, outfp);
+}
+
+static void
+epilogue (void)
+{
+  /* Write the standard PostScript epilogue for the file.
+   */
+  char epilogue[] = "grestore\n";
+  fputs (epilogue, outfp);
+}
+
+static void draw_tree (object *, double, double, double, double,
+		       double *, double *);
+static void draw_line (double, double, double, double);
+static void draw_node (double, double, unsigned);
+
+#define SCALE 0.1
+
+static void
+draw (void)
+{
+  if (t->root)
+    draw_tree (t->root, xpos, ypos, width, height, NULL, NULL);
+  else
+    {
+      /* ... draw NULL root ... */
+    }
+}
+
+/* Draw the tree recursively here. We are allowed to use all the paper we
+ * want between coordinates (x,y) and (x+dx,y+dy). `n' is not NULL. Return
+ * the coordinates of the root of our subtree.
+ */
+static void
+draw_tree (object * n,
+	   double x, double y,
+	   double dx, double dy, double *nx_rtn, double *ny_rtn)
+{
+  double nx, ny;
+
+  /* Decide where to put the root node of this subtree. */
+  nx = x + dx / 2;
+  ny = y + (1 - SCALE / 2) * dy;
+
+  /* Return the root node, if required. */
+  if (nx_rtn)
+    *nx_rtn = nx;
+  if (ny_rtn)
+    *ny_rtn = ny;
+
+  /* If the left subtree exists, draw it first. */
+  if (n->left)
+    {
+      double nx_left, ny_left;
+
+      draw_tree (n->left, x, y, dx / 2, (1 - SCALE) * dy, &nx_left, &ny_left);
+
+      /* Join left node to current node. */
+      draw_line (nx, ny, nx_left, ny_left);
+    }
+  else
+    {
+      /* Draw NULL left node. */
+      /* ... */
+    }
+
+  /* Same for right subtree. */
+  if (n->right)
+    {
+      double nx_right, ny_right;
+
+      draw_tree (n->right, x + dx / 2, y, dx / 2, (1 - SCALE) * dy,
+		 &nx_right, &ny_right);
+
+      /* Join right node to current node. */
+      draw_line (nx, ny, nx_right, ny_right);
+    }
+  else
+    {
+      /* Draw NULL right node. */
+      /* ... */
+    }
+
+  /* Draw current node. */
+  draw_node (nx, ny, n->hits);
+}
+
+static void
+draw_line (double x1, double y1, double x2, double y2)
+{
+  /* Draw a line between (x1,y1) and (x2,y2). */
+  fprintf (outfp, "%g %g %g %g line\n", x1, y1, x2, y2);
+}
+
+static void
+draw_node (double x, double y, unsigned hits)
+{
+  /* Draw a node at (x,y), weighted by `hits'. */
+  double rad;
+
+  if (hits == 0)
+    return;			/* Don't draw it if it's unused. */
+  rad = max_radius * (double) hits / max_hits;
+  if (rad < 0.1)
+    return;			/* Too small to draw. */
+  fprintf (outfp, "%g %g %g node\n", x, y, rad);
+}
+
+static void
+draw_rect (double x, double y, double width, double height)
+{
+  fprintf (outfp, "%g %g %g %g rectstroke\n", x, y, width, height);
+}
+
+static void
+get_max_hits (object * n)
+{
+  /* Search the tree for the node with the maximum number of hits, and
+   * record this number.
+   */
+  if (n == NULL)
+    return;
+  if (n->hits > max_hits)
+    max_hits = n->hits;
+  get_max_hits (n->left);
+  get_max_hits (n->right);
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/treestats/st-locality.c gcc-4.0.2/gcc/bounds/treestats/st-locality.c
--- gcc-4.0.2.org/gcc/bounds/treestats/st-locality.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/treestats/st-locality.c	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,181 @@
+/*----------------------------------------------------------------------*
+ * Bounds Checking for GCC.						*
+ * Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.	*
+ *----------------------------------------------------------------------*
+ * This program is free software; you can redistribute it and/or modify	*
+ * it under the terms of the GNU General Public License as published by	*
+ * the Free Software Foundation; either version 2 of the License, or	*
+ * (at your option) any later version.					*
+ *									*
+ * This program is distributed in the hope that it will be useful,	*
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of	*
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	*
+ * GNU General Public License for more details.				*
+ *									*
+ * You should have received a copy of the GNU General Public License	*
+ * along with this program; if not, write to the Free Software		*
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.		*
+ *----------------------------------------------------------------------*
+ * File:
+ *	treestats/locality.c
+ * Summary:
+ *	Study the locality of objects in the tree.
+ * Other notes:
+ *	
+ * Author      	Date		Notes
+ * RWMJ		28/5/95		Initial implementation.
+ *----------------------------------------------------------------------*/
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "misc.h"
+#include "readfile.h"
+
+static void examine_locality (tree *, struct ext_tree *);
+
+static int percentage[] = { 50, 70, 90, 95, 99, 0 };
+
+int
+main (int argc, char *argv[])
+{
+  int i;
+
+  if (argc < 2)
+    {
+      fprintf (stderr, "st-locality dumpfile [dumpfile [...]]\n");
+      exit (1);
+    }
+
+  printf ("INDEX\tCOUNT");
+  for (i = 0; percentage[i] != 0; ++i)
+    {
+      printf ("\tWS%d", percentage[i]);
+      printf ("\tMU%d", percentage[i]);
+    }
+  putchar ('\n');
+
+  for (i = 1; i < argc; ++i)
+    {
+      tree *t;
+      struct ext_tree *et;
+
+      if (readfile (argv[i], &t, &et) != 0)
+	continue;
+
+      printf ("%u\t%d", et->index, counttree (t));
+      examine_locality (t, et);
+
+      deltree (t);
+    }
+
+  exit (0);
+}
+
+struct loc
+{
+  object *n;
+  int depth;
+};
+
+static int compare_loc (struct loc *, struct loc *);
+static struct loc *flatten (object *, struct loc *, int);
+static int mu_ws_size (struct loc *, int count, int pc, unsigned tot_hits);
+static double mu_avg_depth (struct loc *, int ws_size);
+
+static void
+examine_locality (tree * t, struct ext_tree *et)
+{
+  int count = counttree (t), i;
+  struct loc nodes[count];
+  double mu;
+  int ws;
+  unsigned tot_hits = 0;
+
+  /* Flatten the nodes into our array, recording the depth of each node
+   * too.
+   */
+  (void) flatten (t->root, nodes, 0);
+
+  /* Sort the nodes in the tree into descending order of # of hits. (Node[0]
+   * will be most frequently used node).
+   */
+  qsort (nodes, count, sizeof (struct loc), (__compar_fn_t) compare_loc);
+
+#if 0
+  /* Print nodes here. */
+  for (i = 0; i < count; ++i)
+    printf ("node %d, hits %d, depth %d\n",
+	    i, nodes[i].n->hits, nodes[i].depth);
+#endif
+
+  /* Count total number of hits received.
+   */
+  for (i = 0; i < count; ++i)
+    tot_hits += nodes[i].n->hits;
+
+  /* Calculate average depth of each percentage of objects of interest.
+   */
+  for (i = 0; percentage[i] != 0; ++i)
+    {
+      ws = mu_ws_size (nodes, count, percentage[i], tot_hits);
+      mu = mu_avg_depth (nodes, ws);
+      printf ("\t%d\t%2.2g", ws, mu);
+    }
+  putchar ('\n');
+}
+
+static struct loc *
+flatten (object * n, struct loc *nodes, int depth)
+{
+  if (n == NULL)
+    return nodes;
+
+  nodes->n = n;
+  nodes->depth = depth;
+
+  nodes++;
+
+  nodes = flatten (n->left, nodes, depth + 1);
+  nodes = flatten (n->right, nodes, depth + 1);
+
+  return nodes;
+}
+
+static int
+compare_loc (struct loc *l1, struct loc *l2)
+{
+  return l2->n->hits - l1->n->hits;
+}
+
+static int
+mu_ws_size (struct loc *nodes, int count, int pc, unsigned tot_hits)
+{
+  /* Work out the size of the working set that received pc% of the
+   * hits.
+   */
+  int i;
+  unsigned pc_hits = pc * tot_hits / 100, sum_hits = 0;
+
+  for (i = 0; i < count && sum_hits < pc_hits; ++i)
+    sum_hits += nodes[i].n->hits;
+
+  return i;
+}
+
+static double
+mu_avg_depth (struct loc *nodes, int ws_size)
+{
+  /* Work out the average depth of the first ws_size nodes.
+   */
+  int i;
+  double sum = 0;
+
+  if (ws_size == 0)
+    return 0;
+
+  for (i = 0; i < ws_size; ++i)
+    sum += nodes[i].depth;
+
+  return sum / ws_size;
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/treestats/st-split-analysis gcc-4.0.2/gcc/bounds/treestats/st-split-analysis
--- gcc-4.0.2.org/gcc/bounds/treestats/st-split-analysis	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/treestats/st-split-analysis	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,18 @@
+#!/bin/sh -
+
+# Split up the output of 'st-analyze' into separate files.
+
+if [ x$1 = "x" ]; then
+	echo "$0 inputfile"
+	exit
+fi
+
+files=`head -1 $1`
+col=1
+
+for f in $files
+do
+	echo $col: $f
+	awk \{print\ \$$col\} < $1 > $f
+	col=$[col+1]
+done
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/unsetall.sh gcc-4.0.2/gcc/bounds/unsetall.sh
--- gcc-4.0.2.org/gcc/bounds/unsetall.sh	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/unsetall.sh	2005-09-29 17:50:02.000000000 +0200
@@ -0,0 +1,141 @@
+:
+# unsetall.sh -- unset all extra environment variables
+#
+# 02Jun00 wb initial version
+# 10Sep01 wb handle shell functions
+# 23Apr02 wb replace PS1 $ with -
+
+# set -x
+
+# echo -n "Continue > " ; read line ; unset line
+
+unset unset_oldifs unset_newpath unset_part unset_opts x
+unset did_usr_local_bin did_usr_local_sbin did_usr_bin_x11 did_u_local_bin
+unset did_home_bin
+
+unset_opts="$@"
+
+# echo Initial environment: `printenv | wc -lc`
+
+# Change the prompt
+
+PS1="`echo \"$PS1\" | sed -e 's/@/-/' -e 's/\\\\\\$/-/'`"
+
+# Clear enough entries so the eval works
+
+unset CDPATH DEF_INC DEF_LIB EDITOR OLDPATH SA_EDITOR SPICE_LIBS VISUAL X_LIB
+
+# Clear out most of the environment as reported by printenv
+
+unset printenv
+printenv=printenv
+if [ -x /usr/bin/env ] ; then printenv=/usr/bin/env
+elif [ -x /bin/printenv ] ; then printenv=/bin/printenv
+elif [ -x /usr/ucb/printenv ] ; then printenv=/usr/ucb/printenv
+fi
+
+# echo "printenv is $printenv"
+
+# export -p > junk1.tmp
+
+eval `
+	$printenv | \
+	grep '^[A-Za-z0-9_]*=' | \
+	egrep -v \
+'^LOGNAME=|^TERM=|^PATH=|^HOME=|^DISPLAY=|^SHELL=|^HZ=|^TZ=|^_=|^PS1=|^LD_|^INCDIR=|^LIBPATH=|^TMP|^LINES=|^COLUMNS=' | \
+	cut -f 1 -d= | \
+	sed -e '1,$s/^/unset /' ; \
+	`
+
+# export -p > junk4.tmp
+
+case "$LINES" in
+24|25) unset LINES ;;
+esac
+
+case "$COLUMNS" in
+80) unset COLUMNS ;;
+esac
+
+# Clean the PATH
+
+unset_oldifs="$IFS"
+IFS=":$IFS"
+did_usr_local_bin=no
+did_usr_local_sbin=no
+did_usr_bin_x11=no
+did_u_local_bin=no
+did_home_bin=no
+unset_newpath=
+
+for unset_part in $PATH
+do
+	if [ -z "$DISPLAY" ]
+	then
+		case "X$unset_part" in
+		*/X11*|*/openwin*) unset_part= ;;
+		esac
+	fi
+	case "X$unset_part" in
+	*layout*|*/pl*|*scs*|*dbin|*/comp*|*/cpag*) ;;
+	*)
+		if [ ! -d "$unset_part" ]
+		then
+			x=x
+		elif [ "$unset_part" = /usr/local/bin ]
+		then
+			if [ "$did_usr_local_bin" = no ]
+			then
+				unset_newpath="$unset_newpath:$unset_part"
+				did_usr_local_bin=yes
+			fi
+		elif [ "$unset_part" = /usr/local/sbin ]
+		then
+			if [ "$did_usr_local_sbin" = no ]
+			then
+				unset_newpath="$unset_newpath:$unset_part"
+				did_usr_local_sbin=yes
+			fi
+		elif [ "$unset_part" = /usr/bin/X11 ]
+		then
+			if [ "$did_usr_bin_x11" = no ]
+			then
+				unset_newpath="$unset_newpath:$unset_part"
+				did_usr_bin_x11=yes
+			fi
+		elif [ "$unset_part" = /u/local/bin ]
+		then
+			if [ "$did_u_local_bin" = no ]
+			then
+				unset_newpath="$unset_newpath:$unset_part"
+				did_u_local_bin=yes
+			fi
+		elif [ "$unset_part" = "$HOME/bin" ]
+		then
+			if [ "$did_home_bin" = no ]
+			then
+				unset_newpath="$unset_newpath:$unset_part"
+				did_home_bin=yes
+			fi
+		elif [ "$unset_part" = "" -o "$unset_part" = "." ]
+		then
+			x=x
+		else
+			unset_newpath="$unset_newpath:$unset_part"
+		fi
+		;;
+	esac
+done
+PATH="$unset_newpath"
+export PATH
+IFS="$unset_oldifs"
+set -- $unset_opts
+
+unset unset_oldifs unset_newpath unset_part unset_opts x
+unset did_usr_local_bin did_usr_local_sbin did_usr_bin_x11 did_u_local_bin
+unset did_home_bin
+
+# echo "$0: PATH $PATH"
+echo "$0: Remaining environment:" `$printenv | wc -lc`
+
+unset printenv
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/bounds/VERSION gcc-4.0.2/gcc/bounds/VERSION
--- gcc-4.0.2.org/gcc/bounds/VERSION	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/bounds/VERSION	2005-09-29 17:51:34.000000000 +0200
@@ -0,0 +1,6 @@
+/* GCC with bounds checking, by Richard W.M. Jones.
+ * Maybe this file should be called `patchlevel.h'?
+ */
+
+#define VERSION_GCC	"gcc-4.0.2"
+#define VERSION_LIBRARY	"3.2"
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/builtins.c gcc-4.0.2/gcc/builtins.c
--- gcc-4.0.2.org/gcc/builtins.c	2005-08-28 13:08:55.000000000 +0200
+++ gcc-4.0.2/gcc/builtins.c	2005-09-29 17:50:03.000000000 +0200
@@ -47,6 +47,7 @@ Software Foundation, 59 Temple Place - S
 #include "langhooks.h"
 #include "basic-block.h"
 #include "tree-mudflap.h"
+#include "c-bounds.h"
 
 #define CALLED_AS_BUILT_IN(NODE) \
    (!strncmp (IDENTIFIER_POINTER (DECL_NAME (NODE)), "__builtin_", 10))
@@ -2506,7 +2507,8 @@ static rtx
 expand_builtin_strlen (tree arglist, rtx target,
 		       enum machine_mode target_mode)
 {
-  if (!validate_arglist (arglist, POINTER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist, POINTER_TYPE, VOID_TYPE))
     return 0;
   else
     {
@@ -2613,7 +2615,8 @@ expand_builtin_strlen (tree arglist, rtx
 static rtx
 expand_builtin_strstr (tree arglist, tree type, rtx target, enum machine_mode mode)
 {
-  if (validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled == 0
+      && validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
     {
       tree result = fold_builtin_strstr (arglist, type);
       if (result)
@@ -2629,7 +2632,8 @@ expand_builtin_strstr (tree arglist, tre
 static rtx
 expand_builtin_strchr (tree arglist, tree type, rtx target, enum machine_mode mode)
 {
-  if (validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled == 0
+      && validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
     {
       tree result = fold_builtin_strchr (arglist, type);
       if (result)
@@ -2647,7 +2651,8 @@ expand_builtin_strchr (tree arglist, tre
 static rtx
 expand_builtin_strrchr (tree arglist, tree type, rtx target, enum machine_mode mode)
 {
-  if (validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled == 0
+      && validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
     {
       tree result = fold_builtin_strrchr (arglist, type);
       if (result)
@@ -2663,7 +2668,8 @@ expand_builtin_strrchr (tree arglist, tr
 static rtx
 expand_builtin_strpbrk (tree arglist, tree type, rtx target, enum machine_mode mode)
 {
-  if (validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled == 0
+      && validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
     {
       tree result = fold_builtin_strpbrk (arglist, type);
       if (result)
@@ -2697,8 +2703,10 @@ static rtx
 expand_builtin_memcpy (tree exp, rtx target, enum machine_mode mode)
 {
   tree arglist = TREE_OPERAND (exp, 1);
-  if (!validate_arglist (arglist,
-			 POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist,
+			    POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE,
+			    VOID_TYPE))
     return 0;
   else
     {
@@ -2775,8 +2783,10 @@ static rtx
 expand_builtin_mempcpy (tree arglist, tree type, rtx target, enum machine_mode mode,
 			int endp)
 {
-  if (!validate_arglist (arglist,
-			 POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist,
+			    POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE,
+			    VOID_TYPE))
     return 0;
   /* If return value is ignored, transform mempcpy into memcpy.  */
   else if (target == const0_rtx)
@@ -2861,8 +2871,10 @@ static rtx
 expand_builtin_memmove (tree arglist, tree type, rtx target,
 			enum machine_mode mode, tree orig_exp)
 {
-  if (!validate_arglist (arglist,
-			 POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist,
+			    POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE,
+			    VOID_TYPE))
     return 0;
   else
     {
@@ -2925,8 +2937,10 @@ expand_builtin_bcopy (tree exp)
   tree type = TREE_TYPE (exp);
   tree src, dest, size, newarglist;
 
-  if (!validate_arglist (arglist,
-			 POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist,
+			    POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE,
+			    VOID_TYPE))
     return NULL_RTX;
 
   src = TREE_VALUE (arglist);
@@ -3021,7 +3035,8 @@ static rtx
 expand_builtin_strcpy (tree exp, rtx target, enum machine_mode mode)
 {
   tree arglist = TREE_OPERAND (exp, 1);
-  if (validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled == 0
+      && validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
     {
       tree result = fold_builtin_strcpy (exp, 0);
       if (result)
@@ -3043,6 +3058,10 @@ static rtx
 expand_builtin_stpcpy (tree exp, rtx target, enum machine_mode mode)
 {
   tree arglist = TREE_OPERAND (exp, 1);
+
+  if (bounds_checking_enabled)
+    return 0;
+
   /* If return value is ignored, transform stpcpy into strcpy.  */
   if (target == const0_rtx)
     {
@@ -3141,8 +3160,9 @@ static rtx
 expand_builtin_strncpy (tree exp, rtx target, enum machine_mode mode)
 {
   tree arglist = TREE_OPERAND (exp, 1);
-  if (validate_arglist (arglist,
-			POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled == 0
+      && validate_arglist (arglist,
+			   POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
     {
       tree slen = c_strlen (TREE_VALUE (TREE_CHAIN (arglist)), 1);
       tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));
@@ -3237,8 +3257,9 @@ static rtx
 expand_builtin_memset (tree arglist, rtx target, enum machine_mode mode,
 		       tree orig_exp)
 {
-  if (!validate_arglist (arglist,
-			 POINTER_TYPE, INTEGER_TYPE, INTEGER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, INTEGER_TYPE,
+			    VOID_TYPE))
     return 0;
   else
     {
@@ -3344,7 +3365,8 @@ expand_builtin_bzero (tree exp)
   tree arglist = TREE_OPERAND (exp, 1);
   tree dest, size, newarglist;
 
-  if (!validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
     return NULL_RTX;
 
   dest = TREE_VALUE (arglist);
@@ -3371,8 +3393,9 @@ static rtx
 expand_builtin_memcmp (tree exp ATTRIBUTE_UNUSED, tree arglist, rtx target,
 		       enum machine_mode mode)
 {
-  if (!validate_arglist (arglist,
-			 POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE,
+			    VOID_TYPE))
     return 0;
   else
     {
@@ -3481,7 +3504,8 @@ expand_builtin_strcmp (tree exp, rtx tar
 {
   tree arglist = TREE_OPERAND (exp, 1);
 
-  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
     return 0;
   else
     {
@@ -3600,8 +3624,9 @@ expand_builtin_strncmp (tree exp, rtx ta
 {
   tree arglist = TREE_OPERAND (exp, 1);
 
-  if (!validate_arglist (arglist,
-			 POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE,
+			    VOID_TYPE))
     return 0;
   else
     {
@@ -3728,7 +3753,8 @@ expand_builtin_strncmp (tree exp, rtx ta
 static rtx
 expand_builtin_strcat (tree arglist, tree type, rtx target, enum machine_mode mode)
 {
-  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
     return 0;
   else
     {
@@ -3794,8 +3820,9 @@ expand_builtin_strcat (tree arglist, tre
 static rtx
 expand_builtin_strncat (tree arglist, rtx target, enum machine_mode mode)
 {
-  if (validate_arglist (arglist,
-			POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled == 0
+      && validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE,
+			   VOID_TYPE))
     {
       tree result = fold_builtin_strncat (arglist);
       if (result)
@@ -3811,7 +3838,8 @@ expand_builtin_strncat (tree arglist, rt
 static rtx
 expand_builtin_strspn (tree arglist, rtx target, enum machine_mode mode)
 {
-  if (validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled == 0
+      && validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
     {
       tree result = fold_builtin_strspn (arglist);
       if (result)
@@ -3827,7 +3855,8 @@ expand_builtin_strspn (tree arglist, rtx
 static rtx
 expand_builtin_strcspn (tree arglist, rtx target, enum machine_mode mode)
 {
-  if (validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled == 0
+      && validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
     {
       tree result = fold_builtin_strcspn (arglist);
       if (result)
@@ -4347,7 +4376,7 @@ expand_builtin_alloca (tree arglist, rtx
   /* In -fmudflap-instrumented code, alloca() and __builtin_alloca()
      should always expand to function calls.  These can be intercepted
      in libmudflap.  */
-  if (flag_mudflap)
+  if (bounds_checking_enabled || flag_mudflap)
     return 0;
 
   if (!validate_arglist (arglist, INTEGER_TYPE, VOID_TYPE))
@@ -5909,8 +5938,8 @@ builtin_mathfn_code (tree t)
 static tree
 fold_builtin_constant_p (tree arglist)
 {
-  if (arglist == 0)
-    return 0;
+  if (bounds_checking_enabled || arglist == 0)
+    return integer_zero_node;
 
   arglist = TREE_VALUE (arglist);
 
@@ -6005,7 +6034,8 @@ fold_builtin_classify_type (tree arglist
 static tree
 fold_builtin_strlen (tree arglist)
 {
-  if (!validate_arglist (arglist, POINTER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist, POINTER_TYPE, VOID_TYPE))
     return NULL_TREE;
   else
     {
@@ -6052,7 +6082,8 @@ fold_builtin_nan (tree arglist, tree typ
   REAL_VALUE_TYPE real;
   const char *str;
 
-  if (!validate_arglist (arglist, POINTER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist, POINTER_TYPE, VOID_TYPE))
     return 0;
   str = c_getstr (TREE_VALUE (arglist));
   if (!str)
@@ -7195,8 +7226,9 @@ fold_builtin_memcpy (tree exp)
   tree arglist = TREE_OPERAND (exp, 1);
   tree dest, src, len;
 
-  if (!validate_arglist (arglist,
-			 POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE,
+			    VOID_TYPE))
     return 0;
 
   dest = TREE_VALUE (arglist);
@@ -7220,8 +7252,9 @@ fold_builtin_memcpy (tree exp)
 static tree
 fold_builtin_mempcpy (tree arglist, tree type, int endp)
 {
-  if (validate_arglist (arglist,
-			POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled == 0
+      && validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE,
+			   VOID_TYPE))
     {
       tree dest = TREE_VALUE (arglist);
       tree src = TREE_VALUE (TREE_CHAIN (arglist));
@@ -7257,8 +7290,9 @@ fold_builtin_memmove (tree arglist, tree
 {
   tree dest, src, len;
 
-  if (!validate_arglist (arglist,
-			 POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE,
+			    VOID_TYPE))
     return 0;
 
   dest = TREE_VALUE (arglist);
@@ -7286,8 +7320,8 @@ fold_builtin_strcpy (tree exp, tree len)
   tree arglist = TREE_OPERAND (exp, 1);
   tree dest, src, fn;
 
-  if (!validate_arglist (arglist,
-			 POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
     return 0;
 
   dest = TREE_VALUE (arglist);
@@ -7329,8 +7363,9 @@ fold_builtin_strncpy (tree exp, tree sle
   tree arglist = TREE_OPERAND (exp, 1);
   tree dest, src, len, fn;
 
-  if (!validate_arglist (arglist,
-			 POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE,
+			    VOID_TYPE))
     return 0;
 
   dest = TREE_VALUE (arglist);
@@ -7378,8 +7413,9 @@ fold_builtin_memcmp (tree arglist)
   tree arg1, arg2, len;
   const char *p1, *p2;
 
-  if (!validate_arglist (arglist,
-			 POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE,
+			    VOID_TYPE))
     return 0;
 
   arg1 = TREE_VALUE (arglist);
@@ -7443,7 +7479,8 @@ fold_builtin_strcmp (tree arglist)
   tree arg1, arg2;
   const char *p1, *p2;
 
-  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
     return 0;
 
   arg1 = TREE_VALUE (arglist);
@@ -7502,8 +7539,9 @@ fold_builtin_strncmp (tree arglist)
   tree arg1, arg2, len;
   const char *p1, *p2;
 
-  if (!validate_arglist (arglist,
-			 POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE,
+			    VOID_TYPE))
     return 0;
 
   arg1 = TREE_VALUE (arglist);
@@ -8365,6 +8403,9 @@ build_function_call_expr (tree fn, tree 
 {
   tree call_expr;
 
+  if (bounds_checking_enabled)
+    bounds_convert_funcname (&fn, &arglist);
+
   call_expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);
   call_expr = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),
 		      call_expr, arglist, NULL_TREE);
@@ -8550,7 +8591,8 @@ fold_builtin_strstr (tree arglist, tree 
 static tree
 fold_builtin_strchr (tree arglist, tree type)
 {
-  if (!validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
     return 0;
   else
     {
@@ -8772,8 +8814,9 @@ fold_builtin_strcat (tree arglist)
 static tree
 fold_builtin_strncat (tree arglist)
 {
-  if (!validate_arglist (arglist,
-			 POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist,
+			    POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))
     return 0;
   else
     {
@@ -8827,7 +8870,8 @@ fold_builtin_strncat (tree arglist)
 static tree
 fold_builtin_strspn (tree arglist)
 {
-  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
     return 0;
   else
     {
@@ -8871,7 +8915,8 @@ fold_builtin_strspn (tree arglist)
 static tree
 fold_builtin_strcspn (tree arglist)
 {
-  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
+  if (bounds_checking_enabled
+      || !validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))
     return 0;
   else
     {
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/c-bounds.c gcc-4.0.2/gcc/c-bounds.c
--- gcc-4.0.2.org/gcc/c-bounds.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/c-bounds.c	2005-09-29 21:50:50.000000000 +0200
@@ -0,0 +1,3691 @@
+/* Miscellaneous functions for bounds checking.
+   Written by Richard W.M. Jones <rjones@orchestream.com>.
+   Copyright (C) 1995 Richard W.M. Jones.
+
+This file is part of the bounds checking patches for GNU CC. The main
+body of code used at run time can be found in the `bounds/' subdirectory.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
+
+#include "config.h"
+#include "system.h"
+#include <stdio.h>
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "tree.h"
+#include "tree-flow.h"
+#include "tree-iterator.h"
+#include "flags.h"
+#include "expr.h"
+#include "c-tree.h"
+#include "c-bounds.h"
+#include "output.h"
+#include "toplev.h"
+#include "except.h"
+#include "function.h"
+#include "ggc.h"
+#include "c-tree.h"
+#include "target.h"
+#include "langhooks.h"
+#include "cpplib.h"
+#include "c-pragma.h"
+
+/* List of static pointers initialised with pointer arithemetic expressions.
+   This list is used to generate extra instructions to ensure this 
+   initialisation is bounds checked at runtime.  */
+
+static tree build_current_lineno (void);
+static tree build_current_filename (void);
+static tree build_decl_lineno (tree);
+static tree build_decl_filename (tree);
+static tree bounds_build_function_call (const char *, tree, tree *, int);
+static tree bounds_build_string (const char *);
+static tree bounds_pointer_from_array (tree);
+static tree bounds_pointer_from_array_type (tree);
+static tree bounds_pointer_from_array_ref (tree);
+static tree bounds_lookup_field (tree, tree);
+static tree declare_function_number_var (void);
+static void declare_object_var (tree);
+static tree generate_assignment (tree, tree, tree);
+static tree find_object (tree);
+static tree maybe_find_object (tree);
+static int check_fname_decl (tree);
+static void add_object (tree, enum tree_code);
+static int locate_var_in_tree (tree, const char *);
+static int is_deletable (int, tree);
+static int bounds_remove_calls (tree *, int, int *);
+static unsigned int bounds_hash (register const char *,
+				 register unsigned int);
+static unsigned int bounds_func_hash (register const char *,
+				      register unsigned int);
+static tree check_static_pointer_initialization (tree);
+
+int bounds_in_addr_expr = 0;
+
+static GTY (()) varray_type static_ptr_init_list;
+static GTY (()) varray_type deferred_global_decls;
+static GTY (()) tree bounds_memcpy;
+static GTY (()) tree bounds_mempcpy;
+static GTY (()) tree bounds_memset;
+static GTY (()) tree bounds_find_object;
+static GTY (()) tree bounds_maybe_find_object;
+static GTY (()) tree bounds_check_ptr_plus_int;
+static GTY (()) tree bounds_check_ptr_minus_int;
+static GTY (()) tree bounds_check_ptr_plus_int_obj;
+static GTY (()) tree bounds_check_ptr_minus_int_obj;
+static GTY (()) tree bounds_check_array_reference;
+static GTY (()) tree bounds_check_array_reference_obj;
+static GTY (()) tree bounds_check_component_reference;
+static GTY (()) tree bounds_check_component_reference_obj;
+static GTY (()) tree bounds_check_ptr_diff;
+static GTY (()) tree bounds_check_ptr_diff_obj;
+static GTY (()) tree bounds_check_reference;
+static GTY (()) tree bounds_check_reference_obj;
+static GTY (()) tree bounds_check_ptr_lt_ptr;
+static GTY (()) tree bounds_check_ptr_lt_ptr_obj;
+static GTY (()) tree bounds_check_ptr_le_ptr;
+static GTY (()) tree bounds_check_ptr_le_ptr_obj;
+static GTY (()) tree bounds_check_ptr_gt_ptr;
+static GTY (()) tree bounds_check_ptr_gt_ptr_obj;
+static GTY (()) tree bounds_check_ptr_ge_ptr;
+static GTY (()) tree bounds_check_ptr_ge_ptr_obj;
+static GTY (()) tree bounds_check_ptr_eq_ptr;
+static GTY (()) tree bounds_check_ptr_ne_ptr;
+static GTY (()) tree bounds_check_ptr_postinc;
+static GTY (()) tree bounds_check_ptr_preinc;
+static GTY (()) tree bounds_check_ptr_postdec;
+static GTY (()) tree bounds_check_ptr_predec;
+static GTY (()) tree bounds_check_ptr_postinc_obj;
+static GTY (()) tree bounds_check_ptr_preinc_obj;
+static GTY (()) tree bounds_check_ptr_postdec_obj;
+static GTY (()) tree bounds_check_ptr_predec_obj;
+static GTY (()) tree bounds_check_ptr_postinc_ref;
+static GTY (()) tree bounds_check_ptr_preinc_ref;
+static GTY (()) tree bounds_check_ptr_postdec_ref;
+static GTY (()) tree bounds_check_ptr_predec_ref;
+static GTY (()) tree bounds_check_ptr_postinc_ref_obj;
+static GTY (()) tree bounds_check_ptr_preinc_ref_obj;
+static GTY (()) tree bounds_check_ptr_postdec_ref_obj;
+static GTY (()) tree bounds_check_ptr_predec_ref_obj;
+static GTY (()) tree bounds_check_ptr_true;
+static GTY (()) tree bounds_check_ptr_false;
+static GTY (()) tree bounds_note_constructed_object;
+static GTY (()) tree bounds_note_constructed_private_table;
+static GTY (()) tree bounds_push_function;
+static GTY (()) tree bounds_pop_function;
+static GTY (()) tree bounds_add_param_object;
+static GTY (()) tree bounds_add_stack_object;
+static GTY (()) tree bounds_delete_stack_object;
+static GTY (()) tree bounds_initialize_library;
+static GTY (()) tree bounds_check_free;
+static GTY (()) tree bounds_check_malloc;
+static GTY (()) tree bounds_check_realloc;
+static GTY (()) tree bounds_check_memalign;
+static GTY (()) tree bounds_check_calloc;
+static GTY (()) tree bounds_check_valloc;
+static GTY (()) tree bounds_check_alloca;
+static GTY (()) tree bounds_check___alloca;
+static GTY (()) tree bounds_check___builtin_alloca;
+static GTY (()) tree bounds_check_mmap;
+static GTY (()) tree bounds_check_munmap;
+static GTY (()) tree bounds_check_memcpy;
+static GTY (()) tree bounds_check_mempcpy;
+static GTY (()) tree bounds_check_memmove;
+static GTY (()) tree bounds_check_bcopy;
+static GTY (()) tree bounds_check_memset;
+static GTY (()) tree bounds_check_bzero;
+static GTY (()) tree bounds_check_memcmp;
+static GTY (()) tree bounds_check_bcmp;
+static GTY (()) tree bounds_check_strcpy;
+static GTY (()) tree bounds_check_strncpy;
+static GTY (()) tree bounds_check_strlen;
+static GTY (()) tree bounds_check_strcmp;
+static GTY (()) tree bounds_check_strncmp;
+static GTY (()) tree bounds_check_strcat;
+static GTY (()) tree bounds_check_strncat;
+static GTY (()) tree bounds_check_strpbrk;
+static GTY (()) tree bounds_check_strrchr;
+static GTY (()) tree bounds_check_rindex;
+static GTY (()) tree bounds_check_strspn;
+static GTY (()) tree bounds_check_strcspn;
+static GTY (()) tree bounds_check_strstr;
+static GTY (()) tree bounds_check_strtok;
+static GTY (()) tree bounds_check_strtok_r;
+static GTY (()) tree bounds_check_strdup;
+static GTY (()) tree bounds_check_strchr;
+static GTY (()) tree bounds_check_index;
+static GTY (()) tree bounds_check_strcoll;
+static GTY (()) tree bounds_check_strxfrm;
+static GTY (()) tree bounds_check_strcasecmp;
+static GTY (()) tree bounds_check_strncasecmp;
+static GTY (()) tree bounds_check_memchr;
+static GTY (()) tree bounds_check_memccpy;
+static GTY (()) tree bounds_private_statics;
+
+#include "gt-c-bounds.h"
+
+void
+bounds_init (void)
+{
+  /* Create a prototype for the functions __bounds_check...  */
+  tree bounds_end = tree_cons (NULL_TREE, const_string_type_node,
+		      tree_cons (NULL_TREE, integer_type_node, void_list_node));
+  tree bounds_ptr = tree_cons (NULL_TREE, ptr_type_node,
+		      tree_cons (NULL_TREE, integer_type_node,
+			tree_cons (NULL_TREE, sizetype, bounds_end)));
+  tree bounds_arr = tree_cons (NULL_TREE, ptr_type_node,
+		      tree_cons (NULL_TREE, integer_type_node,
+			tree_cons (NULL_TREE, sizetype,
+			  tree_cons (NULL_TREE, sizetype, bounds_end))));
+  tree bounds_ref = tree_cons (NULL_TREE, ptr_type_node,
+		      tree_cons (NULL_TREE, sizetype, bounds_end));
+  tree bounds_cc = tree_cons (NULL_TREE, ptr_type_node,
+		     tree_cons (NULL_TREE, ptr_type_node,
+		       tree_cons (NULL_TREE, ptr_type_node,
+			 tree_cons (NULL_TREE, ptr_type_node, bounds_end))));
+  tree bounds_cco = tree_cons (NULL_TREE, ptr_type_node,
+		      tree_cons (NULL_TREE, ptr_type_node, bounds_end));
+  tree bounds_eq = tree_cons (NULL_TREE, ptr_type_node,
+		     tree_cons (NULL_TREE, ptr_type_node, bounds_end));
+  tree bounds_inc = tree_cons (NULL_TREE, build_pointer_type (ptr_type_node),
+		      tree_cons (NULL_TREE, integer_type_node, bounds_end));
+  tree bounds_incr = tree_cons (NULL_TREE, build_pointer_type (ptr_type_node),
+		       tree_cons (NULL_TREE, integer_type_node,
+			 tree_cons (NULL_TREE, sizetype, bounds_end)));
+
+  bounds_memcpy =
+    builtin_function ("__bounds_memcpy",
+		      build_function_type (ptr_type_node,
+			tree_cons (NULL_TREE, ptr_type_node,
+			  tree_cons (NULL_TREE, const_ptr_type_node,
+			    tree_cons (NULL_TREE, sizetype,
+				       void_list_node)))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_mempcpy =
+    builtin_function ("__bounds_mempcpy",
+		      build_function_type (ptr_type_node,
+			tree_cons (NULL_TREE, ptr_type_node,
+			  tree_cons (NULL_TREE, const_ptr_type_node,
+			    tree_cons (NULL_TREE, sizetype,
+				       void_list_node)))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+
+  builtin_function ("mempcpy",
+		    build_function_type (ptr_type_node,
+		      tree_cons (NULL_TREE, ptr_type_node,
+			tree_cons (NULL_TREE, const_ptr_type_node,
+			  tree_cons (NULL_TREE, sizetype,
+				     void_list_node)))),
+		    0, NOT_BUILT_IN, NULL, NULL);
+  bounds_memset =
+    builtin_function ("__bounds_memset",
+		      build_function_type (ptr_type_node,
+                        tree_cons (NULL_TREE, ptr_type_node,
+                          tree_cons (NULL_TREE, integer_type_node,
+                            tree_cons (NULL_TREE, sizetype,
+				       void_list_node)))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_find_object =
+    builtin_function ("__bounds_find_object",
+		      build_function_type (ptr_type_node,
+					   tree_cons (NULL_TREE,
+						      ptr_type_node,
+						      void_list_node)),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_maybe_find_object =
+    builtin_function ("__bounds_maybe_find_object",
+		      build_function_type (ptr_type_node,
+					   tree_cons (NULL_TREE, ptr_type_node,
+						      tree_cons (NULL_TREE,
+								 ptr_type_node,
+								 void_list_node))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_plus_int =
+    builtin_function ("__bounds_check_ptr_plus_int",
+		      build_function_type (ptr_type_node,
+					   tree_cons (NULL_TREE, ptr_type_node,
+						      bounds_ptr)),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_minus_int =
+    builtin_function ("__bounds_check_ptr_minus_int",
+		      build_function_type (ptr_type_node,
+					   tree_cons (NULL_TREE, ptr_type_node,
+						      bounds_ptr)),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_plus_int_obj =
+    builtin_function ("__bounds_check_ptr_plus_int_obj",
+		      build_function_type (ptr_type_node, bounds_ptr),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_minus_int_obj =
+    builtin_function ("__bounds_check_ptr_minus_int_obj",
+		      build_function_type (ptr_type_node, bounds_ptr),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_array_reference =
+    builtin_function ("__bounds_check_array_reference",
+		      build_function_type (integer_type_node,
+					   tree_cons (NULL_TREE, ptr_type_node,
+						      bounds_arr)),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_array_reference_obj =
+    builtin_function ("__bounds_check_array_reference_obj",
+		      build_function_type (integer_type_node, bounds_arr),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_component_reference =
+    builtin_function ("__bounds_check_component_reference",
+		      build_function_type (ptr_type_node,
+					   tree_cons (NULL_TREE, ptr_type_node,
+						      bounds_ptr)),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_component_reference_obj =
+    builtin_function ("__bounds_check_component_reference_obj",
+		      build_function_type (ptr_type_node, bounds_ptr),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_diff =
+    builtin_function ("__bounds_check_ptr_diff",
+		      build_function_type (integer_type_node,
+			tree_cons (NULL_TREE, ptr_type_node,
+			  tree_cons (NULL_TREE, ptr_type_node,
+			    tree_cons (NULL_TREE, ptr_type_node,
+			      tree_cons (NULL_TREE, ptr_type_node,
+			        tree_cons (NULL_TREE, sizetype,
+			  		   bounds_end)))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_diff_obj =
+    builtin_function ("__bounds_check_ptr_diff_obj",
+		      build_function_type (integer_type_node,
+			tree_cons (NULL_TREE, ptr_type_node,
+			  tree_cons (NULL_TREE, ptr_type_node,
+			    tree_cons (NULL_TREE, sizetype,
+			  	       bounds_end)))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_reference =
+    builtin_function ("__bounds_check_reference",
+		      build_function_type (ptr_type_node,
+					   tree_cons (NULL_TREE, ptr_type_node,
+						      bounds_ref)),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_reference_obj =
+    builtin_function ("__bounds_check_reference_obj",
+		      build_function_type (ptr_type_node, bounds_ref),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_lt_ptr =
+    builtin_function ("__bounds_check_ptr_lt_ptr",
+		      build_function_type (integer_type_node, bounds_cc),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_lt_ptr_obj =
+    builtin_function ("__bounds_check_ptr_lt_ptr_obj",
+		      build_function_type (integer_type_node, bounds_cco),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_le_ptr =
+    builtin_function ("__bounds_check_ptr_le_ptr",
+		      build_function_type (integer_type_node, bounds_cc),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_le_ptr_obj =
+    builtin_function ("__bounds_check_ptr_le_ptr_obj",
+		      build_function_type (integer_type_node, bounds_cco),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_gt_ptr =
+    builtin_function ("__bounds_check_ptr_gt_ptr",
+		      build_function_type (integer_type_node, bounds_cc),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_gt_ptr_obj =
+    builtin_function ("__bounds_check_ptr_gt_ptr_obj",
+		      build_function_type (integer_type_node, bounds_cco),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_ge_ptr =
+    builtin_function ("__bounds_check_ptr_ge_ptr",
+		      build_function_type (integer_type_node, bounds_cc),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_ge_ptr_obj =
+    builtin_function ("__bounds_check_ptr_ge_ptr_obj",
+		      build_function_type (integer_type_node, bounds_cco),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_eq_ptr =
+    builtin_function ("__bounds_check_ptr_eq_ptr",
+		      build_function_type (integer_type_node, bounds_eq),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_ne_ptr =
+    builtin_function ("__bounds_check_ptr_ne_ptr",
+		      build_function_type (integer_type_node, bounds_eq),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_postinc =
+    builtin_function ("__bounds_check_ptr_postinc",
+		      build_function_type (ptr_type_node,
+					   tree_cons (NULL_TREE, ptr_type_node,
+						      bounds_inc)),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_preinc =
+    builtin_function ("__bounds_check_ptr_preinc",
+		      build_function_type (ptr_type_node,
+					   tree_cons (NULL_TREE, ptr_type_node,
+						      bounds_inc)),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_postdec =
+    builtin_function ("__bounds_check_ptr_postdec",
+		      build_function_type (ptr_type_node,
+					   tree_cons (NULL_TREE, ptr_type_node,
+						      bounds_inc)),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_predec =
+    builtin_function ("__bounds_check_ptr_predec",
+		      build_function_type (ptr_type_node,
+					   tree_cons (NULL_TREE, ptr_type_node,
+						      bounds_inc)),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_postinc_obj =
+    builtin_function ("__bounds_check_ptr_postinc_obj",
+		      build_function_type (ptr_type_node, bounds_inc),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_preinc_obj =
+    builtin_function ("__bounds_check_ptr_preinc_obj",
+		      build_function_type (ptr_type_node, bounds_inc),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_postdec_obj =
+    builtin_function ("__bounds_check_ptr_postdec_obj",
+		      build_function_type (ptr_type_node, bounds_inc),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_predec_obj =
+    builtin_function ("__bounds_check_ptr_predec_obj",
+		      build_function_type (ptr_type_node, bounds_inc),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_postinc_ref =
+    builtin_function ("__bounds_check_ptr_postinc_ref",
+		      build_function_type (ptr_type_node,
+					   tree_cons (NULL_TREE, ptr_type_node,
+						      bounds_incr)),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_preinc_ref =
+    builtin_function ("__bounds_check_ptr_preinc_ref",
+		      build_function_type (ptr_type_node,
+					   tree_cons (NULL_TREE, ptr_type_node,
+						      bounds_incr)),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_postdec_ref =
+    builtin_function ("__bounds_check_ptr_postdec_ref",
+		      build_function_type (ptr_type_node,
+					   tree_cons (NULL_TREE, ptr_type_node,
+						      bounds_incr)),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_predec_ref =
+    builtin_function ("__bounds_check_ptr_predec_ref",
+		      build_function_type (ptr_type_node,
+					   tree_cons (NULL_TREE, ptr_type_node,
+						      bounds_incr)),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_postinc_ref_obj =
+    builtin_function ("__bounds_check_ptr_postinc_ref_obj",
+		      build_function_type (ptr_type_node, bounds_incr),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_preinc_ref_obj =
+    builtin_function ("__bounds_check_ptr_preinc_ref_obj",
+		      build_function_type (ptr_type_node, bounds_incr),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_postdec_ref_obj =
+    builtin_function ("__bounds_check_ptr_postdec_ref_obj",
+		      build_function_type (ptr_type_node, bounds_incr),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_predec_ref_obj =
+    builtin_function ("__bounds_check_ptr_predec_ref_obj",
+		      build_function_type (ptr_type_node, bounds_incr),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_true =
+    builtin_function ("__bounds_check_ptr_true",
+		      build_function_type (integer_type_node,
+					   tree_cons (NULL_TREE, ptr_type_node,
+						      bounds_end)),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_ptr_false =
+    builtin_function ("__bounds_check_ptr_false",
+		      build_function_type (integer_type_node,
+					   tree_cons (NULL_TREE, ptr_type_node,
+						      bounds_end)),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_note_constructed_object =
+    builtin_function ("__bounds_note_constructed_object",
+		      build_function_type (ptr_type_node,
+			tree_cons (NULL_TREE, ptr_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, sizetype,
+			      tree_cons (NULL_TREE, const_string_type_node,
+			        tree_cons (NULL_TREE, integer_type_node,
+			          tree_cons (NULL_TREE, const_string_type_node,
+					     void_list_node))))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_note_constructed_private_table =
+    builtin_function ("__bounds_note_constructed_private_table",
+		      build_function_type (void_type_node,
+			tree_cons (NULL_TREE, ptr_type_node,
+			  tree_cons (NULL_TREE, const_string_type_node,
+			    tree_cons (NULL_TREE, integer_type_node,
+				       void_list_node)))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_push_function =
+    builtin_function ("__bounds_push_function",
+		      build_function_type (integer_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, const_string_type_node,
+			      tree_cons (NULL_TREE, integer_type_node,
+					 void_list_node))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_pop_function =
+    builtin_function ("__bounds_pop_function",
+		      build_function_type (void_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node, void_list_node))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_add_param_object =
+    builtin_function ("__bounds_add_param_object",
+		      build_function_type (void_type_node,
+			tree_cons (NULL_TREE, ptr_type_node,
+			  tree_cons (NULL_TREE, sizetype,
+			    tree_cons (NULL_TREE, sizetype,
+			      tree_cons (NULL_TREE, const_string_type_node,
+			        tree_cons (NULL_TREE, integer_type_node,
+			          tree_cons (NULL_TREE, const_string_type_node,
+			            tree_cons (NULL_TREE, integer_type_node,
+					       void_list_node)))))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_add_stack_object =
+    builtin_function ("__bounds_add_stack_object",
+		      build_function_type (void_type_node,
+			tree_cons (NULL_TREE, ptr_type_node,
+			  tree_cons (NULL_TREE, sizetype,
+			    tree_cons (NULL_TREE, sizetype,
+			      tree_cons (NULL_TREE, const_string_type_node,
+			        tree_cons (NULL_TREE, integer_type_node,
+			          tree_cons (NULL_TREE, const_string_type_node,
+			            tree_cons (NULL_TREE, integer_type_node,
+					       void_list_node)))))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_delete_stack_object =
+    builtin_function ("__bounds_delete_stack_object",
+		      build_function_type (void_type_node,
+			tree_cons (NULL_TREE, ptr_type_node,
+			  tree_cons (NULL_TREE, ptr_type_node,
+			    tree_cons (NULL_TREE, integer_type_node,
+				       void_list_node)))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_initialize_library =
+    builtin_function ("__bounds_initialize_library",
+		      build_function_type (ptr_type_node, void_list_node),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_free =
+    builtin_function ("__bounds_check_free",
+		      build_function_type (void_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, ptr_type_node,
+				       void_list_node)))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_malloc =
+    builtin_function ("__bounds_check_malloc",
+		      build_function_type (ptr_type_node,
+		  	tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, sizetype,
+				       void_list_node)))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_realloc =
+    builtin_function ("__bounds_check_realloc",
+		      build_function_type (ptr_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, ptr_type_node,
+			      tree_cons (NULL_TREE, sizetype,
+				         void_list_node))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_memalign =
+    builtin_function ("__bounds_check_memalign",
+		      build_function_type (ptr_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, sizetype,
+			      tree_cons (NULL_TREE, sizetype,
+				         void_list_node))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_calloc =
+    builtin_function ("__bounds_check_calloc",
+		      build_function_type (ptr_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, sizetype,
+			      tree_cons (NULL_TREE, sizetype,
+				         void_list_node))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_valloc =
+    builtin_function ("__bounds_check_valloc",
+		      build_function_type (ptr_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, sizetype,
+				       void_list_node)))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_alloca =
+    builtin_function ("__bounds_check_alloca",
+		      build_function_type (ptr_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, sizetype,
+				       void_list_node)))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check___alloca =
+    builtin_function ("__bounds_check___alloca",
+		      build_function_type (ptr_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, sizetype,
+				       void_list_node)))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check___builtin_alloca =
+    builtin_function ("__bounds_check___builtin_alloca",
+		      build_function_type (ptr_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, sizetype,
+				       void_list_node)))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_mmap =
+    builtin_function ("__bounds_check_mmap",
+		      build_function_type (ptr_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, ptr_type_node,
+			      tree_cons (NULL_TREE, sizetype,
+			        tree_cons (NULL_TREE, integer_type_node,
+			          tree_cons (NULL_TREE, integer_type_node,
+			            tree_cons (NULL_TREE, integer_type_node,
+				      /* Should be off_t */
+			              tree_cons (NULL_TREE, sizetype,
+				                 void_list_node))))))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_munmap =
+    builtin_function ("__bounds_check_munmap",
+		      build_function_type (integer_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, ptr_type_node,
+			      tree_cons (NULL_TREE, sizetype,
+			  	         void_list_node))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_memcpy =
+    builtin_function ("__bounds_check_memcpy",
+		      build_function_type (ptr_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, ptr_type_node,
+			      tree_cons (NULL_TREE, const_ptr_type_node,
+			        tree_cons (NULL_TREE, sizetype,
+				           void_list_node)))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_mempcpy =
+    builtin_function ("__bounds_check_mempcpy",
+		      build_function_type (ptr_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, ptr_type_node,
+			      tree_cons (NULL_TREE, const_ptr_type_node,
+			        tree_cons (NULL_TREE, sizetype,
+				           void_list_node)))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_memmove =
+    builtin_function ("__bounds_check_memmove",
+		      build_function_type (ptr_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, ptr_type_node,
+			      tree_cons (NULL_TREE, const_ptr_type_node,
+			        tree_cons (NULL_TREE, sizetype,
+				           void_list_node)))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_bcopy =
+    builtin_function ("__bounds_check_bcopy",
+		      build_function_type (ptr_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, const_ptr_type_node,
+			      tree_cons (NULL_TREE, ptr_type_node,
+			        tree_cons (NULL_TREE, integer_type_node,
+				           void_list_node)))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_memset =
+    builtin_function ("__bounds_check_memset",
+		      build_function_type (ptr_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, ptr_type_node,
+			      tree_cons (NULL_TREE, integer_type_node,
+			        tree_cons (NULL_TREE, sizetype,
+				           void_list_node)))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_bzero =
+    builtin_function ("__bounds_check_bzero",
+		      build_function_type (void_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, ptr_type_node,
+			      tree_cons (NULL_TREE, integer_type_node,
+				         void_list_node))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_memcmp =
+    builtin_function ("__bounds_check_memcmp",
+		      build_function_type (integer_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, const_ptr_type_node,
+			      tree_cons (NULL_TREE, const_ptr_type_node,
+			        tree_cons (NULL_TREE, sizetype,
+				           void_list_node)))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_bcmp =
+    builtin_function ("__bounds_check_bcmp",
+		      build_function_type (integer_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, ptr_type_node,
+			      tree_cons (NULL_TREE, ptr_type_node,
+			        tree_cons (NULL_TREE, integer_type_node,
+				           void_list_node)))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_strcpy =
+    builtin_function ("__bounds_check_strcpy",
+		      build_function_type (string_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, string_type_node,
+			      tree_cons (NULL_TREE, const_string_type_node,
+				         void_list_node))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_strncpy =
+    builtin_function ("__bounds_check_strncpy",
+		      build_function_type (string_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, string_type_node,
+			      tree_cons (NULL_TREE, const_string_type_node,
+			        tree_cons (NULL_TREE, sizetype,
+				           void_list_node)))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_strlen =
+    builtin_function ("__bounds_check_strlen",
+		      build_function_type (sizetype,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, const_string_type_node,
+			  	       void_list_node)))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_strcmp =
+    builtin_function ("__bounds_check_strcmp",
+		      build_function_type (integer_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, const_string_type_node,
+			      tree_cons (NULL_TREE, const_string_type_node,
+				         void_list_node))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_strncmp =
+    builtin_function ("__bounds_check_strncmp",
+		      build_function_type (integer_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, const_string_type_node,
+			      tree_cons (NULL_TREE, const_string_type_node,
+			        tree_cons (NULL_TREE, sizetype,
+				           void_list_node)))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_strcat =
+    builtin_function ("__bounds_check_strcat",
+		      build_function_type (string_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, string_type_node,
+			      tree_cons (NULL_TREE, const_string_type_node,
+				         void_list_node))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_strncat =
+    builtin_function ("__bounds_check_strncat",
+		      build_function_type (string_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, string_type_node,
+			      tree_cons (NULL_TREE, const_string_type_node,
+			        tree_cons (NULL_TREE, sizetype,
+				           void_list_node)))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_strpbrk =
+    builtin_function ("__bounds_check_strpbrk",
+		      build_function_type (string_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, const_string_type_node,
+			      tree_cons (NULL_TREE, const_string_type_node,
+				         void_list_node))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_strrchr =
+    builtin_function ("__bounds_check_strrchr",
+		      build_function_type (string_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, const_string_type_node,
+			      tree_cons (NULL_TREE, integer_type_node,
+				         void_list_node))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_rindex =
+    builtin_function ("__bounds_check_rindex",
+		      build_function_type (string_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, const_string_type_node,
+			      tree_cons (NULL_TREE, integer_type_node,
+				         void_list_node))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_strspn =
+    builtin_function ("__bounds_check_strspn",
+		      build_function_type (sizetype,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, const_string_type_node,
+			      tree_cons (NULL_TREE, const_string_type_node,
+				         void_list_node))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_strcspn =
+    builtin_function ("__bounds_check_strcspn",
+		      build_function_type (sizetype,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, const_string_type_node,
+			      tree_cons (NULL_TREE, const_string_type_node,
+			  	         void_list_node))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_strstr =
+    builtin_function ("__bounds_check_strstr",
+		      build_function_type (string_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, const_string_type_node,
+			      tree_cons (NULL_TREE, const_string_type_node,
+				         void_list_node))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_strtok =
+    builtin_function ("__bounds_check_strtok",
+		      build_function_type (string_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, string_type_node,
+			      tree_cons (NULL_TREE, const_string_type_node,
+				         void_list_node))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_strtok_r =
+    builtin_function ("__bounds_check_strtok_r",
+		      build_function_type (string_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, string_type_node,
+			      tree_cons (NULL_TREE, const_string_type_node,
+			        tree_cons (NULL_TREE,
+			          build_pointer_type (string_type_node),
+				           void_list_node)))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_strdup =
+    builtin_function ("__bounds_check_strdup",
+		      build_function_type (string_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, const_string_type_node,
+				       void_list_node)))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_strchr =
+    builtin_function ("__bounds_check_strchr",
+		      build_function_type (string_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, const_string_type_node,
+			      tree_cons (NULL_TREE, integer_type_node,
+				         void_list_node))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_index =
+    builtin_function ("__bounds_check_index",
+		      build_function_type (string_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, const_string_type_node,
+			      tree_cons (NULL_TREE, integer_type_node,
+				         void_list_node))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_strcoll =
+    builtin_function ("__bounds_check_strcoll",
+		      build_function_type (integer_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, const_string_type_node,
+			      tree_cons (NULL_TREE, const_string_type_node,
+				         void_list_node))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_strxfrm =
+    builtin_function ("__bounds_check_strxfrm",
+		      build_function_type (sizetype,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, string_type_node,
+			      tree_cons (NULL_TREE, const_string_type_node,
+			        tree_cons (NULL_TREE, sizetype,
+				           void_list_node)))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_strcasecmp =
+    builtin_function ("__bounds_check_strcasecmp",
+		      build_function_type (integer_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, const_string_type_node,
+			      tree_cons (NULL_TREE, const_string_type_node,
+				         void_list_node))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_strncasecmp =
+    builtin_function ("__bounds_check_strncasecmp",
+		      build_function_type (integer_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, const_string_type_node,
+			      tree_cons (NULL_TREE, const_string_type_node,
+			        tree_cons (NULL_TREE, sizetype,
+				           void_list_node)))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_memchr =
+    builtin_function ("__bounds_check_memchr",
+		      build_function_type (ptr_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, const_ptr_type_node,
+			      tree_cons (NULL_TREE, integer_type_node,
+			        tree_cons (NULL_TREE, sizetype,
+				           void_list_node)))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+  bounds_check_memccpy =
+    builtin_function ("__bounds_check_memccpy",
+		      build_function_type (ptr_type_node,
+			tree_cons (NULL_TREE, const_string_type_node,
+			  tree_cons (NULL_TREE, integer_type_node,
+			    tree_cons (NULL_TREE, ptr_type_node,
+			      tree_cons (NULL_TREE, const_ptr_type_node,
+			        tree_cons (NULL_TREE, integer_type_node,
+			          tree_cons (NULL_TREE, sizetype,
+				             void_list_node))))))),
+		      0, NOT_BUILT_IN, NULL, NULL);
+
+  bounds_private_statics =
+    build_decl (VAR_DECL, get_identifier ("__bounds_private_statics"),
+		build_array_type (char_type_node,
+				  build_index_type (integer_zero_node)));
+  TREE_STATIC (bounds_private_statics) = 1;
+  TREE_READONLY (bounds_private_statics) = 1;
+  TREE_ASM_WRITTEN (bounds_private_statics) = 1;	/* fake.  */
+  DECL_IN_SYSTEM_HEADER (bounds_private_statics) = 1;
+  DECL_IGNORED_P (bounds_private_statics) = 1;
+  DECL_INITIAL (bounds_private_statics) = NULL_TREE;
+  finish_decl (pushdecl (bounds_private_statics), NULL_TREE, NULL_TREE);
+
+}
+
+void
+bounds_register_decl (tree decl)
+{
+  if (!deferred_global_decls)
+    VARRAY_TREE_INIT (deferred_global_decls, 10, "deferred global list");
+
+  VARRAY_PUSH_TREE (deferred_global_decls, decl);
+}
+
+/* Build a file-scope function that gets called before main (). This function
+   calls the bounds checking library for all global variables in this file.
+   The function will look like this:
+  	__GLOBAL$I$main ()
+  	{
+  	  __bounds_initialize_library ();
+  	  __bounds_note_constructed_object (&p, 4, 4, ...);
+  	  ...
+  	}
+ */
+void
+bounds_build_static_constructors (void)
+{
+  tree decl, function_call, params[3];
+  int i, len = 0;
+  tree *vec = NULL;
+  tree ctor_statements = NULL_TREE;
+
+  bounds_checking_enabled = 0;
+
+  /* Get list of top-level named static declarations. The two other type of
+     static data, namely static variables in functions and unnamed static
+     data, are found and dealt with in `varasm.c'.  */
+  if (deferred_global_decls)
+    {
+      len = VARRAY_ACTIVE_SIZE (deferred_global_decls);
+      vec = (tree *) xmalloc (sizeof (tree) * len);
+      for (i = 0; i < len; i++)
+	vec[i] = VARRAY_TREE (deferred_global_decls, i);
+
+      bounds_external_declaration (vec, len);
+    }
+
+  /* Build the table of private static data. This code is in `varasm.c'. This
+     table is declared:
+     static unsigned *__bounds_private_statics;
+   */
+  bounds_assemble_private_statics_table ();
+
+  /* Build a call to initialize the library. This initialization function may
+     be called multiple times as a result. This doesn't matter.  */
+  function_call =
+    bounds_build_function_call ("__bounds_initialize_library",
+				bounds_initialize_library, params, 0);
+  append_to_statement_list (function_call, &ctor_statements);
+
+  /* Build a call to '__bounds_note_constructed_private_table'.  */
+  params[0] = build_c_cast (ptr_type_node,
+			    default_conversion (bounds_private_statics));
+  params[1] = build_current_filename ();
+  params[2] = build_current_lineno ();
+  function_call =
+    bounds_build_function_call ("__bounds_note_constructed_private_table",
+				bounds_note_constructed_private_table,
+				params, 3);
+  append_to_statement_list (function_call, &ctor_statements);
+
+  /* For each top-level declaration, build a constructor call if that is
+     what is required.  */
+  for (i = 0; i < len; ++i)
+    {
+      decl = vec[i];
+      if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl)
+	  /* Don't generate calls for __FUNCTION__ and __PRETTY_FUNCTION__.  */
+	  && !DECL_IN_SYSTEM_HEADER (decl)
+          && !check_fname_decl (decl))
+	{
+	  tree obj, type, ptr, size_exp, params[6], function_call, decl_name,
+	    alignment;
+
+	  /* Obtain a pointer to the object, its size and its alignment. For
+	     arrays, the alignment is the size of each element, and the size
+	     is the size of the whole array. For structs, unions, the alignment
+	     is always 1. Other data types in C are not aggregates, so the
+	     alignment is the same as the size.  */
+	  type = TREE_TYPE (decl);
+	  /* Just ignore static variables if the size hasn't been
+	     decided yet. Declarations like `char buff[];' at the top level
+	     cause this to happen.  */
+	  if (TREE_CODE (type) != ERROR_MARK && DECL_SIZE (decl) != 0)
+	    size_exp = size_binop (CEIL_DIV_EXPR,
+				   DECL_SIZE (decl), bitsize_unit_node);
+	  else
+	    {
+	      warning ("variable with no size will not be bounds checked");
+	      continue;
+	    }
+	  size_exp = build_c_cast (integer_type_node, size_exp);
+	  switch (TREE_CODE (type))
+	    {
+	    case ARRAY_TYPE:
+	      {
+		enum tree_code code;
+		ptr = bounds_pointer_from_array (decl);
+		code = TREE_CODE (TREE_TYPE (TREE_TYPE (ptr)));
+		if (code != RECORD_TYPE
+		    && code != UNION_TYPE && code != QUAL_UNION_TYPE)
+		  alignment = c_size_in_bytes (TREE_TYPE (TREE_TYPE (ptr)));
+		else
+		  alignment = integer_one_node;
+		ptr = build1 (ADDR_EXPR, build_pointer_type (type), decl);
+		break;
+	      }
+	    case RECORD_TYPE:
+	    case UNION_TYPE:
+	    case QUAL_UNION_TYPE:
+	      ptr = build1 (ADDR_EXPR, build_pointer_type (type), decl);
+	      alignment = integer_one_node;
+	      break;
+	    default:
+	      ptr = build1 (ADDR_EXPR, build_pointer_type (type), decl);
+	      alignment = size_exp;
+	      break;
+	    }
+
+	  decl_name =
+	    bounds_build_string (IDENTIFIER_POINTER (DECL_NAME (decl)));
+
+	  if (TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE)
+	    obj = NULL_TREE;
+	  else
+	    obj = find_object (decl);
+
+	  params[0] = build_c_cast (ptr_type_node, ptr);
+	  params[1] = size_exp;
+	  params[2] = alignment;
+	  params[3] = build_decl_filename (decl);
+	  params[4] = build_decl_lineno (decl);
+	  params[5] = decl_name;
+
+	  if (obj)
+	    function_call =
+	      build_modify_expr (obj, NOP_EXPR,
+		bounds_build_function_call ("__bounds_note_constructed_object",
+				            bounds_note_constructed_object,
+					    params, 6));
+	  else
+	    function_call =
+	      bounds_build_function_call ("__bounds_note_constructed_object",
+					  bounds_note_constructed_object,
+					  params, 6);
+
+	  /* Generate the code for this function call within this function.  */
+	  append_to_statement_list (function_call, &ctor_statements);
+
+	  if (POINTER_TYPE_P (TREE_TYPE (decl)) && DECL_INITIAL (decl))
+	    bounds_mark_for_runtime_check (decl);
+	}
+    }
+
+  if (static_ptr_init_list)
+    ctor_statements = check_static_pointer_initialization (ctor_statements);
+
+  cgraph_build_static_cdtor ('I', ctor_statements,
+			     MAX_RESERVED_INIT_PRIORITY - 1);
+
+  bounds_checking_enabled = 1;
+
+  if (deferred_global_decls)
+    {
+      free (vec);
+      VARRAY_CLEAR (deferred_global_decls);
+    }
+}
+
+/* Generate code to check static pointer initialisation involving pointer
+   arithmetic.  */
+
+static tree
+check_static_pointer_initialization (tree ctor_statements)
+{
+  int i, len;
+  tree decl, size_exp, binary_exp;
+  tree result_type;
+  unsigned HOST_WIDE_INT int_cst, offset, size;
+  tree init_exp;
+  int temp = bounds_checking_enabled;
+
+  len = VARRAY_ACTIVE_SIZE (static_ptr_init_list);
+  for (i = 0; i < len; i++)
+    {
+      decl = VARRAY_TREE (static_ptr_init_list, i);
+      init_exp = DECL_INITIAL (decl);
+      result_type = TREE_TYPE (TREE_OPERAND (init_exp, 0));
+      size_exp = c_size_in_bytes (TREE_TYPE (result_type));
+      size = TREE_INT_CST_LOW (size_exp);
+      int_cst = TREE_INT_CST_LOW (TREE_OPERAND (init_exp, 1));
+      offset = int_cst / size;
+      bounds_checking_enabled = 1;
+
+      binary_exp = build_binary_op (TREE_CODE (init_exp),
+				    TREE_OPERAND (init_exp, 0),
+				    build_int_cst (NULL_TREE, offset), 1);
+
+      bounds_checking_enabled = temp;
+      append_to_statement_list (binary_exp, &ctor_statements);
+    }
+  VARRAY_CLEAR (static_ptr_init_list);
+  return ctor_statements;
+}
+
+/* Declare `int __bounds_function_number_var;'  */
+static tree
+declare_function_number_var (void)
+{
+  tree decl;
+
+  bounds_checking_enabled = 0;
+  decl =
+    create_tmp_var_raw (integer_type_node, "__bounds_function_number_var");
+  pushdecl (decl);
+  finish_decl (decl, NULL_TREE, NULL_TREE);
+  bounds_checking_enabled = 1;
+
+  return decl;
+}
+
+/* Declare `void * (name_of_decl)_bounds_object;'  */
+static void
+declare_object_var (tree decl)
+{
+  tree new_decl;
+  tree init;
+  tree lookup_decl;
+  const char *name = IDENTIFIER_POINTER (DECL_NAME (decl));
+  char *newname;
+
+  newname = xmalloc (strlen ("_bounds_object") + strlen (name) + 1);
+  strcpy (newname, name);
+  strcat (newname, "_bounds_object");
+  /* This can happen when a global decl was defined external and later
+     static.  */
+  lookup_decl = maybe_get_identifier (newname);
+  if (lookup_decl && global_bindings_p ())
+    {
+      free (newname);
+      return;
+    }
+  bounds_checking_enabled = 0;
+  new_decl = build_decl (VAR_DECL, get_identifier (newname), ptr_type_node);
+  TREE_STATIC (new_decl) = global_bindings_p () ? 1 : 0;
+  TREE_USED (new_decl) = 1;
+  DECL_ARTIFICIAL (new_decl) = 1;
+  DECL_IGNORED_P (new_decl) = 1;
+  DECL_IN_SYSTEM_HEADER (new_decl) = 1;
+  init = build_c_cast (ptr_type_node, integer_zero_node);
+  DECL_INITIAL (new_decl) = init;
+  pushdecl (new_decl);
+  finish_decl (new_decl, init, NULL_TREE);
+  bounds_checking_enabled = 1;
+  free (newname);
+}
+
+static tree
+find_object (tree ptr)
+{
+  tree decl;
+  tree lookup_decl;
+  const char *name;
+  int newlen;
+  static char *newname = NULL;
+  static int len = 0;
+
+  if (TREE_CODE (ptr) != VAR_DECL
+      && TREE_CODE (ptr) != PARM_DECL
+      && (TREE_CODE (ptr) != ADDR_EXPR
+	  || (TREE_CODE (TREE_OPERAND (ptr, 0)) != VAR_DECL
+	      && TREE_CODE (TREE_OPERAND (ptr, 0)) != PARM_DECL)
+	  || TREE_CODE (TREE_TYPE (TREE_OPERAND (ptr, 0))) != ARRAY_TYPE))
+    return NULL_TREE;
+  if (TREE_CODE (ptr) == ADDR_EXPR)
+    name = IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (ptr, 0)));
+  else
+    name = IDENTIFIER_POINTER (DECL_NAME (ptr));
+  newlen = strlen ("_bounds_object") + strlen (name) + 1;
+  if (newlen > len)
+    {
+      if (newname == NULL)
+	newname = xmalloc (newlen);
+      else
+	newname = xrealloc (newname, newlen);
+      len = newlen;
+    }
+  strcpy (newname, name);
+  strcat (newname, "_bounds_object");
+  lookup_decl = maybe_get_identifier (newname);
+  if (lookup_decl == NULL_TREE)
+    decl = NULL_TREE;
+  else
+    {
+      decl = lookup_name (lookup_decl);
+    }
+  return decl;
+}
+
+static tree
+maybe_find_object (tree ptr)
+{
+  tree params[2];
+  tree result;
+  tree obj = find_object (ptr);
+
+  if (obj == NULL_TREE)
+    return build_c_cast (ptr_type_node, integer_zero_node);
+  bounds_checking_enabled = 0;
+#if 0
+  /* This generates less code but has allways a function call overhead.  */
+  params[0] = obj;
+  params[1] = build_c_cast (ptr_type_node, ptr);
+  result = build_modify_expr (obj, NOP_EXPR,
+			      bounds_build_function_call
+			      ("__bounds_maybe_find_object",
+			       bounds_maybe_find_object, params, 2));
+#else
+  /* This generates more code and has only sometimes a function call overhead.
+     We use this now because the compiler can optimize the conditional
+     expression.  */
+  params[0] = build_c_cast (ptr_type_node, ptr);
+  result = build_conditional_expr (build_binary_op (NE_EXPR, obj,
+						    build_c_cast (
+						      ptr_type_node,
+						      integer_zero_node), 1),
+				   obj,
+				   build_modify_expr (obj, NOP_EXPR,
+						      bounds_build_function_call
+						      ("__bounds_find_object",
+						       bounds_find_object,
+						       params, 1)));
+#endif
+  bounds_checking_enabled = 1;
+  return result;
+}
+
+static int
+check_fname_decl (tree decl)
+{
+  const char *name;
+
+  if (TREE_CODE (decl) == VAR_DECL && DECL_NAME (decl))
+    {
+      name = IDENTIFIER_POINTER (DECL_NAME (decl));
+      if (name
+	  && (strcmp (name, "__FUNCTION__") == 0
+              || strcmp (name, "__PRETTY_FUNCTION__") == 0
+              || strcmp (name, "__func__") == 0))
+        return 1;
+    }
+  return 0;
+}
+
+static void
+add_object (tree decl, enum tree_code type)
+{
+  /* For every pointer, array, record or union variable create a shadow:
+     (name_of_decl)_bounds_object variable.
+     Don't check __FUNCTION__ and __PRETTY_FUNCTION__.  */
+  if (optimize > 2		/* Only do this for -O3 and higher.  */
+      && TREE_CODE (decl) == type && !DECL_IN_SYSTEM_HEADER (decl)
+      && !check_fname_decl (decl)
+      /* Allowing pointer in global_bindings_p could cause problems
+         when the pointer is used in more then one file. The variable
+         '(name_of_decl)_bounds_object' is declated not public in both files
+         and can now point to different objects.
+         This also gives problems when one file is compiled with
+         bounds checking and other files not.  */
+      && ((TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE
+	   && (!global_bindings_p () || !TREE_PUBLIC (decl)))
+	  || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE
+	  || TREE_CODE (TREE_TYPE (decl)) == RECORD_TYPE
+	  || TREE_CODE (TREE_TYPE (decl)) == UNION_TYPE))
+    declare_object_var (decl);
+}
+
+/* Store all static pointer decls initialised using pointer arithmetic.
+   static_ptr_init_list is the list of these decls
+   This is because the pointer arithmetic cannot be checked
+   during compile time since the initial value of a static variable
+   has to be constant. We generate the relevant checking codes later in
+   bounds_build_static_constructors after initialising the checking library.  */
+
+void
+bounds_mark_for_runtime_check (tree decl)
+{
+  tree init_exp = DECL_INITIAL (decl);
+  int temp = bounds_checking_enabled;
+
+  bounds_checking_enabled = 1;
+  if (init_exp
+      && (TREE_CODE (init_exp) == PLUS_EXPR
+	  || TREE_CODE (init_exp) == MINUS_EXPR))
+    {
+      if (!static_ptr_init_list)
+        VARRAY_TREE_INIT (static_ptr_init_list, 10, "static pointer init list");
+
+      VARRAY_PUSH_TREE (static_ptr_init_list, decl);
+    }
+
+  bounds_checking_enabled = temp;
+}
+
+/* DECL is either a static or automatic local variable. Build a constructor
+   function for it so that when it comes into scope, it is added to our
+   list of valid objects. The constructor takes the form of a variable
+   initializer, and there may already be an initializer for this variable,
+   so we must alter the old initializer, if present, so it has the side
+   effect of calling the constructor. So,
+   if there is an initializer already, form the expression:
+  	__bounds_add_stack_object (...), old_initializer
+   else if there isn't, for the expression:
+  	__bounds_add_stack_object (...), 0
+   This has the unfortunate side effect of initializing non-initialized
+   variables to zero, but I can't see how to avoid that.  */
+void
+bounds_frig_decl_initial (tree decl)
+{
+  tree type, decl_name, size_exp, ptr, alignment, params[7], fn_call;
+  tree cleanup_expr;
+  enum tree_code code;
+  int addressable = TREE_ADDRESSABLE (decl);
+
+  add_object (decl, VAR_DECL);
+
+  if (global_bindings_p ()
+      || TREE_CODE (decl) != VAR_DECL || DECL_EXTERNAL (decl))
+    return;
+
+  /* Do not add empty declarations.  */
+  if (DECL_SIZE (decl)
+      && TREE_CODE (DECL_SIZE (decl)) == INTEGER_CST
+      && TREE_INT_CST_LOW (DECL_SIZE (decl)) == 0
+      && TREE_INT_CST_HIGH (DECL_SIZE (decl)) == 0)
+    return;
+
+  /* A static variable declared in a function can't have its DECL_INITIAL
+     modified with a non-constant function call. We catch such variables
+     in varasm.c:make_decl_rtl instead, so forget about them for now.  */
+  if (TREE_STATIC (decl)
+      || (DECL_INITIAL (decl)
+	  && TREE_CODE (DECL_INITIAL (decl)) == CONSTRUCTOR))
+    return;
+
+  type = TREE_TYPE (decl);
+  code = TREE_CODE (type);
+
+  /* Form the parameters for the call to __bounds_add_stack_object ().  */
+  decl_name = bounds_build_string (IDENTIFIER_POINTER (DECL_NAME (decl)));
+  size_exp = c_size_in_bytes (type);
+  switch (TREE_CODE (type))
+    {
+    case ARRAY_TYPE:
+      {
+	enum tree_code type_code;
+	ptr = bounds_pointer_from_array (decl);
+	type_code = TREE_CODE (TREE_TYPE (TREE_TYPE (ptr)));
+	if (type_code != RECORD_TYPE
+	    && type_code != UNION_TYPE && type_code != QUAL_UNION_TYPE)
+	  alignment = c_size_in_bytes (TREE_TYPE (TREE_TYPE (ptr)));
+	else
+	  alignment = integer_one_node;
+	ptr = build1 (ADDR_EXPR, build_pointer_type (type), decl);
+	break;
+      }
+    case RECORD_TYPE:
+    case UNION_TYPE:
+    case QUAL_UNION_TYPE:
+      ptr = build1 (ADDR_EXPR, build_pointer_type (type), decl);
+      alignment = integer_one_node;
+      break;
+    default:
+      ptr = build1 (ADDR_EXPR, build_pointer_type (type), decl);
+      alignment = size_exp;
+      break;
+    }
+
+  params[0] = build_c_cast (ptr_type_node, ptr);
+  params[1] = size_exp;
+  params[2] = alignment;
+  params[3] = build_decl_filename (decl);
+  params[4] = build_decl_lineno (decl);
+  params[5] = decl_name;
+  params[6] = current_function_bounds_nr;
+
+  fn_call = bounds_build_function_call ("__bounds_add_stack_object",
+				        bounds_add_stack_object, params, 7);
+
+  if (!AGGREGATE_TYPE_P (type)
+      && DECL_INITIAL (decl) && DECL_INITIAL (decl) != error_mark_node)
+    { 
+      tree old_init_expr = DECL_INITIAL (decl);
+      tree new_init_expr = build_compound_expr (fn_call, old_init_expr);
+
+      DECL_INITIAL (decl) = bounds_check_assignment (new_init_expr,
+                                                     decl, old_init_expr);
+    }
+  else
+    {
+      add_stmt (fn_call);
+      if (AGGREGATE_TYPE_P (type))
+	addressable = 1;
+    }
+  TREE_ADDRESSABLE (decl) = addressable;
+
+  /* Normally disable this because it requires the code to be C++ compatible. 
+     Enable this only for types with have not an integer size. 
+     For example:
+     int n = 10;
+     int s[n];
+     variable s has not an integer size here.  */
+
+  if (type != error_mark_node && COMPLETE_TYPE_P (TREE_TYPE (decl))
+      && (TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST
+	  || C_DECL_VARIABLE_SIZE (decl)))
+    {
+      params[0] = build_c_cast (ptr_type_node, ptr);
+      params[1] = maybe_find_object (ptr);
+      params[2] = current_function_bounds_nr;
+      cleanup_expr =
+	bounds_build_function_call ("__bounds_delete_stack_object",
+				    bounds_delete_stack_object, params, 3);
+      push_cleanup (decl, cleanup_expr, false);
+      TREE_ADDRESSABLE (decl) = addressable;
+    }
+}
+
+#ifdef __GNUC__
+__inline
+#endif
+const char *bounds_func_lookup (const char *str, unsigned int len);
+
+static int
+locate_var_in_tree (tree node, const char *name)
+{
+  int i;
+  int len;
+  tree save;
+
+  if (node)
+    switch (TREE_CODE_CLASS (TREE_CODE (node)))
+      {
+      case tcc_declaration:
+	if (TREE_CODE (node) == FUNCTION_DECL)
+	  return 1;
+	if (DECL_NAME (node)
+	    && strcmp (IDENTIFIER_POINTER (DECL_NAME (node)), name) == 0)
+	  return 1;
+	if (locate_var_in_tree (DECL_ARGUMENTS (node), name)
+	    || locate_var_in_tree (DECL_RESULT_FLD (node), name))
+	  return 1;
+	save = DECL_INITIAL (node);
+	DECL_INITIAL (node) = NULL_TREE;
+	i = locate_var_in_tree (save, name);
+	DECL_INITIAL (node) = save;
+	return i;
+      case tcc_type:
+	break;
+      case tcc_expression:
+      case tcc_comparison:
+      case tcc_unary:
+      case tcc_binary:
+      case tcc_reference:
+      case tcc_statement:
+	if (TREE_CODE (node) == CALL_EXPR)
+	  {
+	    if (TREE_CODE (TREE_OPERAND (node, 0)) == ADDR_EXPR
+		&& TREE_CODE (TREE_OPERAND (TREE_OPERAND (node, 0), 0))
+		== FUNCTION_DECL)
+	      {
+		const char *fn_name =
+		  IDENTIFIER_POINTER (DECL_NAME
+				      (TREE_OPERAND
+				       (TREE_OPERAND (node, 0), 0)));
+		if (!bounds_func_lookup (fn_name, strlen (fn_name)))
+		  return 1;
+	      }
+	    else
+	      return 1;
+	  }
+	len = TREE_CODE_LENGTH (TREE_CODE (node));
+	for (i = 0; i < len; i++)
+	  if (locate_var_in_tree (TREE_OPERAND (node, i), name))
+	    return 1;
+	break;
+      case tcc_constant:
+	break;
+      case tcc_exceptional:
+	switch (TREE_CODE (node))
+	  {
+	  case TREE_LIST:
+	    return locate_var_in_tree (TREE_PURPOSE (node), name)
+	      || locate_var_in_tree (TREE_VALUE (node), name)
+	      || locate_var_in_tree (TREE_CHAIN (node), name);
+	  case TREE_VEC:
+	    len = TREE_VEC_LENGTH (node);
+	    for (i = 0; i < len; i++)
+	      if (TREE_VEC_ELT (node, i)
+		  && locate_var_in_tree (TREE_VEC_ELT (node, i), name))
+		return 1;
+	    break;
+	  case BLOCK:
+	    return locate_var_in_tree (BLOCK_VARS (node), name)
+	      || locate_var_in_tree (BLOCK_SUBBLOCKS (node), name)
+	      || locate_var_in_tree (BLOCK_ABSTRACT_ORIGIN (node), name);
+	  case STATEMENT_LIST:
+	    {
+	      tree_stmt_iterator i;
+              for (i = tsi_start (node); !tsi_end_p (i); tsi_next (&i))
+                if (locate_var_in_tree (*tsi_stmt_ptr (i), name))
+		  return 1;
+	    }
+	    break;
+	  default:
+	    break;
+	  }
+	break;
+      }
+  return 0;
+}
+
+static int
+is_deletable (int type, tree op)
+{
+  int fntype;
+  const char *fn_name;
+
+  fn_name = IDENTIFIER_POINTER (DECL_NAME (TREE_OPERAND (
+					     TREE_OPERAND (op, 0), 0)));
+  if (type == 2)
+    {
+      if (strcmp (fn_name, "__bounds_push_function") == 0 ||
+          strcmp (fn_name, "__bounds_pop_function") == 0)
+	return 1;
+      return -1;
+    }
+  if (strcmp (fn_name, "__bounds_add_param_object") == 0)
+    fntype = 1;
+  else if (strcmp (fn_name, "__bounds_add_stack_object") == 0)
+    fntype = 2;
+  else if (strcmp (fn_name, "__bounds_delete_stack_object") == 0)
+    fntype = 2;
+  else
+    return -1;
+
+  op = TREE_VALUE ( TREE_OPERAND (op, 1));
+  STRIP_NOPS (op);
+  if (TREE_CODE (op) == ADDR_EXPR)
+    {
+      op = TREE_OPERAND (op, 0);
+      if (TREE_ADDRESSABLE (op) == 0
+          && ((fntype == 1 && TREE_CODE (op) == PARM_DECL)
+              || (fntype == 2 && TREE_CODE (op) == VAR_DECL)))
+	    return 1;
+    }
+  return 0;
+}
+
+static int
+bounds_remove_calls (tree *node, int type, int *pdelete)
+{
+  int i;
+  int len;
+  int count = 0;
+  int delete = 0;
+  tree save;
+
+again:
+  if (*node)
+    switch (TREE_CODE_CLASS (TREE_CODE (*node)))
+      {
+      case tcc_declaration:
+	if (TREE_CODE (*node) == FUNCTION_DECL)
+	  break;
+	count += bounds_remove_calls (&DECL_ARGUMENTS (*node), type, &delete);
+	save = DECL_INITIAL (*node);
+	DECL_INITIAL (*node) = NULL_TREE;
+	count += bounds_remove_calls (&save, type, &delete);
+	DECL_INITIAL (*node) = save;
+	count += bounds_remove_calls (&DECL_RESULT_FLD (*node), type, &delete);
+	break;
+      case tcc_type:
+	break;
+      case tcc_expression:
+      case tcc_comparison:
+      case tcc_unary:
+      case tcc_binary:
+      case tcc_reference:
+      case tcc_statement:
+	if (TREE_CODE (*node) == CALL_EXPR)
+	  {
+	    if (TREE_CODE (TREE_OPERAND (*node, 0)) == ADDR_EXPR
+		&& TREE_CODE (TREE_OPERAND (TREE_OPERAND (*node, 0), 0))
+		== FUNCTION_DECL)
+	      {
+		switch (is_deletable (type, *node)) {
+		case 0:
+		  count++;
+		  break;
+		case 1:
+		  *pdelete = 1;
+		  break;
+		default:
+		  break;
+		}
+	      }
+	    break;
+	  }
+	len = TREE_CODE_LENGTH (TREE_CODE (*node));
+	for (i = 0; i < len; i++)
+	  {
+	    count += bounds_remove_calls (&TREE_OPERAND (*node, i), type,
+					  &delete);
+	    if (delete)
+	      {
+		delete = 0;
+		/* __bounds_delete_stack_object
+		   __bounds_pop_function  */
+		if (TREE_CODE (*node) == TRY_FINALLY_EXPR)
+		  {
+		    *node = TREE_OPERAND (*node, 0);
+		    goto again;
+		  }
+		/* __bounds_push_function  */
+		else if (TREE_CODE (*node) == MODIFY_EXPR)
+		  {
+		    *pdelete = 1;
+		    break;
+		  }
+		/* __bounds_add_stack_object  */
+		else if (TREE_CODE (*node) == COMPOUND_EXPR)
+		  {
+		    *node = TREE_OPERAND (*node, 1);
+		    goto again;
+		  }
+		else
+		  abort ();
+	      }
+	  }
+	break;
+      case tcc_constant:
+	break;
+      case tcc_exceptional:
+	switch (TREE_CODE (*node))
+	  {
+	  case TREE_LIST:
+	    count += bounds_remove_calls (&TREE_PURPOSE (*node), type, &delete);
+	    count += bounds_remove_calls (&TREE_VALUE (*node), type, &delete);
+	    count += bounds_remove_calls (&TREE_CHAIN (*node), type, &delete);
+	    break;
+	  case TREE_VEC:
+	    len = TREE_VEC_LENGTH (*node);
+	    for (i = 0; i < len; i++)
+	      if (TREE_VEC_ELT (*node, i))
+		count += bounds_remove_calls (&TREE_VEC_ELT (*node, i), type,
+					      &delete);
+	    break;
+	  case BLOCK:
+	    count += bounds_remove_calls (&BLOCK_VARS (*node), type, &delete);
+	    count += bounds_remove_calls (&BLOCK_SUBBLOCKS (*node), type,
+					  &delete);
+	    count += bounds_remove_calls (&BLOCK_ABSTRACT_ORIGIN (*node), type,
+					  &delete);
+	    break;
+	  case STATEMENT_LIST:
+	    {
+	      tree_stmt_iterator i;
+
+              for (i = tsi_start (*node); !tsi_end_p (i); )
+		{
+                  count += bounds_remove_calls (tsi_stmt_ptr (i), type,
+						&delete);
+		  if (delete)
+		    {
+		      /* __bounds_push_function
+		         __bounds_add_param_object
+		         __bounds_add_stack_object  */
+		      delete = 0;
+		      tsi_delink (&i); 
+		    }
+	          else
+		    tsi_next (&i);
+		}
+	    }
+	    break;
+	  default:
+	    break;
+	  }
+	break;
+      }
+  return count;
+}
+
+/* This is the section where we attempt to optimize calls to
+  	__bounds_push_function
+  	__bounds_pop_function
+  	__bounds_add_param_object
+  	__bounds_add_stack_object
+  	__bounds_delete_stack_object
+   We cannily observe that if the address of a local variable or local
+   parameter is not taken (with '&') then there is no need recording
+   it in the tree. But we can't determine this until the whole function has
+   been parsed, so we have to delete these calls later on to optimize them.
+   In the first pass, we delete calls to `__bounds_add_stack_object',
+   `__bounds_delete_stack_object' and `__bounds_add_param_object' if they
+   are redundant (if the VAR_DECL is not addressed).
+   In the second pass, we delete calls to `__bounds_push_function' and
+   `__bounds_pop_function' is no calls to add parameters remain in the
+   function.  */
+
+void
+bounds_delete_redundant_calls (tree fndecl)
+{
+  int delete = 0;
+
+  if (bounds_remove_calls (&DECL_SAVED_TREE (fndecl), 1, &delete) == 0
+      && !current_function_calls_setjmp
+      && !current_function_has_nonlocal_label
+      && !current_function_has_nonlocal_goto
+      && !current_function_calls_alloca) 
+    bounds_remove_calls (&DECL_SAVED_TREE (fndecl), 2, &delete);
+}
+
+static tree
+generate_assignment (tree result, tree lobj, tree robj)
+{
+  tree tmpvar, tmp, new;
+
+  bounds_checking_enabled = 0;
+  if (robj == NULL_TREE)
+    new = build_modify_expr (lobj, NOP_EXPR, build_c_cast (ptr_type_node,
+							   integer_zero_node));
+  else
+    new = build_modify_expr (lobj, NOP_EXPR, robj);
+  /* If the object is allready used in the tree. We must use a temporary
+     variable and use the construct:
+     tmpvar = result, lobj = robj, tmpvar
+     If the object is not used we can use the simpler construct:
+     lobj = robj, result.  */
+  if (locate_var_in_tree (result, IDENTIFIER_POINTER (DECL_NAME (lobj))))
+    {
+      tmpvar = create_tmp_var_raw (TREE_TYPE (result), "__bounds_tmp");
+      TREE_READONLY (TREE_TYPE (tmpvar)) = 0;
+      TREE_READONLY (tmpvar) = 0;
+      pushdecl (tmpvar);
+      finish_decl (tmpvar, NULL_TREE, NULL_TREE);
+      /* Build expression : "tmpvar = result, lobj = robj, tmpvar"  */
+      tmp = build_modify_expr (tmpvar, NOP_EXPR, result);
+      result = build_compound_expr (build_compound_expr (tmp, new), tmpvar);
+    }
+  else
+    {
+      /* Build expression : "lobj = robj, result"  */
+      result = build_compound_expr (new, result);
+    }
+  bounds_checking_enabled = 1;
+  return result;
+}
+
+/* When building a unary '&' operator, we normally perform the identities
+   &x[y] == x + y and so on. We cannot do this with bounds checking, since
+   we may already have expanded the array reference into a call to the
+   bounds checking library. So we need to extend the patterns recognized
+   here.
+  
+   #	FORM	PATTERN						RETURN
+   1	&*p	*(type *)__bounds_check_reference (p, ...)	p
+   2	&x[y]	x[__bounds_check_array_ref (x, y, ...)]		x+y
+   3	&p->e	(*(type *)__bounds_check_comp_ref (p, ...)).e	p+offset (e)
+ */
+tree
+bounds_cancel_address_expr (tree exp)
+{
+  tree obj = NULL_TREE;
+
+  if (exp)
+    obj = find_object (exp);
+
+  if (exp
+      && TREE_CODE (exp) == INDIRECT_REF
+      && (TREE_CODE (TREE_OPERAND (exp, 0)) == CONVERT_EXPR
+	  || TREE_CODE (TREE_OPERAND (exp, 0)) == NOP_EXPR)
+      && TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)) == CALL_EXPR)
+    {
+      /* Could be pattern #1. Find the name of the function being
+         called here.  */
+      tree call_expr = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);
+      const char *fn_name =
+	IDENTIFIER_POINTER (DECL_NAME
+			    (TREE_OPERAND (TREE_OPERAND (call_expr, 0), 0)));
+      const char *newname = NULL;
+      const char *newname_obj = NULL;
+      tree tnewname = NULL;
+      tree tnewname_obj = NULL;
+
+      if (fn_name[0] == '_' && fn_name[1] == '_'
+	  && fn_name[2] == 'b' && fn_name[3] == 'o')
+	{
+	  if (strcmp (fn_name, "__bounds_check_reference") == 0)
+	    {
+	      tree arg1 =
+		TREE_VALUE (TREE_CHAIN (TREE_OPERAND (call_expr, 1)));
+
+	      /* This is pattern #1.  */
+	      if (obj)
+		arg1 = generate_assignment (arg1, obj, NULL_TREE);
+	      return build_c_cast (TREE_TYPE (TREE_OPERAND (exp, 0)), arg1);
+	    }
+	  else if (strcmp (fn_name, "__bounds_check_reference_obj") == 0)
+	    {
+	      tree arg0 = TREE_VALUE (TREE_OPERAND (call_expr, 1));
+
+	      /* This is pattern #1.  */
+	      if (obj)
+		arg0 = generate_assignment (arg0, obj, NULL_TREE);
+	      return build_c_cast (TREE_TYPE (TREE_OPERAND (exp, 0)), arg0);
+	    }
+	  else if (strcmp (fn_name, "__bounds_check_ptr_postinc_ref") == 0)
+	    {
+	      newname = "__bounds_check_ptr_postinc";
+	      tnewname = bounds_check_ptr_postinc;
+	    }
+	  else if (strcmp (fn_name, "__bounds_check_ptr_postinc_ref_obj") ==
+		   0)
+	    {
+	      newname_obj = "__bounds_check_ptr_postinc_obj";
+	      tnewname_obj = bounds_check_ptr_postinc_obj;
+	    }
+	  else if (strcmp (fn_name, "__bounds_check_ptr_preinc_ref") == 0)
+	    {
+	      newname = "__bounds_check_ptr_preinc";
+	      tnewname = bounds_check_ptr_preinc;
+	    }
+	  else if (strcmp (fn_name, "__bounds_check_ptr_preinc_ref_obj") == 0)
+	    {
+	      newname_obj = "__bounds_check_ptr_preinc_obj";
+	      tnewname_obj = bounds_check_ptr_preinc_obj;
+	    }
+	  else if (strcmp (fn_name, "__bounds_check_ptr_postdec_ref") == 0)
+	    {
+	      newname = "__bounds_check_ptr_postdec";
+	      tnewname = bounds_check_ptr_postdec;
+	    }
+	  else if (strcmp (fn_name, "__bounds_check_ptr_postdec_ref_obj") ==
+		   0)
+	    {
+	      newname_obj = "__bounds_check_ptr_postdec_obj";
+	      tnewname_obj = bounds_check_ptr_postdec_obj;
+	    }
+	  else if (strcmp (fn_name, "__bounds_check_ptr_predec_ref") == 0)
+	    {
+	      newname = "__bounds_check_ptr_predec";
+	      tnewname = bounds_check_ptr_predec;
+	    }
+	  else if (strcmp (fn_name, "__bounds_check_ptr_predec_ref_obj") == 0)
+	    {
+	      newname_obj = "__bounds_check_ptr_predec_obj";
+	      tnewname_obj = bounds_check_ptr_predec_obj;
+	    }
+	  if (newname || newname_obj)
+	    {
+	      tree arg0 = TREE_OPERAND (call_expr, 1);
+	      tree arg1 = TREE_CHAIN (arg0);
+	      tree arg2 = TREE_CHAIN (arg1);
+	      tree arg3 = TREE_CHAIN (arg2);
+	      tree arg4 = newname ? TREE_CHAIN (arg3) : NULL_TREE;
+	      tree r_expr, params[5];
+
+	      params[0] = TREE_VALUE (arg0);
+	      params[1] = TREE_VALUE (arg1);
+	      params[2] = TREE_VALUE (arg2);
+	      params[3] = TREE_VALUE (arg3);
+	      params[4] = newname ? TREE_VALUE (arg4) : NULL_TREE;
+	      if (newname)
+		r_expr = bounds_build_function_call (newname, tnewname,
+						     params, 5);
+	      else
+		r_expr = bounds_build_function_call (newname_obj, tnewname_obj,
+						     params, 4);
+
+	      if (obj)
+		r_expr = generate_assignment (r_expr, obj, NULL_TREE);
+	      return build_c_cast (TREE_TYPE (TREE_OPERAND (exp, 0)), r_expr);
+	    }
+	}
+    }
+  else if (exp
+	   && TREE_CODE (exp) == ARRAY_REF
+	   && TREE_CODE (TREE_OPERAND (exp, 1)) == CALL_EXPR)
+    {
+      /* Could be pattern #2. Find the name of the function being
+         called here.  */
+      tree call_expr = TREE_OPERAND (exp, 1);
+      const char *fn_name =
+	IDENTIFIER_POINTER (DECL_NAME
+			    (TREE_OPERAND (TREE_OPERAND (call_expr, 0), 0)));
+      if (fn_name[0] == '_' && fn_name[1] == '_' && fn_name[2] == 'b'
+	  && fn_name[3] == 'o')
+	{
+	  if (strcmp (fn_name, "__bounds_check_array_reference") == 0)
+	    {
+	      /* This is pattern #2. Return expression for `arg1 + arg2'. We
+	         still want this to be checked ...  */
+	      tree arg1 =
+		TREE_VALUE (TREE_CHAIN (TREE_OPERAND (call_expr, 1)));
+	      tree arg2 =
+		TREE_VALUE (TREE_CHAIN
+			    (TREE_CHAIN (TREE_OPERAND (call_expr, 1))));
+	      tree atype = bounds_pointer_from_array_ref (exp);
+	      tree r_expr = build_binary_op (PLUS_EXPR,
+					     build_c_cast (atype, arg1),
+					     arg2, 1);
+
+	      if (obj)
+		r_expr = generate_assignment (r_expr, obj, NULL_TREE);
+	      return r_expr;
+	    }
+	  else if (strcmp (fn_name, "__bounds_check_array_reference_obj") ==
+		   0)
+	    {
+	      /* This is pattern #2. Return expression for `arg0 + arg1'. We
+	         still want this to be checked ...  */
+	      tree arg0 = TREE_VALUE (TREE_OPERAND (call_expr, 1));
+	      tree arg1 =
+		TREE_VALUE (TREE_CHAIN (TREE_OPERAND (call_expr, 1)));
+	      tree atype = bounds_pointer_from_array_ref (exp);
+	      tree r_expr = build_binary_op (PLUS_EXPR,
+					     build_c_cast (atype, arg0),
+					     arg1, 1);
+
+	      if (obj)
+		r_expr = generate_assignment (r_expr, obj, NULL_TREE);
+	      return r_expr;
+	    }
+	}
+    }
+  else if (exp
+	   && TREE_CODE (exp) == COMPONENT_REF
+	   && TREE_CODE (TREE_OPERAND (exp, 0)) == INDIRECT_REF
+	   && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))
+	       == CONVERT_EXPR
+	       || TREE_CODE (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))
+	       == NOP_EXPR)
+	   && TREE_CODE (TREE_OPERAND (TREE_OPERAND (TREE_OPERAND
+						     (exp, 0), 0), 0))
+	   == CALL_EXPR)
+    {
+      /* This is pattern #3. Return expression for `arg1 + offset (field)'.
+         Note that `arg0' is a pointer and `field' is a FIELD_DECL.
+         FIXME: This ought to be checked ...  */
+      tree call_expr = TREE_OPERAND (TREE_OPERAND (TREE_OPERAND
+						   (exp, 0), 0), 0);
+      const char *fn_name =
+	IDENTIFIER_POINTER (DECL_NAME
+			    (TREE_OPERAND (TREE_OPERAND (call_expr, 0), 0)));
+      tree field = TREE_OPERAND (exp, 1);
+      tree field_name = DECL_NAME (field);
+      tree r_expr;
+
+      if (fn_name[0] == '_' && fn_name[1] == '_'
+	  && fn_name[2] == 'b' && fn_name[3] == 'o')
+	{
+	  if (strcmp (fn_name, "__bounds_check_component_reference") == 0)
+	    {
+	      tree arg1 =
+		TREE_VALUE (TREE_CHAIN (TREE_OPERAND (call_expr, 1)));
+
+	      arg1 =
+		build_c_cast (TREE_TYPE
+			      (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)),
+			      arg1);
+	      bounds_checking_enabled = 0;
+	      r_expr = build_unary_op (ADDR_EXPR,
+				       build_component_ref (build_indirect_ref
+							    (arg1, "->"),
+							    field_name), 0);
+	      bounds_checking_enabled = 1;
+	      if (obj)
+		r_expr = generate_assignment (r_expr, obj, NULL_TREE);
+	      return r_expr;
+	    }
+	  else if (strcmp (fn_name, "__bounds_check_component_reference_obj")
+		   == 0)
+	    {
+	      tree arg0 = TREE_VALUE (TREE_OPERAND (call_expr, 1));
+
+	      arg0 =
+		build_c_cast (TREE_TYPE
+			      (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)),
+			      arg0);
+	      bounds_checking_enabled = 0;
+	      r_expr = build_unary_op (ADDR_EXPR,
+				       build_component_ref (build_indirect_ref
+							    (arg0, "->"),
+							    field_name), 0);
+	      bounds_checking_enabled = 1;
+	      if (obj)
+		r_expr = generate_assignment (r_expr, obj, NULL_TREE);
+	      return r_expr;
+	    }
+	}
+    }
+  else if (exp && obj)
+    {
+      tree r_exp;
+      bounds_checking_enabled = 0;
+      r_exp = build_unary_op (ADDR_EXPR, exp, 0);
+      bounds_checking_enabled = 1;
+      return generate_assignment (r_exp, obj, NULL_TREE);
+    }
+
+  /* No matching pattern. Return 0.  */
+  return NULL_TREE;
+}
+
+tree
+bounds_check_assignment (tree result, tree lhs, tree rhs)
+{
+  tree lobj = find_object (lhs);
+
+  if (lobj == NULL_TREE)
+    return result;
+  return generate_assignment (result, lobj, find_object (rhs));
+}
+
+tree
+bounds_build_reference (tree ptr)
+{
+  tree pointer = default_conversion (ptr);
+  tree type = TREE_TYPE (pointer), type_of_type = TREE_TYPE (type);
+  tree params[6], function_call;
+  enum tree_code code = TREE_CODE (TREE_TYPE (type));
+  tree size_exp = (code == FUNCTION_TYPE ||
+		   code == VOID_TYPE ||
+		   code == ERROR_MARK || TYPE_SIZE (TREE_TYPE (type)) != 0)
+    ? c_size_in_bytes (TREE_TYPE (type)) : size_int (0);
+  tree obj = maybe_find_object (ptr);
+  tree ptrptr = NULL_TREE, inc = 0;
+  const char *new = NULL;
+  const char *new_obj = NULL;
+  tree tnew = NULL;
+  tree tnew_obj = NULL;
+
+  if (TREE_CODE (type_of_type) != ARRAY_TYPE)
+    type_of_type = TYPE_MAIN_VARIANT (type_of_type);
+
+  if (ptr && (TREE_CODE (ptr) == CONVERT_EXPR || TREE_CODE (ptr) == NOP_EXPR)
+      && TREE_CODE (TREE_OPERAND (ptr, 0)) == CALL_EXPR)
+    {
+      tree call_expr = TREE_OPERAND (ptr, 0);
+      const char *fn_name =
+	IDENTIFIER_POINTER (DECL_NAME
+			    (TREE_OPERAND (TREE_OPERAND (call_expr, 0), 0)));
+
+      if (fn_name[0] == '_' && fn_name[1] == '_'
+	  && fn_name[2] == 'b' && fn_name[3] == 'o')
+	{
+	  if (strcmp (fn_name, "__bounds_check_ptr_postinc") == 0)
+	    {
+	      new = "__bounds_check_ptr_postinc_ref";
+	      tnew = bounds_check_ptr_postinc_ref;
+	      new_obj = "__bounds_check_ptr_postinc_ref_obj";
+	      tnew_obj = bounds_check_ptr_postinc_ref_obj;
+	    }
+	  else if (strcmp (fn_name, "__bounds_check_ptr_preinc") == 0)
+	    {
+	      new = "__bounds_check_ptr_preinc_ref";
+	      tnew = bounds_check_ptr_preinc_ref;
+	      new_obj = "__bounds_check_ptr_preinc_ref_obj";
+	      tnew_obj = bounds_check_ptr_preinc_ref_obj;
+	    }
+	  else if (strcmp (fn_name, "__bounds_check_ptr_postdec") == 0)
+	    {
+	      new = "__bounds_check_ptr_postdec_ref";
+	      tnew = bounds_check_ptr_postdec_ref;
+	      new_obj = "__bounds_check_ptr_postdec_ref_obj";
+	      tnew_obj = bounds_check_ptr_postdec_ref_obj;
+	    }
+	  else if (strcmp (fn_name, "__bounds_check_ptr_predec") == 0)
+	    {
+	      new = "__bounds_check_ptr_predec_ref";
+	      tnew = bounds_check_ptr_predec_ref;
+	      new_obj = "__bounds_check_ptr_predec_ref_obj";
+	      tnew_obj = bounds_check_ptr_predec_ref_obj;
+	    }
+	  if (new)
+	    {
+	      obj = TREE_VALUE (TREE_OPERAND (call_expr, 1));
+	      ptrptr = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (call_expr, 1)));
+	      inc =
+		TREE_VALUE (TREE_CHAIN
+			    (TREE_CHAIN (TREE_OPERAND (call_expr, 1))));
+	    }
+	  else
+	    {
+	      if (strcmp (fn_name, "__bounds_check_ptr_postinc_obj") == 0)
+		{
+		  new_obj = "__bounds_check_ptr_postinc_ref_obj";
+		  tnew_obj = bounds_check_ptr_postinc_ref_obj;
+		}
+	      else if (strcmp (fn_name, "__bounds_check_ptr_preinc_obj") == 0)
+		{
+		  new_obj = "__bounds_check_ptr_preinc_ref_obj";
+		  tnew_obj = bounds_check_ptr_preinc_ref_obj;
+		}
+	      else if (strcmp (fn_name, "__bounds_check_ptr_postdec_obj") ==
+		       0)
+		{
+		  new_obj = "__bounds_check_ptr_postdec_ref_obj";
+		  tnew_obj = bounds_check_ptr_postdec_ref_obj;
+		}
+	      else if (strcmp (fn_name, "__bounds_check_ptr_predec_obj") == 0)
+		{
+		  new_obj = "__bounds_check_ptr_predec_ref_obj";
+		  tnew_obj = bounds_check_ptr_predec_ref_obj;
+		}
+	      if (new_obj)
+		{
+		  ptrptr = TREE_VALUE (TREE_OPERAND (call_expr, 1));
+		  inc = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (call_expr, 1)));
+		}
+	    }
+	}
+    }
+
+  /* Build cast to correct pointer type, and reference it.  */
+  if (new_obj)
+    {
+      /* Build a call to new or new_obj. This returns the
+         pointer passed, which we then reference.  */
+      params[0] = obj;
+      params[1] = build_c_cast (ptr_type_node, ptrptr);
+      params[2] = inc;
+      params[3] = size_exp;
+      params[4] = build_current_filename ();
+      params[5] = build_current_lineno ();
+
+      if (new && TREE_CODE (obj) != INTEGER_CST)
+	function_call = bounds_build_function_call (new, tnew, params, 6);
+      else
+	function_call = bounds_build_function_call (new_obj, tnew_obj,
+						    &params[1], 5);
+
+      return build1 (INDIRECT_REF, type_of_type,
+		     build_c_cast (type, function_call));
+    }
+  else
+    {
+      /* Build a call to __bounds_check_reference. This returns the
+         pointer passed, which we then reference.  */
+      params[0] = obj;
+      params[1] = build_c_cast (ptr_type_node, ptr);
+      params[2] = size_exp;
+      params[3] = build_current_filename ();
+      params[4] = build_current_lineno ();
+
+      if (TREE_CODE (obj) == INTEGER_CST)
+	{
+	  function_call =
+	    bounds_build_function_call ("__bounds_check_reference_obj",
+					bounds_check_reference_obj,
+					&params[1], 4);
+	  return build1 (INDIRECT_REF, type_of_type,
+			 build_c_cast (type, function_call));
+	}
+      else
+	{
+	  function_call =
+	    bounds_build_function_call ("__bounds_check_reference",
+				        bounds_check_reference, params, 5);
+
+	  return build1 (INDIRECT_REF, type_of_type,
+			 build_c_cast (type, function_call));
+	}
+    }
+}
+
+static tree
+bounds_lookup_field (tree decl, tree component)
+{
+  tree type = TREE_TYPE (decl);
+  tree field;
+
+  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))
+    {
+      if (DECL_NAME (field) == NULL_TREE
+	  && (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE
+	      || TREE_CODE (TREE_TYPE (field)) == UNION_TYPE))
+	{
+	  tree anon = bounds_lookup_field (field, component);
+
+	  if (anon)
+	    return field;
+	}
+
+      if (DECL_NAME (field) == component)
+	break;
+    }
+
+  if (field == NULL_TREE)
+    return NULL_TREE;
+
+  return field;
+}
+
+/* This functions reduces the size in a __bounds_check_component_reference
+   or __bounds_check_component_reference_obj call. This can be done if
+   a expression like "p->d.a" is present. The size of the call we be
+   reduced from the size of p->d into the size of p->d.a. This is needed
+   if not the complete p->d structure is malloced. Which happens often
+   when the last element of a structure is an array.  */
+
+tree
+bounds_build_component_ref (tree datum, tree component)
+{
+  tree type = TREE_TYPE (datum);
+  enum tree_code code = TREE_CODE (type);
+  tree field;
+
+  if (TREE_CODE (datum) != COMPOUND_EXPR
+      && (code == RECORD_TYPE || code == UNION_TYPE)
+      && COMPLETE_TYPE_P (type)
+      && (field = bounds_lookup_field (datum, component))
+      && TREE_CODE (datum) == COMPONENT_REF
+      && TREE_CODE (TREE_OPERAND (datum, 0)) == INDIRECT_REF
+      && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (datum, 0), 0)) ==
+	  CONVERT_EXPR
+	  || TREE_CODE (TREE_OPERAND (TREE_OPERAND (datum, 0), 0)) ==
+	  NOP_EXPR)
+      &&
+      TREE_CODE (TREE_OPERAND (TREE_OPERAND (TREE_OPERAND (datum, 0), 0), 0))
+      == CALL_EXPR)
+    {
+      tree call_expr = TREE_OPERAND (TREE_OPERAND (TREE_OPERAND
+						   (datum, 0), 0), 0);
+      const char *fn_name =
+	IDENTIFIER_POINTER (DECL_NAME
+			    (TREE_OPERAND (TREE_OPERAND (call_expr, 0), 0)));
+      tree size_exp = c_size_in_bytes (TREE_TYPE (field));
+
+      if (fn_name[0] == '_' && fn_name[1] == '_'
+	  && fn_name[2] == 'b' && fn_name[3] == 'o')
+	{
+	  if (strcmp (fn_name, "__bounds_check_component_reference") == 0)
+	    {
+	      TREE_VALUE (TREE_CHAIN
+			  (TREE_CHAIN
+			   (TREE_CHAIN (TREE_OPERAND (call_expr, 1))))) =
+		size_exp;
+	    }
+	  else if (strcmp (fn_name, "__bounds_check_component_reference_obj")
+		   == 0)
+	    {
+	      TREE_VALUE (TREE_CHAIN
+			  (TREE_CHAIN (TREE_OPERAND (call_expr, 1)))) =
+		size_exp;
+	    }
+	}
+    }
+  return build_component_ref (datum, component);
+}
+
+tree
+bounds_build_component_indirect_ref (tree pointer, tree component)
+{
+  /* Generate correct code for 'p->component' expressions. The expression
+     built looks like this:
+     *(type *)
+     (__bounds_check_component_reference (p, offsetof (component), ...))
+     . component
+   */
+  tree params[6], function_call, obj;
+  tree type, type_of_type;
+  tree ref_exp, offset_exp, size_exp;
+
+  /* Find the size and offset of the FIELD_DECL for component. Note that
+     ref_exp            p->e
+     size_exp   sizeof (p->e)
+
+     #define Offset(p_type,field) ((int)&(((p_type)NULL)->field))
+     offset_exp = Offset(type(ref_exp),component)
+   */
+  bounds_checking_enabled = 0;
+  ref_exp = build_component_ref (build_indirect_ref (pointer, "->"),
+				 component);
+  if (ref_exp == error_mark_node)
+    {
+      bounds_checking_enabled = 1;
+      return error_mark_node;
+    }
+
+  /* We cannot check bit field components.  */
+  if (TREE_CODE (ref_exp) == COMPONENT_REF
+      && DECL_BIT_FIELD (TREE_OPERAND (ref_exp, 1)))
+    {
+      bounds_checking_enabled = 1;
+      return ref_exp;
+    }
+
+  /* Don't check array references because some users have the following
+     code:
+
+     struct { int a[10]; } *q;
+
+     q = malloc (5 * sizeof(int));
+     q->a[4] = 0;
+
+     __bounds_check_array_reference will check the array reference
+     correctly.  */
+  if (TREE_CODE (ref_exp) == COMPONENT_REF
+      && TREE_CODE (TREE_TYPE (ref_exp)) == ARRAY_TYPE)
+    {
+      bounds_checking_enabled = 1;
+      return ref_exp;
+    }
+
+  /* Handle a struct / union of arrays such as used in varray.h. If all
+     elemants are arrays then we let __bounds_check_array_reference do
+     the check.  */
+  if (TREE_CODE (ref_exp) == COMPONENT_REF
+      && (TREE_CODE (TREE_TYPE (ref_exp)) == RECORD_TYPE
+	  || TREE_CODE (TREE_TYPE (ref_exp)) == UNION_TYPE))
+    {
+      tree x = TREE_TYPE (ref_exp);
+      for (x = TYPE_FIELDS (x); x != NULL_TREE; x = TREE_CHAIN (x))
+	if (TREE_CODE (TREE_TYPE (x)) != ARRAY_TYPE)
+	  break;
+      if (x == NULL_TREE)
+	{
+	  bounds_checking_enabled = 1;
+	  return ref_exp;
+	}
+    }
+
+  /* Handle size_of (bitfields) special because the function
+     c_size_in_bytes can not handle them.  */
+  if (TREE_CODE (ref_exp) == COMPONENT_REF
+      && TREE_CODE (TREE_OPERAND (ref_exp, 1)) == FIELD_DECL)
+    {
+      if (DECL_C_BIT_FIELD (TREE_OPERAND (ref_exp, 1)) == 0)
+	size_exp = c_size_in_bytes (TREE_TYPE (ref_exp));
+      else
+	{
+	  size_exp = DECL_SIZE (TREE_OPERAND (ref_exp, 1));
+	  size_exp = size_binop (CEIL_DIV_EXPR, size_exp, bitsize_unit_node);
+	  force_fit_type (size_exp, 0, false, false);
+	}
+    }
+  else
+    size_exp = c_size_in_bytes (TREE_TYPE (ref_exp));
+
+  /* If `type' points to an array, turn it into a pointer to the
+     first element.  */
+  type = default_conversion (TREE_TYPE (pointer));
+
+  if (TREE_CODE (type) == ARRAY_TYPE)
+    type = bounds_pointer_from_array_type (type);
+
+  bounds_disable_field_check = 1;
+  offset_exp = build_c_cast (integer_type_node,
+			     build_unary_op (ADDR_EXPR,
+					     build_component_ref
+					     (build_indirect_ref
+					      (build_c_cast
+					       (type,
+						integer_zero_node), "->"),
+					      component), 0));
+  bounds_disable_field_check = 0;
+  bounds_checking_enabled = 1;
+
+  obj = maybe_find_object (pointer);
+
+  params[0] = obj;
+  params[1] = build_c_cast (ptr_type_node, pointer);
+  params[2] = offset_exp;
+  params[3] = size_exp;
+  params[4] = build_current_filename ();
+  params[5] = build_current_lineno ();
+
+  type_of_type = TREE_TYPE (type);
+  if (TREE_CODE (type_of_type) != ARRAY_TYPE)
+    type_of_type = TYPE_MAIN_VARIANT (type_of_type);
+  if (TREE_CODE (obj) == INTEGER_CST)
+    {
+      function_call =
+	bounds_build_function_call ("__bounds_check_component_reference_obj",
+				    bounds_check_component_reference_obj,
+				    &params[1], 5);
+      return
+	build_component_ref (build1
+			     (INDIRECT_REF, type_of_type,
+			      build_c_cast (type, function_call)), component);
+    }
+  else
+    {
+      function_call =
+	bounds_build_function_call ("__bounds_check_component_reference",
+				    bounds_check_component_reference,
+				    params, 6);
+      return
+	build_component_ref (build1
+			     (INDIRECT_REF, type_of_type,
+			      build_c_cast (type, function_call)), component);
+    }
+}
+
+tree
+bounds_build_array_reference (tree array, tree index)
+{
+  /* In bounds checking modes, generate a call to __bounds_check_
+     array_reference and an indirect ref. to that.  */
+  tree params[7], function_call;
+  tree array_type = TREE_TYPE (array);
+  tree array_element_type = TREE_TYPE (array_type);
+  tree size_exp = c_size_in_bytes (array_element_type);
+  tree size_array = TYPE_SIZE (array_type) == 0 ? integer_zero_node
+    : c_size_in_bytes (array_type);
+  tree ptr;
+  tree arr = array;
+  tree obj;
+
+  if (TREE_CODE (array_element_type) != ARRAY_TYPE)
+    array_element_type = TYPE_MAIN_VARIANT (array_element_type);
+
+  if (TREE_CODE (arr) == CONST_DECL)
+    arr = DECL_INITIAL (arr);
+
+  while (TREE_CODE (arr) == NON_LVALUE_EXPR
+	 || (TREE_CODE (arr) == NOP_EXPR
+	     && TREE_TYPE (TREE_OPERAND (arr, 0)) == TREE_TYPE (arr)))
+    arr = TREE_OPERAND (arr, 0);
+
+  if (TREE_CODE (arr) != INDIRECT_REF
+      && TREE_CODE (arr) != COMPOUND_EXPR && !lvalue_p (arr)
+      && !(TREE_CODE (arr) == CONSTRUCTOR && TREE_STATIC (arr)))
+    {
+      return build4 (ARRAY_REF, array_element_type,
+		     array, index, NULL_TREE, NULL_TREE);
+    }
+  array = stabilize_reference (array);
+  bounds_checking_enabled = 0;
+  ptr = default_conversion (array);
+  bounds_checking_enabled = 1;
+  while (TREE_CODE (arr) == ARRAY_REF)
+    arr = TREE_OPERAND (arr, 0);
+  obj = maybe_find_object (arr);
+
+  /* If we are referencing an array object within a structure use
+     that object.  */
+  if (TREE_CODE (obj) == INTEGER_CST
+      && TREE_CODE (arr) == COMPONENT_REF
+      && TREE_CODE (TREE_OPERAND (arr, 0)) == INDIRECT_REF
+      && (TREE_CODE (TREE_OPERAND (TREE_OPERAND (arr, 0), 0))
+	  == CONVERT_EXPR
+	  || TREE_CODE (TREE_OPERAND (TREE_OPERAND (arr, 0), 0))
+	  == NOP_EXPR)
+      && TREE_CODE (TREE_OPERAND (TREE_OPERAND (TREE_OPERAND (arr, 0), 0), 0))
+      == CALL_EXPR)
+    {
+      tree call_expr = TREE_OPERAND (TREE_OPERAND (TREE_OPERAND
+						   (arr, 0), 0), 0);
+      const char *fn_name =
+	IDENTIFIER_POINTER (DECL_NAME
+			    (TREE_OPERAND (TREE_OPERAND (call_expr, 0), 0)));
+      if (strcmp (fn_name, "__bounds_check_component_reference") == 0)
+	obj = TREE_VALUE (TREE_OPERAND (call_expr, 1));
+    }
+
+  params[0] = obj;
+  params[1] = build_c_cast (ptr_type_node, ptr);
+  params[2] = index;
+  params[3] = size_exp;
+  params[4] = size_array;
+  params[5] = build_current_filename ();
+  params[6] = build_current_lineno ();
+
+  if (TREE_CODE (obj) == INTEGER_CST)
+    {
+      function_call =
+	bounds_build_function_call ("__bounds_check_array_reference_obj",
+				    bounds_check_array_reference_obj,
+				    &params[1], 6);
+      return build4 (ARRAY_REF, array_element_type, array,
+		     function_call, NULL_TREE, NULL_TREE);
+    }
+  else
+    {
+      function_call =
+	bounds_build_function_call ("__bounds_check_array_reference",
+				    bounds_check_array_reference, params, 7);
+      return build4 (ARRAY_REF, array_element_type, array,
+		     function_call, NULL_TREE, NULL_TREE);
+    }
+}
+
+int
+bounds_can_test_array_reference_now (tree array, tree index)
+{
+  /* This is called before 'bounds_build_array_reference' to see if we can
+     test the array reference right now. If so, and it is outside bounds,
+     we give an error. We return 1 if we could do the test, 0 if the test
+     has to be done at run time.  */
+  tree min, max, min_is_ok, max_is_ok;
+
+  if (!TREE_CONSTANT (index)
+      /* Make sure this is an array type, with known domain.  */
+      || TREE_CODE (TREE_TYPE (array)) != ARRAY_TYPE
+      || !TYPE_DOMAIN (TREE_TYPE (array))
+      || !TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (array)))
+      || !TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (array))))
+    return 0;
+
+  /* See if we can get the array bounds now.  */
+  min = TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (array)));
+  max = TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (array)));
+
+  /* See if we can evaluate the test now.
+     MIN_IS_OK := 'index' >= 'min'
+     MAX_IS_OK := 'index' <= 'max+1'
+     The +1 is added to allow 'int a[10]; int b=&a[10];'.  */
+  if (bounds_in_addr_expr)
+    max = build_binary_op (PLUS_EXPR, max, integer_one_node, 0);
+  min_is_ok = build_binary_op (GE_EXPR, index, min, 0);
+  max_is_ok = build_binary_op (LE_EXPR, index, max, 0);
+
+  /* If we could do the comparison, and both expressions folded to constant
+     non-zero, then we have done the test, and we return 1. If either
+     expression was zero, there was a mistake. If the things couldn't be
+     folded, we return 0.  */
+  if (!min_is_ok || !max_is_ok
+      || TREE_CODE (min_is_ok) != INTEGER_CST
+      || TREE_CODE (max_is_ok) != INTEGER_CST)
+    return 0;
+  if (integer_zerop (min_is_ok) || integer_zerop (max_is_ok))
+    error ("array expression is out of bounds");
+  return 1;
+}
+
+tree
+bounds_build_ptr_plus_int (enum tree_code resultcode, tree ptrop, tree intop,
+			   tree size_exp)
+{
+  tree result_type = TREE_TYPE (ptrop);
+  tree params[6];
+  enum tree_code plus = PLUS_EXPR;
+  tree obj = maybe_find_object (ptrop);
+  tree new_obj = NULL_TREE, ptr = NULL_TREE;
+  tree intval = NULL_TREE, sizeval = NULL_TREE;
+  const char *name;
+  const char *name_obj;
+  tree tname;
+  tree tname_obj;
+
+  if (resultcode == PLUS_EXPR)
+    {
+      name = "__bounds_check_ptr_plus_int";
+      tname = bounds_check_ptr_plus_int;
+      name_obj = "__bounds_check_ptr_plus_int_obj";
+      tname_obj = bounds_check_ptr_plus_int_obj;
+    }
+  else
+    {
+      name = "__bounds_check_ptr_minus_int";
+      tname = bounds_check_ptr_minus_int;
+      name_obj = "__bounds_check_ptr_minus_int_obj";
+      tname_obj = bounds_check_ptr_minus_int_obj;
+    }
+
+  if (ptrop
+      && (TREE_CODE (ptrop) == CONVERT_EXPR || TREE_CODE (ptrop) == NOP_EXPR)
+      && TREE_CODE (TREE_OPERAND (ptrop, 0)) == CALL_EXPR)
+    {
+      tree call_expr = TREE_OPERAND (ptrop, 0);
+      const char *fn_name =
+	IDENTIFIER_POINTER (DECL_NAME
+			    (TREE_OPERAND (TREE_OPERAND (call_expr, 0), 0)));
+
+      if (fn_name[0] == '_' && fn_name[1] == '_'
+	  && fn_name[2] == 'b' && fn_name[3] == 'o')
+	{
+	  if (strcmp (fn_name, "__bounds_check_ptr_plus_int_obj") == 0
+	      || strcmp (fn_name, "__bounds_check_ptr_minus_int_obj") == 0)
+	    {
+	      plus = strcmp (fn_name, "__bounds_check_ptr_plus_int_obj") == 0
+		? PLUS_EXPR : MINUS_EXPR;
+	      ptr = TREE_VALUE (TREE_OPERAND (call_expr, 1));
+	      intval = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (call_expr, 1)));
+	      sizeval =
+		TREE_VALUE (TREE_CHAIN
+			    (TREE_CHAIN (TREE_OPERAND (call_expr, 1))));
+	    }
+	  else if (strcmp (fn_name, "__bounds_check_ptr_plus_int") == 0
+		   || strcmp (fn_name, "__bounds_check_ptr_minus_int") == 0)
+	    {
+	      plus = strcmp (fn_name, "__bounds_check_ptr_plus_int") == 0
+		? PLUS_EXPR : MINUS_EXPR;
+	      new_obj = TREE_VALUE (TREE_OPERAND (call_expr, 1));
+	      ptr = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (call_expr, 1)));
+	      intval =
+		TREE_VALUE (TREE_CHAIN
+			    (TREE_CHAIN (TREE_OPERAND (call_expr, 1))));
+	      sizeval =
+		TREE_VALUE (TREE_CHAIN
+			    (TREE_CHAIN
+			     (TREE_CHAIN (TREE_OPERAND (call_expr, 1)))));
+	    }
+	}
+    }
+
+  if (ptr
+      && TREE_CODE (size_exp) == INTEGER_CST
+      && TREE_CODE (sizeval) == INTEGER_CST
+      && TREE_INT_CST_HIGH (size_exp) == TREE_INT_CST_HIGH (sizeval)
+      && TREE_INT_CST_LOW (size_exp) == TREE_INT_CST_LOW (sizeval))
+    {
+      intop = build_binary_op (plus == resultcode ? PLUS_EXPR : MINUS_EXPR,
+			       intop, intval, 1);
+      ptrop = ptr;
+      if (new_obj)
+	obj = new_obj;
+    }
+
+  params[0] = obj;
+  params[1] = build_c_cast (ptr_type_node, ptrop);
+  params[2] = build_c_cast (integer_type_node, intop);
+  params[3] = size_exp;
+  params[4] = build_current_filename ();
+  params[5] = build_current_lineno ();
+
+  if (TREE_CODE (params[0]) != INTEGER_CST)
+    return build_c_cast (result_type,
+			 bounds_build_function_call (name, tname, params, 6));
+  else
+    return build_c_cast (result_type,
+			 bounds_build_function_call (name_obj, tname_obj,
+						     &params[1], 5));
+}
+
+tree
+bounds_build_ptr_diff (tree op0, tree op1, tree target_type)
+{
+  tree size_exp = c_size_in_bytes (target_type);
+  tree params[7];
+
+  op0 = save_expr (op0);
+  op1 = save_expr (op1);
+  params[0] = maybe_find_object (op0);
+  params[1] = maybe_find_object (op1);
+  params[2] = build_c_cast (ptr_type_node, op0);
+  params[3] = build_c_cast (ptr_type_node, op1);
+  params[4] = size_exp;
+  params[5] = build_current_filename ();
+  params[6] = build_current_lineno ();
+
+  if (TREE_CODE (params[0]) != INTEGER_CST
+      || TREE_CODE (params[1]) != INTEGER_CST)
+    return bounds_build_function_call ("__bounds_check_ptr_diff",
+				       bounds_check_ptr_diff, params, 7);
+  else
+    return bounds_build_function_call ("__bounds_check_ptr_diff_obj",
+				       bounds_check_ptr_diff_obj,
+				       &params[2], 5);
+}
+
+/* Build a pointer comparison operation. CODE will be one of LT_EXPR,
+   LE_EXPR, GE_EXPR, GT_EXPR, EQ_EXPR or NE_EXPR. RESULT_TYPE is the
+   type of the resulting expression. OP0 and OP1 are guaranteed to have
+   been promoted to pointers by this stage.  */
+tree
+bounds_build_comparison (enum tree_code code, tree result_type,
+			 tree op0, tree op1)
+{
+  tree params[6];
+  const char *name;
+  const char *name_obj;
+  tree tname;
+  tree tname_obj;
+
+  /* RESULT_TYPE must always be integer_type_node.  */
+  if (result_type != integer_type_node)
+    abort ();
+
+  /* Decide which function we'll be calling here.  */
+  switch (code)
+    {
+    case LT_EXPR:
+      name = "__bounds_check_ptr_lt_ptr";
+      tname = bounds_check_ptr_lt_ptr;
+      name_obj = "__bounds_check_ptr_lt_ptr_obj";
+      tname_obj = bounds_check_ptr_lt_ptr_obj;
+      break;
+    case LE_EXPR:
+      name = "__bounds_check_ptr_le_ptr";
+      tname = bounds_check_ptr_le_ptr;
+      name_obj = "__bounds_check_ptr_le_ptr_obj";
+      tname_obj = bounds_check_ptr_le_ptr_obj;
+      break;
+    case GE_EXPR:
+      name = "__bounds_check_ptr_ge_ptr";
+      tname = bounds_check_ptr_ge_ptr;
+      name_obj = "__bounds_check_ptr_ge_ptr_obj";
+      tname_obj = bounds_check_ptr_ge_ptr_obj;
+      break;
+    case GT_EXPR:
+      name = "__bounds_check_ptr_gt_ptr";
+      tname = bounds_check_ptr_gt_ptr;
+      name_obj = "__bounds_check_ptr_gt_ptr_obj";
+      tname_obj = bounds_check_ptr_gt_ptr_obj;
+      break;
+    case EQ_EXPR:
+      name = "__bounds_check_ptr_eq_ptr";
+      tname = bounds_check_ptr_eq_ptr;
+      name_obj = NULL;
+      tname_obj = NULL_TREE;
+      break;
+    case NE_EXPR:
+      name = "__bounds_check_ptr_ne_ptr";
+      tname = bounds_check_ptr_ne_ptr;
+      name_obj = NULL;
+      tname_obj = NULL_TREE;
+      break;
+    default:
+      abort ();
+    }
+
+  if (code == EQ_EXPR || code == NE_EXPR)
+    {
+      op0 = save_expr (op0);
+      op1 = save_expr (op1);
+      params[0] = build_c_cast (ptr_type_node, op0);
+      params[1] = build_c_cast (ptr_type_node, op1);
+      params[2] = build_current_filename ();
+      params[3] = build_current_lineno ();
+
+      return bounds_build_function_call (name, tname, params, 4);
+    }
+  else
+    {
+      op0 = save_expr (op0);
+      op1 = save_expr (op1);
+      params[0] = maybe_find_object (op0);
+      params[1] = maybe_find_object (op1);
+      params[2] = build_c_cast (ptr_type_node, op0);
+      params[3] = build_c_cast (ptr_type_node, op1);
+      params[4] = build_current_filename ();
+      params[5] = build_current_lineno ();
+
+      if (TREE_CODE (params[0]) != INTEGER_CST
+          || TREE_CODE (params[1]) != INTEGER_CST)
+        return bounds_build_function_call (name, tname, params, 6);
+      else
+        return bounds_build_function_call (name_obj, tname_obj,
+					   &params[2], 4);
+    }
+}
+
+/* Build a pre- or post-, inc- or decrement expression. TYPE is the pointer
+   type. ARG is the pointer itself. INC is the actual increment amount.
+   For 'p++' we build:
+  	(type*) __bounds_check_ptr_postinc (&p, inc, ...);
+  	(type*) __bounds_check_ptr_preinc (&p, inc, ...);
+ */
+tree
+bounds_build_inc_or_dec (enum tree_code code, tree type, tree arg, tree inc)
+{
+  tree params[5];
+  const char *name;
+  const char *name_obj;
+  tree tname;
+  tree tname_obj;
+
+  if (DECL_P (arg))
+    DECL_REGISTER (arg) = 0;
+  c_mark_addressable (arg);
+
+  switch (code)
+    {
+    case POSTINCREMENT_EXPR:
+      name = "__bounds_check_ptr_postinc";
+      tname = bounds_check_ptr_postinc;
+      name_obj = "__bounds_check_ptr_postinc_obj";
+      tname_obj = bounds_check_ptr_postinc_obj;
+      break;
+    case PREINCREMENT_EXPR:
+      name = "__bounds_check_ptr_preinc";
+      tname = bounds_check_ptr_preinc;
+      name_obj = "__bounds_check_ptr_preinc_obj";
+      tname_obj = bounds_check_ptr_preinc_obj;
+      break;
+    case POSTDECREMENT_EXPR:
+      name = "__bounds_check_ptr_postdec";
+      tname = bounds_check_ptr_postdec;
+      name_obj = "__bounds_check_ptr_postdec_obj";
+      tname_obj = bounds_check_ptr_postdec_obj;
+      break;
+    case PREDECREMENT_EXPR:
+      name = "__bounds_check_ptr_predec";
+      tname = bounds_check_ptr_predec;
+      name_obj = "__bounds_check_ptr_predec_obj";
+      tname_obj = bounds_check_ptr_predec_obj;
+      break;
+    default:
+      abort ();
+    }
+
+  params[0] = maybe_find_object (arg);
+  params[1] = build_c_cast (build_pointer_type (ptr_type_node),
+			    build1 (ADDR_EXPR,
+				    build_pointer_type (TREE_TYPE (arg)),
+				    build_c_cast (ptr_type_node, arg)));
+  params[2] = build_c_cast (integer_type_node, inc);
+  params[3] = build_current_filename ();
+  params[4] = build_current_lineno ();
+
+  if (TREE_CODE (params[0]) != INTEGER_CST)
+    return build_c_cast (type, bounds_build_function_call (name, tname,
+							   params, 5));
+  else
+    return build_c_cast (type,
+			 bounds_build_function_call (name_obj, tname_obj,
+						     &params[1], 4));
+}
+
+/* Build the truthvalue of a pointer expression, eg. `if (ptr)'. We build
+   a call to __bounds_check_ptr_true (ptr, filename, line); The return type
+   is int.  */
+tree
+bounds_build_truthvalue_conversion (tree arg)
+{
+  tree params[3];
+
+  arg = save_expr (arg);
+  params[0] = build_c_cast (ptr_type_node, default_conversion (arg));
+  params[1] = build_current_filename ();
+  params[2] = build_current_lineno ();
+
+  return bounds_build_function_call ("__bounds_check_ptr_true",
+				     bounds_check_ptr_true, params, 3);
+}
+
+/* Build the invert truthvalue of a pointer expression, ie. `!ptr'. We build
+   a call to __bounds_check_ptr_false (ptr, filename, line); The return type
+   is int.  */
+tree
+bounds_build_invert_truthvalue (tree arg)
+{
+  tree params[3];
+
+  arg = save_expr (arg);
+  params[0] = build_c_cast (ptr_type_node, default_conversion (arg));
+  params[1] = build_current_filename ();
+  params[2] = build_current_lineno ();
+
+  return bounds_build_function_call ("__bounds_check_ptr_false",
+				     bounds_check_ptr_false, params, 3);
+}
+
+/* This function is called just after the function's arguments have been
+   processed. We here build extra code at the start and end of the function
+   to find the function's arguments, and if the function is main, to find
+   the program's argument list. A side effect of this call is that an
+   extra block level will be built around the function. As an example:
+  	f (int a, char b) { ... }
+   becomes:
+  	f (int a, char b)
+  	{
+  	  __bounds_push_function ("f", 0, ...);
+  	  __bounds_add_param_object (&a, 4, 4, file, line, "a");
+  	  __bounds_add_param_object (&b, 1, 1, file, line, "b");
+  	  {
+  	    previous function code here ...
+  	  }
+  	  __bounds_pop_function ("f");
+  	}
+ */
+
+void
+bounds_build_args (void)
+{
+  tree params[7], function_call, arg, cleanup_expr, cleanup_params[2];
+
+  /* This is the current function declaration.  */
+  tree fndecl = current_function_decl;
+
+  /* This is the list of arguments of the current function.  */
+  tree args = DECL_ARGUMENTS (fndecl);
+
+  /* This is the name of the function.  */
+  const char *function_name;
+
+  /* True if this is main ().  */
+  int in_main;
+
+  /* Some checks here ...  */
+  if (!DECL_NAME (fndecl))
+    {
+      error ("can't have unnamed functions in bounds checked code");
+      return;
+    }
+
+  /* Get the function name. Determine if it's `main'.  */
+  in_main = DECL_NAME (fndecl)
+    && MAIN_NAME_P (DECL_NAME (fndecl)) && DECL_FILE_SCOPE_P (fndecl);
+
+  current_function_bounds_nr = declare_function_number_var ();
+
+  /* Make sure that '__bounds_pop_function' gets called if we leave this
+     function early.  */
+
+  function_name = IDENTIFIER_POINTER (DECL_NAME (current_function_decl));
+  cleanup_params[0] = bounds_build_string (function_name);
+  cleanup_params[1] = current_function_bounds_nr;
+  cleanup_expr = bounds_build_function_call ("__bounds_pop_function",
+					     bounds_pop_function,
+					     cleanup_params, 2);
+  push_cleanup (NULL_TREE, cleanup_expr, false);
+
+  /* Build a call to __bounds_push_function with the function name and the
+     source file/line it appears at. The matching '__bounds_pop_function' will
+     delete all unmatched stack objects when the function exits.  */
+  params[0] = bounds_build_string (function_name);
+  params[1] = build_int_cst (NULL_TREE, in_main);
+  params[2] = build_current_filename ();
+  params[3] = build_current_lineno ();
+  function_call = build_modify_expr (current_function_bounds_nr, NOP_EXPR,
+				     bounds_build_function_call
+				     ("__bounds_push_function",
+				      bounds_push_function, params, 4));
+  add_stmt (function_call);
+
+  /* Note the locations of the function parameters now.  */
+  for (arg = args; arg; arg = TREE_CHAIN (arg))
+    {
+      tree size_exp, ptr, alignment, type;
+      enum tree_code code;
+      int addressable = TREE_ADDRESSABLE (arg);
+
+      /* Make sure that the parameter gets a stack slot and doesn't stay in
+         a register. Setting DECL_REGISTER to 0 avoids warning messages if
+         the parameter is actually declared `register'.  */
+
+      /* Build a call to __bounds_add_param_object (...) which is just a
+         wrapper around __bounds_add_stack_object and takes the same args.  */
+      type = TREE_TYPE (arg);
+      code = TREE_CODE (type);
+
+      /* If this is `main' and this is a PARM_DECL associated with a call
+         to a `__bounds_add_param_object' then mark it addressable so it
+         doesn't get deleted.  */
+      if (in_main)
+	{
+	  DECL_REGISTER (arg) = 0;
+	  c_mark_addressable (arg);
+	  addressable = 1;
+	}
+
+      size_exp = c_size_in_bytes (type);
+      switch (code)
+	{
+	case ARRAY_TYPE:
+	  {
+	    enum tree_code type_code;
+	    ptr = bounds_pointer_from_array (arg);
+	    type_code = TREE_CODE (TREE_TYPE (TREE_TYPE (ptr)));
+	    if (type_code != RECORD_TYPE && type_code != UNION_TYPE &&
+		type_code != QUAL_UNION_TYPE)
+	      alignment = c_size_in_bytes (TREE_TYPE (TREE_TYPE (ptr)));
+	    else
+	      alignment = integer_one_node;
+	    ptr = build1 (ADDR_EXPR, build_pointer_type (type), arg);
+	    break;
+	  }
+	case RECORD_TYPE:
+	case UNION_TYPE:
+	case QUAL_UNION_TYPE:
+	  ptr = build1 (ADDR_EXPR, build_pointer_type (type), arg);
+	  alignment = integer_one_node;
+	  break;
+	default:
+	  ptr = build1 (ADDR_EXPR, build_pointer_type (type), arg);
+	  alignment = size_exp;
+	  break;
+	}
+
+      add_object (arg, PARM_DECL);
+
+      params[0] = build_c_cast (ptr_type_node, ptr);
+      params[1] = size_exp;
+      params[2] = alignment;
+      params[3] = build_decl_filename (arg);
+      params[4] = build_decl_lineno (arg);
+      params[5] = bounds_build_string (IDENTIFIER_POINTER (DECL_NAME (arg)));
+      params[6] = current_function_bounds_nr;
+
+      function_call = bounds_build_function_call ("__bounds_add_param_object",
+						  bounds_add_param_object,
+						  params, 7);
+      TREE_ADDRESSABLE (arg) = addressable;
+
+      add_stmt (function_call);
+    }
+}
+
+
+/* Build a node containing the current line number and current input file-
+   name.  */
+static tree
+build_current_lineno (void)
+{
+  return build_int_cst (NULL_TREE, input_line);
+}
+
+static tree
+build_current_filename (void)
+{
+  return bounds_build_string (input_filename);
+}
+
+/* `build_string' wrapper that sets TREE_TYPE and other things correctly. We
+   can build strings like the input_filename over and over again, and GCC will
+   optimize them to a single instance in the output file.  */
+static tree
+bounds_build_string (const char *str)
+{
+  int len;
+  tree t;
+
+  len = strlen (str);
+  t = build_string (len + 1, str);
+  TREE_TYPE (t) = build_array_type (char_type_node,
+				    build_index_type (build_int_cst
+						      (NULL_TREE, len)));
+  TREE_CONSTANT (t) = 1;	/* put it in the text segment  */
+  TREE_READONLY (t) = 1;
+  TREE_INVARIANT (t) = 1;
+  TREE_STATIC (t) = 1;		/* don't share it  */
+
+  return default_conversion (t);
+}
+
+/* Build a node containing the decl's line number and source file.  */
+static tree
+build_decl_lineno (tree decl)
+{
+  return build_int_cst (NULL_TREE, DECL_SOURCE_LINE (decl));
+}
+
+static tree
+build_decl_filename (tree decl)
+{
+  return bounds_build_string (DECL_SOURCE_FILE (decl));
+}
+
+/* Build function call with parameters. n >= 0.  */
+static tree
+bounds_build_function_call (const char *name, tree decl,
+			    tree * params, int n)
+{
+  tree paramlist, function_name, function_decl;
+  int i;
+
+  if (n > 0)
+    {
+      /* Chain the parameters together in reverse order.  */
+      paramlist = build_tree_list (NULL_TREE, params[n - 1]);
+      for (i = n - 2; i >= 0; --i)
+	paramlist =
+	  chainon (build_tree_list (NULL_TREE, params[i]), paramlist);
+    }
+  else
+    paramlist = NULL_TREE;
+
+  /* Look up function name and get the declaration of it.  */
+  function_name = get_identifier (name);
+  if (function_name == NULL_TREE)
+    function_decl = NULL_TREE;
+  else
+    function_decl = lookup_name (function_name);
+
+  if (function_decl == NULL_TREE)
+    function_decl = decl;
+
+  /* Return function_call (...);  */
+  return build_function_call (function_decl, paramlist);
+}
+
+/* From a decl which has type array, get a pointer to the first element that
+   has type the primary array element type.
+   eg.	int a[10][5]; would return a pointer to an int.
+   For 1D arrays, this is identical to `default_conversion'.  */
+static tree
+bounds_pointer_from_array (tree decl)
+{
+  tree ptr, type;
+
+  if (TREE_CODE (TREE_TYPE (decl)) != ARRAY_TYPE)
+    abort ();
+
+  /* Get the correct pointer, but we will change its type in a minute.  */
+  ptr = default_conversion (decl);
+
+  type = TREE_TYPE (decl);
+  while (TREE_CODE (type) == ARRAY_TYPE)
+    type = TREE_TYPE (type);
+
+  /* Type should now be the type of the fundamental elements (eg. int). Build
+     a pointer to that.  */
+  TREE_TYPE (ptr) = build_pointer_type (type);
+
+  return ptr;
+}
+
+/* Similar to the above function, but build the pointer type from the array
+   type directly.  */
+static tree
+bounds_pointer_from_array_type (tree type)
+{
+  if (TREE_CODE (type) != ARRAY_TYPE)
+    abort ();
+
+  while (TREE_CODE (type) == ARRAY_TYPE)
+    type = TREE_TYPE (type);
+
+  /* Type should now be the type of the fundamental elements (eg. int). Build
+     a pointer to that.  */
+  return build_pointer_type (type);
+}
+
+/* Returns a pointer to the element type of this array type.
+   Note this is different from the two functions above as it doesnt recurse
+   down to the basic types. Therefore given int a[4][4][4] it will return
+   pointer to int[][].  */
+
+static tree
+bounds_pointer_from_array_ref (tree type)
+{
+  if (TREE_CODE (TREE_TYPE (TREE_OPERAND (type, 0))) != ARRAY_TYPE)
+    abort ();
+
+  type = TREE_TYPE (TREE_TYPE (TREE_OPERAND (type, 0)));
+
+  return build_pointer_type (type);
+}
+
+#ifdef __GNUC__
+__inline
+#endif
+const char *bounds_lookup
+PARAMS ((register const char *, register unsigned int));
+
+/* Change malloc and friends into __bounds_check functions  */
+void
+bounds_convert_funcname (tree * function, tree * params)
+{
+  if (function && params && *function
+      && TREE_CODE (*function) == FUNCTION_DECL)
+    {
+      tree name, function_name, function_decl, paramlist;
+      const char *fn_name;
+      char new_name[100];
+
+      name = DECL_NAME (*function);
+      fn_name = IDENTIFIER_POINTER (name);
+
+      if (bounds_lookup (fn_name, strlen (fn_name)))
+	{
+	  if (!strcmp (fn_name, "alloca")
+	      || !strcmp (fn_name, "__alloca")
+	      || !strcmp (fn_name, "__builtin_alloca"))
+	    current_function_calls_alloca = 1;
+	  strcpy (new_name, "__bounds_check_");
+	  strcat (new_name, fn_name);
+	  function_name = get_identifier (new_name);
+	  function_decl = lookup_name (function_name);
+	  *function = function_decl;
+	  if (*params == NULL_TREE)
+	    paramlist = build_tree_list (NULL_TREE, build_current_lineno ());
+	  else
+	    paramlist = chainon (build_tree_list (NULL_TREE,
+						  build_current_lineno ()),
+				 *params);
+	  paramlist = chainon (build_tree_list (NULL_TREE,
+						build_current_filename ()),
+			       paramlist);
+	  *params = paramlist;
+	}
+    }
+}
+
+/* In the future generate seprate files for these two functions.  */
+
+/* Input for gperf
+malloc
+free
+realloc
+memalign
+calloc
+valloc
+alloca
+__builtin_alloca
+__alloca
+mmap
+munmap
+memcpy
+mempcpy
+memmove
+bcopy
+memset
+bzero
+memcmp
+bcmp
+strcpy
+strncpy
+strlen
+strcmp
+strncmp
+strcat
+strncat
+strpbrk
+strrchr
+rindex
+strspn
+strcspn
+strstr
+strtok
+strtok_r
+strchr
+strdup
+index
+strcoll
+strxfrm
+memchr
+memccpy
+strcasecmp
+strncasecmp
+*/
+
+/* C code produced by gperf version 3.0.1 */
+/* Command-line: gperf -k'1,4,$' -H bounds_hash -N bounds_lookup names.gperf  */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+
+#define TOTAL_KEYWORDS 43
+#define MIN_WORD_LENGTH 4
+#define MAX_WORD_LENGTH 16
+#define MIN_HASH_VALUE 6
+#define MAX_HASH_VALUE 107
+/* maximum key range = 102, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+bounds_hash (const char *str, unsigned int len)
+{
+  static unsigned char asso_values[] =
+    {
+      108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108,   0, 108,   0,  10,  15,
+       36,  35,   0, 108, 108,   0, 108,  10,  55,   5,
+        0,  25,   0, 108,  30,   0,  55,  21,  10, 108,
+        0,  20, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108, 108, 108, 108, 108, 108,
+      108, 108, 108, 108, 108, 108
+    };
+  return len + asso_values[(unsigned char)str[3]] + asso_values[(unsigned char)str[0]] + asso_values[(unsigned char)str[len - 1]];
+}
+
+#ifdef __GNUC__
+__inline
+#endif
+const char *
+bounds_lookup (const char *str, unsigned int len)
+{
+  static const char * wordlist[] =
+    {
+      "", "", "", "", "", "",
+      "strspn",
+      "strncmp",
+      "",
+      "mmap",
+      "",
+      "strncasecmp",
+      "strxfrm",
+      "memalign",
+      "bcmp",
+      "",
+      "munmap",
+      "strpbrk",
+      "", "", "",
+      "strcmp",
+      "strcspn",
+      "", "",
+      "strcasecmp",
+      "memcmp",
+      "strncpy",
+      "", "", "",
+      "alloca",
+      "mempcpy",
+      "", "",
+      "bcopy",
+      "strstr",
+      "__builtin_alloca",
+      "", "",
+      "index",
+      "strcpy",
+      "strdup",
+      "", "", "",
+      "memcpy",
+      "memccpy",
+      "", "", "",
+      "strchr",
+      "memmove",
+      "", "", "",
+      "memchr",
+      "", "", "", "",
+      "strlen",
+      "strncat",
+      "__alloca",
+      "", "",
+      "memset",
+      "strrchr",
+      "", "",
+      "bzero",
+      "strtok",
+      "rindex",
+      "",
+      "free",
+      "",
+      "strcat",
+      "strcoll",
+      "", "", "",
+      "malloc",
+      "", "", "", "",
+      "valloc",
+      "", "", "", "",
+      "calloc",
+      "",
+      "strtok_r",
+      "", "", "", "", "", "", "", "", "",
+      "", "", "", "",
+      "realloc"
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = bounds_hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= 0)
+        {
+          register const char *s = wordlist[key];
+
+          if (*str == *s && !strcmp (str + 1, s + 1))
+            return s;
+        }
+    }
+  return 0;
+}
+
+#undef TOTAL_KEYWORDS
+#undef MIN_WORD_LENGTH
+#undef MAX_WORD_LENGTH
+#undef MIN_HASH_VALUE
+#undef MAX_HASH_VALUE
+
+/* Input for gperf
+__bounds_check_array_reference
+__bounds_check_array_reference_obj
+__bounds_check_component_reference
+__bounds_check_component_reference_obj
+__bounds_check_ptr_diff
+__bounds_check_ptr_diff_obj
+__bounds_check_ptr_eq_ptr
+__bounds_check_ptr_false
+__bounds_check_ptr_false_obj
+__bounds_check_ptr_ge_ptr
+__bounds_check_ptr_ge_ptr_obj
+__bounds_check_ptr_gt_ptr
+__bounds_check_ptr_gt_ptr_obj
+__bounds_check_ptr_le_ptr
+__bounds_check_ptr_le_ptr_obj
+__bounds_check_ptr_lt_ptr
+__bounds_check_ptr_lt_ptr_obj
+__bounds_check_ptr_minus_int
+__bounds_check_ptr_minus_int_obj
+__bounds_check_ptr_ne_ptr
+__bounds_check_ptr_plus_int
+__bounds_check_ptr_plus_int_obj
+__bounds_check_ptr_postdec
+__bounds_check_ptr_postdec_obj
+__bounds_check_ptr_postdec_ref
+__bounds_check_ptr_postdec_ref_obj
+__bounds_check_ptr_postinc
+__bounds_check_ptr_postinc_obj
+__bounds_check_ptr_postinc_ref
+__bounds_check_ptr_postinc_ref_obj
+__bounds_check_ptr_predec
+__bounds_check_ptr_predec_obj
+__bounds_check_ptr_predec_ref
+__bounds_check_ptr_predec_ref_obj
+__bounds_check_ptr_preinc
+__bounds_check_ptr_preinc_obj
+__bounds_check_ptr_preinc_ref
+__bounds_check_ptr_preinc_ref_obj
+__bounds_check_ptr_true
+__bounds_check_ptr_true_obj
+__bounds_check_reference
+__bounds_check_reference_obj
+*/
+
+/* C code produced by gperf version 3.0.1 */
+/* Command-line: gperf -k'20,21,24,$' -H bounds_func_hash -N bounds_func_lookup names.gperf  */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+
+#define TOTAL_KEYWORDS 42
+#define MIN_WORD_LENGTH 23
+#define MAX_WORD_LENGTH 38
+#define MIN_HASH_VALUE 27
+#define MAX_HASH_VALUE 110
+/* maximum key range = 84, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+bounds_func_hash (const char *str, unsigned int len)
+{
+  static unsigned char asso_values[] =
+    {
+      111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111,   0, 111,   0, 111,   5,
+       15,   5,  30,   6, 111,   0,   0, 111,  60,   5,
+        0,  20,  15,  25,   0,   0,   0, 111, 111, 111,
+      111,  35, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111, 111, 111, 111, 111, 111,
+      111, 111, 111, 111, 111, 111
+    };
+  register int hval = len;
+
+  switch (hval)
+    {
+      default:
+        hval += asso_values[(unsigned char)str[23]];
+      /*FALLTHROUGH*/
+      case 23:
+      case 22:
+      case 21:
+        hval += asso_values[(unsigned char)str[20]];
+      /*FALLTHROUGH*/
+      case 20:
+        hval += asso_values[(unsigned char)str[19]];
+        break;
+    }
+  return hval + asso_values[(unsigned char)str[len - 1]];
+}
+
+#ifdef __GNUC__
+__inline
+#endif
+const char *
+bounds_func_lookup (const char *str, unsigned int len)
+{
+  static const char * wordlist[] =
+    {
+      "", "", "", "", "", "", "", "", "",
+      "", "", "", "", "", "", "", "", "",
+      "", "", "", "", "", "", "", "", "",
+      "__bounds_check_ptr_true_obj",
+      "__bounds_check_ptr_true",
+      "",
+      "__bounds_check_ptr_ne_ptr",
+      "__bounds_check_ptr_gt_ptr",
+      "",
+      "__bounds_check_ptr_minus_int",
+      "",
+      "__bounds_check_ptr_gt_ptr_obj",
+      "__bounds_check_ptr_ge_ptr",
+      "__bounds_check_ptr_minus_int_obj",
+      "__bounds_check_reference_obj",
+      "__bounds_check_reference",
+      "__bounds_check_ptr_ge_ptr_obj",
+      "",
+      "__bounds_check_ptr_diff_obj",
+      "",
+      "__bounds_check_ptr_preinc_obj",
+      "__bounds_check_ptr_preinc",
+      "", "",
+      "__bounds_check_ptr_preinc_ref_obj",
+      "__bounds_check_ptr_predec_obj",
+      "__bounds_check_ptr_predec",
+      "", "",
+      "__bounds_check_ptr_predec_ref_obj",
+      "",
+      "__bounds_check_ptr_eq_ptr",
+      "", "",
+      "__bounds_check_component_reference_obj",
+      "__bounds_check_component_reference",
+      "", "", "",
+      "__bounds_check_ptr_false_obj",
+      "__bounds_check_ptr_false",
+      "__bounds_check_ptr_postinc_obj",
+      "__bounds_check_ptr_postinc",
+      "",
+      "__bounds_check_ptr_diff",
+      "__bounds_check_ptr_postinc_ref_obj",
+      "", "", "", "",
+      "__bounds_check_ptr_preinc_ref",
+      "", "", "", "",
+      "__bounds_check_ptr_predec_ref",
+      "__bounds_check_ptr_postdec_obj",
+      "__bounds_check_ptr_postdec",
+      "", "",
+      "__bounds_check_ptr_postdec_ref_obj",
+      "__bounds_check_ptr_lt_ptr",
+      "", "", "",
+      "__bounds_check_ptr_lt_ptr_obj",
+      "__bounds_check_ptr_le_ptr",
+      "", "", "",
+      "__bounds_check_ptr_le_ptr_obj",
+      "__bounds_check_ptr_postinc_ref",
+      "", "", "",
+      "__bounds_check_array_reference_obj",
+      "__bounds_check_array_reference",
+      "",
+      "__bounds_check_ptr_plus_int",
+      "", "", "",
+      "__bounds_check_ptr_plus_int_obj",
+      "", "", "",
+      "__bounds_check_ptr_postdec_ref"
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = bounds_func_hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= 0)
+        {
+          register const char *s = wordlist[key];
+
+          if (*str == *s && !strcmp (str + 1, s + 1))
+            return s;
+        }
+    }
+  return 0;
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/c-bounds.h gcc-4.0.2/gcc/c-bounds.h
--- gcc-4.0.2.org/gcc/c-bounds.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/c-bounds.h	2005-09-29 17:50:03.000000000 +0200
@@ -0,0 +1,59 @@
+/* Miscellaneous functions for bounds checking.
+   Written by Richard W.M. Jones <rjones@orchestream.com>.
+   Copyright (C) 1995 Richard W.M. Jones.
+
+This file is part of the bounds checking patches for GNU CC. The main
+body of code used at run time can be found in the `bounds/' subdirectory.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
+
+#ifndef _C_BOUNDS_H
+#define _C_BOUNDS_H
+
+void bounds_init (void);
+tree bounds_check_assignment (tree, tree, tree);
+void bounds_external_declaration (tree *, int);
+void bounds_build_static_constructors (void);
+void bounds_frig_decl_initial (tree);
+void bounds_delete_redundant_calls (tree);
+tree bounds_cancel_address_expr (tree);
+tree bounds_build_reference (tree);
+tree bounds_build_array_reference (tree, tree);
+int bounds_can_test_array_reference_now (tree, tree);
+tree bounds_build_ptr_plus_int (enum tree_code, tree, tree, tree);
+tree bounds_build_ptr_diff (tree, tree, tree);
+tree bounds_build_comparison (enum tree_code, tree, tree, tree);
+tree bounds_build_inc_or_dec (enum tree_code, tree, tree, tree);
+tree bounds_build_invert_truthvalue (tree);
+tree bounds_build_truthvalue_conversion (tree);
+tree bounds_build_component_ref (tree, tree);
+tree bounds_build_component_indirect_ref (tree, tree);
+void bounds_build_args (void);
+void bounds_convert_funcname (tree * function, tree * params);
+void bounds_assemble_private_statics_table (void);
+void bounds_mark_for_runtime_check (tree);
+void bounds_reorder_expr (tree);
+void bounds_register_decl(tree);
+
+extern int bounds_checking_enabled_initial;
+extern int bounds_checking_enabled;
+extern int bounds_strings_only_enabled;
+extern int bounds_disable_field_check;
+extern int bounds_in_static_decl;
+extern int bounds_reentrant_defined;
+extern int bounds_in_addr_expr;
+extern char *bounds_constructor_name;
+
+#endif /* _C_BOUNDS_H */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/c-common.c gcc-4.0.2/gcc/c-common.c
--- gcc-4.0.2.org/gcc/c-common.c	2005-09-01 18:46:46.000000000 +0200
+++ gcc-4.0.2/gcc/c-common.c	2005-09-29 17:50:03.000000000 +0200
@@ -47,6 +47,7 @@ Software Foundation, 59 Temple Place - S
 #include "tree-mudflap.h"
 #include "opts.h"
 #include "real.h"
+#include "c-bounds.h"
 
 cpp_reader *parse_in;		/* Declared in c-pragma.h.  */
 
@@ -1131,6 +1132,12 @@ warn_for_collisions_1 (tree written, tre
 {
   struct tlist *tmp;
 
+  /* In bounds checking we may generate two calls to bounds_find_object
+     in the same statement for the same value. The return will be the
+     same so ignore this warning.  */
+  if (bounds_checking_enabled && optimize > 2)
+    return;
+
   /* Avoid duplicate warnings.  */
   for (tmp = warned_ids; tmp; tmp = tmp->next)
     if (tmp->expr == written)
@@ -2260,6 +2267,18 @@ pointer_int_sum (enum tree_code resultco
   else
     size_exp = size_in_bytes (TREE_TYPE (result_type));
 
+  /* For bounds checked code, we have all the information necessary to
+     generate the function call here. We generate the call
+     __bounds_check_ptr_plus_int (void *pointer, int offset, size_t size,
+                                  int is_plus, char *filename, int line);
+     where pointer is the pointer value, offset is the int operand, size
+     is the size_exp, is_plus is resultcode == PLUS_EXPR, etc.  */
+  if (bounds_checking_enabled
+      && !bounds_in_static_decl
+      && (!bounds_strings_only_enabled ||
+	  TYPE_NAME (char_type_node) == TYPE_NAME (TREE_TYPE (result_type))))
+    return bounds_build_ptr_plus_int (resultcode, ptrop, intop, size_exp);
+
   /* If what we are about to multiply by the size of the elements
      contains a constant term, apply distributive law
      and multiply that constant term separately.
@@ -2492,6 +2511,20 @@ c_common_truthvalue_conversion (tree exp
 	       0));
     }
 
+  /* In bounds checking mode, if we evaluate the truthvalue of a pointer we
+     want to check the pointer is not ILLEGAL or otherwise invalid. We build
+     the necessary code here.  */
+  if (bounds_checking_enabled)
+    {
+      enum tree_code code = TREE_CODE (TREE_TYPE (expr));
+      if (((code == POINTER_TYPE || code == ARRAY_TYPE)
+	   && (!bounds_strings_only_enabled
+	       || TYPE_NAME (char_type_node) ==
+	          TYPE_NAME (TREE_TYPE (TREE_TYPE (expr)))))
+          || code == FUNCTION_TYPE)
+        return bounds_build_truthvalue_conversion (expr);
+    }
+
   return build_binary_op (NE_EXPR, expr, integer_zero_node, 1);
 }
 
@@ -3275,6 +3308,9 @@ c_common_nodes_and_builtins (void)
   if (flag_mudflap)
     mudflap_init ();
 
+  if (bounds_checking_enabled)
+    bounds_init ();
+
   main_identifier_node = get_identifier ("main");
 
   /* Create the built-in __null node.  It is important that this is
@@ -5725,7 +5761,8 @@ fold_offsetof_1 (tree expr)
 	return base;
 
       t = TREE_OPERAND (expr, 1);
-      if (DECL_C_BIT_FIELD (t))
+      if (bounds_disable_field_check ? DECL_BIT_FIELD (t)
+				     : DECL_C_BIT_FIELD (t))
 	{
 	  error ("attempt to take address of bit-field structure "
 		 "member %qs", IDENTIFIER_POINTER (DECL_NAME (t)));
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/c-common.h gcc-4.0.2/gcc/c-common.h
--- gcc-4.0.2.org/gcc/c-common.h	2005-07-11 16:28:39.000000000 +0200
+++ gcc-4.0.2/gcc/c-common.h	2005-09-29 17:50:03.000000000 +0200
@@ -828,6 +828,8 @@ extern tree default_conversion (tree);
 
 extern tree common_type (tree, tree);
 
+extern tree c_size_in_bytes (tree);
+
 extern tree decl_constant_value (tree);
 
 /* Handle increment and decrement of boolean types.  */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/c-decl.c gcc-4.0.2/gcc/c-decl.c
--- gcc-4.0.2.org/gcc/c-decl.c	2005-09-09 02:51:44.000000000 +0200
+++ gcc-4.0.2/gcc/c-decl.c	2005-09-29 17:50:04.000000000 +0200
@@ -60,6 +60,7 @@ Software Foundation, 59 Temple Place - S
 #include "libfuncs.h"
 #include "except.h"
 #include "langhooks-def.h"
+#include "c-bounds.h"
 
 /* In grokdeclarator, distinguish syntactic contexts of declarators.  */
 enum decl_context
@@ -3540,6 +3541,13 @@ finish_decl (tree decl, tree init, tree 
 	  push_cleanup (decl, cleanup, false);
 	}
     }
+
+  /* In bounds checking mode, if this is a local variable declaration, then
+     we create or alter the initializer so that it has the side effect of
+     calling __bounds_add_stack_object.  */
+  if (bounds_checking_enabled)
+    bounds_frig_decl_initial (decl);
+
 }
 
 /* Given a parsed parameter declaration, decode it into a PARM_DECL.  */
@@ -6566,6 +6574,17 @@ finish_function (void)
     {
       if (!decl_function_context (fndecl))
         {
+	  /* We now have the function. In bounds checking mode we want to
+	     delete redundant calls to:
+	      __bounds_push_function
+	      __bounds_pop_function
+	      __bounds_add_param_object
+	      __bounds_add_stack_object
+	      __bounds_delete_stack_object
+	     if it turns out that these are unnecessary in this function.  */
+	  if (bounds_checking_enabled)
+	    bounds_delete_redundant_calls (fndecl);
+
           c_genericize (fndecl);
           c_warn_unused_result_recursively (fndecl);
 
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/cfgexpand.c gcc-4.0.2/gcc/cfgexpand.c
--- gcc-4.0.2.org/gcc/cfgexpand.c	2005-08-18 11:50:51.000000000 +0200
+++ gcc-4.0.2/gcc/cfgexpand.c	2005-09-29 17:50:04.000000000 +0200
@@ -37,6 +37,7 @@ Boston, MA 02111-1307, USA.  */
 #include "flags.h"
 #include "diagnostic.h"
 #include "toplev.h"
+#include "c-bounds.h"
 
 /* Verify that there is exactly single jump instruction since last and attach
    REG_BR_PROB note specifying probability.
@@ -173,6 +174,9 @@ alloc_stack_frame_space (HOST_WIDE_INT s
 {
   HOST_WIDE_INT offset, new_frame_offset;
 
+  if (bounds_checking_enabled)
+    size += align;
+
   new_frame_offset = frame_offset;
   if (FRAME_GROWS_DOWNWARD)
     {
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/c-gimplify.c gcc-4.0.2/gcc/c-gimplify.c
--- gcc-4.0.2.org/gcc/c-gimplify.c	2005-01-27 19:22:19.000000000 +0100
+++ gcc-4.0.2/gcc/c-gimplify.c	2005-09-29 17:50:04.000000000 +0200
@@ -482,7 +482,7 @@ gimplify_compound_literal_expr (tree *ex
   /* This decl isn't mentioned in the enclosing block, so add it to the
      list of temps.  FIXME it seems a bit of a kludge to say that
      anonymous artificial vars aren't pushed, but everything else is.  */
-  if (DECL_NAME (decl) == NULL_TREE)
+  if (DECL_SEEN_IN_BIND_EXPR_P (decl) == 0 && DECL_NAME (decl) == NULL_TREE)
     gimple_add_tmp_var (decl);
 
   gimplify_and_add (decl_s, pre_p);
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/c-lang.c gcc-4.0.2/gcc/c-lang.c
--- gcc-4.0.2.org/gcc/c-lang.c	2005-01-18 12:35:59.000000000 +0100
+++ gcc-4.0.2/gcc/c-lang.c	2005-09-29 17:50:04.000000000 +0200
@@ -35,6 +35,7 @@ Software Foundation, 59 Temple Place - S
 #include "c-pretty-print.h"
 #include "c-objc-common.h"
 #include "c-pragma.h"
+#include "c-bounds.h"
 
 enum c_language_kind c_language = clk_c;
 
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/c.opt gcc-4.0.2/gcc/c.opt
--- gcc-4.0.2.org/gcc/c.opt	2005-05-01 03:11:57.000000000 +0200
+++ gcc-4.0.2/gcc/c.opt	2005-09-29 17:50:04.000000000 +0200
@@ -461,6 +461,14 @@ fasm
 C ObjC C++ ObjC++
 Recognize the \"asm\" keyword
 
+fbounds-checking
+C
+Generate code to check bounds before indexing arrays
+
+fbc-strings-only
+C
+Restrict bounds checking to strings only
+
 fbuiltin
 C ObjC C++ ObjC++
 Recognize built-in functions
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/c-opts.c gcc-4.0.2/gcc/c-opts.c
--- gcc-4.0.2.org/gcc/c-opts.c	2005-05-01 03:11:56.000000000 +0200
+++ gcc-4.0.2/gcc/c-opts.c	2005-09-29 17:50:04.000000000 +0200
@@ -38,6 +38,7 @@ Software Foundation, 59 Temple Place - S
 #include "opts.h"
 #include "options.h"
 #include "mkdeps.h"
+#include "c-bounds.h"
 
 #ifndef DOLLARS_IN_IDENTIFIERS
 # define DOLLARS_IN_IDENTIFIERS true
@@ -552,6 +553,27 @@ c_common_handle_option (size_t scode, co
       flag_no_asm = !value;
       break;
 
+    case OPT_fbounds_checking:
+      bounds_checking_enabled_initial = value;
+      bounds_checking_enabled = value;
+      if (bounds_checking_enabled)
+	{
+	  flag_strict_aliasing = 0;
+          flag_no_builtin = value;  /* So we can check mem* functions too.  */
+	}
+      break;
+
+    case OPT_fbc_strings_only:
+      bounds_checking_enabled_initial = value;
+      bounds_strings_only_enabled = value;
+      bounds_checking_enabled = value;
+      if (bounds_checking_enabled)
+	{
+	  flag_strict_aliasing = 0;
+          flag_no_builtin = value;  /* So we can check mem* functions too.  */
+	}
+      break;
+
     case OPT_fbuiltin:
       flag_no_builtin = !value;
       break;
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/cp/bounds.c gcc-4.0.2/gcc/cp/bounds.c
--- gcc-4.0.2.org/gcc/cp/bounds.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/cp/bounds.c	2005-09-29 17:50:04.000000000 +0200
@@ -0,0 +1,187 @@
+/* This file is a dummy, for when C++ gets bounds checking like C. In the
+   mean time, there are some empty function definitions here, since `calls.c'
+   references these (but never calls them). */
+
+#include "config.h"
+#include "system.h"
+#include <stdio.h>
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "tree.h"
+#include "varray.h"
+#include "ggc.h"
+#include "cpplib.h"
+#include "c-pragma.h"
+
+static GTY (()) varray_type static_ptr_init_list;
+static GTY (()) varray_type deferred_global_decls;
+static GTY (()) tree bounds_memcpy;
+static GTY (()) tree bounds_mempcpy;
+static GTY (()) tree bounds_memset;
+static GTY (()) tree bounds_find_object;
+static GTY (()) tree bounds_maybe_find_object;
+static GTY (()) tree bounds_check_ptr_plus_int;
+static GTY (()) tree bounds_check_ptr_minus_int;
+static GTY (()) tree bounds_check_ptr_plus_int_obj;
+static GTY (()) tree bounds_check_ptr_minus_int_obj;
+static GTY (()) tree bounds_check_array_reference;
+static GTY (()) tree bounds_check_array_reference_obj;
+static GTY (()) tree bounds_check_component_reference;
+static GTY (()) tree bounds_check_component_reference_obj;
+static GTY (()) tree bounds_check_ptr_diff;
+static GTY (()) tree bounds_check_ptr_diff_obj;
+static GTY (()) tree bounds_check_reference;
+static GTY (()) tree bounds_check_reference_obj;
+static GTY (()) tree bounds_check_ptr_lt_ptr;
+static GTY (()) tree bounds_check_ptr_lt_ptr_obj;
+static GTY (()) tree bounds_check_ptr_le_ptr;
+static GTY (()) tree bounds_check_ptr_le_ptr_obj;
+static GTY (()) tree bounds_check_ptr_gt_ptr;
+static GTY (()) tree bounds_check_ptr_gt_ptr_obj;
+static GTY (()) tree bounds_check_ptr_ge_ptr;
+static GTY (()) tree bounds_check_ptr_ge_ptr_obj;
+static GTY (()) tree bounds_check_ptr_eq_ptr;
+static GTY (()) tree bounds_check_ptr_ne_ptr;
+static GTY (()) tree bounds_check_ptr_postinc;
+static GTY (()) tree bounds_check_ptr_preinc;
+static GTY (()) tree bounds_check_ptr_postdec;
+static GTY (()) tree bounds_check_ptr_predec;
+static GTY (()) tree bounds_check_ptr_postinc_obj;
+static GTY (()) tree bounds_check_ptr_preinc_obj;
+static GTY (()) tree bounds_check_ptr_postdec_obj;
+static GTY (()) tree bounds_check_ptr_predec_obj;
+static GTY (()) tree bounds_check_ptr_postinc_ref;
+static GTY (()) tree bounds_check_ptr_preinc_ref;
+static GTY (()) tree bounds_check_ptr_postdec_ref;
+static GTY (()) tree bounds_check_ptr_predec_ref;
+static GTY (()) tree bounds_check_ptr_postinc_ref_obj;
+static GTY (()) tree bounds_check_ptr_preinc_ref_obj;
+static GTY (()) tree bounds_check_ptr_postdec_ref_obj;
+static GTY (()) tree bounds_check_ptr_predec_ref_obj;
+static GTY (()) tree bounds_check_ptr_true;
+static GTY (()) tree bounds_check_ptr_false;
+static GTY (()) tree bounds_note_constructed_object;
+static GTY (()) tree bounds_note_constructed_private_table;
+static GTY (()) tree bounds_push_function;
+static GTY (()) tree bounds_pop_function;
+static GTY (()) tree bounds_add_param_object;
+static GTY (()) tree bounds_add_stack_object;
+static GTY (()) tree bounds_delete_stack_object;
+static GTY (()) tree bounds_initialize_library;
+static GTY (()) tree bounds_check_free;
+static GTY (()) tree bounds_check_malloc;
+static GTY (()) tree bounds_check_realloc;
+static GTY (()) tree bounds_check_memalign;
+static GTY (()) tree bounds_check_calloc;
+static GTY (()) tree bounds_check_valloc;
+static GTY (()) tree bounds_check_alloca;
+static GTY (()) tree bounds_check___alloca;
+static GTY (()) tree bounds_check___builtin_alloca;
+static GTY (()) tree bounds_check_mmap;
+static GTY (()) tree bounds_check_munmap;
+static GTY (()) tree bounds_check_memcpy;
+static GTY (()) tree bounds_check_mempcpy;
+static GTY (()) tree bounds_check_memmove;
+static GTY (()) tree bounds_check_bcopy;
+static GTY (()) tree bounds_check_memset;
+static GTY (()) tree bounds_check_bzero;
+static GTY (()) tree bounds_check_memcmp;
+static GTY (()) tree bounds_check_bcmp;
+static GTY (()) tree bounds_check_strcpy;
+static GTY (()) tree bounds_check_strncpy;
+static GTY (()) tree bounds_check_strlen;
+static GTY (()) tree bounds_check_strcmp;
+static GTY (()) tree bounds_check_strncmp;
+static GTY (()) tree bounds_check_strcat;
+static GTY (()) tree bounds_check_strncat;
+static GTY (()) tree bounds_check_strpbrk;
+static GTY (()) tree bounds_check_strrchr;
+static GTY (()) tree bounds_check_rindex;
+static GTY (()) tree bounds_check_strspn;
+static GTY (()) tree bounds_check_strcspn;
+static GTY (()) tree bounds_check_strstr;
+static GTY (()) tree bounds_check_strtok;
+static GTY (()) tree bounds_check_strtok_r;
+static GTY (()) tree bounds_check_strdup;
+static GTY (()) tree bounds_check_strchr;
+static GTY (()) tree bounds_check_index;
+static GTY (()) tree bounds_check_strcoll;
+static GTY (()) tree bounds_check_strxfrm;
+static GTY (()) tree bounds_check_strcasecmp;
+static GTY (()) tree bounds_check_strncasecmp;
+static GTY (()) tree bounds_check_memchr;
+static GTY (()) tree bounds_check_memccpy;
+static GTY (()) tree bounds_private_statics;
+
+#include "gt-c-bounds.h"
+
+int bounds_in_static_decl = 0;
+int bounds_disable_field_check = 0;
+
+void
+bounds_init (void)
+{
+  abort ();
+}
+
+void
+bounds_convert_funcname (tree * function ATTRIBUTE_UNUSED,
+			 tree * params ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+void
+bounds_build_static_constructors (void)
+{
+  abort ();
+}
+
+void
+bounds_register_decl (tree decl ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+int
+bounds_is_deletable_fn_p (char *name ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+void
+bounds_note_call_for_deletion (rtx first_insn ATTRIBUTE_UNUSED,
+			       rtx last_insn ATTRIBUTE_UNUSED,
+			       char *fnname ATTRIBUTE_UNUSED,
+			       tree callexpr ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+tree
+bounds_build_truthvalue_conversion (tree arg ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+void
+bounds_delete_redundant_calls (void)
+{
+  abort ();
+}
+
+tree
+bounds_build_ptr_plus_int (enum tree_code resultcode ATTRIBUTE_UNUSED,
+			   tree ptrop ATTRIBUTE_UNUSED,
+			   tree intop ATTRIBUTE_UNUSED,
+			   tree size_exp ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+void
+bounds_mark_for_runtime_check (tree decl ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/cp/Make-lang.in gcc-4.0.2/gcc/cp/Make-lang.in
--- gcc-4.0.2.org/gcc/cp/Make-lang.in	2005-06-02 19:30:57.000000000 +0200
+++ gcc-4.0.2/gcc/cp/Make-lang.in	2005-09-29 17:50:04.000000000 +0200
@@ -83,7 +83,7 @@ CXX_AND_OBJCXX_OBJS = cp/call.o cp/decl.
  cp/typeck.o cp/cvt.o cp/except.o cp/friend.o cp/init.o cp/method.o \
  cp/search.o cp/semantics.o cp/tree.o cp/repo.o cp/dump.o cp/optimize.o \
  cp/mangle.o cp/cp-objcp-common.o cp/name-lookup.o cp/cxx-pretty-print.o \
- cp/cp-gimplify.o tree-mudflap.o $(CXX_C_OBJS)
+ cp/cp-gimplify.o cp/bounds.o tree-mudflap.o $(CXX_C_OBJS)
 
 # Language-specific object files for C++.
 CXX_OBJS = cp/cp-lang.o stub-objc.o $(CXX_AND_OBJCXX_OBJS)
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/c-parse.in gcc-4.0.2/gcc/c-parse.in
--- gcc-4.0.2.org/gcc/c-parse.in	2005-01-05 18:08:35.000000000 +0100
+++ gcc-4.0.2/gcc/c-parse.in	2005-09-29 17:50:04.000000000 +0200
@@ -214,6 +214,7 @@ do {									\
 %type <ttype> maybe_attribute attributes attribute attribute_list attrib
 %type <ttype> any_word
 
+%type <ttype> bounds_compstmt_start bounds_compstmt
 %type <ttype> compstmt compstmt_start compstmt_primary_start
 %type <ttype> stmt label stmt_nocomp start_break start_continue
 
@@ -331,6 +332,15 @@ static tree offsetof_base;
     flag_iso = (val >> 3) & 1;			\
   } while (0)
 
+/* When including c-bounds.h we must also include rtl.h. This
+   does not work because we have some values in rtl.def that
+   match codes in this file.  */
+extern int bounds_checking_enabled, bounds_in_static_decl, bounds_in_addr_expr,
+           bounds_strings_only_enabled;
+tree bounds_build_component_ref PARAMS((tree, tree));
+tree bounds_build_component_indirect_ref PARAMS((tree, tree));
+void bounds_build_args PARAMS((void));
+
 @@ifobjc
 /* Objective-C specific parser/lexer information */
 
@@ -473,7 +483,9 @@ identifier:
 	;
 
 unop:     '&'
-		{ $$ = ADDR_EXPR; }
+		{ if (bounds_checking_enabled)
+		    bounds_in_addr_expr++;
+		  $$ = ADDR_EXPR; }
 	| '-'
 		{ $$ = NEGATE_EXPR; }
 	| '+'
@@ -757,12 +769,26 @@ primary:
 		{ $$.value = build_array_ref ($1.value, $3.value);
 		  $$.original_code = ERROR_MARK; }
 	| primary '.' identifier
-		{ $$.value = build_component_ref ($1.value, $3);
+		{
+		  if (bounds_checking_enabled
+		      && !bounds_strings_only_enabled
+		      && !(bounds_in_static_decl || global_bindings_p ()))
+		    $$.value = bounds_build_component_ref ($1.value, $3);
+                  else
+		    $$.value = build_component_ref ($1.value, $3);
 		  $$.original_code = ERROR_MARK; }
 	| primary POINTSAT identifier
 		{
-                  tree expr = build_indirect_ref ($1.value, "->");
-		  $$.value = build_component_ref (expr, $3);
+		  if (bounds_checking_enabled
+		      && !bounds_strings_only_enabled
+		      && !(bounds_in_static_decl || global_bindings_p ()))
+		    $$.value = bounds_build_component_indirect_ref ($1.value,
+								    $3);
+                  else
+                    {
+                      tree expr = build_indirect_ref ($1.value, "->");
+		      $$.value = build_component_ref (expr, $3);
+		    }
 		  $$.original_code = ERROR_MARK;
 		}
 	| primary PLUSPLUS
@@ -1518,7 +1544,7 @@ nested_function:
 	   an error which then was handled by compstmt_or_error.  There
 	   followed a repeated execution of that same rule, which called
 	   YYERROR1 again, and so on.  */
-	compstmt
+	bounds_compstmt
 		{ tree decl = current_function_decl;
 		  add_stmt ($6);
 		  finish_function ();
@@ -1548,7 +1574,7 @@ notype_nested_function:
 	   an error which then was handled by compstmt_or_error.  There
 	   followed a repeated execution of that same rule, which called
 	   YYERROR1 again, and so on.  */
-	compstmt
+	bounds_compstmt
 		{ tree decl = current_function_decl;
 		  add_stmt ($6);
 		  finish_function ();
@@ -2018,9 +2044,36 @@ label_decl:
 /* This is the body of a function definition.
    It causes syntax errors to ignore to the next openbrace.  */
 compstmt_or_error:
-	  compstmt
+	  bounds_compstmt
 		{ add_stmt ($1); }
-	| error compstmt
+	| error bounds_compstmt
+	;
+
+bounds_compstmt_start: /* empty */
+	{ if (bounds_checking_enabled)
+	    {
+	      $$ = c_begin_compound_stmt (true);
+	      /* In bounds checking mode, emit various function calls here
+		 so we can find the function's arguments.
+		 Enter a new function context. This is the 'outer block' of
+		 this function.  */
+	      bounds_build_args ();
+	    }
+	  else
+	     $$ = NULL_TREE; }
+	;
+
+bounds_compstmt:
+	bounds_compstmt_start compstmt
+	{ if (bounds_checking_enabled)
+	    {
+	      /* In bounds checking mode, we may have introduced an extra
+		 binding contour in. We pop it here.  */
+	      add_stmt ($2);
+	      $$ = c_end_compound_stmt ($1, true);
+	    }
+	  else
+	    $$ = $2; }
 	;
 
 compstmt_start: '{' { $$ = c_begin_compound_stmt (true); }
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/c-pragma.c gcc-4.0.2/gcc/c-pragma.c
--- gcc-4.0.2.org/gcc/c-pragma.c	2005-06-06 21:20:21.000000000 +0200
+++ gcc-4.0.2/gcc/c-pragma.c	2005-09-29 17:50:04.000000000 +0200
@@ -40,6 +40,9 @@ Software Foundation, 59 Temple Place - S
 #define GCC_BAD2(gmsgid, arg) \
   do { warning (gmsgid, arg); return; } while (0)
 
+extern int bounds_checking_enabled_initial;
+static void bounds_handle_pragma_checking (cpp_reader *);
+
 typedef struct align_stack GTY(())
 {
   int                  alignment;
@@ -416,7 +419,8 @@ handle_pragma_redefine_extname (cpp_read
   if (t != CPP_EOF)
     warning ("junk at end of #pragma redefine_extname");
 
-  if (!flag_mudflap && !targetm.handle_pragma_redefine_extname)
+  if (!bounds_checking_enabled_initial
+      && !flag_mudflap && !targetm.handle_pragma_redefine_extname)
     {
       if (warn_unknown_pragmas > in_system_header)
 	warning ("#pragma redefine_extname not supported on this target");
@@ -660,6 +664,32 @@ handle_pragma_visibility (cpp_reader *du
 
 #endif
 
+static void
+bounds_handle_pragma_checking (cpp_reader * ARG_UNUSED (dummy))
+{
+  int error = 0;
+  tree x;
+  enum cpp_ttype token;
+
+  token = c_lex (&x);
+  if (token == CPP_NAME)
+    {
+      const char *op = IDENTIFIER_POINTER (x);
+      if (!strcmp (op, "on"))
+	bounds_checking_enabled = bounds_checking_enabled_initial;
+      else if (!strcmp (op, "off"))
+	bounds_checking_enabled = 0;
+      else
+	error = 1;
+    }
+  else
+    error = 1;
+  if (error)
+    warning ("#pragma bounds_checking must be followed by on or off");
+  else if (c_lex (&x) != CPP_EOF)
+    warning ("junk at end of #pragma bounds_checking");
+}
+
 /* Front-end wrappers for pragma registration to avoid dragging
    cpplib.h in almost everywhere.  */
 void
@@ -697,6 +727,8 @@ init_pragma (void)
   c_register_pragma (0, "redefine_extname", handle_pragma_redefine_extname);
   c_register_pragma (0, "extern_prefix", handle_pragma_extern_prefix);
 
+  c_register_pragma (0, "bounds_checking", bounds_handle_pragma_checking);
+
   c_register_pragma ("GCC", "pch_preprocess", c_common_pch_pragma);
 
 #ifdef REGISTER_TARGET_PRAGMAS
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/c-tree.h gcc-4.0.2/gcc/c-tree.h
--- gcc-4.0.2.org/gcc/c-tree.h	2005-07-08 15:07:35.000000000 +0200
+++ gcc-4.0.2/gcc/c-tree.h	2005-09-29 17:50:04.000000000 +0200
@@ -601,6 +601,14 @@ extern bool c_override_global_bindings_t
 /* True means we've initialized exception handling.  */
 extern bool c_eh_initialized_p;
 
+/* Flag for bounds checking.  */
+
+extern int bounds_checking_enabled;
+   
+/* Flag for string only bounds checking.  */
+
+extern int bounds_strings_only_enabled;
+   
 /* In c-decl.c */
 extern void c_finish_incomplete_decl (tree);
 extern void c_write_global_declarations (void);
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/c-typeck.c gcc-4.0.2/gcc/c-typeck.c
--- gcc-4.0.2.org/gcc/c-typeck.c	2005-09-06 22:10:50.000000000 +0200
+++ gcc-4.0.2/gcc/c-typeck.c	2005-09-29 17:50:04.000000000 +0200
@@ -44,6 +44,7 @@ Software Foundation, 59 Temple Place - S
 #include "tree-iterator.h"
 #include "tree-gimple.h"
 #include "tree-flow.h"
+#include "c-bounds.h"
 
 /* Possible cases of implicit bad conversions.  Used to select
    diagnostic messages in convert_for_assignment.  */
@@ -71,6 +72,13 @@ struct c_label_context_vm *label_context
    message within this initializer.  */
 static int missing_braces_mentioned;
 
+/* Bounds checking is turned off temporarily inside static initializers by
+   c-typeck.c:start_init using the following flag.  */
+int bounds_in_static_decl;
+
+/* Nonzero in bounds checking mode when a bit field is tested */
+int bounds_disable_field_check = 0;
+
 static int require_constant_value;
 static int require_constant_elements;
 
@@ -1195,7 +1203,7 @@ type_lists_compatible_p (tree args1, tre
 
 /* Compute the size to increment a pointer by.  */
 
-static tree
+tree
 c_size_in_bytes (tree type)
 {
   enum tree_code code = TREE_CODE (type);
@@ -1612,7 +1620,14 @@ build_component_ref (tree datum, tree co
 
 /* Given an expression PTR for a pointer, return an expression
    for the value pointed to.
-   ERRORSTRING is the name of the operator to appear in error messages.  */
+   ERRORSTRING is the name of the operator to appear in error messages.
+
+   For bounds checked code, we generate a call to:
+     void*  __bounds_check_reference (void *pointer, size_t size,
+                                      char *filename, int line);
+   This function checks that the reference will be successful (else
+   aborts with an error message). We then make the reference ourselves
+   as usual.  */
 
 tree
 build_indirect_ref (tree ptr, const char *errorstring)
@@ -1632,9 +1647,16 @@ build_indirect_ref (tree ptr, const char
 	  tree mvt = t;
 	  tree ref;
 
-	  if (TREE_CODE (mvt) != ARRAY_TYPE)
-	    mvt = TYPE_MAIN_VARIANT (mvt);
-	  ref = build1 (INDIRECT_REF, mvt, pointer);
+	  if (bounds_checking_enabled && !bounds_in_static_decl
+	      && (!bounds_strings_only_enabled
+		  || TYPE_NAME (t) == TYPE_NAME (char_type_node)))
+	    ref = bounds_build_reference (ptr);
+	  else
+	    {
+	      if (TREE_CODE (mvt) != ARRAY_TYPE)
+	        mvt = TYPE_MAIN_VARIANT (mvt);
+	      ref = build1 (INDIRECT_REF, mvt, pointer);
+	    }
 
 	  if (!COMPLETE_OR_VOID_TYPE_P (t) && TREE_CODE (t) != ARRAY_TYPE)
 	    {
@@ -1670,7 +1692,14 @@ build_indirect_ref (tree ptr, const char
    If A is a variable or a member, we generate a primitive ARRAY_REF.
    This avoids forcing the array out of registers, and can work on
    arrays that are not lvalues (for example, members of structures returned
-   by functions).  */
+   by functions).
+
+   In bounds checked mode, we generate a call to the function:
+     __bounds_check_array_reference
+   which checks the offset. It returns the address of the object which we
+   then directly reference.
+   In some cases, generates `ptr_plus_int, ref' even in the case
+   &p[i] where the ref is unnecessary. */
 
 tree
 build_array_ref (tree array, tree index)
@@ -1762,10 +1791,34 @@ build_array_ref (tree array, tree index)
 	    pedwarn ("ISO C90 forbids subscripting non-lvalue array");
 	}
 
-      type = TREE_TYPE (TREE_TYPE (array));
-      if (TREE_CODE (type) != ARRAY_TYPE)
-	type = TYPE_MAIN_VARIANT (type);
-      rval = build4 (ARRAY_REF, type, array, index, NULL_TREE, NULL_TREE);
+      if (bounds_checking_enabled
+	  && (!bounds_strings_only_enabled
+	      || TYPE_NAME (TREE_TYPE (TREE_TYPE (array))) ==
+		 TYPE_NAME (char_type_node)))
+	{
+	  /* In bounds checking modes, generate a call to __bounds_check_
+	     array_reference and an indirect ref. to that.  */
+	  if (bounds_in_static_decl)
+	    {
+	      if (!bounds_can_test_array_reference_now (array, index))
+		warning ("cannot check this array reference");
+              type = TREE_TYPE (TREE_TYPE (array));
+              if (TREE_CODE (type) != ARRAY_TYPE)
+	        type = TYPE_MAIN_VARIANT (type);
+	      rval = build4 (ARRAY_REF, type, array, index,
+			     NULL_TREE, NULL_TREE);
+	    }
+	  else
+	    rval = bounds_build_array_reference (array, index);
+	}
+      else
+	{
+          type = TREE_TYPE (TREE_TYPE (array));
+          if (TREE_CODE (type) != ARRAY_TYPE)
+	    type = TYPE_MAIN_VARIANT (type);
+          rval = build4 (ARRAY_REF, type, array, index, NULL_TREE, NULL_TREE);
+	}
+
       /* Array ref is const/volatile if the array elements are
          or if the array is.  */
       TREE_READONLY (rval)
@@ -1968,6 +2021,9 @@ build_function_call (tree function, tree
   tree name = NULL_TREE, result;
   tree tem;
 
+  if (bounds_checking_enabled)
+    bounds_convert_funcname (&function, &params);
+
   /* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */
   STRIP_TYPE_NOPS (function);
 
@@ -2393,7 +2449,9 @@ parser_build_binary_op (enum tree_code c
 }
 
 /* Return a tree for the difference of pointers OP0 and OP1.
-   The resulting tree has type int.  */
+   The resulting tree has type int.
+   If bounds-checking is switched on, generate a call to
+   __bounds_check_ptr_plus_int to check the operation.  */
 
 static tree
 pointer_diff (tree op0, tree op1)
@@ -2403,6 +2461,8 @@ pointer_diff (tree op0, tree op1)
   tree target_type = TREE_TYPE (TREE_TYPE (op0));
   tree con0, con1, lit0, lit1;
   tree orig_op1 = op1;
+  bool char_ptrs_diff = TYPE_NAME (char_type_node) ==
+                        TYPE_NAME (TREE_TYPE (TREE_TYPE (op0)));
 
   if (pedantic || warn_pointer_arith)
     {
@@ -2446,6 +2506,13 @@ pointer_diff (tree op0, tree op1)
     }
 
 
+  if (bounds_checking_enabled && !bounds_in_static_decl
+      && (!bounds_strings_only_enabled || char_ptrs_diff))
+    /* Build a call to the following function here instead:
+	 int  __bounds_check_ptr_diff (void *ptr1, void *ptr2, size_t size,
+                                       char *filename, int line);  */
+    return bounds_build_ptr_diff (op0, op1, target_type);
+
   /* First do the subtraction as integers;
      then drop through to build the divide operator.
      Do not do default conversions on the minus operator
@@ -2571,8 +2638,22 @@ build_unary_op (enum tree_code code, tre
 	  error ("wrong type argument to unary exclamation mark");
 	  return error_mark_node;
 	}
-      arg = lang_hooks.truthvalue_conversion (arg);
-      return invert_truthvalue (arg);
+
+      /* In bounds checking mode, if we are inverting a pointer (ie. `!ptr')
+         we want to check that the pointer is not ILLEGAL and not pointing
+         to invalid memory.  */
+      if (bounds_checking_enabled
+          && (((typecode == POINTER_TYPE || typecode == ARRAY_TYPE)
+               && (!bounds_strings_only_enabled
+                   || TYPE_NAME (char_type_node) ==
+                      TYPE_NAME (TREE_TYPE (TREE_TYPE (arg)))))
+              || typecode == FUNCTION_TYPE))
+        return bounds_build_invert_truthvalue (arg);
+      else
+        {
+          arg = lang_hooks.truthvalue_conversion (arg);
+          return invert_truthvalue (arg);
+        }
 
     case NOP_EXPR:
       break;
@@ -2681,6 +2762,14 @@ build_unary_op (enum tree_code code, tre
 
 	if (TREE_CODE (TREE_TYPE (arg)) == BOOLEAN_TYPE)
 	  val = boolean_increment (code, arg);
+        else if (bounds_checking_enabled && !bounds_in_static_decl
+                 && TREE_CODE (TREE_TYPE (arg)) == POINTER_TYPE
+                 && (!bounds_strings_only_enabled
+                     || TYPE_NAME (char_type_node) ==
+                        TYPE_NAME (TREE_TYPE (TREE_TYPE (arg)))))
+          /* If bounds checking, generate a function call to ensure the
+             inc/decrement will be correct.  */
+          val = bounds_build_inc_or_dec (code, TREE_TYPE (arg), arg, inc);
 	else
 	  val = build2 (code, TREE_TYPE (arg), arg, inc);
 	TREE_SIDE_EFFECTS (val) = 1;
@@ -2693,29 +2782,50 @@ build_unary_op (enum tree_code code, tre
     case ADDR_EXPR:
       /* Note that this operation never does default_conversion.  */
 
-      /* Let &* cancel out to simplify resulting code.  */
-      if (TREE_CODE (arg) == INDIRECT_REF)
-	{
-	  /* Don't let this be an lvalue.  */
-	  if (lvalue_p (TREE_OPERAND (arg, 0)))
-	    return non_lvalue (TREE_OPERAND (arg, 0));
-	  return TREE_OPERAND (arg, 0);
-	}
+      if (bounds_in_addr_expr)
+        bounds_in_addr_expr--;
 
-      /* For &x[y], return x+y */
-      if (TREE_CODE (arg) == ARRAY_REF)
-	{
-	  if (!c_mark_addressable (TREE_OPERAND (arg, 0)))
+      if (!(bounds_checking_enabled && !bounds_in_static_decl
+            && (!bounds_strings_only_enabled
+                || TYPE_NAME (char_type_node) == TYPE_NAME (TREE_TYPE (arg)))))
+        {
+          /* Let &* cancel out to simplify resulting code.  */
+          if (TREE_CODE (arg) == INDIRECT_REF)
+            {
+              /* Don't let this be an lvalue.  */
+              if (lvalue_p (TREE_OPERAND (arg, 0)))
+                return non_lvalue (TREE_OPERAND (arg, 0));
+              return TREE_OPERAND (arg, 0);
+            }
+
+          /* For &x[y], return x+y  */
+          if (TREE_CODE (arg) == ARRAY_REF)
+            {
+              if (!c_mark_addressable (TREE_OPERAND (arg, 0)))
+                return error_mark_node;
+              return build_binary_op (PLUS_EXPR, TREE_OPERAND (arg, 0),
+                                      TREE_OPERAND (arg, 1), 1);
+            }
+
+          /* Anything not already handled and not a true memory reference
+	     or a non-lvalue array is an error.  */
+          else if (typecode != FUNCTION_TYPE && !flag
+	           && !lvalue_or_else (arg, lv_addressof))
 	    return error_mark_node;
-	  return build_binary_op (PLUS_EXPR, TREE_OPERAND (arg, 0),
-				  TREE_OPERAND (arg, 1), 1);
-	}
+        }
+      else
+        {
+          /* In bounds checking code, the patterns for '&*' and '&x[y]' are
+             more complicated because we have already expanded the '*' or the
+             'x[y]' expression. We sort this out in 'c-bounds.c'.  */
+          if (noconvert == 0)
+            {
+              tree cancelled_expr = bounds_cancel_address_expr (arg);
 
-      /* Anything not already handled and not a true memory reference
-	 or a non-lvalue array is an error.  */
-      else if (typecode != FUNCTION_TYPE && !flag
-	       && !lvalue_or_else (arg, lv_addressof))
-	return error_mark_node;
+              if (cancelled_expr != NULL_TREE)
+                return cancelled_expr;
+            }
+        }
 
       /* Ordinary case; arg is a COMPONENT_REF or a decl.  */
       argtype = TREE_TYPE (arg);
@@ -2734,7 +2844,9 @@ build_unary_op (enum tree_code code, tre
 	return error_mark_node;
 
       gcc_assert (TREE_CODE (arg) != COMPONENT_REF
-		  || !DECL_C_BIT_FIELD (TREE_OPERAND (arg, 1)));
+		  || (bounds_disable_field_check
+			? !DECL_BIT_FIELD (TREE_OPERAND (arg, 1))
+		        : !DECL_C_BIT_FIELD (TREE_OPERAND (arg, 1))));
 
       argtype = build_pointer_type (argtype);
 
@@ -2791,6 +2903,15 @@ lvalue_p (tree ref)
     case BIND_EXPR:
       return TREE_CODE (TREE_TYPE (ref)) == ARRAY_TYPE;
 
+    case SAVE_EXPR:
+      return bounds_checking_enabled
+           && lvalue_p (TREE_OPERAND (ref, 0));
+
+    case COND_EXPR:
+      return bounds_checking_enabled
+           && lvalue_p (TREE_OPERAND (ref, 1))
+           && lvalue_p (TREE_OPERAND (ref, 2));
+
     default:
       return 0;
     }
@@ -2842,7 +2963,8 @@ c_mark_addressable (tree exp)
     switch (TREE_CODE (x))
       {
       case COMPONENT_REF:
-	if (DECL_C_BIT_FIELD (TREE_OPERAND (x, 1)))
+        if (bounds_disable_field_check ? DECL_BIT_FIELD (TREE_OPERAND (x, 1))
+                                       : DECL_C_BIT_FIELD (TREE_OPERAND (x, 1)))
 	  {
 	    error
 	      ("cannot take address of bit-field %qD", TREE_OPERAND (x, 1));
@@ -2867,7 +2989,8 @@ c_mark_addressable (tree exp)
       case CONST_DECL:
       case PARM_DECL:
       case RESULT_DECL:
-	if (C_DECL_REGISTER (x)
+	if (bounds_checking_enabled == 0
+	    && C_DECL_REGISTER (x)
 	    && DECL_NONLOCAL (x))
 	  {
 	    if (TREE_PUBLIC (x) || TREE_STATIC (x) || DECL_EXTERNAL (x))
@@ -2878,7 +3001,7 @@ c_mark_addressable (tree exp)
 	      }
 	    pedwarn ("register variable %qD used in nested function", x);
 	  }
-	else if (C_DECL_REGISTER (x))
+	else if (bounds_checking_enabled == 0 && C_DECL_REGISTER (x))
 	  {
 	    if (TREE_PUBLIC (x) || TREE_STATIC (x) || DECL_EXTERNAL (x))
 	      error ("address of global register variable %qD requested", x);
@@ -3434,9 +3557,17 @@ build_modify_expr (tree lhs, enum tree_c
      as the LHS argument.  */
 
   if (olhstype == TREE_TYPE (result))
-    return result;
+    {
+      if (bounds_checking_enabled)
+        result = bounds_check_assignment (result, lhs, newrhs);
+      return result;
+    }
+  if (bounds_checking_enabled)
+    return bounds_check_assignment (
+                convert_for_assignment (olhstype, result, ic_assign,
+                                        NULL_TREE, NULL_TREE, 0), lhs, newrhs);
   return convert_for_assignment (olhstype, result, ic_assign,
-				 NULL_TREE, NULL_TREE, 0);
+                                 NULL_TREE, NULL_TREE, 0);
 }
 
 /* Convert value RHS to type TYPE as preparation for an assignment
@@ -3928,6 +4059,9 @@ store_init_value (tree decl, tree init)
   if (TREE_CODE (type) == ERROR_MARK)
     return;
 
+  if (bounds_checking_enabled && decl != 0)
+    bounds_in_static_decl = TREE_STATIC (decl);
+
   /* Digest the specified initializer into an expression.  */
 
   value = digest_init (type, init, true, TREE_STATIC (decl));
@@ -3970,6 +4104,9 @@ store_init_value (tree decl, tree init)
 	    }
 	}
     }
+
+  if (bounds_checking_enabled)
+    bounds_in_static_decl = 0;
 }
 
 /* Methods for storing and printing names for error messages.  */
@@ -4568,6 +4705,10 @@ start_init (tree decl, tree asmspec_tree
   const char *locus;
   struct initializer_stack *p = xmalloc (sizeof (struct initializer_stack));
 
+  /* In a static initializer, temporarily turn off bounds checking.  */
+  if (bounds_checking_enabled && decl != 0)
+    bounds_in_static_decl = TREE_STATIC (decl);
+
   p->decl = constructor_decl;
   p->require_constant_value = require_constant_value;
   p->require_constant_elements = require_constant_elements;
@@ -4648,6 +4789,11 @@ finish_init (void)
   constructor_top_level = p->top_level;
   initializer_stack = p->next;
   free (p);
+
+  /* If bounds checking was temporarily suspended in a static decl, turn it
+     back on.  */
+  if (bounds_checking_enabled)
+    bounds_in_static_decl = 0;
 }
 
 /* Call here when we see the initializer is surrounded by braces.
@@ -7413,6 +7559,10 @@ build_binary_op (enum tree_code code, tr
   /* Nonzero means set RESULT_TYPE to the common type of the args.  */
   int common = 0;
 
+  /* Nonzero means we may build bounds checking code for a comparison
+     operation (<, >, <=, >=, ==, !=) here. */
+  int bounds_checked_comparison = 0;
+
   if (convert_p)
     {
       op0 = default_conversion (orig_op0);
@@ -7652,22 +7802,31 @@ build_binary_op (enum tree_code code, tr
 
 	  if (result_type == NULL_TREE)
 	    result_type = ptr_type_node;
+	  bounds_checked_comparison = 1;
 	}
       else if (code0 == POINTER_TYPE && TREE_CODE (op1) == INTEGER_CST
 	       && integer_zerop (op1))
-	result_type = type0;
+	{
+	  result_type = type0;
+	  bounds_checked_comparison = 1;
+        }
       else if (code1 == POINTER_TYPE && TREE_CODE (op0) == INTEGER_CST
 	       && integer_zerop (op0))
-	result_type = type1;
+	{
+	  result_type = type1;
+	  bounds_checked_comparison = 1;
+	}
       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)
 	{
 	  result_type = type0;
 	  pedwarn ("comparison between pointer and integer");
+	  bounds_checked_comparison = 1;
 	}
       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)
 	{
 	  result_type = type1;
 	  pedwarn ("comparison between pointer and integer");
+	  bounds_checked_comparison = 1;
 	}
       break;
 
@@ -7696,6 +7855,8 @@ build_binary_op (enum tree_code code, tr
 	      result_type = ptr_type_node;
 	      pedwarn ("comparison of distinct pointer types lacks a cast");
 	    }
+	  bounds_checked_comparison = 1;
+	  bounds_checked_comparison = 1;
 	}
       else if (code0 == POINTER_TYPE && TREE_CODE (op1) == INTEGER_CST
 	       && integer_zerop (op1))
@@ -7703,6 +7864,7 @@ build_binary_op (enum tree_code code, tr
 	  result_type = type0;
 	  if (pedantic || extra_warnings)
 	    pedwarn ("ordered comparison of pointer with integer zero");
+	  bounds_checked_comparison = 1;
 	}
       else if (code1 == POINTER_TYPE && TREE_CODE (op0) == INTEGER_CST
 	       && integer_zerop (op0))
@@ -7710,16 +7872,19 @@ build_binary_op (enum tree_code code, tr
 	  result_type = type1;
 	  if (pedantic)
 	    pedwarn ("ordered comparison of pointer with integer zero");
+	  bounds_checked_comparison = 1;
 	}
       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)
 	{
 	  result_type = type0;
 	  pedwarn ("comparison between pointer and integer");
+	  bounds_checked_comparison = 1;
 	}
       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)
 	{
 	  result_type = type1;
 	  pedwarn ("comparison between pointer and integer");
+	  bounds_checked_comparison = 1;
 	}
       break;
 
@@ -8028,12 +8193,29 @@ build_binary_op (enum tree_code code, tr
     build_type = result_type;
 
   {
-    tree result = build2 (resultcode, build_type, op0, op1);
+    tree result;
+
+    if (! bounds_checking_enabled
+        || bounds_in_static_decl
+        || ! bounds_checked_comparison)
+      result = build2 (resultcode, build_type, op0, op1);
+    else
+      {
+        /* If strings only and either ops not a char.
+           Note that bounds_checked_comparison => code0 or code1 is a
+           pointer type.  */
+        tree temp = TYPE_NAME (char_type_node);
+        tree name0 = TREE_TYPE (type0) ? TYPE_NAME (TREE_TYPE (type0)) : NULL;
+        tree name1 = TREE_TYPE (type1) ? TYPE_NAME (TREE_TYPE (type1)) : NULL;
+        if (bounds_strings_only_enabled && (temp != name0) && (temp != name1))
+          result = build2 (resultcode, build_type, op0, op1);
+        else
+          result = bounds_build_comparison (resultcode, build_type, op0, op1);
+      }
 
     /* Treat expressions in initializers specially as they can't trap.  */
     result = require_constant_value ? fold_initializer (result)
-				    : fold (result);
-
+                                    : fold (result);
     if (final_type != 0)
       result = convert (final_type, result);
     return result;
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/doc/extend.texi gcc-4.0.2/gcc/doc/extend.texi
--- gcc-4.0.2.org/gcc/doc/extend.texi	2005-07-20 12:36:23.000000000 +0200
+++ gcc-4.0.2/gcc/doc/extend.texi	2005-09-29 17:50:04.000000000 +0200
@@ -67,6 +67,8 @@ extensions, accepted by GCC in C89 mode 
 * Incomplete Enums::    @code{enum foo;}, with details to follow.
 * Function Names::	Printable strings which are the name of the current
 			 function.
+* Bounds Checking::     Add full, fine-grained array & pointer checking to
+                         C programs.
 * Return Address::      Getting the return or frame address of a function.
 * Vector Extensions::   Using vector instructions through built-in functions.
 * Offsetof::            Special syntax for implementing @code{offsetof}.
@@ -4385,6 +4387,670 @@ literals.  GCC 3.4 and later treat them 
 @code{__func__}.  In C++, @code{__FUNCTION__} and
 @code{__PRETTY_FUNCTION__} have always been variables.
 
+@node Bounds Checking
+@section Bounds Checking
+@cindex Bounds Checking
+
+The C part of the GNU compiler now supports full fine-grained pointer checking
+at runtime. This work was originally done by @w{Richard W.M. Jones}
+`rjones@@orchestream.com',
+and has been extended by the work of many other kind
+contributors.@footnote{See the file @file{bounds/CONTRIBUTORS} for a full
+list of the people who gave their effort for free to make all this possible.}
+
+The runtime checking library, test kit and various tools can be found in
+the @file{bounds/} subdirectory.
+
+The brief manual here is a distillation of the original paper that appeared
+at the same time as the original patches to GCC. The paper contains more
+details about the inner workings of bounds checking GCC. The paper can be
+found in PostScript format in @file{bounds/report/bcrep2.ps.gz}.
+
+@menu
+* Compiling with checks::       How to compile your programs with bounds
+                                 checks on at runtime.
+* Incompatibilities with checking:: You can't use setjmp/longjmp, and threads
+                                 and signal handlers need special attention.
+* Unchecked code and libraries:: You can freely mix unchecked source files and
+                                 libraries with your checked program.
+* Debugging with GDB::          You may debug bounds checked programs with
+                                 GDB and there are special breakpoints for this
+                                 purpose.
+* Environment at runtime::      Customizing the runtime environment by passing
+                                 options in @code{GCC_BOUNDS_OPTS}.
+* Managing the heap::           How bounds checking uses the heap at runtime.
+* Unchecked objects::           How unchecked objects work.
+* Miscellaneous features::      Other features that might be of interest.
+* Checking 2D array indices::   Notes about 2D array indices.
+* What errors are caught::      What errors are caught and what errors are
+                                 missed?
+* Performance::                 How fast (or slow) can you expect bounds
+                                 checked programs to go?
+* Stubborn bugs::               Special ``features'' you may need to know
+                                 about.
+* Using G77 with bounds checking:: A small patch you have to make to get a
+                                smooth compile with G77.
+@end menu
+
+@ignore
+
+NOT YET DOCUMENTED!!! ---
+
+bounds/tools subdirectory
+bounds/misc subdirectory
+bounds/report subdirectory
+bounds/tests subdirectory
+bounds/treestats subdirectory
+
+tidy up this menu - need to make it more hierarchical
+
+@end ignore
+
+@node Compiling with checks
+@subsection Compiling with checks
+
+To compile all or part of your program with bounds checking, simply add the
+@code{-fbounds-checking} flag when compiling and linking. In the simplest
+instance, you might do:
+
+@example
+gcc -fbounds-checking program.c -o program
+@end example
+
+@noindent
+Or, linking several checked files together:
+
+@example
+gcc -fbounds-checking -c file1.c -o file1.o
+gcc -fbounds-checking -c file2.c -o file2.o
+gcc -fbounds-checking -c file3.c -o file3.o
+gcc -fbounds-checking file1.o file2.o file3.o -o program
+@end example
+
+If your program uses a Makefile, you will probably only need to add the
+@code{-fbounds-checking} flag to @code{CFLAGS}, and remake the program
+from scratch.
+
+@node Incompatibilities with checking
+@subsection Incompatibilities with checking
+
+@itemize @bullet
+@item Programs that use setjmp and longjmp.
+
+Bounds checking is unfortunately incompatible with setjmp/longjmp. This is
+regrettable, but the problem is quite fundamental and it is unlikely that
+these functions will ever be permissable.
+
+@item Using signal handlers.
+
+If possible, move signal handlers to a separate source file and set checking
+off in that file. If this is not possible, then you will need to edit
+@file{bounds/lib/mutex.h} which provides mutual exclusion to vital
+internal structures in the checking library. Normally this mutual exclusion
+is turned off, for reasons of efficiency.
+
+@item Using threads.
+
+You may use threads with bounds checking. If more than one thread could
+ever run with bounds checking, you will need to provide mutual exclusion
+as with signal handlers above. Edit the file @file{bounds/lib/mutex.h} and
+add whatever code is necessary to give mutual exclusion.
+
+@item Checking C++ programs.
+
+Every so often, someone mails me to ask why their C++ program isn't checked
+when they do @code{g++ -fbounds-checking}. At the moment, the bounds checking
+changes are specific to the C front end, so you can't use them with the other
+GCC front ends (eg. C++, FORTRAN, Modula-2). There is no reason why bounds
+checking couldn't be added to the C++ front end. It would take perhaps one or
+two months to do. It is highly unlikely that I will ever do this, but if a
+keen beta-tester wants it enough, I may be willing to help them. In the
+meantime, it is possible to translate C++ programs to C and check them, but
+line number and other debugging information may get scrambled in the process.
+@end itemize
+
+
+@node Unchecked code and libraries
+@subsection Unchecked code and libraries
+
+You can normally freely mix unchecked and checked code. This is why you don't
+need to make any changes to your C or X11 libraries when you install GCC
+with bounds checking. The checking library will detect code compiled with
+and without checking automagically, and let the two run together. You
+can mix unchecked object files with checked ones for the same reason. Always
+pass the @code{-fbounds-checking} flag to the link stage.
+
+@example
+gcc -fbounds-checking -c file1.c -o file1.o
+gcc -c unchecked.c -o unchecked.o
+gcc -fbounds-checking file1.o unchecked.o -o program
+@end example
+
+The checking library will usually only know about variables that are
+declared in checked code, and about memory allocated with @code{malloc}. So
+if a variable is declared in @file{unchecked.c} above, then references
+to it will @emph{not} be checked, even when these references occur in
+checked code.
+
+Say that file @file{unchecked.c} contains the following code:
+
+@example
+int a[10];
+
+int *get_ptr_to_a () @{ return a; @}
+@end example
+
+and file @file{file1.c} contains:
+
+@example
+extern int *get_ptr_to_a ();
+
+main ()
+@{
+  int *ptr_to_a = get_ptr_to_a ();
+  int i;
+
+  for (i = 0; i < 20; ++i) ptr_to_a[i] = 0;
+@}
+@end example
+
+The references to @code{ptr_to_a} will not be checked. You can resolve
+this by adding @code{a}, either by hand, or semi-automatically.
+@xref{Unchecked objects}.
+
+If you place @code{extern int a[10];} anywhere in @file{file1.c}, bounds
+checking GCC will also be able to find and check the array references
+properly.
+
+If you include @file{bounds/run-includes/unchecked.h}, you get facilities
+to turn bounds checking on and off over short stretches of code and
+within single expressions and statements. Even when bounds checking is
+switched off, you may still use these features. The macros are silently
+ignored if bounds checking is off, or if the compiler is not GCC.
+
+@itemize @bullet
+@item @code{BOUNDS_CHECKING_OFF} @dots{} @code{BOUNDS_CHECKING_ON}
+
+Turn off bounds checking over a section of code. For instance:
+@example
+/* This code is checked ... */
+BOUNDS_CHECKING_OFF;
+/* This code is unchecked ... */
+BOUNDS_CHECKING_ON;
+/* This code is checked again ... */
+@end example
+The unchecked code should not try to return from a function, or jump over
+the @code{BOUNDS_CHECKING_ON} statement with @code{goto}, else checking
+will be switched off for the rest of the program!
+
+@item @code{BOUNDS_CHECKING_OFF_DURING}
+
+Switch off checking in a single statement. For instance:
+@example
+BOUNDS_CHECKING_OFF_DURING (p += 5);
+@end example
+The statement should not (obviously) be goto, return, @dots{}
+
+@item @code{BOUNDS_CHECKING_OFF_IN_EXPR}
+
+Switch off checking while a single expression is being evaluated. For instance:
+@example
+p = BOUNDS_CHECKING_OFF_IN_EXPR (a + 5);
+@end example
+
+@end itemize
+
+@node Debugging with GDB
+@subsection Debugging with GDB
+
+If you have GDB (or another debugger) on your system, you will be able to
+debug bounds checked programs easily and efficiently. To help you catch
+bounds errors before the program aborts (which sometimes causes the
+program's stack to disappear), place a breakpoint at
+@code{__bounds_breakpoint}. The checking library always calls this
+breakpoint before aborting. If the @code{-never-fatal} flag has been supplied
+@xref{Environment at runtime}, you will need to place this
+breakpoint, since the program does not abort when it hits a bounds error.
+
+@node Environment at runtime
+@subsection Environment at runtime
+
+You can customize the way a bounds-checked program runs by passing options
+to it in the environment variable `GCC_BOUNDS_OPTS'. For instance, suppose
+you don't want the banner message that appears when bounds checked programs
+start up. With sh or ksh, you might type:
+
+@example
+% GCC_BOUNDS_OPTS='-no-message' program
+@end example
+
+With csh:
+
+@example
+% setenv GCC_BOUNDS_OPTS '-no-message'; program
+@end example
+
+You can put any combination of the following flags in GCC_BOUNDS_OPTS. Place
+spaces or tabs between each flag.
+
+@table @samp
+@item -no-message
+Don't print the introductory message.
+@item -no-statistics
+Don't print library call statistics with the program quits.
+@item -?, -help
+Print this list of options, then quit the program before it starts.
+@item -reuse-heap (*)
+@item -reuse-age=<age>
+@item -no-reuse-heap
+See the discussion of heap memory, @xref{Managing the heap}.
+@item -warn-unchecked-statics
+@item -no-warn-unchecked-statics (*)
+@item -warn-unchecked-stack
+@item -no-warn-unchecked-stack (*)
+See the discussion of unchecked objects, @xref{Unchecked objects}.
+@item -warn-free-null (*)
+@item -no-warn-free-null
+Give a warning if free (0) is called. Note that this may be correct in
+ANSI C, and some libraries, notably X11, do it quite often.
+@item -warn-misc-strings (*)
+@item -no-warn-misc-strings
+Miscellaneous warnings with str* and mem* functions, such as trying to call
+@code{memcpy} with size = 0.
+@item -warn-illegal
+@item -no-warn-illegal (*)
+Warn when ILLEGAL pointers are generated. These patches, provided by
+@w{Don Lewis} <gdonl@@gv.ssi1.com>, help to track down ILLEGAL pointer
+errors when they happen.
+@item -warn-unaligned (*)
+@item -no-warn-unaligned
+Warn when a pointer is used in an unaligned manner, for instance reading
+integer data as chars. This warning is turned on by default, but may be
+disabled, since some programs do this quite harmlessly. These patches were
+suggested by @w{Stuart Kemp} and @w{Eberhard Mattes}.
+@item -warn-all
+Turn on all of the warnings above.
+@item -array-index-check (*)
+@item -no-array-index-check
+Check 2D array indices correctly. This is turned on by default. This will
+only check arrays with size > 1. This is done to avoid problems with
+structure hack definintions.
+@xref{Checking 2D array indices}.
+@item -never-fatal
+Normally the library will call abort() after it detects the first bounds
+error. If this flag is given, the library attempts to proceed. The first
+error may generate more errors itself afterwards, so only the first error
+is guaranteed to be correct.
+@item -print-calls
+@item -no-print-calls (*)
+Print calls to the checking library. This option is only useful if you
+want to debug bounds checking GCC itself.
+@item -print-heap
+@item -print-heap-long
+@item -no-print-heap (*)
+Print the contents of the heap at program end. This is useful to find 
+memory leaks in your program.
+@code{-print-heap} shows the total leaked memory for each @code{malloc} call,
+while @code{-print-heap-long} shows each leaked allocation in detail.
+@end table
+
+Items marked with a `(*)' are the default.
+
+@node Managing the heap
+@subsection Managing the heap
+
+The bounds checking library includes a customized version of the GNU
+@code{malloc} library. Calls to @code{malloc}, @code{free}, @code{realloc},
+@code{calloc}, @code{cfree}, @code{valloc} and @code{memalign} are
+checked. You will get a bounds error if you try to:
+
+@itemize @bullet
+@item
+Free a pointer that has not been allocated in the proper way, or free a pointer
+twice.
+
+@item
+Reallocate a pointer that has not been allocated, or has been freed.
+
+@item
+Use a pointer to freed memory, or to memory that has been moved by
+@code{realloc}.
+
+@item
+Free or reallocate static memory.
+
+@end itemize
+
+There are several strategies for tracking stale memory pointers. Ideally,
+we would like to never reuse VM after the programmer has freed it, so that
+we will always be able to detect a stale pointer, no matter how long the
+program runs before using it. If you wish this behaviour, then pass
+the @code{-no-reuse-heap} option in `GCC_BOUNDS_OPTS'
+@xref{Environment at runtime}.@footnote{In a future version of bounds
+checking GCC, we will be able to unmap this memory. Thus the operating
+system will be able to reuse physical memory, whilest virtual memory
+addresses remain unused.}
+
+In practice, we found this technique to be wasteful, so the default is to
+reuse heap memory immediately. However, in order to provide some
+protection against stale pointers, you may pass the @code{-reuse-age=<age>}
+option to the library. This will add freed blocks to a queue of pending
+blocks. You must call @code{free} @code{<age>} times before the block
+is actually reused.
+
+Notice that the most common error is:
+
+@example
+free_list (list *p)
+@{
+  for (; p != NULL; p = p->next)
+    free (p);
+@}
+@end example
+
+The default flags, @code{-reuse-heap -reuse-age=0}, will catch this error.
+
+@node Unchecked objects
+@subsection Unchecked objects
+
+Variables declared in files that are not compiled with @code{-fbounds-checking}
+are not normally known about by the checking library. Pointers that
+point to these variables are not checked, even where the operations
+on these pointers happen within checked code. To be sure that your
+program is running without any errors, you should turn on warnings about
+unchecked operations by giving the @code{-warn-unchecked-statics} and/or
+@code{-warn-unchecked-stack} flags at runtime. @xref{Environment at
+runtime}.
+
+To avoid these warnings, and check all operations, you should take steps
+to add these objects to the tree used by the checking library. There are
+three approaches:
+
+@itemize @bullet
+@item
+Declare the object as @code{extern} somewhere in checked code. Make sure that
+the size of the object appears in the expression, ie. @code{extern int a[10];},
+not @code{extern int a[];}.
+
+@item
+Add the object by hand by calling @code{__bounds_note_constructed_object}.
+This function is declared:
+@example
+void __bounds_note_constructed_object (ptr, size, align, filename, line, name);
+  void *ptr;      /* Pointer to the object. */
+  size_t size;    /* Size of the object (bytes). */
+  size_t align;   /* Pass 1 here. */
+  char *filename; /* Filename where declared (for debugging). */
+  int line;       /* Line number. */
+  char *name;     /* Name of the object. */
+@end example
+
+@item
+Add all the objects from a single object file, or a library automagically,
+using the @code{grab-statics} tool in @file{bounds/tools}. There is a README
+file in that directory that will tell you more.
+
+@end itemize
+
+@node Miscellaneous features
+@subsection Miscellaneous features
+
+@itemize @bullet
+@item Detecting when a source file is being compiled with bounds checking.
+
+When GCC compiles a file with the @code{-fbounds-checking} flag, it
+defines @code{__BOUNDS_CHECKING_ON} in the preprocessor. In addition, the
+variable @code{__bounds_checking_on} is set to 1 when bounds checking is
+on in the program as a whole, and set to 0 when it is not. The variable
+is actually located in @code{libgcc.a}, so it is always present (unless
+you aren't using GCC).
+
+Notice the subtle difference between these two methods. Say a program
+consists of source files @file{file1.c} and @file{file2.c}. If the
+program is compiled with
+
+@example
+gcc -fbounds-checking -c file1.c
+gcc -c file2.c
+gcc -fbounds-checking file1.o file2.o -o program
+@end example
+
+@noindent
+then @file{file1.c} will be compiled with @code{__BOUNDS_CHECKING_ON}
+defined. In @file{file2.c} this will not be defined. Both files will
+be able to declare @code{extern int __bounds_checking_on;} and the
+variable will be read as @code{1} by both.
+
+If the same files are compiled without bounds checking, then
+@code{__BOUNDS_CHECKING_ON} will not be defined. Both files will be
+able to declare @code{extern int __bounds_checking_on;} and will read
+the variable as @code{0}.
+
+If the same files are compiled with another C compiler, then variable
+@code{__bounds_checking_on} will not exist. So all references to this
+variable should be defended by @code{#ifdef __GNUC__} @dots{}
+@code{#endif}.
+
+@end itemize
+
+@node Checking 2D array indices
+@subsection Checking 2D array indices
+
+2D arrays (and, indeed, n-D arrays with n >= 2) are checked as you might
+expect. We consider such arrays to be flattened before checking. For instance
+a mathematical 3x3-matrix @code{A} might be defined as:
+
+@example
+double A[3][3];
+@end example
+
+When @code{-no-array-index-check} is active we consider such a array as
+flattened.
+Bounds checking will then consider this to be a flat array with 9 elements.
+So, it is perfectly sound to write @code{A[1][4]}, since @code{1*3+4} @equiv{}
+@code{7}, and 0 <= 7 < 9. Similarly, @code{A[0][8]} and @code{A[2][-1]}
+will not generate bounds errors. (Interestingly, though, errors in the
+first index @emph{will} be caught --- this is to do with a subtlety in the
+way bounds checking works).
+
+When @code{-array-index-check} is present every dimension of the array is
+checked separatly. This is the default.
+This flag is only used for arrays with size > 1. For arrays with size of 1
+or 0 the flattened model is used. This allows the following code to work
+correctly.
+
+@example
+struct _string_t
+@{
+  int len;
+  char str[1];
+@};
+@end example
+
+@node What errors are caught
+@subsection What errors are caught
+
+A lot of people tell me that they have Purify, and bounds checking GCC seems
+unnecessary, since it seems to duplicate Purify but more slowly. Well,
+there are important reasons why bounds checking GCC is better than Purify,
+and if you rely on Purify alone, you will certainly miss bugs in your
+program.
+
+@noindent
+This is what bounds checking GCC will find, which Purify won't:
+
+@itemize @bullet
+@item Bounds of stack and static variables
+
+Try compiling:
+@example
+main ()
+@{
+  int a[10], b[100], i;
+
+  for (i = 0; i < 100; ++i)
+    a[i] = 0;
+@}
+@end example
+Purify will only detect these sorts of errors reliably if @code{a} is allocated
+with @code{malloc}.
+
+@item Large offsets from memory allocated with @code{malloc}
+
+Bugs such as the following one will not be found reliably by Purify, since
+it only puts a certain amount of blank padding between @code{malloc}'d
+memory.
+@example
+struct large_type @{
+  int data[5000];
+@};
+
+main ()
+@{
+  char *m1;
+  struct large_type *m2;
+  int i;
+
+  m1 = (char *) malloc (20000);
+  m2 = (struct large_type *) malloc (sizeof (struct large_type) * 5);
+
+  for (i = 4; i >= -2; --i) /* note: error when i == -1 */
+    m2[i].data[0] = 0;
+@}
+@end example
+
+@end itemize
+
+@noindent
+This is what Purify will find, which bounds checking GCC won't:
+
+@itemize @bullet
+@item Using a variable or memory before it is initialized
+
+Bounds checking GCC can't currently check this, but it may well be added
+in a future version. GCC itself will pick up simple instances of this
+if you pass the @code{-Winitialized} flag (without @code{-fbounds-checking}),
+but cannot check use of @code{malloc}'d memory.
+
+@end itemize
+
+There is a freeware program which emulates Purify available from Tristan
+Gingold <gingold@@amoco.saclay.cea.fr>. It only runs under Linux. Purify
+only works on Sun SPARCstations and HP-PA machines, and, of course, costs
+lots of cash.
+
+@node Performance
+@subsection Performance
+
+This page is under construction.
+
+@node Stubborn bugs
+@subsection Stubborn bugs
+
+The very latest list of bugs can be found in @file{bounds/BUGS}. This is a
+list of some of the most stubborn bugs, some of which have been around since
+the first version. Please send bug reports and (even better) bug fixes to
+`rjones@@orchestream.com' or `Haj.Ten.Brugge@@net.HCC.nl'.
+
+@itemize @bullet
+@ignore
+@item Incorrect initialization of arrays and structures.
+
+Bounds checking relies on being able to rewrite initializers for stack
+variables with side effect calls, so we can detect when a variable comes
+into scope. For instance, the code:
+
+@example
+f ()
+@{
+  @{
+    int a;
+    /* ... */
+  @}
+  @{
+    int b;
+    /* ... */
+  @}
+@}
+@end example
+
+@noindent
+may be rewritten as:
+
+@example
+f ()
+@{
+  @{
+    int a = (__bounds_add_stack_object (&a, 4, 1, ...), 0);
+    /* ... */
+  @}
+  @{
+    int b = (__bounds_add_stack_object (&b, 4, 1, ...), 0);
+    /* ... */
+  @}
+@}
+@end example
+
+The code that rewrites variable initializers is
+@w{@code{c-bounds.c:bounds_frig_decl_initial}}. The function works for
+simple things like basic types, strings, arrays of strings; but it chokes
+on some more complicated types. It usually throws the error
+
+@example
+empty initializer cannot be bounds checked
+@end example
+
+@noindent
+when it meets one of these usages. The following uses are known to throw
+up this error (all occurring as auto variables inside functions):
+
+@example
+char nodes[][20] = @{"foo", "bar"@};
+--- reported by Stuart Kemp <skemp@@bmc.com>
+
+struct @{ unsigned char c[6]; @} e = @{ 1, 2, 3, 4, 5, 6 @};
+
+struct @{ int foo, bar; @} var = *othervar;
+--- reported by Frank Cringle <fdc@@cliwe.ping.de>
+@end example
+
+I don't fully understand the TREE generated by GCC for constructors. Can
+someone else solve this?
+@end ignore
+
+@item Padding missed out between aggregates and 32-bit objects on the stack.
+
+Bounds checking GCC usually inserts bytes of padding between adjacent
+stack objects. This dead area between objects helps the checking library
+to detect the difference between a pointer to the last byte + 1 of one
+object and a pointer to the first byte of the next object. For some
+reason, this padding is omitted occasionally when a 32-bit object (eg. int,
+pointer) follows an aggregate (eg. array). But not always.
+
+The bug used to happen under Linux, but at some point in the past it seems
+to have fixed itself. The bug still appears under Solaris. You can demonstrate
+the bug by compiling Tcl/Tk on Solaris. The checking library will report
+at run time that a reference has been made to the byte following the end
+of the first object. When you look at the code, you will see that it is in fact
+referring to the next object (ie. the 32-bit integer).
+
+Update (16/10/95): I fixed some stuff in @w{assign_stack_local} and
+@w{assign_outer_stack_local} (thanks to @w{Don Lewis} @w{<gdonl@@gv.ssi1.com>})
+but I haven't been able to verify that this bug has gone for sure.
+
+@end itemize
+
+@node Using G77 with bounds checking
+@subsection Using G77 with bounds checking
+
+Bounds checking patches break the current G77 patches. You can get round this
+very easily. Copy @code{cp/bounds.c} into the @code{f/} subdirectory. Alter
+@code{f/Makefile.in} so that it compiles @code{bounds.c} along with
+the other G77 object files.
+
+Notice that this doesn't add bounds checking to FORTRAN @w{(:-<)}. Just lets
+you compile it.
+
 @node Return Address
 @section Getting the Return or Frame Address of a Function
 
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/expr.c gcc-4.0.2/gcc/expr.c
--- gcc-4.0.2.org/gcc/expr.c	2005-09-10 03:03:28.000000000 +0200
+++ gcc-4.0.2/gcc/expr.c	2005-09-29 17:50:05.000000000 +0200
@@ -52,6 +52,7 @@ Software Foundation, 59 Temple Place - S
 #include "tree-flow.h"
 #include "target.h"
 #include "timevar.h"
+#include "c-bounds.h"
 
 /* Decide whether a function's arguments should be processed
    from first to last or from last to first.
@@ -1341,6 +1342,9 @@ emit_block_move_via_libcall (rtx dst, rt
   arg_list = tree_cons (NULL_TREE, src_tree, arg_list);
   arg_list = tree_cons (NULL_TREE, dst_tree, arg_list);
 
+  if (bounds_checking_enabled)
+    bounds_convert_funcname (&fn, &arg_list);
+
   /* Now we have to build up the CALL_EXPR itself.  */
   call_expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);
   call_expr = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),
@@ -1365,7 +1369,10 @@ init_block_move_fn (const char *asmspec)
     {
       tree args, fn;
 
-      fn = get_identifier ("memcpy");
+      if (bounds_checking_enabled)
+        fn = get_identifier ("__bounds_memcpy");
+      else
+        fn = get_identifier ("memcpy");
       args = build_function_type_list (ptr_type_node, ptr_type_node,
 				       const_ptr_type_node, sizetype,
 				       NULL_TREE);
@@ -2544,6 +2551,9 @@ clear_storage_via_libcall (rtx object, r
   arg_list = tree_cons (NULL_TREE, integer_zero_node, arg_list);
   arg_list = tree_cons (NULL_TREE, object_tree, arg_list);
 
+  if (bounds_checking_enabled)
+    bounds_convert_funcname (&fn, &arg_list);
+
   /* Now we have to build up the CALL_EXPR itself.  */
   call_expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);
   call_expr = build3 (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),
@@ -2568,7 +2578,10 @@ init_block_clear_fn (const char *asmspec
     {
       tree fn, args;
 
-      fn = get_identifier ("memset");
+      if (bounds_checking_enabled)
+        fn = get_identifier ("__bounds_memset");
+      else
+        fn = get_identifier ("memset");
       args = build_function_type_list (ptr_type_node, ptr_type_node,
 				       integer_type_node, sizetype,
 				       NULL_TREE);
@@ -5229,6 +5242,7 @@ store_field (rtx target, HOST_WIDE_INT b
 	 RHS isn't the same size as the bitfield, we must use bitfield
 	 operations.  */
       || (bitsize >= 0
+	  && TREE_TYPE (exp) != error_mark_node
 	  && TREE_CODE (TYPE_SIZE (TREE_TYPE (exp))) == INTEGER_CST
 	  && compare_tree_int (TYPE_SIZE (TREE_TYPE (exp)), bitsize) != 0))
     {
@@ -6057,7 +6071,13 @@ expand_var (tree var)
       else if (TREE_CODE (var) == VAR_DECL && !TREE_STATIC (var))
 	expand_decl (var);
       else if (TREE_CODE (var) == VAR_DECL && TREE_STATIC (var))
-	rest_of_decl_compilation (var, 0, 0);
+	{
+	  rest_of_decl_compilation (var, 0, 0);
+	  /* Generate extra runtime expression for decl if needed.  */
+	  if (bounds_checking_enabled && POINTER_TYPE_P (TREE_TYPE (var)))
+	    bounds_mark_for_runtime_check (var);
+
+	}
       else
 	/* No expansion needed.  */
 	gcc_assert (TREE_CODE (var) == TYPE_DECL
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/flags.h gcc-4.0.2/gcc/flags.h
--- gcc-4.0.2.org/gcc/flags.h	2005-02-13 20:05:03.000000000 +0100
+++ gcc-4.0.2/gcc/flags.h	2005-09-29 17:50:05.000000000 +0200
@@ -201,6 +201,14 @@ extern int flag_renumber_insns;
 
 extern int frame_pointer_needed;
 
+/* Flag indicating bounds checking in the C front-end.  */
+
+extern int bounds_checking_enabled;
+
+/* Flag for string only bounds checking.  */
+
+extern int bounds_strings_only_enabled;
+
 /* Nonzero if subexpressions must be evaluated from left-to-right.  */
 extern int flag_evaluation_order;
 
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/fold-const.c gcc-4.0.2/gcc/fold-const.c
--- gcc-4.0.2.org/gcc/fold-const.c	2005-09-09 11:25:02.000000000 +0200
+++ gcc-4.0.2/gcc/fold-const.c	2005-09-29 17:50:05.000000000 +0200
@@ -3021,6 +3021,15 @@ invert_truthvalue (tree arg)
       return build1 (CLEANUP_POINT_EXPR, type,
 		     invert_truthvalue (TREE_OPERAND (arg, 0)));
 
+      /* Bounds checking often builds call expressions returning an integer
+	 in place of equality and inequality operations, so we must catch
+	 this case specially here. Otherwise, we abort after this switch
+	 statement, since the return type cannot be `BOOLEAN' in C.  */
+    case CALL_EXPR:
+      if (bounds_checking_enabled && TREE_CODE (type) == INTEGER_TYPE)
+	return build1 (TRUTH_NOT_EXPR, type, arg);
+      break;
+
     default:
       break;
     }
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/fortran/bounds.c gcc-4.0.2/gcc/fortran/bounds.c
--- gcc-4.0.2.org/gcc/fortran/bounds.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/fortran/bounds.c	2005-09-29 17:50:05.000000000 +0200
@@ -0,0 +1,166 @@
+/* This file is a dummy, for when C++ gets bounds checking like C. In the
+   mean time, there are some empty function definitions here, since `calls.c'
+   references these (but never calls them). */
+
+#include "config.h"
+#include "system.h"
+#include <stdio.h>
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "tree.h"
+#include "varray.h"
+#include "ggc.h"
+
+static GTY (()) varray_type static_ptr_init_list;
+static GTY (()) varray_type deferred_global_decls;
+static GTY (()) tree bounds_memcpy;
+static GTY (()) tree bounds_mempcpy;
+static GTY (()) tree bounds_memset;
+static GTY (()) tree bounds_find_object;
+static GTY (()) tree bounds_maybe_find_object;
+static GTY (()) tree bounds_check_ptr_plus_int;
+static GTY (()) tree bounds_check_ptr_minus_int;
+static GTY (()) tree bounds_check_ptr_plus_int_obj;
+static GTY (()) tree bounds_check_ptr_minus_int_obj;
+static GTY (()) tree bounds_check_array_reference;
+static GTY (()) tree bounds_check_array_reference_obj;
+static GTY (()) tree bounds_check_component_reference;
+static GTY (()) tree bounds_check_component_reference_obj;
+static GTY (()) tree bounds_check_ptr_diff;
+static GTY (()) tree bounds_check_ptr_diff_obj;
+static GTY (()) tree bounds_check_reference;
+static GTY (()) tree bounds_check_reference_obj;
+static GTY (()) tree bounds_check_ptr_lt_ptr;
+static GTY (()) tree bounds_check_ptr_lt_ptr_obj;
+static GTY (()) tree bounds_check_ptr_le_ptr;
+static GTY (()) tree bounds_check_ptr_le_ptr_obj;
+static GTY (()) tree bounds_check_ptr_gt_ptr;
+static GTY (()) tree bounds_check_ptr_gt_ptr_obj;
+static GTY (()) tree bounds_check_ptr_ge_ptr;
+static GTY (()) tree bounds_check_ptr_ge_ptr_obj;
+static GTY (()) tree bounds_check_ptr_eq_ptr;
+static GTY (()) tree bounds_check_ptr_ne_ptr;
+static GTY (()) tree bounds_check_ptr_postinc;
+static GTY (()) tree bounds_check_ptr_preinc;
+static GTY (()) tree bounds_check_ptr_postdec;
+static GTY (()) tree bounds_check_ptr_predec;
+static GTY (()) tree bounds_check_ptr_postinc_obj;
+static GTY (()) tree bounds_check_ptr_preinc_obj;
+static GTY (()) tree bounds_check_ptr_postdec_obj;
+static GTY (()) tree bounds_check_ptr_predec_obj;
+static GTY (()) tree bounds_check_ptr_postinc_ref;
+static GTY (()) tree bounds_check_ptr_preinc_ref;
+static GTY (()) tree bounds_check_ptr_postdec_ref;
+static GTY (()) tree bounds_check_ptr_predec_ref;
+static GTY (()) tree bounds_check_ptr_postinc_ref_obj;
+static GTY (()) tree bounds_check_ptr_preinc_ref_obj;
+static GTY (()) tree bounds_check_ptr_postdec_ref_obj;
+static GTY (()) tree bounds_check_ptr_predec_ref_obj;
+static GTY (()) tree bounds_check_ptr_true;
+static GTY (()) tree bounds_check_ptr_false;
+static GTY (()) tree bounds_note_constructed_object;
+static GTY (()) tree bounds_note_constructed_private_table;
+static GTY (()) tree bounds_push_function;
+static GTY (()) tree bounds_pop_function;
+static GTY (()) tree bounds_add_param_object;
+static GTY (()) tree bounds_add_stack_object;
+static GTY (()) tree bounds_delete_stack_object;
+static GTY (()) tree bounds_initialize_library;
+static GTY (()) tree bounds_check_free;
+static GTY (()) tree bounds_check_malloc;
+static GTY (()) tree bounds_check_realloc;
+static GTY (()) tree bounds_check_memalign;
+static GTY (()) tree bounds_check_calloc;
+static GTY (()) tree bounds_check_valloc;
+static GTY (()) tree bounds_check_alloca;
+static GTY (()) tree bounds_check___alloca;
+static GTY (()) tree bounds_check___builtin_alloca;
+static GTY (()) tree bounds_check_mmap;
+static GTY (()) tree bounds_check_munmap;
+static GTY (()) tree bounds_check_memcpy;
+static GTY (()) tree bounds_check_mempcpy;
+static GTY (()) tree bounds_check_memmove;
+static GTY (()) tree bounds_check_bcopy;
+static GTY (()) tree bounds_check_memset;
+static GTY (()) tree bounds_check_bzero;
+static GTY (()) tree bounds_check_memcmp;
+static GTY (()) tree bounds_check_bcmp;
+static GTY (()) tree bounds_check_strcpy;
+static GTY (()) tree bounds_check_strncpy;
+static GTY (()) tree bounds_check_strlen;
+static GTY (()) tree bounds_check_strcmp;
+static GTY (()) tree bounds_check_strncmp;
+static GTY (()) tree bounds_check_strcat;
+static GTY (()) tree bounds_check_strncat;
+static GTY (()) tree bounds_check_strpbrk;
+static GTY (()) tree bounds_check_strrchr;
+static GTY (()) tree bounds_check_rindex;
+static GTY (()) tree bounds_check_strspn;
+static GTY (()) tree bounds_check_strcspn;
+static GTY (()) tree bounds_check_strstr;
+static GTY (()) tree bounds_check_strtok;
+static GTY (()) tree bounds_check_strtok_r;
+static GTY (()) tree bounds_check_strdup;
+static GTY (()) tree bounds_check_strchr;
+static GTY (()) tree bounds_check_index;
+static GTY (()) tree bounds_check_strcoll;
+static GTY (()) tree bounds_check_strxfrm;
+static GTY (()) tree bounds_check_strcasecmp;
+static GTY (()) tree bounds_check_strncasecmp;
+static GTY (()) tree bounds_check_memchr;
+static GTY (()) tree bounds_check_memccpy;
+static GTY (()) tree bounds_private_statics;
+
+#include "gt-c-bounds.h"
+
+void
+bounds_convert_funcname (tree * function ATTRIBUTE_UNUSED,
+			 tree * params ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+void
+bounds_mark_for_runtime_check (tree decl ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+void
+bounds_build_static_constructors (void)
+{
+  abort ();
+}
+
+void
+bounds_register_decl (tree decl ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+int
+bounds_is_deletable_fn_p (char *name ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+void
+bounds_note_call_for_deletion (rtx first_insn ATTRIBUTE_UNUSED,
+			       rtx last_insn ATTRIBUTE_UNUSED,
+			       char *fnname ATTRIBUTE_UNUSED,
+			       tree callexpr ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+tree
+bounds_build_truthvalue_conversion (tree arg ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+void
+bounds_delete_redundant_calls (void)
+{
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/fortran/Make-lang.in gcc-4.0.2/gcc/fortran/Make-lang.in
--- gcc-4.0.2.org/gcc/fortran/Make-lang.in	2004-11-13 08:35:54.000000000 +0100
+++ gcc-4.0.2/gcc/fortran/Make-lang.in	2005-09-29 17:50:05.000000000 +0200
@@ -74,7 +74,7 @@ F95_OBJS = $(F95_PARSER_OBJS) \
     fortran/trans.o fortran/trans-array.o fortran/trans-common.o \
     fortran/trans-const.o fortran/trans-decl.o fortran/trans-expr.o \
     fortran/trans-intrinsic.o fortran/trans-io.o fortran/trans-stmt.o \
-    fortran/trans-types.o
+    fortran/trans-types.o fortran/bounds.o
 
 # GFORTRAN uses GMP for its internal arithmetics.
 F95_LIBS = $(GMPLIBS) $(LIBS)
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/function.c gcc-4.0.2/gcc/function.c
--- gcc-4.0.2.org/gcc/function.c	2005-03-10 16:11:04.000000000 +0100
+++ gcc-4.0.2/gcc/function.c	2005-09-29 17:50:06.000000000 +0200
@@ -61,6 +61,7 @@ Software Foundation, 59 Temple Place - S
 #include "target.h"
 #include "cfglayout.h"
 #include "tree-gimple.h"
+#include "c-bounds.h"
 
 #ifndef LOCAL_ALIGNMENT
 #define LOCAL_ALIGNMENT(TYPE, ALIGNMENT) ALIGNMENT
@@ -421,6 +422,9 @@ assign_stack_local_1 (enum machine_mode 
   else
     alignment = align / BITS_PER_UNIT;
 
+  if (bounds_checking_enabled)
+    size += BIGGEST_ALIGNMENT / BITS_PER_UNIT;
+
 #ifdef FRAME_GROWS_DOWNWARD
   function->x_frame_offset -= size;
 #endif
@@ -465,7 +469,11 @@ assign_stack_local_1 (enum machine_mode 
   /* On a big-endian machine, if we are allocating more space than we will use,
      use the least significant bytes of those that are allocated.  */
   if (BYTES_BIG_ENDIAN && mode != BLKmode)
-    bigend_correction = size - GET_MODE_SIZE (mode);
+    {
+      bigend_correction = size - GET_MODE_SIZE (mode);
+      if (bounds_checking_enabled)
+	bigend_correction -= BIGGEST_ALIGNMENT / BITS_PER_UNIT;
+    }
 
   /* If we have already instantiated virtual registers, return the actual
      address relative to the frame pointer.  */
@@ -607,6 +615,10 @@ assign_stack_temp_for_type (enum machine
   /* These are now unused.  */
   gcc_assert (keep <= 1);
 
+  /* Add a byte of padding between bounds checked variables.  */
+  if (bounds_checking_enabled)
+    size += BIGGEST_ALIGNMENT / BITS_PER_UNIT;
+
   if (mode == BLKmode)
     align = BIGGEST_ALIGNMENT;
   else
@@ -4088,6 +4100,9 @@ expand_main_function (void)
 #ifndef HAS_INIT_SECTION
   emit_library_call (init_one_libfunc (NAME__MAIN), LCT_NORMAL, VOIDmode, 0);
 #endif
+  if (bounds_checking_enabled && bounds_reentrant_defined)
+    emit_library_call (gen_rtx_SYMBOL_REF (Pmode, "__bounds_pthread_init"),
+		       LCT_NORMAL, VOIDmode, 0);
 }
 
 /* Start the RTL for a new function, and set variables used for
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/function.h gcc-4.0.2/gcc/function.h
--- gcc-4.0.2.org/gcc/function.h	2005-02-20 12:09:16.000000000 +0100
+++ gcc-4.0.2/gcc/function.h	2005-09-29 17:50:06.000000000 +0200
@@ -349,6 +349,10 @@ struct function GTY(())
   /* The variables unexpanded so far.  */
   tree unexpanded_var_list;
 
+  /* Contains the variable that holds the current bounds-checking function
+     number.  */
+  tree bounds_function_nr;
+
   /* Collected bit flags.  */
 
   /* Nonzero if function being compiled needs to be given an address
@@ -471,6 +475,7 @@ extern int trampolines_created;
 #define current_function_epilogue_delay_list (cfun->epilogue_delay_list)
 #define current_function_has_nonlocal_label (cfun->has_nonlocal_label)
 #define current_function_has_nonlocal_goto (cfun->has_nonlocal_goto)
+#define current_function_bounds_nr (cfun->bounds_function_nr)
 
 #define return_label (cfun->x_return_label)
 #define naked_return_label (cfun->x_naked_return_label)
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/gcc.c gcc-4.0.2/gcc/gcc.c
--- gcc-4.0.2.org/gcc/gcc.c	2005-06-06 21:20:29.000000000 +0200
+++ gcc-4.0.2/gcc/gcc.c	2005-09-29 17:50:06.000000000 +0200
@@ -577,6 +577,12 @@ proper position among the other output f
 #ifndef CPP_SPEC
 #define CPP_SPEC ""
 #endif
+#ifndef BOUNDS_CPP_SPEC
+#define	BOUNDS_CPP_SPEC	" %{fbounds-checking:-D__BOUNDS_CHECKING_ON}" \
+			" %{fbc-strings-only:-D__BC_STRINGS_ONLY_ON}" \
+			" %{fbounds-checking|fbc-strings-only: " \
+				"-include unchecked.h} "
+#endif
 
 /* config.h can define CC1_SPEC to provide extra args to cc1 and cc1plus
    or extra switch-translations.  */
@@ -701,6 +707,8 @@ proper position among the other output f
     %{s} %{t} %{u*} %{x} %{z} %{Z} %{!A:%{!nostdlib:%{!nostartfiles:%S}}}\
     %{static:} %{L*} %(mfwrap) %(link_libgcc) %o %(mflib)\
     %{fprofile-arcs|fprofile-generate:-lgcov}\
+    %{!symbolic:%{!shared:%{fbounds-checking:libboundscheck.a%s}}}\
+    %{!symbolic:%{!shared:%{fbc-strings-only:libboundscheck.a%s}}}\
     %{!nostdlib:%{!nodefaultlibs:%(link_gcc_c_sequence)}}\
     %{!A:%{!nostdlib:%{!nostartfiles:%E}}} %{T*} }}}}}}"
 #endif
@@ -723,7 +731,7 @@ proper position among the other output f
 #endif
 
 static const char *asm_debug;
-static const char *cpp_spec = CPP_SPEC;
+static const char *cpp_spec = CPP_SPEC BOUNDS_CPP_SPEC;
 static const char *cc1_spec = CC1_SPEC;
 static const char *cc1plus_spec = CC1PLUS_SPEC;
 static const char *link_gcc_c_sequence_spec = LINK_GCC_C_SEQUENCE_SPEC;
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/genconditions.c gcc-4.0.2/gcc/genconditions.c
--- gcc-4.0.2.org/gcc/genconditions.c	2005-01-24 13:08:06.000000000 +0100
+++ gcc-4.0.2/gcc/genconditions.c	2005-09-29 17:50:06.000000000 +0200
@@ -128,7 +128,11 @@ extern rtx operands[];\n");
    array initializers, fall back (by using dummy-conditions.c above)\n\
    to assuming that all conditions potentially vary at run time.  It\n\
    works in 3.0.1 and later; 3.0 only when not optimizing.  */\n\
-#define MAYBE_EVAL(expr) (__builtin_constant_p(expr) ? (int) (expr) : -1)\n");
+#ifndef __BOUNDS_CHECKING_ON\n\
+# define MAYBE_EVAL(expr) (__builtin_constant_p(expr) ? (int) (expr) : -1)\n\
+#else\n\
+# define MAYBE_EVAL(expr) -1\n\
+#endif\n");
 }
 
 /* Write out one entry in the conditions table, using the data pointed
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/gimplify.c gcc-4.0.2/gcc/gimplify.c
--- gcc-4.0.2.org/gcc/gimplify.c	2005-09-02 17:34:38.000000000 +0200
+++ gcc-4.0.2/gcc/gimplify.c	2005-09-29 17:50:06.000000000 +0200
@@ -334,7 +334,7 @@ create_tmp_var_raw (tree type, const cha
   TYPE_ATTRIBUTES (new_type) = TYPE_ATTRIBUTES (type);
 
   tmp_var = build_decl (VAR_DECL, prefix ? create_tmp_var_name (prefix) : NULL,
-			type);
+			new_type);
 
   /* The variable was declared by the compiler.  */
   DECL_ARTIFICIAL (tmp_var) = 1;
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/ginclude/stdarg.h gcc-4.0.2/gcc/ginclude/stdarg.h
--- gcc-4.0.2.org/gcc/ginclude/stdarg.h	2003-03-13 03:58:40.000000000 +0100
+++ gcc-4.0.2/gcc/ginclude/stdarg.h	2005-09-29 17:50:07.000000000 +0200
@@ -49,7 +49,22 @@ typedef __builtin_va_list __gnuc_va_list
 
 #define va_start(v,l)	__builtin_va_start(v,l)
 #define va_end(v)	__builtin_va_end(v)
+
+/* Define va_arg in terms of __builtin_va_arg as appropriate for bounds
+   checking.  */
+#ifndef __BOUNDS_CHECKING_ON
+
 #define va_arg(v,l)	__builtin_va_arg(v,l)
+
+#else /* __BOUNDS_CHECKING_ON */
+
+#define va_arg(AP,TYPE) \
+_Pragma("bounds_checking off") \
+  __builtin_va_arg(AP,TYPE) \
+_Pragma("bounds_checking on")
+
+#endif /* __BOUNDS_CHECKING_ON */
+
 #if !defined(__STRICT_ANSI__) || __STDC_VERSION__ + 0 >= 199900L
 #define va_copy(d,s)	__builtin_va_copy(d,s)
 #endif
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/ginclude/unchecked.h gcc-4.0.2/gcc/ginclude/unchecked.h
--- gcc-4.0.2.org/gcc/ginclude/unchecked.h	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/ginclude/unchecked.h	2005-09-29 17:50:07.000000000 +0200
@@ -0,0 +1,1752 @@
+/*----------------------------------------------------------------------*
+ * Bounds Checking for GCC.						*
+ * Copyright (C) 1995 Richard W.M. Jones <rjones@orchestream.com>.	*
+ *----------------------------------------------------------------------*
+ * This program is free software; you can redistribute it and/or modify	*
+ * it under the terms of the GNU General Public License as published by	*
+ * the Free Software Foundation; either version 2 of the License, or	*
+ * (at your option) any later version.					*
+ *									*
+ * This program is distributed in the hope that it will be useful,	*
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of	*
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	*
+ * GNU General Public License for more details.				*
+ *									*
+ * You should have received a copy of the GNU General Public License	*
+ * along with this program; if not, write to the Free Software		*
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.		*
+ *----------------------------------------------------------------------*
+ * File:
+ *	run-includes/unchecked.h
+ * Summary:
+ *	Macros to allow per-pointer and per-use unchecked pointers.
+ * Other notes:
+ *	
+ * Author      	Date		Notes
+ * RWMJ		23/1/95		Initial implementation.
+ * RWMJ         17/6/95         Added miscellaneous features.
+ *----------------------------------------------------------------------*/
+
+#ifndef _bounds_unchecked_h
+#define _bounds_unchecked_h
+
+#if defined(__GNUC__) && defined(__BOUNDS_CHECKING_ON)
+
+/* Make pointer operations unchecked on each use.  */
+#define UNCHECKED_PTR_DIFF(p,q)		BOUNDS_CHECKING_OFF_IN_EXPR((p) - (q))
+#define UNCHECKED_PTR_PLUS_INT(p,i)	BOUNDS_CHECKING_OFF_IN_EXPR((p) + (i))
+#define UNCHECKED_PTR_MINUS_INT(p,i)	BOUNDS_CHECKING_OFF_IN_EXPR((p) - (i))
+
+/* How to switch checking off over a region of the program. You will need
+ * 'DEBUG_FEATURES' set in the library. You do:
+ *     ..
+ *    BOUNDS_CHECKING_OFF;
+ *     .. strange pointer operations here ..
+ *    BOUNDS_CHECKING_ON;
+ */
+#define BOUNDS_CHECKING_OFF \
+_Pragma("bounds_checking off")
+
+#define BOUNDS_CHECKING_ON  \
+_Pragma("bounds_checking on")
+
+/* Switch bounds checking off in a single statement. You do:
+ *    BOUNDS_CHECKING_OFF_DURING (stmt);
+ * This works for most 'ordinary' statements, ie. not returns, or gotos, etc.
+ * For expressions, use:
+ *    BOUNDS_CHECKING_OFF_IN_EXPR (expr)
+ */
+#define BOUNDS_CHECKING_OFF_DURING(stmt) \
+  BOUNDS_CHECKING_OFF \
+  do { stmt; } while (0) \
+  BOUNDS_CHECKING_ON
+
+#define BOUNDS_CHECKING_OFF_IN_EXPR(expr) \
+  BOUNDS_CHECKING_OFF \
+  (expr) \
+  BOUNDS_CHECKING_ON
+
+
+#if defined(__OPTIMIZE__) && defined(__BOUNDS_INLINE__)
+
+#ifndef __BOUNDS_DEBUG_FEATURES
+#define	__BOUNDS_DEBUG_FEATURES	0
+#endif
+#ifndef __BOUNDS_COLLECT_STATS
+#define	__BOUNDS_COLLECT_STATS	0
+#endif
+
+#if __BOUNDS_DEBUG_FEATURES
+extern int __bounds_debug_print_calls;
+#endif
+
+#if __BOUNDS_COLLECT_STATS
+extern unsigned __bounds_stats_ptr_plus_int;
+extern unsigned __bounds_stats_array_reference;
+extern unsigned __bounds_stats_ptr_diff;
+extern unsigned __bounds_stats_reference;
+extern unsigned __bounds_stats_component_reference;
+extern unsigned __bounds_stats_ptr_le_ptr;
+extern unsigned __bounds_stats_ptr_lt_ptr;
+extern unsigned __bounds_stats_ptr_ge_ptr;
+extern unsigned __bounds_stats_ptr_gt_ptr;
+extern unsigned __bounds_stats_ptr_ne_ptr;
+extern unsigned __bounds_stats_ptr_eq_ptr;
+extern unsigned __bounds_stats_ptr_postinc;
+extern unsigned __bounds_stats_ptr_preinc;
+extern unsigned __bounds_stats_ptr_postdec;
+extern unsigned __bounds_stats_ptr_predec;
+extern unsigned __bounds_stats_ptr_true;
+extern unsigned __bounds_stats_ptr_false;
+#endif
+
+#pragma bounds_checking off
+
+#define __BOUNDS_NULL    (void *)0
+#define __BOUNDS_ILLEGAL (void *)-2
+
+typedef __SIZE_TYPE__ __bounds_size_t;
+
+typedef struct
+{
+  void *__bounds_base;		/* Points to base of the object.  */
+  void *__bounds_extent;	/* Points to last byte in object+1.  */
+  __bounds_size_t __bounds_size;	/* Size of the object.  */
+} __bounds_object;
+
+typedef union
+{
+  void *__bounds_void_pointer;
+  char *__bounds_char_pointer;
+} __bounds_union_type;
+
+extern __bounds_object *__bounds_find_object (void *__bounds_pointer);
+
+#pragma redefine_extname __dummy_bounds_check_ptr_plus_int \
+				__bounds_check_ptr_plus_int
+
+extern void *__dummy_bounds_check_ptr_plus_int (__bounds_object *
+						__bounds_obj,
+						void *__bounds_pointer,
+						int __bounds_offset,
+						__bounds_size_t __bounds_size,
+						const char *__bounds_filename,
+						int __bounds_line);
+
+extern __inline__ void *
+__bounds_check_ptr_plus_int (__bounds_object * __bounds_obj,
+			     void *__bounds_pointer, int __bounds_offset,
+			     __bounds_size_t __bounds_size,
+			     const char *__bounds_filename, int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pnew;
+
+  __bounds_union.__bounds_void_pointer = __bounds_pointer;
+  __bounds_union.__bounds_char_pointer +=
+    (int) __bounds_size *__bounds_offset;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_pnew > __bounds_obj->__bounds_extent)
+    __bounds_pnew =
+      __dummy_bounds_check_ptr_plus_int (__bounds_obj, __bounds_pointer,
+					 __bounds_offset, __bounds_size,
+					 __bounds_filename, __bounds_line);
+#if __BOUNDS_COLLECT_STATS
+  else
+    ++__bounds_stats_ptr_plus_int;
+#endif
+  return __bounds_pnew;
+}
+
+extern __inline__ void *
+__bounds_check_ptr_plus_int_obj (void *__bounds_pointer,
+				 int __bounds_offset,
+				 __bounds_size_t __bounds_size,
+				 const char *__bounds_filename,
+				 int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pnew;
+  __bounds_object *__bounds_obj = __bounds_find_object (__bounds_pointer);
+
+  __bounds_union.__bounds_void_pointer = __bounds_pointer;
+  __bounds_union.__bounds_char_pointer +=
+    (int) __bounds_size *__bounds_offset;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_pnew > __bounds_obj->__bounds_extent)
+    __bounds_pnew =
+      __dummy_bounds_check_ptr_plus_int (__bounds_obj, __bounds_pointer,
+					 __bounds_offset, __bounds_size,
+					 __bounds_filename, __bounds_line);
+#if __BOUNDS_COLLECT_STATS
+  else
+    ++__bounds_stats_ptr_plus_int;
+#endif
+  return __bounds_pnew;
+}
+
+#pragma redefine_extname __dummy_bounds_check_ptr_minus_int \
+				__bounds_check_ptr_minus_int
+
+extern void *__dummy_bounds_check_ptr_minus_int (__bounds_object *
+						 __bounds_obj,
+						 void *__bounds_pointer,
+						 int __bounds_offset,
+						 __bounds_size_t
+						 __bounds_size,
+						 const char
+						 *__bounds_filename,
+						 int __bounds_line);
+
+extern __inline__ void *
+__bounds_check_ptr_minus_int (__bounds_object * __bounds_obj,
+			      void *__bounds_pointer, int __bounds_offset,
+			      __bounds_size_t __bounds_size,
+			      const char *__bounds_filename,
+			      int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pnew;
+
+  __bounds_union.__bounds_void_pointer = __bounds_pointer;
+  __bounds_union.__bounds_char_pointer -=
+    (int) __bounds_size *__bounds_offset;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_pnew > __bounds_obj->__bounds_extent)
+    __bounds_pnew =
+      __dummy_bounds_check_ptr_minus_int (__bounds_obj, __bounds_pointer,
+					  __bounds_offset, __bounds_size,
+					  __bounds_filename, __bounds_line);
+#if __BOUNDS_COLLECT_STATS
+  else
+    ++__bounds_stats_ptr_plus_int;
+#endif
+  return __bounds_pnew;
+}
+
+extern __inline__ void *
+__bounds_check_ptr_minus_int_obj (void *__bounds_pointer,
+				  int __bounds_offset,
+				  __bounds_size_t __bounds_size,
+				  const char *__bounds_filename,
+				  int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pnew;
+  __bounds_object *__bounds_obj = __bounds_find_object (__bounds_pointer);
+
+  __bounds_union.__bounds_void_pointer = __bounds_pointer;
+  __bounds_union.__bounds_char_pointer -=
+    (int) __bounds_size *__bounds_offset;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_pnew > __bounds_obj->__bounds_extent)
+    __bounds_pnew =
+      __dummy_bounds_check_ptr_minus_int (__bounds_obj, __bounds_pointer,
+					  __bounds_offset, __bounds_size,
+					  __bounds_filename, __bounds_line);
+#if __BOUNDS_COLLECT_STATS
+  else
+    ++__bounds_stats_ptr_plus_int;
+#endif
+  return __bounds_pnew;
+}
+
+#pragma redefine_extname __dummy_bounds_check_array_reference \
+				__bounds_check_array_reference
+
+extern int
+__dummy_bounds_check_array_reference (__bounds_object * __bounds_obj,
+				      void *__bounds_pointer,
+				      int __bounds_offset,
+				      __bounds_size_t __bounds_size,
+				      __bounds_size_t __bounds_array_size,
+				      const char *__bounds_filename,
+				      int __bounds_line);
+
+extern __inline__ int
+__bounds_check_array_reference (__bounds_object * __bounds_obj,
+				void *__bounds_pointer, int __bounds_offset,
+				__bounds_size_t __bounds_size,
+				__bounds_size_t __bounds_array_size,
+				const char *__bounds_filename,
+				int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pnew;
+  void *__bounds_ptop;
+
+  __bounds_union.__bounds_void_pointer = __bounds_pointer;
+  __bounds_union.__bounds_char_pointer +=
+    (int) __bounds_size *__bounds_offset;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+  __bounds_union.__bounds_char_pointer += __bounds_size;
+  __bounds_ptop = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       (__bounds_array_size > __bounds_size
+	&& (__bounds_offset < 0
+	    || ((int) __bounds_size * __bounds_offset) >=
+	    (int) __bounds_array_size)) || __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_ptop > __bounds_obj->__bounds_extent)
+    __bounds_offset = __dummy_bounds_check_array_reference (__bounds_obj,
+							    __bounds_pointer,
+							    __bounds_offset,
+							    __bounds_size,
+							    __bounds_array_size,
+							    __bounds_filename,
+							    __bounds_line);
+#if __BOUNDS_COLLECT_STATS
+  else
+    ++__bounds_stats_array_reference;
+#endif
+  return __bounds_offset;
+}
+
+extern __inline__ int
+__bounds_check_array_reference_obj (void *__bounds_pointer,
+				    int __bounds_offset,
+				    __bounds_size_t __bounds_size,
+				    __bounds_size_t __bounds_array_size,
+				    const char *__bounds_filename,
+				    int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pnew;
+  void *__bounds_ptop;
+  __bounds_object *__bounds_obj = __bounds_find_object (__bounds_pointer);
+
+  __bounds_union.__bounds_void_pointer = __bounds_pointer;
+  __bounds_union.__bounds_char_pointer +=
+    (int) __bounds_size *__bounds_offset;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+  __bounds_union.__bounds_char_pointer += __bounds_size;
+  __bounds_ptop = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       (__bounds_array_size > __bounds_size
+	&& (__bounds_offset < 0
+	    || ((int) __bounds_size * __bounds_offset) >=
+	    (int) __bounds_array_size)) || __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_ptop > __bounds_obj->__bounds_extent)
+    __bounds_offset = __dummy_bounds_check_array_reference (__bounds_obj,
+							    __bounds_pointer,
+							    __bounds_offset,
+							    __bounds_size,
+							    __bounds_array_size,
+							    __bounds_filename,
+							    __bounds_line);
+#if __BOUNDS_COLLECT_STATS
+  else
+    ++__bounds_stats_array_reference;
+#endif
+  return __bounds_offset;
+}
+
+#pragma redefine_extname __dummy_bounds_check_ptr_diff \
+				__bounds_check_ptr_diff
+
+extern int
+__dummy_bounds_check_ptr_diff (__bounds_object * __bounds_obj1,
+			       __bounds_object * __bounds_obj2,
+			       void *__bounds_pointer1,
+			       void *__bounds_pointer2,
+			       __bounds_size_t __bounds_size,
+			       const char *__bounds_filename,
+			       int __bounds_line);
+
+extern __inline__ int
+__bounds_check_ptr_diff (__bounds_object * __bounds_obj1,
+			 __bounds_object * __bounds_obj2,
+			 void *__bounds_pointer1, void *__bounds_pointer2,
+			 __bounds_size_t __bounds_size,
+			 const char *__bounds_filename, int __bounds_line)
+{
+  int __bounds_result;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj1 == __BOUNDS_NULL || __bounds_obj1 != __bounds_obj2)
+    __bounds_result =
+      __dummy_bounds_check_ptr_diff (__bounds_obj1, __bounds_obj2,
+				     __bounds_pointer1, __bounds_pointer2,
+				     __bounds_size, __bounds_filename,
+				     __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_diff;
+#endif
+      __bounds_result = (int) ((char *) __bounds_pointer1 -
+			       (char *) __bounds_pointer2) /
+	(int) __bounds_size;
+    }
+  return __bounds_result;
+}
+
+extern __inline__ int
+__bounds_check_ptr_diff_obj (void *__bounds_pointer1, void *__bounds_pointer2,
+			     __bounds_size_t __bounds_size,
+			     const char *__bounds_filename, int __bounds_line)
+{
+  int __bounds_result;
+
+  __bounds_object *__bounds_obj1 = __bounds_find_object (__bounds_pointer1);
+  __bounds_object *__bounds_obj2 = __bounds_find_object (__bounds_pointer2);
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj1 == __BOUNDS_NULL || __bounds_obj1 != __bounds_obj2)
+    __bounds_result =
+      __dummy_bounds_check_ptr_diff (__bounds_obj1, __bounds_obj2,
+				     __bounds_pointer1, __bounds_pointer2,
+				     __bounds_size, __bounds_filename,
+				     __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_diff;
+#endif
+      __bounds_result = (int) ((char *) __bounds_pointer1 -
+			       (char *) __bounds_pointer2) /
+	(int) __bounds_size;
+    }
+  return __bounds_result;
+}
+
+#pragma redefine_extname __dummy_bounds_check_component_reference \
+				__bounds_check_component_reference
+
+extern void *__dummy_bounds_check_component_reference (__bounds_object *
+						       __bounds_obj,
+						       void *__bounds_pointer,
+						       int __bounds_offset,
+						       int __bounds_size,
+						       const char
+						       *__bounds_filename,
+						       int __bounds_line);
+
+extern __inline__ void *
+__bounds_check_component_reference (__bounds_object * __bounds_obj,
+				    void *__bounds_pointer,
+				    int __bounds_offset, int __bounds_size,
+				    const char *__bounds_filename,
+				    int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_plow;
+  void *__bounds_phigh;
+
+  __bounds_union.__bounds_void_pointer = __bounds_pointer;
+  __bounds_union.__bounds_char_pointer += __bounds_offset;
+  __bounds_plow = __bounds_union.__bounds_void_pointer;
+  __bounds_union.__bounds_char_pointer += __bounds_size;
+  __bounds_phigh = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_plow < __bounds_obj->__bounds_base
+       || __bounds_phigh > __bounds_obj->__bounds_extent)
+    __bounds_pointer =
+      __dummy_bounds_check_component_reference (__bounds_obj,
+						__bounds_pointer,
+						__bounds_offset,
+						__bounds_size,
+						__bounds_filename,
+						__bounds_line);
+#if __BOUNDS_COLLECT_STATS
+  else
+    ++__bounds_stats_component_reference;
+#endif
+  return __bounds_pointer;
+}
+
+extern __inline__ void *
+__bounds_check_component_reference_obj (void *__bounds_pointer,
+					int __bounds_offset,
+					int __bounds_size,
+					const char *__bounds_filename,
+					int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_plow;
+  void *__bounds_phigh;
+  __bounds_object *__bounds_obj = __bounds_find_object (__bounds_pointer);
+
+  __bounds_union.__bounds_void_pointer = __bounds_pointer;
+  __bounds_union.__bounds_char_pointer += __bounds_offset;
+  __bounds_plow = __bounds_union.__bounds_void_pointer;
+  __bounds_union.__bounds_char_pointer += __bounds_size;
+  __bounds_phigh = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_plow < __bounds_obj->__bounds_base
+       || __bounds_phigh > __bounds_obj->__bounds_extent)
+    __bounds_pointer =
+      __dummy_bounds_check_component_reference (__bounds_obj,
+						__bounds_pointer,
+						__bounds_offset,
+						__bounds_size,
+						__bounds_filename,
+						__bounds_line);
+#if __BOUNDS_COLLECT_STATS
+  else
+    ++__bounds_stats_component_reference;
+#endif
+  return __bounds_pointer;
+}
+
+#pragma redefine_extname __dummy_bounds_check_reference \
+				__bounds_check_reference
+
+extern void *__dummy_bounds_check_reference (__bounds_object * __bounds_obj,
+					     void *__bounds_pointer,
+					     __bounds_size_t __bounds_size,
+					     const char *__bounds_filename,
+					     int __bounds_line);
+
+extern __inline__ void *
+__bounds_check_reference (__bounds_object * __bounds_obj,
+			  void *__bounds_pointer,
+			  __bounds_size_t __bounds_size,
+			  const char *__bounds_filename, int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_ptop;
+
+  __bounds_union.__bounds_void_pointer = __bounds_pointer;
+  __bounds_union.__bounds_char_pointer += __bounds_size;
+  __bounds_ptop = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pointer < __bounds_obj->__bounds_base
+       || __bounds_ptop > __bounds_obj->__bounds_extent)
+    __bounds_pointer =
+      __dummy_bounds_check_reference (__bounds_obj, __bounds_pointer,
+				      __bounds_size, __bounds_filename,
+				      __bounds_line);
+#if __BOUNDS_COLLECT_STATS
+  else
+    ++__bounds_stats_reference;
+#endif
+  return __bounds_pointer;
+}
+
+extern __inline__ void *
+__bounds_check_reference_obj (void *__bounds_pointer,
+			      __bounds_size_t __bounds_size,
+			      const char *__bounds_filename,
+			      int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_ptop;
+  __bounds_object *__bounds_obj = __bounds_find_object (__bounds_pointer);
+
+  __bounds_union.__bounds_void_pointer = __bounds_pointer;
+  __bounds_union.__bounds_char_pointer += __bounds_size;
+  __bounds_ptop = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pointer < __bounds_obj->__bounds_base
+       || __bounds_ptop > __bounds_obj->__bounds_extent)
+    __bounds_pointer =
+      __dummy_bounds_check_reference (__bounds_obj, __bounds_pointer,
+				      __bounds_size, __bounds_filename,
+				      __bounds_line);
+#if __BOUNDS_COLLECT_STATS
+  else
+    ++__bounds_stats_reference;
+#endif
+  return __bounds_pointer;
+}
+
+#pragma redefine_extname __dummy_bounds_check_ptr_true \
+				__bounds_check_ptr_true
+
+extern int
+__dummy_bounds_check_ptr_true (void *__bounds_pointer,
+			       const char *__bounds_filename,
+			       int __bounds_line);
+
+extern __inline__ int
+__bounds_check_ptr_true (void *__bounds_pointer,
+			 const char *__bounds_filename, int __bounds_line)
+{
+  int __bounds_result;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_pointer == __BOUNDS_ILLEGAL)
+    __bounds_result =
+      __dummy_bounds_check_ptr_true (__bounds_pointer, __bounds_filename,
+				     __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_true;
+#endif
+      __bounds_result = __bounds_pointer != __BOUNDS_NULL;
+    }
+  return __bounds_result;
+}
+
+#pragma redefine_extname __dummy_bounds_check_ptr_false \
+				__bounds_check_ptr_false
+
+extern int
+__dummy_bounds_check_ptr_false (void *__bounds_pointer,
+				const char *__bounds_filename,
+				int __bounds_line);
+
+extern __inline__ int
+__bounds_check_ptr_false (void *__bounds_pointer,
+			  const char *__bounds_filename, int __bounds_line)
+{
+  int __bounds_result;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_pointer == __BOUNDS_ILLEGAL)
+    __bounds_result = __dummy_bounds_check_ptr_false (__bounds_pointer,
+						      __bounds_filename,
+						      __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_false;
+#endif
+      __bounds_result = __bounds_pointer == __BOUNDS_NULL;
+    }
+  return __bounds_result;
+}
+
+#pragma redefine_extname __dummy_bounds_check_ptr_le_ptr \
+				__bounds_check_ptr_le_ptr
+
+extern int
+__dummy_bounds_check_ptr_le_ptr (__bounds_object * __bounds_obj1,
+				 __bounds_object * __bounds_obj2,
+				 void *__bounds_pointer1,
+				 void *__bounds_pointer2,
+				 const char *__bounds_filename,
+				 int __bounds_line);
+
+extern __inline__ int
+__bounds_check_ptr_le_ptr (__bounds_object * __bounds_obj1,
+			   __bounds_object * __bounds_obj2,
+			   void *__bounds_pointer1, void *__bounds_pointer2,
+			   const char *__bounds_filename, int __bounds_line)
+{
+  int __bounds_result;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj1 == __BOUNDS_NULL || __bounds_obj1 != __bounds_obj2)
+    __bounds_result =
+      __dummy_bounds_check_ptr_le_ptr (__bounds_obj1, __bounds_obj2,
+				       __bounds_pointer1, __bounds_pointer2,
+				       __bounds_filename, __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_le_ptr;
+#endif
+      __bounds_result = __bounds_pointer1 <= __bounds_pointer2;
+    }
+  return __bounds_result;
+}
+
+extern __inline__ int
+__bounds_check_ptr_le_ptr_obj (void *__bounds_pointer1,
+			       void *__bounds_pointer2,
+			       const char *__bounds_filename,
+			       int __bounds_line)
+{
+  int __bounds_result;
+  __bounds_object *__bounds_obj1 = __bounds_find_object (__bounds_pointer1);
+  __bounds_object *__bounds_obj2 = __bounds_find_object (__bounds_pointer2);
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj1 == __BOUNDS_NULL || __bounds_obj1 != __bounds_obj2)
+    __bounds_result =
+      __dummy_bounds_check_ptr_le_ptr (__bounds_obj1, __bounds_obj2,
+				       __bounds_pointer1, __bounds_pointer2,
+				       __bounds_filename, __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_le_ptr;
+#endif
+      __bounds_result = __bounds_pointer1 <= __bounds_pointer2;
+    }
+  return __bounds_result;
+}
+
+#pragma redefine_extname __dummy_bounds_check_ptr_lt_ptr \
+				__bounds_check_ptr_lt_ptr
+
+extern int
+__dummy_bounds_check_ptr_lt_ptr (__bounds_object * __bounds_obj1,
+				 __bounds_object * __bounds_obj2,
+				 void *__bounds_pointer1,
+				 void *__bounds_pointer2,
+				 const char *__bounds_filename,
+				 int __bounds_line);
+
+extern __inline__ int
+__bounds_check_ptr_lt_ptr (__bounds_object * __bounds_obj1,
+			   __bounds_object * __bounds_obj2,
+			   void *__bounds_pointer1, void *__bounds_pointer2,
+			   const char *__bounds_filename, int __bounds_line)
+{
+  int __bounds_result;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj1 == __BOUNDS_NULL || __bounds_obj1 != __bounds_obj2)
+    __bounds_result =
+      __dummy_bounds_check_ptr_lt_ptr (__bounds_obj1, __bounds_obj2,
+				       __bounds_pointer1, __bounds_pointer2,
+				       __bounds_filename, __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_lt_ptr;
+#endif
+      __bounds_result = __bounds_pointer1 < __bounds_pointer2;
+    }
+  return __bounds_result;
+}
+
+extern __inline__ int
+__bounds_check_ptr_lt_ptr_obj (void *__bounds_pointer1,
+			       void *__bounds_pointer2,
+			       const char *__bounds_filename,
+			       int __bounds_line)
+{
+  int __bounds_result;
+  __bounds_object *__bounds_obj1 = __bounds_find_object (__bounds_pointer1);
+  __bounds_object *__bounds_obj2 = __bounds_find_object (__bounds_pointer2);
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj1 == __BOUNDS_NULL || __bounds_obj1 != __bounds_obj2)
+    __bounds_result =
+      __dummy_bounds_check_ptr_lt_ptr (__bounds_obj1, __bounds_obj2,
+				       __bounds_pointer1, __bounds_pointer2,
+				       __bounds_filename, __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_lt_ptr;
+#endif
+      __bounds_result = __bounds_pointer1 < __bounds_pointer2;
+    }
+  return __bounds_result;
+}
+
+#pragma redefine_extname __dummy_bounds_check_ptr_ge_ptr \
+				__bounds_check_ptr_ge_ptr
+
+extern int
+__dummy_bounds_check_ptr_ge_ptr (__bounds_object * __bounds_obj1,
+				 __bounds_object * __bounds_obj2,
+				 void *__bounds_pointer1,
+				 void *__bounds_pointer2,
+				 const char *__bounds_filename,
+				 int __bounds_line);
+
+extern __inline__ int
+__bounds_check_ptr_ge_ptr (__bounds_object * __bounds_obj1,
+			   __bounds_object * __bounds_obj2,
+			   void *__bounds_pointer1, void *__bounds_pointer2,
+			   const char *__bounds_filename, int __bounds_line)
+{
+  int __bounds_result;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj1 == __BOUNDS_NULL || __bounds_obj1 != __bounds_obj2)
+    __bounds_result =
+      __dummy_bounds_check_ptr_ge_ptr (__bounds_obj1, __bounds_obj2,
+				       __bounds_pointer1, __bounds_pointer2,
+				       __bounds_filename, __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_ge_ptr;
+#endif
+      __bounds_result = __bounds_pointer1 >= __bounds_pointer2;
+    }
+  return __bounds_result;
+}
+
+extern __inline__ int
+__bounds_check_ptr_ge_ptr_obj (void *__bounds_pointer1,
+			       void *__bounds_pointer2,
+			       const char *__bounds_filename,
+			       int __bounds_line)
+{
+  int __bounds_result;
+  __bounds_object *__bounds_obj1 = __bounds_find_object (__bounds_pointer1);
+  __bounds_object *__bounds_obj2 = __bounds_find_object (__bounds_pointer2);
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj1 == __BOUNDS_NULL || __bounds_obj1 != __bounds_obj2)
+    __bounds_result =
+      __dummy_bounds_check_ptr_ge_ptr (__bounds_obj1, __bounds_obj2,
+				       __bounds_pointer1, __bounds_pointer2,
+				       __bounds_filename, __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_ge_ptr;
+#endif
+      __bounds_result = __bounds_pointer1 >= __bounds_pointer2;
+    }
+  return __bounds_result;
+}
+
+#pragma redefine_extname __dummy_bounds_check_ptr_gt_ptr \
+				__bounds_check_ptr_gt_ptr
+
+extern int
+__dummy_bounds_check_ptr_gt_ptr (__bounds_object * __bounds_obj1,
+				 __bounds_object * __bounds_obj2,
+				 void *__bounds_pointer1,
+				 void *__bounds_pointer2,
+				 const char *__bounds_filename,
+				 int __bounds_line);
+
+extern __inline__ int
+__bounds_check_ptr_gt_ptr (__bounds_object * __bounds_obj1,
+			   __bounds_object * __bounds_obj2,
+			   void *__bounds_pointer1, void *__bounds_pointer2,
+			   const char *__bounds_filename, int __bounds_line)
+{
+  int __bounds_result;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj1 == __BOUNDS_NULL || __bounds_obj1 != __bounds_obj2)
+    __bounds_result =
+      __dummy_bounds_check_ptr_gt_ptr (__bounds_obj1, __bounds_obj2,
+				       __bounds_pointer1, __bounds_pointer2,
+				       __bounds_filename, __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_gt_ptr;
+#endif
+      __bounds_result = __bounds_pointer1 > __bounds_pointer2;
+    }
+  return __bounds_result;
+}
+
+extern __inline__ int
+__bounds_check_ptr_gt_ptr_obj (void *__bounds_pointer1,
+			       void *__bounds_pointer2,
+			       const char *__bounds_filename,
+			       int __bounds_line)
+{
+  int __bounds_result;
+  __bounds_object *__bounds_obj1 = __bounds_find_object (__bounds_pointer1);
+  __bounds_object *__bounds_obj2 = __bounds_find_object (__bounds_pointer2);
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj1 == __BOUNDS_NULL || __bounds_obj1 != __bounds_obj2)
+    __bounds_result =
+      __dummy_bounds_check_ptr_gt_ptr (__bounds_obj1, __bounds_obj2,
+				       __bounds_pointer1, __bounds_pointer2,
+				       __bounds_filename, __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_gt_ptr;
+#endif
+      __bounds_result = __bounds_pointer1 > __bounds_pointer2;
+    }
+  return __bounds_result;
+}
+
+#pragma redefine_extname __dummy_bounds_check_ptr_ne_ptr \
+				__bounds_check_ptr_ne_ptr
+
+extern int
+__dummy_bounds_check_ptr_ne_ptr (void *__bounds_pointer1,
+				 void *__bounds_pointer2,
+				 const char *__bounds_filename,
+				 int __bounds_line);
+
+extern __inline__ int
+__bounds_check_ptr_ne_ptr (void *__bounds_pointer1, void *__bounds_pointer2,
+			   const char *__bounds_filename, int __bounds_line)
+{
+  int __bounds_result;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_pointer1 == __BOUNDS_ILLEGAL
+       || __bounds_pointer2 == __BOUNDS_ILLEGAL)
+    __bounds_result = __dummy_bounds_check_ptr_ne_ptr (__bounds_pointer1,
+						       __bounds_pointer2,
+						       __bounds_filename,
+						       __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_ne_ptr;
+#endif
+      __bounds_result = __bounds_pointer1 != __bounds_pointer2;
+    }
+  return __bounds_result;
+}
+
+#pragma redefine_extname __dummy_bounds_check_ptr_eq_ptr \
+				__bounds_check_ptr_eq_ptr
+
+extern int
+__dummy_bounds_check_ptr_eq_ptr (void *__bounds_pointer1,
+				 void *__bounds_pointer2,
+				 const char *__bounds_filename,
+				 int __bounds_line);
+
+extern __inline__ int
+__bounds_check_ptr_eq_ptr (void *__bounds_pointer1, void *__bounds_pointer2,
+			   const char *__bounds_filename, int __bounds_line)
+{
+  int __bounds_result;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_pointer1 == __BOUNDS_ILLEGAL
+       || __bounds_pointer2 == __BOUNDS_ILLEGAL)
+    __bounds_result = __dummy_bounds_check_ptr_eq_ptr (__bounds_pointer1,
+						       __bounds_pointer2,
+						       __bounds_filename,
+						       __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_eq_ptr;
+#endif
+      __bounds_result = __bounds_pointer1 == __bounds_pointer2;
+    }
+  return __bounds_result;
+}
+
+#pragma redefine_extname __dummy_bounds_check_ptr_postinc \
+				__bounds_check_ptr_postinc
+
+extern void *__dummy_bounds_check_ptr_postinc (__bounds_object * __bounds_obj,
+					       void **__bounds_ptr_to_ptr,
+					       int __bounds_inc,
+					       const char *__bounds_filename,
+					       int __bounds_line);
+
+extern __inline__ void *
+__bounds_check_ptr_postinc (__bounds_object * __bounds_obj,
+			    void **__bounds_ptr_to_ptr, int __bounds_inc,
+			    const char *__bounds_filename, int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pold = *__bounds_ptr_to_ptr;;
+  void *__bounds_pnew;
+
+  __bounds_union.__bounds_void_pointer = __bounds_pold;
+  __bounds_union.__bounds_char_pointer += __bounds_inc;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_pnew > __bounds_obj->__bounds_extent)
+    __bounds_pold = __dummy_bounds_check_ptr_postinc (__bounds_obj,
+						      __bounds_ptr_to_ptr,
+						      __bounds_inc,
+						      __bounds_filename,
+						      __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_postinc;
+#endif
+      *__bounds_ptr_to_ptr = __bounds_pnew;
+    }
+  return __bounds_pold;
+}
+
+extern __inline__ void *
+__bounds_check_ptr_postinc_obj (void **__bounds_ptr_to_ptr,
+				int __bounds_inc,
+				const char *__bounds_filename,
+				int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pold = *__bounds_ptr_to_ptr;;
+  void *__bounds_pnew;
+  __bounds_object *__bounds_obj = __bounds_find_object (__bounds_pold);
+
+  __bounds_union.__bounds_void_pointer = __bounds_pold;
+  __bounds_union.__bounds_char_pointer += __bounds_inc;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_pnew > __bounds_obj->__bounds_extent)
+    __bounds_pold = __dummy_bounds_check_ptr_postinc (__bounds_obj,
+						      __bounds_ptr_to_ptr,
+						      __bounds_inc,
+						      __bounds_filename,
+						      __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_postinc;
+#endif
+      *__bounds_ptr_to_ptr = __bounds_pnew;
+    }
+  return __bounds_pold;
+}
+
+#pragma redefine_extname __dummy_bounds_check_ptr_preinc \
+				__bounds_check_ptr_preinc
+
+extern void *__dummy_bounds_check_ptr_preinc (__bounds_object * __bounds_obj,
+					      void **__bounds_ptr_to_ptr,
+					      int __bounds_inc,
+					      const char *__bounds_filename,
+					      int __bounds_line);
+
+extern __inline__ void *
+__bounds_check_ptr_preinc (__bounds_object * __bounds_obj,
+			   void **__bounds_ptr_to_ptr, int __bounds_inc,
+			   const char *__bounds_filename, int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pold = *__bounds_ptr_to_ptr;;
+  void *__bounds_pnew;
+
+  __bounds_union.__bounds_void_pointer = __bounds_pold;
+  __bounds_union.__bounds_char_pointer += __bounds_inc;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_pnew > __bounds_obj->__bounds_extent)
+    __bounds_pnew =
+      __dummy_bounds_check_ptr_preinc (__bounds_obj, __bounds_ptr_to_ptr,
+				       __bounds_inc, __bounds_filename,
+				       __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_preinc;
+#endif
+      *__bounds_ptr_to_ptr = __bounds_pnew;
+    }
+  return __bounds_pnew;
+}
+
+extern __inline__ void *
+__bounds_check_ptr_preinc_obj (void **__bounds_ptr_to_ptr,
+			       int __bounds_inc,
+			       const char *__bounds_filename,
+			       int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pold = *__bounds_ptr_to_ptr;;
+  void *__bounds_pnew;
+  __bounds_object *__bounds_obj = __bounds_find_object (__bounds_pold);
+
+  __bounds_union.__bounds_void_pointer = __bounds_pold;
+  __bounds_union.__bounds_char_pointer += __bounds_inc;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_pnew > __bounds_obj->__bounds_extent)
+    __bounds_pnew =
+      __dummy_bounds_check_ptr_preinc (__bounds_obj, __bounds_ptr_to_ptr,
+				       __bounds_inc, __bounds_filename,
+				       __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_preinc;
+#endif
+      *__bounds_ptr_to_ptr = __bounds_pnew;
+    }
+  return __bounds_pnew;
+}
+
+#pragma redefine_extname __dummy_bounds_check_ptr_postdec \
+				__bounds_check_ptr_postdec
+
+extern void *__dummy_bounds_check_ptr_postdec (__bounds_object * __bounds_obj,
+					       void **__bounds_ptr_to_ptr,
+					       int __bounds_inc,
+					       const char *__bounds_filename,
+					       int __bounds_line);
+
+extern __inline__ void *
+__bounds_check_ptr_postdec (__bounds_object * __bounds_obj,
+			    void **__bounds_ptr_to_ptr, int __bounds_inc,
+			    const char *__bounds_filename, int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pold = *__bounds_ptr_to_ptr;;
+  void *__bounds_pnew;
+
+  __bounds_union.__bounds_void_pointer = __bounds_pold;
+  __bounds_union.__bounds_char_pointer -= __bounds_inc;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_pnew > __bounds_obj->__bounds_extent)
+    __bounds_pold = __dummy_bounds_check_ptr_postdec (__bounds_obj,
+						      __bounds_ptr_to_ptr,
+						      __bounds_inc,
+						      __bounds_filename,
+						      __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_postdec;
+#endif
+      *__bounds_ptr_to_ptr = __bounds_pnew;
+    }
+  return __bounds_pold;
+}
+
+extern __inline__ void *
+__bounds_check_ptr_postdec_obj (void **__bounds_ptr_to_ptr,
+				int __bounds_inc,
+				const char *__bounds_filename,
+				int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pold = *__bounds_ptr_to_ptr;;
+  void *__bounds_pnew;
+  __bounds_object *__bounds_obj = __bounds_find_object (__bounds_pold);
+
+  __bounds_union.__bounds_void_pointer = __bounds_pold;
+  __bounds_union.__bounds_char_pointer -= __bounds_inc;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_pnew > __bounds_obj->__bounds_extent)
+    __bounds_pold = __dummy_bounds_check_ptr_postdec (__bounds_obj,
+						      __bounds_ptr_to_ptr,
+						      __bounds_inc,
+						      __bounds_filename,
+						      __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_postdec;
+#endif
+      *__bounds_ptr_to_ptr = __bounds_pnew;
+    }
+  return __bounds_pold;
+}
+
+#pragma redefine_extname __dummy_bounds_check_ptr_predec \
+				__bounds_check_ptr_predec
+
+extern void *__dummy_bounds_check_ptr_predec (__bounds_object * __bounds_obj,
+					      void **__bounds_ptr_to_ptr,
+					      int __bounds_inc,
+					      const char *__bounds_filename,
+					      int __bounds_line);
+
+extern __inline__ void *
+__bounds_check_ptr_predec (__bounds_object * __bounds_obj,
+			   void **__bounds_ptr_to_ptr, int __bounds_inc,
+			   const char *__bounds_filename, int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pold = *__bounds_ptr_to_ptr;;
+  void *__bounds_pnew;
+
+  __bounds_union.__bounds_void_pointer = __bounds_pold;
+  __bounds_union.__bounds_char_pointer -= __bounds_inc;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_pnew > __bounds_obj->__bounds_extent)
+    __bounds_pnew =
+      __dummy_bounds_check_ptr_predec (__bounds_obj, __bounds_ptr_to_ptr,
+				       __bounds_inc, __bounds_filename,
+				       __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_predec;
+#endif
+      *__bounds_ptr_to_ptr = __bounds_pnew;
+    }
+  return __bounds_pnew;
+}
+
+extern __inline__ void *
+__bounds_check_ptr_predec_obj (void **__bounds_ptr_to_ptr,
+			       int __bounds_inc,
+			       const char *__bounds_filename,
+			       int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pold = *__bounds_ptr_to_ptr;;
+  void *__bounds_pnew;
+  __bounds_object *__bounds_obj = __bounds_find_object (__bounds_pold);
+
+  __bounds_union.__bounds_void_pointer = __bounds_pold;
+  __bounds_union.__bounds_char_pointer -= __bounds_inc;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_pnew > __bounds_obj->__bounds_extent)
+    __bounds_pnew =
+      __dummy_bounds_check_ptr_predec (__bounds_obj, __bounds_ptr_to_ptr,
+				       __bounds_inc, __bounds_filename,
+				       __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_predec;
+#endif
+      *__bounds_ptr_to_ptr = __bounds_pnew;
+    }
+  return __bounds_pnew;
+}
+
+#pragma redefine_extname __dummy_bounds_check_ptr_postinc_ref \
+				__bounds_check_ptr_postinc_ref
+
+extern void *__dummy_bounds_check_ptr_postinc_ref (__bounds_object *
+						   __bounds_obj,
+						   void **__bounds_ptr_to_ptr,
+						   int __bounds_inc,
+						   __bounds_size_t
+						   __bounds_size,
+						   const char
+						   *__bounds_filename,
+						   int __bounds_line);
+
+extern __inline__ void *
+__bounds_check_ptr_postinc_ref (__bounds_object * __bounds_obj,
+				void **__bounds_ptr_to_ptr, int __bounds_inc,
+				__bounds_size_t __bounds_size,
+				const char *__bounds_filename,
+				int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pold = *__bounds_ptr_to_ptr;;
+  void *__bounds_pnew;
+  void *__bounds_ptop;
+
+  __bounds_union.__bounds_void_pointer = __bounds_pold;
+  __bounds_union.__bounds_char_pointer += __bounds_inc;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+  __bounds_union.__bounds_char_pointer += __bounds_size;
+  __bounds_ptop = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_pnew > __bounds_obj->__bounds_extent
+       || __bounds_pold < __bounds_obj->__bounds_base
+       || __bounds_ptop > __bounds_obj->__bounds_extent)
+    __bounds_pold = __dummy_bounds_check_ptr_postinc_ref (__bounds_obj,
+							  __bounds_ptr_to_ptr,
+							  __bounds_inc,
+							  __bounds_size,
+							  __bounds_filename,
+							  __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_postinc;
+#endif
+      *__bounds_ptr_to_ptr = __bounds_pnew;
+    }
+  return __bounds_pold;
+}
+
+extern __inline__ void *
+__bounds_check_ptr_postinc_ref_obj (void **__bounds_ptr_to_ptr,
+				    int __bounds_inc,
+				    __bounds_size_t __bounds_size,
+				    const char *__bounds_filename,
+				    int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pold = *__bounds_ptr_to_ptr;;
+  void *__bounds_pnew;
+  void *__bounds_ptop;
+  __bounds_object *__bounds_obj = __bounds_find_object (__bounds_pold);
+
+  __bounds_union.__bounds_void_pointer = __bounds_pold;
+  __bounds_union.__bounds_char_pointer += __bounds_inc;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+  __bounds_union.__bounds_char_pointer += __bounds_size;
+  __bounds_ptop = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_pnew > __bounds_obj->__bounds_extent
+       || __bounds_pold < __bounds_obj->__bounds_base
+       || __bounds_ptop > __bounds_obj->__bounds_extent)
+    __bounds_pold = __dummy_bounds_check_ptr_postinc_ref (__bounds_obj,
+							  __bounds_ptr_to_ptr,
+							  __bounds_inc,
+							  __bounds_size,
+							  __bounds_filename,
+							  __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_postinc;
+#endif
+      *__bounds_ptr_to_ptr = __bounds_pnew;
+    }
+  return __bounds_pold;
+}
+
+#pragma redefine_extname __dummy_bounds_check_ptr_preinc_ref \
+				__bounds_check_ptr_preinc_ref
+
+extern void *__dummy_bounds_check_ptr_preinc_ref (__bounds_object *
+						  __bounds_obj,
+						  void **__bounds_ptr_to_ptr,
+						  int __bounds_inc,
+						  __bounds_size_t
+						  __bounds_size,
+						  const char
+						  *__bounds_filename,
+						  int __bounds_line);
+
+extern __inline__ void *
+__bounds_check_ptr_preinc_ref (__bounds_object * __bounds_obj,
+			       void **__bounds_ptr_to_ptr, int __bounds_inc,
+			       __bounds_size_t __bounds_size,
+			       const char *__bounds_filename,
+			       int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pold = *__bounds_ptr_to_ptr;;
+  void *__bounds_pnew;
+  void *__bounds_ptop;
+
+  __bounds_union.__bounds_void_pointer = __bounds_pold;
+  __bounds_union.__bounds_char_pointer += __bounds_inc;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+  __bounds_union.__bounds_char_pointer += __bounds_size;
+  __bounds_ptop = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_pnew > __bounds_obj->__bounds_extent
+       || __bounds_ptop > __bounds_obj->__bounds_extent)
+    __bounds_pnew = __dummy_bounds_check_ptr_preinc_ref (__bounds_obj,
+							 __bounds_ptr_to_ptr,
+							 __bounds_inc,
+							 __bounds_size,
+							 __bounds_filename,
+							 __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_preinc;
+#endif
+      *__bounds_ptr_to_ptr = __bounds_pnew;
+    }
+  return __bounds_pnew;
+}
+
+extern __inline__ void *
+__bounds_check_ptr_preinc_ref_obj (void **__bounds_ptr_to_ptr,
+				   int __bounds_inc,
+				   __bounds_size_t __bounds_size,
+				   const char *__bounds_filename,
+				   int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pold = *__bounds_ptr_to_ptr;;
+  void *__bounds_pnew;
+  void *__bounds_ptop;
+  __bounds_object *__bounds_obj = __bounds_find_object (__bounds_pold);
+
+  __bounds_union.__bounds_void_pointer = __bounds_pold;
+  __bounds_union.__bounds_char_pointer += __bounds_inc;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+  __bounds_union.__bounds_char_pointer += __bounds_size;
+  __bounds_ptop = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_pnew > __bounds_obj->__bounds_extent
+       || __bounds_ptop > __bounds_obj->__bounds_extent)
+    __bounds_pnew = __dummy_bounds_check_ptr_preinc_ref (__bounds_obj,
+							 __bounds_ptr_to_ptr,
+							 __bounds_inc,
+							 __bounds_size,
+							 __bounds_filename,
+							 __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_preinc;
+#endif
+      *__bounds_ptr_to_ptr = __bounds_pnew;
+    }
+  return __bounds_pnew;
+}
+
+#pragma redefine_extname __dummy_bounds_check_ptr_postdec_ref \
+				__bounds_check_ptr_postdec_ref
+
+extern void *__dummy_bounds_check_ptr_postdec_ref (__bounds_object *
+						   __bounds_obj,
+						   void **__bounds_ptr_to_ptr,
+						   int __bounds_inc,
+						   __bounds_size_t
+						   __bounds_size,
+						   const char
+						   *__bounds_filename,
+						   int __bounds_line);
+
+extern __inline__ void *
+__bounds_check_ptr_postdec_ref (__bounds_object * __bounds_obj,
+				void **__bounds_ptr_to_ptr, int __bounds_inc,
+				__bounds_size_t __bounds_size,
+				const char *__bounds_filename,
+				int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pold = *__bounds_ptr_to_ptr;;
+  void *__bounds_pnew;
+  void *__bounds_ptop;
+
+  __bounds_union.__bounds_void_pointer = __bounds_pold;
+  __bounds_union.__bounds_char_pointer -= __bounds_inc;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+  __bounds_union.__bounds_char_pointer += __bounds_size;
+  __bounds_ptop = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_pnew > __bounds_obj->__bounds_extent
+       || __bounds_pold < __bounds_obj->__bounds_base
+       || __bounds_ptop > __bounds_obj->__bounds_extent)
+    __bounds_pold = __dummy_bounds_check_ptr_postdec_ref (__bounds_obj,
+							  __bounds_ptr_to_ptr,
+							  __bounds_inc,
+							  __bounds_size,
+							  __bounds_filename,
+							  __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_postdec;
+#endif
+      *__bounds_ptr_to_ptr = __bounds_pnew;
+    }
+  return __bounds_pold;
+}
+
+extern __inline__ void *
+__bounds_check_ptr_postdec_ref_obj (void **__bounds_ptr_to_ptr,
+				    int __bounds_inc,
+				    __bounds_size_t __bounds_size,
+				    const char *__bounds_filename,
+				    int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pold = *__bounds_ptr_to_ptr;;
+  void *__bounds_pnew;
+  void *__bounds_ptop;
+  __bounds_object *__bounds_obj = __bounds_find_object (__bounds_pold);
+
+  __bounds_union.__bounds_void_pointer = __bounds_pold;
+  __bounds_union.__bounds_char_pointer -= __bounds_inc;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+  __bounds_union.__bounds_char_pointer += __bounds_size;
+  __bounds_ptop = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_pnew > __bounds_obj->__bounds_extent
+       || __bounds_pold < __bounds_obj->__bounds_base
+       || __bounds_ptop > __bounds_obj->__bounds_extent)
+    __bounds_pold = __dummy_bounds_check_ptr_postdec_ref (__bounds_obj,
+							  __bounds_ptr_to_ptr,
+							  __bounds_inc,
+							  __bounds_size,
+							  __bounds_filename,
+							  __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_postdec;
+#endif
+      *__bounds_ptr_to_ptr = __bounds_pnew;
+    }
+  return __bounds_pold;
+}
+
+#pragma redefine_extname __dummy_bounds_check_ptr_predec_ref \
+				__bounds_check_ptr_predec_ref
+
+extern void *__dummy_bounds_check_ptr_predec_ref (__bounds_object *
+						  __bounds_obj,
+						  void **__bounds_ptr_to_ptr,
+						  int __bounds_inc,
+						  __bounds_size_t
+						  __bounds_size,
+						  const char
+						  *__bounds_filename,
+						  int __bounds_line);
+
+extern __inline__ void *
+__bounds_check_ptr_predec_ref (__bounds_object * __bounds_obj,
+			       void **__bounds_ptr_to_ptr, int __bounds_inc,
+			       __bounds_size_t __bounds_size,
+			       const char *__bounds_filename,
+			       int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pold = *__bounds_ptr_to_ptr;;
+  void *__bounds_pnew;
+  void *__bounds_ptop;
+
+  __bounds_union.__bounds_void_pointer = __bounds_pold;
+  __bounds_union.__bounds_char_pointer -= __bounds_inc;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+  __bounds_union.__bounds_char_pointer += __bounds_size;
+  __bounds_ptop = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_pnew > __bounds_obj->__bounds_extent
+       || __bounds_ptop > __bounds_obj->__bounds_extent)
+    __bounds_pnew = __dummy_bounds_check_ptr_predec_ref (__bounds_obj,
+							 __bounds_ptr_to_ptr,
+							 __bounds_inc,
+							 __bounds_size,
+							 __bounds_filename,
+							 __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_predec;
+#endif
+      *__bounds_ptr_to_ptr = __bounds_pnew;
+    }
+  return __bounds_pnew;
+}
+
+extern __inline__ void *
+__bounds_check_ptr_predec_ref_obj (void **__bounds_ptr_to_ptr,
+				   int __bounds_inc,
+				   __bounds_size_t __bounds_size,
+				   const char *__bounds_filename,
+				   int __bounds_line)
+{
+  __bounds_union_type __bounds_union;
+  void *__bounds_pold = *__bounds_ptr_to_ptr;;
+  void *__bounds_pnew;
+  void *__bounds_ptop;
+  __bounds_object *__bounds_obj = __bounds_find_object (__bounds_pold);
+
+  __bounds_union.__bounds_void_pointer = __bounds_pold;
+  __bounds_union.__bounds_char_pointer -= __bounds_inc;
+  __bounds_pnew = __bounds_union.__bounds_void_pointer;
+  __bounds_union.__bounds_char_pointer += __bounds_size;
+  __bounds_ptop = __bounds_union.__bounds_void_pointer;
+
+  if (
+#if __BOUNDS_DEBUG_FEATURES
+       __bounds_debug_print_calls ||
+#endif
+       __bounds_obj == __BOUNDS_NULL
+       || __bounds_pnew < __bounds_obj->__bounds_base
+       || __bounds_pnew > __bounds_obj->__bounds_extent
+       || __bounds_ptop > __bounds_obj->__bounds_extent)
+    __bounds_pnew = __dummy_bounds_check_ptr_predec_ref (__bounds_obj,
+							 __bounds_ptr_to_ptr,
+							 __bounds_inc,
+							 __bounds_size,
+							 __bounds_filename,
+							 __bounds_line);
+  else
+    {
+#if __BOUNDS_COLLECT_STATS
+      ++__bounds_stats_ptr_predec;
+#endif
+      *__bounds_ptr_to_ptr = __bounds_pnew;
+    }
+  return __bounds_pnew;
+}
+
+#pragma bounds_checking on
+
+#endif
+
+#else /* not __GNUC__ or not __BOUNDS_CHECKING_ON */
+
+#define UNCHECKED_PTR_DIFF(p,q)			((p) - (q))
+#define UNCHECKED_PTR_PLUS_INT(p,i)		((p) + (i))
+#define UNCHECKED_PTR_MINUS_INT(p,i)		((p) - (i))
+
+#define BOUNDS_CHECKING_OFF
+#define BOUNDS_CHECKING_ON
+
+#define BOUNDS_CHECKING_OFF_DURING(stmt)	do { stmt; } while (0)
+#define BOUNDS_CHECKING_OFF_IN_EXPR(expr)	(expr)
+
+#endif /* __GNUC__, __BOUNDS_CHECKING_ON */
+#endif /* _bounds_unchecked_h */
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/java/bounds.c gcc-4.0.2/gcc/java/bounds.c
--- gcc-4.0.2.org/gcc/java/bounds.c	1970-01-01 01:00:00.000000000 +0100
+++ gcc-4.0.2/gcc/java/bounds.c	2005-09-29 17:50:07.000000000 +0200
@@ -0,0 +1,166 @@
+/* This file is a dummy, for when C++ gets bounds checking like C. In the
+   mean time, there are some empty function definitions here, since `calls.c'
+   references these (but never calls them). */
+
+#include "config.h"
+#include "system.h"
+#include <stdio.h>
+#include "coretypes.h"
+#include "tm.h"
+#include "rtl.h"
+#include "tree.h"
+#include "varray.h"
+#include "ggc.h"
+
+static GTY (()) varray_type static_ptr_init_list;
+static GTY (()) varray_type deferred_global_decls;
+static GTY (()) tree bounds_memcpy;
+static GTY (()) tree bounds_mempcpy;
+static GTY (()) tree bounds_memset;
+static GTY (()) tree bounds_find_object;
+static GTY (()) tree bounds_maybe_find_object;
+static GTY (()) tree bounds_check_ptr_plus_int;
+static GTY (()) tree bounds_check_ptr_minus_int;
+static GTY (()) tree bounds_check_ptr_plus_int_obj;
+static GTY (()) tree bounds_check_ptr_minus_int_obj;
+static GTY (()) tree bounds_check_array_reference;
+static GTY (()) tree bounds_check_array_reference_obj;
+static GTY (()) tree bounds_check_component_reference;
+static GTY (()) tree bounds_check_component_reference_obj;
+static GTY (()) tree bounds_check_ptr_diff;
+static GTY (()) tree bounds_check_ptr_diff_obj;
+static GTY (()) tree bounds_check_reference;
+static GTY (()) tree bounds_check_reference_obj;
+static GTY (()) tree bounds_check_ptr_lt_ptr;
+static GTY (()) tree bounds_check_ptr_lt_ptr_obj;
+static GTY (()) tree bounds_check_ptr_le_ptr;
+static GTY (()) tree bounds_check_ptr_le_ptr_obj;
+static GTY (()) tree bounds_check_ptr_gt_ptr;
+static GTY (()) tree bounds_check_ptr_gt_ptr_obj;
+static GTY (()) tree bounds_check_ptr_ge_ptr;
+static GTY (()) tree bounds_check_ptr_ge_ptr_obj;
+static GTY (()) tree bounds_check_ptr_eq_ptr;
+static GTY (()) tree bounds_check_ptr_ne_ptr;
+static GTY (()) tree bounds_check_ptr_postinc;
+static GTY (()) tree bounds_check_ptr_preinc;
+static GTY (()) tree bounds_check_ptr_postdec;
+static GTY (()) tree bounds_check_ptr_predec;
+static GTY (()) tree bounds_check_ptr_postinc_obj;
+static GTY (()) tree bounds_check_ptr_preinc_obj;
+static GTY (()) tree bounds_check_ptr_postdec_obj;
+static GTY (()) tree bounds_check_ptr_predec_obj;
+static GTY (()) tree bounds_check_ptr_postinc_ref;
+static GTY (()) tree bounds_check_ptr_preinc_ref;
+static GTY (()) tree bounds_check_ptr_postdec_ref;
+static GTY (()) tree bounds_check_ptr_predec_ref;
+static GTY (()) tree bounds_check_ptr_postinc_ref_obj;
+static GTY (()) tree bounds_check_ptr_preinc_ref_obj;
+static GTY (()) tree bounds_check_ptr_postdec_ref_obj;
+static GTY (()) tree bounds_check_ptr_predec_ref_obj;
+static GTY (()) tree bounds_check_ptr_true;
+static GTY (()) tree bounds_check_ptr_false;
+static GTY (()) tree bounds_note_constructed_object;
+static GTY (()) tree bounds_note_constructed_private_table;
+static GTY (()) tree bounds_push_function;
+static GTY (()) tree bounds_pop_function;
+static GTY (()) tree bounds_add_param_object;
+static GTY (()) tree bounds_add_stack_object;
+static GTY (()) tree bounds_delete_stack_object;
+static GTY (()) tree bounds_initialize_library;
+static GTY (()) tree bounds_check_free;
+static GTY (()) tree bounds_check_malloc;
+static GTY (()) tree bounds_check_realloc;
+static GTY (()) tree bounds_check_memalign;
+static GTY (()) tree bounds_check_calloc;
+static GTY (()) tree bounds_check_valloc;
+static GTY (()) tree bounds_check_alloca;
+static GTY (()) tree bounds_check___alloca;
+static GTY (()) tree bounds_check___builtin_alloca;
+static GTY (()) tree bounds_check_mmap;
+static GTY (()) tree bounds_check_munmap;
+static GTY (()) tree bounds_check_memcpy;
+static GTY (()) tree bounds_check_mempcpy;
+static GTY (()) tree bounds_check_memmove;
+static GTY (()) tree bounds_check_bcopy;
+static GTY (()) tree bounds_check_memset;
+static GTY (()) tree bounds_check_bzero;
+static GTY (()) tree bounds_check_memcmp;
+static GTY (()) tree bounds_check_bcmp;
+static GTY (()) tree bounds_check_strcpy;
+static GTY (()) tree bounds_check_strncpy;
+static GTY (()) tree bounds_check_strlen;
+static GTY (()) tree bounds_check_strcmp;
+static GTY (()) tree bounds_check_strncmp;
+static GTY (()) tree bounds_check_strcat;
+static GTY (()) tree bounds_check_strncat;
+static GTY (()) tree bounds_check_strpbrk;
+static GTY (()) tree bounds_check_strrchr;
+static GTY (()) tree bounds_check_rindex;
+static GTY (()) tree bounds_check_strspn;
+static GTY (()) tree bounds_check_strcspn;
+static GTY (()) tree bounds_check_strstr;
+static GTY (()) tree bounds_check_strtok;
+static GTY (()) tree bounds_check_strtok_r;
+static GTY (()) tree bounds_check_strdup;
+static GTY (()) tree bounds_check_strchr;
+static GTY (()) tree bounds_check_index;
+static GTY (()) tree bounds_check_strcoll;
+static GTY (()) tree bounds_check_strxfrm;
+static GTY (()) tree bounds_check_strcasecmp;
+static GTY (()) tree bounds_check_strncasecmp;
+static GTY (()) tree bounds_check_memchr;
+static GTY (()) tree bounds_check_memccpy;
+static GTY (()) tree bounds_private_statics;
+
+#include "gt-c-bounds.h"
+
+void
+bounds_convert_funcname (tree * function ATTRIBUTE_UNUSED,
+			 tree * params ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+void
+bounds_mark_for_runtime_check (tree decl ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+void
+bounds_build_static_constructors (void)
+{
+  abort ();
+}
+
+void
+bounds_register_decl (tree decl ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+int
+bounds_is_deletable_fn_p (char *name ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+void
+bounds_note_call_for_deletion (rtx first_insn ATTRIBUTE_UNUSED,
+			       rtx last_insn ATTRIBUTE_UNUSED,
+			       char *fnname ATTRIBUTE_UNUSED,
+			       tree callexpr ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+tree
+bounds_build_truthvalue_conversion (tree arg ATTRIBUTE_UNUSED)
+{
+  abort ();
+}
+
+void
+bounds_delete_redundant_calls (void)
+{
+}
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/java/Make-lang.in gcc-4.0.2/gcc/java/Make-lang.in
--- gcc-4.0.2.org/gcc/java/Make-lang.in	2005-05-07 00:53:36.000000000 +0200
+++ gcc-4.0.2/gcc/java/Make-lang.in	2005-09-29 17:50:07.000000000 +0200
@@ -107,7 +107,8 @@ JAVA_OBJS = java/parse.o java/class.o ja
   java/zextract.o java/jcf-io.o java/win32-host.o java/jcf-parse.o java/mangle.o \
   java/mangle_name.o java/builtins.o java/resource.o \
   java/jcf-write.o java/buffer.o java/check-init.o java/jcf-depend.o \
-  java/jcf-path.o java/xref.o java/boehm.o java/java-gimplify.o
+  java/jcf-path.o java/xref.o java/boehm.o java/java-gimplify.o \
+  java/bounds.o
 
 GCJH_OBJS = java/gjavah.o java/jcf-io.o java/jcf-depend.o java/jcf-path.o \
   java/win32-host.o java/zextract.o version.o errors.o ggc-none.o \
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/libgcc2.c gcc-4.0.2/gcc/libgcc2.c
--- gcc-4.0.2.org/gcc/libgcc2.c	2005-03-21 08:24:36.000000000 +0100
+++ gcc-4.0.2/gcc/libgcc2.c	2005-09-29 17:50:10.000000000 +0200
@@ -1899,6 +1899,12 @@ TRANSFER_FROM_TRAMPOLINE
 #endif
 #endif /* L_trampoline */
 
+#ifdef L__main
+/* If there are any bounds-checked modules in this program at all, then
+   __bounds_initialize_library will be called, which sets the following flag. */
+int __bounds_checking_on = 0;
+#endif
+
 #ifndef __CYGWIN__
 #ifdef L__main
 
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/Makefile.in gcc-4.0.2/gcc/Makefile.in
--- gcc-4.0.2.org/gcc/Makefile.in	2005-09-09 23:05:39.000000000 +0200
+++ gcc-4.0.2/gcc/Makefile.in	2005-09-29 17:50:10.000000000 +0200
@@ -308,6 +308,7 @@ USER_H = $(srcdir)/ginclude/float.h \
 	 $(srcdir)/ginclude/stddef.h \
 	 $(srcdir)/ginclude/varargs.h \
 	 $(srcdir)/unwind.h \
+	 $(srcdir)/ginclude/unchecked.h \
 	 $(EXTRA_HEADERS)
 
 # The GCC to use for compiling libgcc.a and crt*.o.
@@ -607,13 +608,16 @@ OTHER_FIXINCLUDES_DIRS=
 # A list of all the language-specific executables.
 COMPILERS = cc1$(exeext) @all_compilers@
 
+# Specify a rule for making the bounds checking library.
+LIBBOUNDSCHECK = stmp_libboundscheck
+
 # List of things which should already be built whenever we try to use xgcc
 # to compile anything (without linking).
 GCC_PASSES=xgcc$(exeext) cc1$(exeext) specs $(EXTRA_PASSES)
 
 # List of things which should already be built whenever we try to use xgcc
 # to link anything.
-GCC_PARTS=$(GCC_PASSES) $(LIBGCC) $(EXTRA_PROGRAMS) $(COLLECT2) $(EXTRA_PARTS)
+GCC_PARTS=$(GCC_PASSES) $(LIBGCC) $(LIBBOUNDSCHECK) $(EXTRA_PROGRAMS) $(COLLECT2) $(EXTRA_PARTS)
 
 # Directory to link to, when using the target `maketest'.
 DIR = ../gcc
@@ -886,7 +890,7 @@ CXX_TARGET_OBJS=@cxx_target_objs@
 C_AND_OBJC_OBJS = attribs.o c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o \
   c-convert.o c-aux-info.o c-common.o c-opts.o c-format.o c-semantics.o \
   c-incpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o prefix.o \
-  c-objc-common.o c-dump.o c-pch.o $(C_TARGET_OBJS) \
+  c-objc-common.o c-dump.o c-pch.o c-bounds.o $(C_TARGET_OBJS) \
   c-gimplify.o tree-mudflap.o c-pretty-print.o
 
 # Language-specific object files for C.
@@ -1126,12 +1130,12 @@ config.status: $(srcdir)/configure $(src
 all.internal: start.encap rest.encap doc
 # This is what to compile if making a cross-compiler.
 all.cross: native gcc-cross cpp$(exeext) specs \
-	$(LIBGCC) $(EXTRA_PARTS) lang.all.cross doc @GENINSRC@ srcextra
+	$(LIBGCC) $(LIBBOUNDSCHECK) $(EXTRA_PARTS) lang.all.cross doc @GENINSRC@ srcextra
 # This is what must be made before installing GCC and converting libraries.
 start.encap: native xgcc$(exeext) cpp$(exeext) specs \
 	xlimits.h lang.start.encap @GENINSRC@ srcextra
 # These can't be made until after GCC can run.
-rest.encap: $(STMP_FIXPROTO) $(LIBGCC) $(EXTRA_PARTS) lang.rest.encap
+rest.encap: $(STMP_FIXPROTO) $(LIBGCC) $(LIBBOUNDSCHECK) $(EXTRA_PARTS) lang.rest.encap
 # This is what is made with the host's compiler
 # whether making a cross compiler or not.
 native: config.status auto-host.h build-@POSUB@ $(LANGUAGES) \
@@ -1146,7 +1150,7 @@ PROTO: proto
 
 # On the target machine, finish building a cross compiler.
 # This does the things that can't be done on the host machine.
-rest.cross: $(LIBGCC) specs
+rest.cross: $(LIBGCC) $(LIBBOUNDSCHECK) specs
 
 # Recompile all the language-independent object files.
 # This is used only if the user explicitly asks for it.
@@ -2438,6 +2442,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/co
   $(srcdir)/tree-chrec.h $(srcdir)/tree-complex.c \
   $(srcdir)/tree-ssa-operands.h $(srcdir)/tree-ssa-operands.c \
   $(srcdir)/tree-profile.c $(srcdir)/rtl-profile.c $(srcdir)/tree-nested.c \
+  $(srcdir)/c-bounds.c \
   $(out_file) \
   @all_gtfiles@
 
@@ -2459,6 +2464,7 @@ gt-tree-eh.h \
 gt-tree-ssanames.h gt-tree-iterator.h gt-gimplify.h \
 gt-tree-phinodes.h gt-tree-cfg.h gt-tree-nested.h \
 gt-tree-ssa-operands.h gt-tree-ssa-propagate.h \
+gt-c-bounds.h \
 gt-stringpool.h : s-gtype ; @true
 
 gtyp-gen.h: s-gtyp-gen ; @true
@@ -3100,6 +3106,14 @@ mostlyclean: lang.mostlyclean
 	-rm -f $(STAGECOPYSTUFF) $(STAGEMOVESTUFF)
 	-rm -f *$(coverageexts)
 	-rm -rf libgcc
+# Clean up libboundscheck and bounds/ subdirectory.
+	-rm -f $(LIBBOUNDSCHECK)
+	if [ -d bounds/lib ]; then \
+	  srcdir1=`cd $(srcdir); pwd`; \
+	  cd bounds/lib; \
+	  $(MAKE) -f $$srcdir1/bounds/lib/Makefile srcdir=$$srcdir1 mostlyclean; \
+	else true; \
+	fi
 # Delete build programs
 	-rm -f build/*
 	-rm -f mddeps.mk
@@ -3200,7 +3214,7 @@ maintainer-clean:
 # Install the driver last so that the window when things are
 # broken is small.
 install: install-common $(INSTALL_HEADERS) $(INSTALL_LIBGCC) \
-    install-cpp install-man install-info install-@POSUB@ \
+    install-cpp install-libboundscheck install-man install-info install-@POSUB@ \
     lang.install-normal install-driver
 
 # Handle cpp installation.
@@ -3353,6 +3367,27 @@ install-libgcc: libgcc.mk libgcc.a libgc
 	  mkinstalldirs='$(mkinstalldirs)' \
 	  -f libgcc.mk install
 
+# Install the checking library.
+install-libboundscheck: stmp_libboundscheck installdirs
+	thisdir1=`pwd`; \
+	srcdir1=`cd $(srcdir); pwd`; \
+	for i in `$$thisdir1/xgcc -B$$thisdir1/ --print-multi-lib 2>/dev/null`; do \
+	  dir=`echo $$i | sed -e 's/;.*$$//'`; \
+	  flags=`echo $$i | sed -e 's/^[^;]*;//' -e 's/@/ -/g'`; \
+	  (cd bounds/lib/$$dir; \
+	   $(MAKE) -f $$srcdir1/bounds/lib/Makefile install \
+	   srcdir=$$srcdir1 tooldir=$(tooldir) AR="$(AR)" AR_FLAGS="$(AR_FLAGS)" \
+	   GCC_FOR_TARGET="$$thisdir1/xgcc -B$$thisdir1/" \
+	   GCC_CFLAGS="$(GCC_CFLAGS)" \
+	   MULTI_FLAGS="$$flags" \
+	   RANLIB_FOR_TARGET="$(RANLIB_FOR_TARGET)" \
+	   INSTALL_DATA="$(INSTALL_DATA)" \
+	   DESTDIR="$(DESTDIR)" \
+	   libsubdir="$(libsubdir)/$$dir" \
+	   LIBBOUNDSCHECKDIR="$$thisdir1/$$dir" \
+	  ); \
+	done
+
 # Install multiple versions of libgcc.a, libgcov.a.
 install-multilib: stmp-multilib installdirs
 	$(MAKE) \
@@ -4153,6 +4188,54 @@ stagefeedback-start:
 	fi; done
 stagefeedback: force stagefeedback-start lang.stagefeedback
 
+# Build the bounds checking library for GCC.
+$(LIBBOUNDSCHECK): force
+	if [ -d bounds ]; then true; else mkdir bounds; fi; \
+	if [ -d bounds/lib ]; then true; else mkdir bounds/lib; fi; \
+	thisdir1=`pwd`; \
+	srcdir1=`cd $(srcdir); pwd`; \
+	for i in `$$thisdir1/xgcc -B$$thisdir1/ --print-multi-lib 2>/dev/null`; do \
+	  dir=`echo $$i | sed -e 's/;.*$$//'`; \
+	  if [ -d bounds/lib/$$dir ]; then true; else mkdir bounds/lib/$$dir; fi; \
+	  flags=`echo $$i | sed -e 's/^[^;]*;//' -e 's/@/ -/g'`; \
+	  (cd bounds/lib/$$dir; \
+	   $(MAKE) -f $$srcdir1/bounds/lib/Makefile libboundscheck.a \
+	    srcdir=$$srcdir1 tooldir=$(tooldir) AR="$(AR)" AR_FLAGS="$(AR_FLAGS)" \
+	    GCC_FOR_TARGET="$$thisdir1/xgcc -B$$thisdir1/" \
+	    GCC_CFLAGS="$(GCC_CFLAGS)" \
+	    MULTI_FLAGS="$$flags" \
+	    RANLIB_FOR_TARGET="$(RANLIB_FOR_TARGET)" \
+	    INSTALL_DATA="$(INSTALL_DATA)" \
+	    DESTDIR="$(DESTDIR)" \
+	    libsubdir="$(libsubdir)/$$dir" \
+	    LIBBOUNDSCHECKDIR="$$thisdir1/$$dir" \
+	  ); \
+        done; \
+	touch stmp_libboundscheck
+
+# This is used by bounds/lib/Makefile if the user runs that directly.
+sublibboundscheck: force
+	thisdir1=`pwd`; \
+	srcdir1=`cd $(srcdir); pwd`; \
+	for i in `$$thisdir1/xgcc -B$$thisdir1/ --print-multi-lib 2>/dev/null`; do \
+	  dir=`echo $$i | sed -e 's/;.*$$//'`; \
+	  if [ -d bounds/lib/$$dir ]; then true; else mkdir bounds/lib/$$dir; fi; \
+	  flags=`echo $$i | sed -e 's/^[^;]*;//' -e 's/@/ -/g'`; \
+	  (cd bounds/lib/$$dir; \
+	   $(MAKE) -f $$srcdir1/bounds/lib/Makefile libboundscheck.a \
+	    srcdir=$$srcdir1 tooldir=$(tooldir) AR="$(AR)" AR_FLAGS="$(AR_FLAGS)" \
+	    GCC_FOR_TARGET="$$thisdir1/xgcc -B$$thisdir1/" \
+	    GCC_CFLAGS="$(GCC_CFLAGS)" \
+	    MULTI_FLAGS="$$flags" \
+	    RANLIB_FOR_TARGET="$(RANLIB_FOR_TARGET)" \
+	    INSTALL_DATA="$(INSTALL_DATA)" \
+	    DESTDIR="$(DESTDIR)" \
+	    libsubdir="$(libsubdir)/$$dir" \
+	    LIBBOUNDSCHECKDIR="$$thisdir1/$$dir" \
+	  ); \
+        done; \
+	touch stmp_libboundscheck
+
 # Copy just the executable files from a particular stage into a subdirectory,
 # and delete the object files.  Use this if you're just verifying a version
 # that is pretty sure to work, and you are short of disk space.
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/optabs.c gcc-4.0.2/gcc/optabs.c
--- gcc-4.0.2.org/gcc/optabs.c	2005-02-12 12:34:21.000000000 +0100
+++ gcc-4.0.2/gcc/optabs.c	2005-09-29 17:50:10.000000000 +0200
@@ -5163,12 +5163,26 @@ init_optabs (void)
     = init_one_libfunc ("ffs");
 
   abort_libfunc = init_one_libfunc ("abort");
-  memcpy_libfunc = init_one_libfunc ("memcpy");
-  memmove_libfunc = init_one_libfunc ("memmove");
-  memcmp_libfunc = init_one_libfunc ("memcmp");
-  memset_libfunc = init_one_libfunc ("memset");
   setbits_libfunc = init_one_libfunc ("__setbits");
 
+  /* In bounds checking mode, we need to call the unchecked versions of some
+     of these functions. The '__bounds_...' functions are supplied by
+     libboundscheck.  */
+  if (!bounds_checking_enabled)
+    {
+      memcpy_libfunc = init_one_libfunc ("memcpy");
+      memmove_libfunc = init_one_libfunc ("memmove");
+      memcmp_libfunc = init_one_libfunc ("memcmp");
+      memset_libfunc = init_one_libfunc ("memset");
+    }
+  else
+    {
+      memcpy_libfunc = init_one_libfunc ("__bounds_memcpy");
+      memmove_libfunc = init_one_libfunc ("__bounds_memmove");
+      memcmp_libfunc = init_one_libfunc ("__bounds_memcmp");
+      memset_libfunc = init_one_libfunc ("__bounds_memset");
+    }
+
   unwind_resume_libfunc = init_one_libfunc (USING_SJLJ_EXCEPTIONS
 					    ? "_Unwind_SjLj_Resume"
 					    : "_Unwind_Resume");
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/opts.c gcc-4.0.2/gcc/opts.c
--- gcc-4.0.2.org/gcc/opts.c	2005-02-24 10:24:13.000000000 +0100
+++ gcc-4.0.2/gcc/opts.c	2005-09-29 17:50:10.000000000 +0200
@@ -39,6 +39,9 @@ Software Foundation, 59 Temple Place - S
 #include "insn-attr.h"		/* For INSN_SCHEDULING.  */
 #include "target.h"
 
+/* Flag set if -D_REENTRANT is given.  */
+int bounds_reentrant_defined = 0;
+
 /* Value of the -G xx switch, and whether it was passed or not.  */
 unsigned HOST_WIDE_INT g_switch_value;
 bool g_switch_set;
@@ -444,6 +447,9 @@ decode_options (unsigned int argc, const
      determine the default value of many flags.  */
   for (i = 1; i < argc; i++)
     {
+      if (! strcmp (argv[i], "-D_REENTRANT"))
+        bounds_reentrant_defined = 1;
+
       if (!strcmp (argv[i], "-O"))
 	{
 	  optimize = 1;
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/passes.c gcc-4.0.2/gcc/passes.c
--- gcc-4.0.2.org/gcc/passes.c	2005-08-23 09:39:45.000000000 +0200
+++ gcc-4.0.2/gcc/passes.c	2005-09-29 17:50:10.000000000 +0200
@@ -81,6 +81,7 @@ Software Foundation, 59 Temple Place - S
 #include "alloc-pool.h"
 #include "tree-pass.h"
 #include "tree-dump.h"
+#include "c-bounds.h"
 
 #if defined (DWARF2_UNWIND_INFO) || defined (DWARF2_DEBUGGING_INFO)
 #include "dwarf2out.h"
@@ -108,6 +109,10 @@ Software Foundation, 59 Temple Place - S
 #define DUMPFILE_FORMAT ".%02d."
 #endif
 
+/* Name of the constructor used for for bounds checking.  */
+
+char *bounds_constructor_name = NULL;
+
 static int initializing_dump = 0;
 
 /* Routine to open a dump file.  Return true if the dump file is enabled.  */
@@ -1507,6 +1512,15 @@ rest_of_clean_state (void)
 static void
 rest_of_compilation (void)
 {
+  int save_optimize = optimize;
+
+  if (current_function_decl && bounds_constructor_name
+      && DECL_NAME (current_function_decl)
+      && IDENTIFIER_POINTER (DECL_NAME (current_function_decl))
+      && strcmp(IDENTIFIER_POINTER (DECL_NAME (current_function_decl)),
+              bounds_constructor_name) == 0)
+    optimize = 0;
+
   /* If we're emitting a nested function, make sure its parent gets
      emitted as well.  Doing otherwise confuses debug info.  */
   {
@@ -1761,6 +1775,8 @@ rest_of_compilation (void)
  exit_rest_of_compilation:
 
   rest_of_clean_state ();
+
+  optimize = save_optimize;
 }
 
 void
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/stmt.c gcc-4.0.2/gcc/stmt.c
--- gcc-4.0.2.org/gcc/stmt.c	2005-03-10 01:17:58.000000000 +0100
+++ gcc-4.0.2/gcc/stmt.c	2005-09-29 17:50:10.000000000 +0200
@@ -1823,8 +1823,13 @@ expand_nl_goto_receiver (void)
 }
 
 /* Generate RTL for the automatic variable declaration DECL.
-   (Other kinds of declarations are simply ignored if seen here.)  */
+   (Other kinds of declarations are simply ignored if seen here.)
 
+   In bounds checking mode (for C only at present) we insert an extra byte
+   after automatic variables. This lets us validly generate pointers to
+   the end of the object + 1. Notice that in bounds checking mode, no
+   real automatic variables make it into registers.  */
+        
 void
 expand_decl (tree decl)
 {
@@ -1875,7 +1880,9 @@ expand_decl (tree decl)
     }
   else if (use_register_for_decl (decl))
     {
-      /* Automatic variable that can go in a register.  */
+      /* Automatic variable that can go in a register.
+	 In bounds checking mode, no automatic variables make it into regs,
+	 since we take the address of all of them.  */
       int unsignedp = TYPE_UNSIGNED (type);
       enum machine_mode reg_mode
 	= promote_mode (type, DECL_MODE (decl), &unsignedp, 0);
@@ -1947,7 +1954,17 @@ expand_decl (tree decl)
 
       /* Compute the variable's size, in bytes.  This will expand any
 	 needed SAVE_EXPRs for the first time.  */
-      size = expand_expr (DECL_SIZE_UNIT (decl), NULL_RTX, VOIDmode, 0);
+      if (!bounds_checking_enabled)
+        size = expand_expr (DECL_SIZE_UNIT (decl), NULL_RTX, VOIDmode, 0);
+      else
+        /* In bounds checking mode, make the size one byte larger.  */
+        size = expand_expr (
+                 size_binop (PLUS_EXPR, DECL_SIZE (decl),
+                   size_binop (CEIL_DIV_EXPR,
+                     convert (bitsizetype, size_int (BIGGEST_ALIGNMENT)),
+                     convert (bitsizetype, size_int (BITS_PER_UNIT)))),
+                 NULL_RTX, VOIDmode, 0);
+
       free_temp_slots ();
 
       /* Allocate space on the stack for the variable.  Note that
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/toplev.c gcc-4.0.2/gcc/toplev.c
--- gcc-4.0.2.org/gcc/toplev.c	2005-09-09 02:51:44.000000000 +0200
+++ gcc-4.0.2/gcc/toplev.c	2005-09-29 17:50:10.000000000 +0200
@@ -374,6 +374,18 @@ static const param_info lang_independent
   { NULL, 0, 0, 0, NULL }
 };
 
+/* Flag indicating that bounds checking has been enabled in the C
+   front end. There are some changes in `varasm.c' that depend upon
+   the state of this flag.  */
+
+int bounds_checking_enabled_initial = 0;
+int bounds_checking_enabled = 0;
+
+/* Flag indicating bounds checking is restricted to strings only
+   This flag is only useful if bounds-checking is enabled.  */
+
+int bounds_strings_only_enabled = 0;
+
 /* Here is a table, controlled by the tm.h file, listing each -m switch
    and which bits in `target_switches' it should set or clear.
    If VALUE is positive, it is bits to set.
@@ -1029,6 +1041,10 @@ compile_file (void)
      functions in this compilation unit were deferred.  */
   coverage_finish ();
 
+  /* Build bounds-checking constructors for this file.  */
+  if (bounds_checking_enabled)
+    bounds_build_static_constructors ();
+
   /* Likewise for mudflap static object registrations.  */
   if (flag_mudflap)
     mudflap_finish_file ();
diff -rupN -x tags -x 'c-parse.[cy]' -x 'objc-parse.[cy]' -x 'parse.[ch]' -x '*.info*' gcc-4.0.2.org/gcc/varasm.c gcc-4.0.2/gcc/varasm.c
--- gcc-4.0.2.org/gcc/varasm.c	2005-07-22 21:32:58.000000000 +0200
+++ gcc-4.0.2/gcc/varasm.c	2005-09-29 17:50:10.000000000 +0200
@@ -52,6 +52,7 @@ Software Foundation, 59 Temple Place - S
 #include "tree-mudflap.h"
 #include "cgraph.h"
 #include "cfglayout.h"
+#include "c-bounds.h"
 
 #ifdef XCOFF_DEBUGGING_INFO
 #include "xcoffout.h"		/* Needed for external data
@@ -179,6 +180,17 @@ enum in_section { no_section, in_text, i
 };
 static GTY(()) enum in_section in_section = no_section;
 
+/* In bounds checking mode, we build a list of private statics allocated
+   in the output file. At the end, we build the list into an array, so we
+   can find all these strings and things. */
+static struct private_statics_elem {
+  struct private_statics_elem *next;
+  char *name;                   /* Name for this object. */
+  int name_label;               /* (Private: label for this name). */
+  char *label;                  /* Assembler label. */
+  int size;                     /* Size of the declaration. */
+} *private_statics_list = NULL;
+
 /* Return a nonzero value if DECL has a section attribute.  */
 #ifndef IN_NAMED_SECTION
 #define IN_NAMED_SECTION(DECL) \
@@ -1000,6 +1012,11 @@ make_decl_rtl (tree decl)
      will have to know how to strip this information.  */
   targetm.encode_section_info (decl, DECL_RTL (decl), true);
 
+  /* In bounds checked mode, we want to remember this assembler
+     label till the end of the file.  */
+  if (bounds_checking_enabled && TREE_CODE (decl) == VAR_DECL)
+    bounds_register_decl (decl);
+
   /* Make this function static known to the mudflap runtime.  */
   if (flag_mudflap && TREE_CODE (decl) == VAR_DECL)
     mudflap_enqueue_decl (decl);
@@ -1663,6 +1680,13 @@ assemble_variable (tree decl, int top_le
       if (size == 0)
 	rounded = 1;
 
+      /* In bounds checking mode, pad with 1 byte afterwards.  */
+      if (bounds_checking_enabled) {
+	/* We will fix this in a moment ...  */
+	size += BIGGEST_ALIGNMENT / BITS_PER_UNIT;
+	rounded += BIGGEST_ALIGNMENT;
+      }
+
       /* Round size up to multiple of BIGGEST_ALIGNMENT bits
 	 so that each uninitialized object starts on such a boundary.  */
       rounded += (BIGGEST_ALIGNMENT / BITS_PER_UNIT) - 1;
@@ -1710,10 +1734,51 @@ assemble_variable (tree decl, int top_le
   if (align > BITS_PER_UNIT)
     ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (DECL_ALIGN_UNIT (decl)));
 
+  if (bounds_checking_enabled)
+    {
+#if 0 /* Not all targets may support this trick.  */
+#ifdef ASM_DECLARE_OBJECT_NAME
+      if (TREE_TYPE(decl) != error_mark_node
+          && TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (TREE_TYPE (decl))))
+        {
+	  static int decl_cnt = 0;
+	  char bounds_name[100];
+
+          tree save_size = TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (TREE_TYPE (decl)));
+          TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (TREE_TYPE(decl))) =
+            size_binop (PLUS_EXPR,
+		        TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (TREE_TYPE (decl))),
+		        convert (sizetype,
+			         bitsize_int(2 * BIGGEST_ALIGNMENT / BITS_PER_UNIT)));
+	  ASM_GENERATE_INTERNAL_LABEL (bounds_name, "__BOUNDS_", decl_cnt);
+	  decl_cnt++;
+          ASM_DECLARE_OBJECT_NAME (asm_out_file, bounds_name, decl);
+          TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (TREE_TYPE (decl))) = save_size;
+        }
+#endif
+#endif
+      assemble_integer (constm1_rtx, BIGGEST_ALIGNMENT / BITS_PER_UNIT,
+		        BITS_PER_UNIT, 1);
+    }
+
   /* Do any machine/system dependent processing of the object.  */
 #ifdef ASM_DECLARE_OBJECT_NAME
   last_assemble_variable_decl = decl;
-  ASM_DECLARE_OBJECT_NAME (asm_out_file, name, decl);
+  if (bounds_checking_enabled
+      && TREE_TYPE(decl) != error_mark_node
+      && TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (TREE_TYPE (decl))))
+    {
+      tree save_size = TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (TREE_TYPE (decl)));
+      TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (TREE_TYPE(decl))) =
+        size_binop (PLUS_EXPR,
+		    TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (TREE_TYPE (decl))),
+		    convert (sizetype,
+			     bitsize_int(BIGGEST_ALIGNMENT / BITS_PER_UNIT)));
+      ASM_DECLARE_OBJECT_NAME (asm_out_file, name, decl);
+      TYPE_SIZE_UNIT (TYPE_MAIN_VARIANT (TREE_TYPE (decl))) = save_size;
+    }
+  else
+    ASM_DECLARE_OBJECT_NAME (asm_out_file, name, decl);
 #else
   /* Standard thing is just output label for the object.  */
   ASM_OUTPUT_LABEL (asm_out_file, name);
@@ -1731,6 +1796,12 @@ assemble_variable (tree decl, int top_le
       else
 	/* Leave space for it.  */
 	assemble_zeros (tree_low_cst (DECL_SIZE_UNIT (decl), 1));
+
+      /* In bounds checking mode, add a single byte of padding after the
+	 variable.  */
+      if (bounds_checking_enabled)
+        assemble_integer (constm1_rtx, BIGGEST_ALIGNMENT / BITS_PER_UNIT,
+			  BITS_PER_UNIT, 1);
     }
 }
 
@@ -2149,6 +2220,91 @@ assemble_integer (rtx x, unsigned int si
 
   return false;
 }
+
+/* In bounds checking mode, build a table at the end of the file containing
+   pointers and sizes of all private static data in the file.  */
+
+void
+bounds_assemble_private_statics_table (void)
+{
+  struct private_statics_elem *p, *p_next;
+  rtx ptr_rtx, size_rtx, name_rtx;
+  int align, this_label_no = 0;
+  char label[256];
+
+  /* This table used to go in readonly_data_section, but unfortunately
+     this broke AIX on RS/6000 machines. The error message was `data adcons
+     in readonly sections' where (I presume) an `adcon' is an addressable
+     constant. Anyway, I've put this in the ordinary data section for
+     now. A correct solution probably involves looking at the `SELECT_
+     SECTION' macro. */
+/*  readonly_data_section (); */
+  data_section ();
+
+  /* Align it to the default alignment for integers. Take care not to align
+     bigger than the maximum the object file format will allow. Increase
+     alignment on machines that can benefit. */
+  align = BIGGEST_ALIGNMENT;
+#ifdef DATA_ALIGNMENT
+  align = DATA_ALIGNMENT (integer_type_node, align);
+#endif
+  if (align > BITS_PER_UNIT)
+    ASM_OUTPUT_ALIGN (asm_out_file, floor_log2 (align / BITS_PER_UNIT));
+
+  /* Write out the label for this object. */
+  ASM_OUTPUT_LABEL (asm_out_file, "__bounds_private_statics");
+
+  /* Write out the elements in the array, ie. a list of (label_pointer,
+     size, name_pointer). */
+  for (p = private_statics_list; p; p = p->next)
+    {
+      /* Write a pointer to the object.  */
+      ptr_rtx = gen_rtx_SYMBOL_REF (Pmode, p->label);
+      assemble_integer ( ptr_rtx, POINTER_SIZE/BITS_PER_UNIT, POINTER_SIZE, 0);
+
+      /* Write the size of the object.  */
+      size_rtx = GEN_INT (p->size);
+      assemble_integer ( size_rtx, POINTER_SIZE/BITS_PER_UNIT, POINTER_SIZE, 0);
+
+      /* Write out a pointer to the object's name. We write the names out
+         afterwards. */
+      if (p->name != NULL)
+        {
+	  p->name_label = this_label_no ++;
+	  ASM_GENERATE_INTERNAL_LABEL (label, "LPS", p->name_label);
+	  name_rtx = gen_rtx_SYMBOL_REF (Pmode, label);
+          assemble_integer ( name_rtx, POINTER_SIZE/BITS_PER_UNIT,
+			     POINTER_SIZE, 0);
+        }
+      else
+        {
+	  assemble_integer ( const0_rtx, POINTER_SIZE/BITS_PER_UNIT,
+			     POINTER_SIZE, 0);
+        }	
+    }
+
+  /* NULL-terminate the array. */
+  assemble_integer ( const0_rtx, POINTER_SIZE/BITS_PER_UNIT, POINTER_SIZE, 0);
+  assemble_integer ( const0_rtx, POINTER_SIZE/BITS_PER_UNIT, POINTER_SIZE, 0);
+  assemble_integer ( const0_rtx, POINTER_SIZE/BITS_PER_UNIT, POINTER_SIZE, 0);
+
+  /* Write out the object names that we referred to in the above table. */
+  for (p = private_statics_list; p; p = p->next)
+    if (p->name != NULL)
+      {
+	ASM_GENERATE_INTERNAL_LABEL (label, "LPS", p->name_label);
+	ASM_OUTPUT_LABEL (asm_out_file, label);
+	assemble_string (p->name, strlen (p->name) + 1);
+      }
+
+  /* For completeness, free up this list. */
+  for (p = private_statics_list; p; p = p_next)
+    {
+      p_next = p->next;
+      free (p);
+    }
+  private_statics_list = NULL;
+}
 
 void
 assemble_real (REAL_VALUE_TYPE d, enum machine_mode mode, unsigned int align)
@@ -2747,6 +2903,28 @@ output_constant_def_contents (rtx symbol
   if (TREE_CODE (exp) == STRING_CST)
     size = MAX (TREE_STRING_LENGTH (exp), size);
 
+  if (bounds_checking_enabled)
+    {
+#if 0 /* Not all targets may support this trick.  */
+#ifdef ASM_DECLARE_OBJECT_NAME
+      static int str_cnt = 0;
+      char bounds_name[100];
+      int new_size = size + 2 * BIGGEST_ALIGNMENT / BITS_PER_UNIT;
+      tree decl, type;
+
+      type = build_array_type (char_type_node,
+			       build_index_type (size_int (new_size)));
+      decl = build_decl (VAR_DECL, NULL_TREE, type);
+
+      ASM_GENERATE_INTERNAL_LABEL (bounds_name, "__BOUNDS_STR_", str_cnt);
+      str_cnt++;
+      ASM_DECLARE_OBJECT_NAME (asm_out_file, bounds_name, decl);
+#endif
+#endif
+      assemble_integer (constm1_rtx, BIGGEST_ALIGNMENT / BITS_PER_UNIT,
+		        BITS_PER_UNIT, 1);
+    }
+
   /* Do any machine/system dependent processing of the constant.  */
 #ifdef ASM_DECLARE_CONSTANT_NAME
   ASM_DECLARE_CONSTANT_NAME (asm_out_file, label, exp, size);
@@ -2759,6 +2937,67 @@ output_constant_def_contents (rtx symbol
   output_constant (exp, size, align);
   if (flag_mudflap)
     mudflap_enqueue_constant (exp);
+
+  /* In bounds checked mode, put a byte of padding after addressed
+     constants. Then add the assembler label and the (real) byte size to
+     a list. We will output this list as a private array at the end, so
+     we can pick up these static constants for checking.  */
+  if (bounds_checking_enabled)
+    {
+      struct private_statics_elem *private_static;
+
+      assemble_integer (constm1_rtx, BIGGEST_ALIGNMENT / BITS_PER_UNIT,
+			BITS_PER_UNIT, 1);
+      if (size != 0)
+	{
+	  private_static
+	    = (struct private_statics_elem *)
+	    xmalloc (sizeof (struct private_statics_elem));
+	  private_static->name = NULL;		/* Object has no name. */
+	  private_static->label = xstrdup (label);
+	  private_static->size = size;
+	  private_static->next = private_statics_list;
+	  private_statics_list = private_static;
+	}
+      else
+	warning ("cannot generate bounds checking code for zero sized static object");
+    }
+}
+
+/* Add external data definitions to the private_static list. Use a
+   negative size to flag this is an external data definition. */
+void
+bounds_external_declaration ( tree * vec, int len )
+{
+  int i;
+  tree decl;
+ 
+  for (i = 0 ; i < len ; i++) {
+
+    decl = vec[i];
+
+    if (TREE_CODE(decl) == VAR_DECL
+        && DECL_EXTERNAL (decl)
+        && TREE_USED(decl))
+      {
+        int size = int_size_in_bytes (TREE_TYPE (decl));
+
+        if (size > 0) {
+          struct private_statics_elem *private_static;
+          const char *label = IDENTIFIER_POINTER (DECL_NAME (decl)) ;
+	  char *new_label;
+
+	  new_label = xstrdup (label);
+          private_static = (struct private_statics_elem *)
+			    xmalloc (sizeof (struct private_statics_elem));
+          private_static->name = new_label;
+          private_static->label = new_label;
+          private_static->size = -size;
+          private_static->next = private_statics_list;
+          private_statics_list = private_static;
+        }
+      }
+  }
 }
 
 /* Look up EXP in the table of constant descriptors.  Return the rtl
