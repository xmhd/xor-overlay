From f9566b0c08270e8899b2f183380fc9140759a3ed Mon Sep 17 00:00:00 2001
From: Nick Alcock <nick.alcock@oracle.com>
Date: Wed, 14 Nov 2018 19:42:21 +0000
Subject: [PATCH 02/14] ctf: generate CTF information for the kernel

This introduces a new tool, dwarf2ctf, which runs whenever 'make ctf' is
run, extracting information on the kernel's types and global variables
from the DWARF-format debug information in the kernel build tree,
deduplicating it, and emitting it in Sun's Compact Type Format into a
mmappable type archive named vmlinux.ctfa, which is installed at 'make
install' time into /lib/modules/$(uname -r)/kernel/.  Out-of-tree
modules cannot participate in this mechanism since the file is already
written: CTF information for such modules is instead linked into such
modules at build time as new sections named .SUNW_ctf (as a result, most
of the build-time machinery for this is in scripts/Makefile.modpost).
Care should be taken not to strip such sections into debug RPMs (they
are small enough that this should not be a problem).

Within the ctfa file, the type information is divided into a shared
repository, containing all types used by more than one module, CTF for
the core kernel, and separate CTF for each module built, whether or not
this module has been compiled in or not: if a file *could* be built as a
module, it will be considered to be a module from the perspective of CTF
file emission (and kallmodsyms: see the next commit).  This ensures that
external consumers such as DTrace always find types for a given module
in the same place, regardless of the local kernel configuration, as long
as that module is present at all, assisting in portability of D scripts
between installations.  The ctf_ar tool in libdtrace-ctf can be used to
inspect ctfa files, and the ctf_dump tool can be used to look at the ctf
files they contain.

This process needs a pair of new files, objects.builtin (which lists all
object files that are unconditionally built into the kernel and cannot
be built as modules) and modules_thick.builtin, which maps from the thin
archives that make up built-in modules to their constituent object
files.  Taken together, these files let dwarf2ctf determine whether a
given object file linked into vmlinux.o is part of a module, and if so,
which one.

There is a single manually-maintained blacklist of structure members
dwarf2ctf cannot handle in scripts/dwarf2ctf/member.blacklist: this is
used to identify structure members which have different definitions in
different object files even though they are defined in the same location
in the same source file, usually due to preprocessor magic.  (Currently,
the only item in this list is present for example purposes only, since
the file in question was recently removed from the kernel: dwarf2ctf can
these days identify most members needing blacklisting automatically, and
will fail with an error if it needs more help.  It is quite possible that
dwarf2ctf will fail on make allyesconfig kernel configurations and other
extreme cases: I hope to track all such bugs down in time.)

The documentation for dwarf2ctf is currently somewhat outdated: an
update is planned.  It remains largely accurate except for some details
of the deduplication pass.

This introduces new kernel build-time dependencies on elfutils, zlib,
glib, and the new libdtrace-ctf package (shared with DTrace userspace).
No new runtime dependencies are introduced.

Orabug: 30544408
Signed-off-by: Nick Alcock <nick.alcock@oracle.com>
Signed-off-by: Tomas Jedlicka <tomas.jedlicka@oracle.com>
Reviewed-by: Kris Van Hees <kris.van.hees@oracle.com>
---
 .gitignore                         |    2 +
 Documentation/dwarf2ctf            | 1056 ++++++
 Documentation/process/changes.rst  |   23 +-
 Makefile                           |   49 +-
 lib/Kconfig                        |   12 +
 scripts/Makefile                   |    1 +
 scripts/Makefile.modfinal          |  141 +-
 scripts/dwarf2ctf/.gitignore       |    1 +
 scripts/dwarf2ctf/Makefile         |   11 +
 scripts/dwarf2ctf/dwarf2ctf.c      | 4961 ++++++++++++++++++++++++++++
 scripts/dwarf2ctf/eu_simple.c      |    2 +
 scripts/dwarf2ctf/member.blacklist |    1 +
 scripts/eu_simple.c                |  356 ++
 scripts/eu_simple.h                |   91 +
 scripts/move-if-change             |    8 +
 scripts/package/mkspec             |   12 +
 16 files changed, 6721 insertions(+), 6 deletions(-)
 create mode 100644 Documentation/dwarf2ctf
 create mode 100644 scripts/dwarf2ctf/.gitignore
 create mode 100644 scripts/dwarf2ctf/Makefile
 create mode 100644 scripts/dwarf2ctf/dwarf2ctf.c
 create mode 100644 scripts/dwarf2ctf/eu_simple.c
 create mode 100644 scripts/dwarf2ctf/member.blacklist
 create mode 100644 scripts/eu_simple.c
 create mode 100644 scripts/eu_simple.h
 create mode 100755 scripts/move-if-change

diff --git a/.gitignore b/.gitignore
index 48ef09c8f9a3..74e0568c12f5 100644
--- a/.gitignore
+++ b/.gitignore
@@ -48,6 +48,7 @@ Module.symvers
 modules.builtin
 modules.order
 modules_thick.builtin
+objects.builtin
 
 #
 # Top-level generic files
@@ -58,6 +59,7 @@ modules_thick.builtin
 /vmlinux
 /vmlinux.32
 /vmlinux.symvers
+/vmlinux.ctfa
 /vmlinux-gdb.py
 /vmlinuz
 /System.map
diff --git a/Documentation/dwarf2ctf b/Documentation/dwarf2ctf
new file mode 100644
index 000000000000..48a75c0519ff
--- /dev/null
+++ b/Documentation/dwarf2ctf
@@ -0,0 +1,1056 @@
+dwarf2ctf, a type encoder for the Linux kernel
+=========
+
+(This program is obsoleted by toolchain-based CTF support if available.)
+
+Many kernel-level debugging and tracing systems need access to the kernel's type
+information.  Since C doesn't support any form of introspection, the data must
+be extracted in some other way: here, we extract it from the DWARF debugging
+information generated by the compiler.  Unfortunately, this information is very
+voluminous (just the type information alone adds up to a couple of hundred
+megabytes in a 'make allyesconfig' kernel): even if users are happy to spend the
+disk space, the time and memory required to read much of this information in is
+likely to be prohibitive.
+
+This problem is not new -- back in 2004, Sun had the same problem when
+attempting to give DTrace a view of the type information in the Solaris kernel.
+Their solution was the Compact ANSI-C Type Format (CTF), a highly compacted
+representation of C types suitable for debuggers and tracers.  They combined
+this with a highly efficient tool for converting DWARF2 types to CTF, and hacks
+in the Solaris kernel causing the kernel itself to emit CTF data for its own
+types.
+
+Unfortunately while this tool may be highly efficient it is not adequate for the
+Linux kernel.  It treats every ELF object as an independent entity with an
+independent set of types -- perfectly all right for the Solaris kernel with a
+few hundred modules maximum, but very much not for Linux, where distro kernels
+often compile in thousands of modules.  Ideally, we would like to treat all
+kernel modules, built-in or not, the same way, sharing and deduplicating all
+globally-visible types across the entire set of visible modules and recording
+each precisely once.
+
+We also want to collect descriptions of global variables and emit descriptions
+of their name->type mapping as well, since the kernel has no easily accessible
+ELF section we can extract this information from at runtime (kernel modules must
+be accessible at runtime for modern Linux systems to work, but the kernel itself
+could have come from over the network or off a USB key or from a non-mounted
+partition or an EFI boot partition or who knows where, and could have any name
+even if it is accessible: so tracing tools should not rely on being able to look
+inside the kernel image).
+
+We do all this with dwarf2ctf, a CTF generation tool that reads in DWARF from a
+set of object files (usually, every object file in the kernel and all modules)
+and fills a directory with compressed files containing CTF representations of
+the types in those object files: the kernel build system regenerates these as
+necessary and links them directly into kernel modules.
+
+Caveats: It is somewhat specific to the form of DWARF output emitted by GCC, and
+doesn't yet support DWARF-4 type signatures or compressed DWARF at all.
+
+We'll look at each part of this system in turn, from the top down, starting with
+using the kernel type information  dwarf2ctf produces in other programs.
+
+
+Using dwarf2ctf output
+----------------------
+
+Using this data is fairly simple.  Once you've read the CTF sections from the
+kernel modules and inflated them (or ignored them if they are empty or, as just
+mentioned, one byte long), you simply need to look at the ctf_parent_name() for
+each module, and if it is set to "ctf", call ctf_import() to set the parent of
+this module to the CTF data you have read from the .ctf.shared_ctf section in
+the ctf.ko kernel module.  The core kernel's types are stored in the
+.ctf.vmlinux section in the same kernel module, and all built-in kernel modules
+have their types in .ctf.$module_name.  Non-built-in kernel modules just have a
+.ctf section containing their types, which again might need their parent set to
+"shared_ctf".  (Out-of-tree kernel modules will have no such parent.)
+
+Once you've set up the parenthood relationships you can call ctf_close() on the
+shared type repository and forget about it entirely: it will be refcounted and
+destroyed when all its children are closed.
+
+
+You should end up with a family of CTF files, one per kernel module built-in or
+not and one for the core kernel, freely usable for whatever purpose you need.
+
+
+Invocation and build-system connections
+----------
+
+dwarf2ctf's command-line syntax emphasises simplicity over compactness.  Linux
+has nearly-infinitely-long command lines these days, so we can take advantage of
+this.
+
+Two syntaxes are supported.  The first shares types across multiple modules and
+the core kernel; the second is used for out-of-tree module building, and avoids
+either sharing anything at all across modules or depending on the set of shared
+types defined for the core kernel.
+
+
+dwarf2ctf outputdir objects.builtin modules.builtin dedup.blacklist \
+	  vmlinux.o module.o ...
+dwarf2ctf outputdir -e module.o ...
+
+where:
+
+ - 'outputdir' is the possibly-relative path to a directory in which the
+   generated CTF files get placed.
+ - 'objects.builtin' is the name of the file containing the object files that
+   correspond to always-built-in kernel code (that cannot be built as modules).
+ - 'modules.builtin' is the name of the file containing the names of
+   kernel modules presently built in to the kernel.
+ - 'dedup.blacklist' is a blacklist of modules that should never participate
+   in deduplication: see 'Duplicate type detection' below.
+ - the .o filenames are the names of object files comprising the kernel and/or
+   modules: you can feed in whole modules at once (before linking with .mod.o).
+   This list is often very, very long (I have seen command-lines in excess of
+   60Kb).
+
+dwarf2ctf's output consists of a series of gzip-compressed .ctf.new files in the
+outputdir, which the makefile compares with and if necessary moves over the top
+of .ctf files with the same basename, so as to avoid relinking things if
+dwarf2ctf has written out content identical to what it wrote last time it ran.
+These fall into several classes, partitioned according to the contents of
+objects.builtin and modules.builtin:
+
+ - shared_ctf.builtin.ctf: The shared type repository.  Types shared by more
+   than one of the files below go here.
+   libdtrace-ctf).  See 'Using dwarf2ctf output' below regarding use of this
+   data.
+ - vmlinux.builtin.ctf: Types in the core kernel, that cannot be built in to
+   modules, go here.
+ - *.builtin.ctf: One of these is generated for the types in each module that
+   is presently built in to the kernel.
+ - *.mod.ctf: One of these is generated for each .ko.
+
+All the files in the first three classes are linked into the ctf.ko module under
+various names, an empty module containing nothing but CTF data.
+
+
+A lengthy section of Makefile.modpost, and a short section of the toplevel
+Makefile, is dedicated to creating these files, and to linking them into the
+kernel modules.  The dependency graph related to dwarf2ctf output is quite
+complex: modules and objects (ld -r'ed *.o files) are processed by dwarf2ctf to
+produce a number of files in the .ctf directory, and the final modules depend on
+the relevant ctf files.  The .mod.ctf's go into the .ko's with the same stem
+name, but ctf.ko receives content from all the CTF files corresponding to
+built-in modules, and until dwarf2ctf runs and creates those files we cannot
+tell what those CTF files will be, though we do have a wildcard that matches
+them all.
+[
+GNU Make's 'secondary expansion' feature comes to the rescue here: we can
+compute a list of expected CTF filenames at runtime, given the names of the
+modules we are linking in.  For the builtin modules, we cheat and touch a stamp
+file after moving any .ctf.new files back over a .ctf file, then depend on that
+to see if ctf.ko needs to be relinked.
+
+The actual incorporation of the CTF data into the kernel modules happens before
+module signing (if signing is active), by calling objcopy --add-section on the
+module in question.  This too has some knotty corners.
+
+First of all, the module linkage process normally links a module using all the
+prerequisites of the module's target -- but we have designated all the CTF files
+as prerequisites of the module's target, and we don't want to link them directly
+in using ld(1), since they aren't object files.  So we have to filter them out in
+the link line.
+
+Secondly, those modules which have no CTF files should acquire empty CTF
+sections to indicate their lack of unique types -- but objcopy in binutils 2.20
+and below silently exits if asked to --add-section an empty file.  So we use dd
+to generate a file with a one-byte null in it instead, and teach the users of
+CTF sections to treat a one-byte-long 'CTF' section as if it were empty.
+
+
+Overview of dwarf2ctf operation
+--------
+
+There are four phases to dwarf2ctf operation: initialization, duplicate type
+detection, CTF construction, and writeout.  Some of these phases can repeat.
+All but the last phase consists purely of sucking data from object files into
+GHashTables in memory. (The last two phases could potentially be combined,
+shrinking the size of one hash and saving memory, but the hash that is shrunk is
+by no means the largest one, so the extra complexity is probably not worth it.)
+
+dwarf2ctf uses several other libraries to do this:
+
+ - elfutils, used for DWARF parsing.  We could potentially write our own
+   DWARF parser, but elfutils works and is tested.
+
+ - glib, used for the GHashTable.  The rest of the kernel uses roll-your-own
+   hash tables, but dwarf2ctf makes heavy demands of its hashtables: they must
+   be expanding hashes capable of efficiently storing hundreds of thousands of
+   items, with amortized log(N) lookup time, and they must support deletion
+   (though it need not be particularly efficient deletion).  This rules out
+   simple fixed-size bucket hashes like the ones used in other parts of the
+   kernel build system: GHashTable is already implemented, and works.
+
+ - zlib, used to compress the CTF information.
+
+ - libdtrace-ctf, which both reads and writes the CTF data.  This is a port of
+   the Solaris CTF library, GPLed and with additional support for the storage
+   of name->type mappings (meant to represent variables) akin to its existing
+   ELF symbol->type mappings.
+
+dwarf2ctf has a good few important data structures, described at the top of
+scripts/dwarf2ctf/dwarf2ctf.c.
+
+dwarf2ctf has its own trace facility, implemented via the dw_ctf_trace() macro
+and enabled by compiling with -DDEBUG and setting DWARF2CTF_TRACE in the
+environment.  (The first step is required because some very numerous data
+structures are greatly expanded when debugging is turned on, which would waste
+memory if it were done all the time).  This produces a huge volume of trace
+output, several gigabytes when run over an allyesconfig kernel.
+
+
+Unless you're interested in how dwarf2ctf works internally, you can stop reading
+here.  If you are interested, now is a good time to read the comments above
+main() in scripts/dwarf2ctf/dwarf2ctf.c, which briefly describe dwarf2ctf's data
+structures and functions.
+
+
+Flow of Control
+---------------
+
+The /* C comments */ point to other sections of this document,
+
+Functions named in the /* Utilities */ section of dwarf2ctf.c are not mentioned
+here for simplicity's sake.
+
+[C]: Callback
+[R]: recursive
+[1]: Numbers: Mutually-recursive loop
+|: Several functions which all call the same functions
+->: Call from array of callbacks (filter_ctf_*() omitted as uninteresting)
+
+main()
+ /* See 'Initialization' */
+ init_assembly_tab()
+ init_builtin()
+ init_dedup_blacklist()
+ init_member_blacklist()
+ run()
+   init_tu_to_modules()
+   init_ctf_table()
+
+   /* Duplicate detection */
+
+   scan_duplicates()
+     process_file()                       /* Toplevel DWARF walkers */
+[C]    detect_duplicates_init()
+[R]    process_tu_func()
+[C]      assembly_filter_tab[]
+[C]      detect_duplicates()
+[ 1]       mark_shared()
+[R]          type_id()                    /* Type IDs */
+[C1]           mark_shared()
+[R]        mark_seen_contained()
+[C]    detect_duplicates_done()
+
+     process_file()
+[C]    detect_duplicates_init()
+[R]    process_tu_func()
+[C]      assembly_filter_tab[]
+[C]      detect_duplicates_alias_fixup()
+[R]        type_id()
+[C]          is_named_struct_union_enum()
+[R]        type_id()
+[C]          detect_duplicates_alias_fixup_internal()
+               mark_shared() (see above)
+[C]    detect_duplicates_done()
+
+   /* CTF construction */
+
+   process_file()
+[R]  process_tu_func()
+[C]    assembly_filter_tab[]
+[C]    construct_ctf()
+[ 2]     construct_ctf_id()
+[R3]       die_to_ctf()
+             assembly_tab[]
+[C]           -> assemble_ctf_base()
+              -> assemble_ctf_pointer()
+               | assemble_ctf_array()
+               | assemble_ctf_array_dimension()
+               | assemble_ctf_typedef()
+               | assemble_ctf_cvr_qual()
+               | assemble_ctf_variable()
+                   lookup_ctf_type()
+[ 2]                 construct_ctf_id()
+              -> assemble_ctf_enumeration()
+              -> assemble_ctf_enumerator()
+              -> assemble_ctf_struct_union()
+              -> assemble_ctf_su_member()
+[ 3]               die_to_ctf()
+[ 2]               construct_ctf_id()
+
+   write_types()
+
+Initialization
+--------------
+
+ init_assembly_tab()
+ init_builtin()
+ init_dedup_blacklist()
+ run()
+   init_tu_to_modules()
+   init_ctf_table()
+
+This happens at the top of main() and run(), and in various functions named
+init_*().  Of these, init_assembly_tab() and init_builtin() serve only to turn
+various static arrays and files mentioned on the command line into more useful
+internal representations (e.g. the assembly filter array of structures is turned
+into a pair of arrays indexed by DWARF tag), and the blacklisting functions are
+described in the section on duplicate type detection below.
+
+init_ctf_table(), called both at initialization time and later during CTF
+assembly when new CTF files are found to be needed, creates a new CTF file in
+memory and either marks it as a child of the shared type repository, or (if it
+*is* the shared type repository, or deduplication is off and there is only one
+CTF file being processed and no shared type repository at all) creates a few
+types in it which CTF has representations of but DWARF does not: a void type,
+and a generic catchall pointer-to-function-returning-int.
+
+That leaves init_tu_to_modules().  This walks over all the top-level
+compile_unit DIEs in the DWARF debugging information in every object file
+mentioned in the list of modules and built-in modules, constructing a mapping
+from translation unit name back to the name of the kernel module it comes from,
+even if that module is built in to the kernel.  This is normally the same as the
+filename (sans extension), but for built-in kernel modules, the name comes from
+the modules.builtin file's entry for the translation unit instead, so that the
+output can land in a .builtin.ctf file rather than being jammed into
+vmlinux.builtin.ctf with the core kernel's types.
+
+This means that dwarf2ctf can operate in terms of the kernel module a type is
+contained within rather than having to think about the mapping between object
+file name, translation unit name and module name all the time.
+
+
+Toplevel DWARF walkers
+----------------------
+
+     process_file()
+[C]    (per-TU initialization callback)
+[R]    process_tu_func()
+[C]      assembly_filter_tab[]
+[C]      (per-DIE callback)
+[C]    (per-TU cleanup callback)
+
+All routines in dwarf2ctf other than initialization and writeout are DWARF
+walkers: i.e., they walk over all DWARF DIEs in all object files specified on
+the command line and do something with every DIE.  This job is done by
+process_file() and its helper process_tu_func(), which not only digs out the
+corresponding (built-in or non-built-in) module name corresponding to each
+object file, but also detects and skips translation units it has handled before
+(in case they are incrementally linked into multiple object files) and allows
+callbacks to be invoked at the start and end of each translation unit.
+
+Even though dwarf2ctf only cares about top-level types, in some situations DWARF
+can emit top-level types with references to a non-top-level type: if all
+occurrences of the top-level type are an opaque structure, and the only
+non-opaque definition is inside a function, references in the same translation
+unit as the non-opaque definition will point to the definition inside the
+function (and references outside the translation unit will not point at any
+definition).  Thus, if we want to catch all nuances of globally-visible types,
+we have to scan types inside functions and lexical blocks inside functions too.
+
+To avoid generating a vast number of unnecessary type definitions, the 'assembly
+table' which describes how to construct a CTF type given a DWARF DIE also
+contains a description of a set of filters which are passed the current DIE and
+its parent: if they return false, the DIE is skipped and never passed to the
+callback function.  We also avoid calling the callback for any DWARF DIE whose
+tag doesn't appear in the assembly table at all: there's no point doing
+duplicate detection or anything else for a DWARF DIE we won't be generating CTF
+from.  There are currently two filters defined: filter_ctf_file_scope(), which
+is called for every DWARF DIE whose tag is one we never expect to see a
+reference to if it is inside a function (except if they relate to a structure or
+union, as above), and filter_ctf_uninteresting(), which is called for variables
+to see if they are worthy of recording (top-level named variables with external
+linkage not part of the internal workings of macros only).
+
+
+Type IDs
+--------
+
+[R]  type_id()
+[C]    (optional per-type callback)
+
+The only thing dwarf2ctf does which the Sun tool does not is the detection of
+duplicate and shared types, both within individual kernel modules and across
+modules.  Our ultimate goal is that a type that appears in the source code once
+appears in the CTF output once as well.  This goal has mostly been attained,
+except for out-of-tree modules, where cross-module type sharing must be disabled
+to avoid requiring rebuilds of the module whenever the core kernel is rebuilt.
+
+The core of this is the concept of a *type ID* and the function type_id() which
+computes it.  A type ID is an identifier for a type which precisely represents
+that type and only that type.  Doing this for types in different headers or at
+different scopes with the same name without needing to encode knowledge of C
+scoping rules into dwarf2ctf is an interesting proposition: we can use the line
+number and filename info provided by DWARF in most user-specified types to help.
+
+A type ID is a recursively-constructed string of the following form (fixed
+elements represented by {}, optional elements by []):
+
+//[filename]//[line number]//{type string}
+
+Types are *based* upon other types iff they have a DW_AT_type attribute pointing
+to some other type.  All types based upon other types have a type ID that is the
+type ID of the type upon which they are based, with additional information
+specific to this type appended to it.  The filename and line number is only
+added for those types which are not based upon other types and which have a
+filename and line number in the DWARF (lots don't, e.g. base types): the
+filename is canonicalized with realpath(), though since this is quite slow and
+type_id() is called a lot, the mapping from DWARF filename to realpath() result
+is cached.  Types that have no filename or line number start with '////'.
+
+We use // to separate the filename and line number elements because this is the
+shortest string other than NUL that cannot appear in a canonicalized POSIX
+pathname (ignoring Pyramid, Cygwin and other strange systems that actually
+return // in the result of realpath(): Linux doesn't use it and that's all that
+matters.  Should it start to use it, we can switch delimiter to ///.)
+
+Function pointers are not represented (or, rather, are all mapped to the same
+type ID, the generic catchall function-pointer type mentioned above); array
+dimensions are represented by [index-type dimension], or [] for flexible array
+members.  Structure members are not represented, since they are not types, but
+the types of their members *are* represented, as are nested structures (the line
+number and filename serving, as ever, to disambiguate them from other structures
+with the same name declared nested inside different structures).
+
+The following are some examples of valid type IDs (assuming the kernel source
+tree is, implausibly, located at /k/, just off the root directory: comments on
+individual types done /* like C */; the last example is broken across lines for
+formatting's sake):
+
+//fp//*  # a pointer to a function, any function
+////long int
+////char []
+////unsigned int typedef __kernel_uid_t typedef __kernel_uid32_t
+//fp//* typedef __signalfn_t * typedef __sighandler_t
+////struct nsproxy                       /* an opaque type */
+////struct nsproxy * #                   /* pointer to it */
+////long unsigned int typedef u64 volatile
+////long unsigned int volatile const * const
+////long unsigned int typedef sector_t [////long unsigned int  511]
+/k/include/linux/types.h//222//struct list_head
+/k/include/linux/types.h//222//struct list_head *
+/k/include/linux/types.h//222//struct list_head [////long unsigned int 5]
+/k/include/linux/types.h//217//struct    /* no struct tag */
+/k/include/linux/types.h//217//struct typedef atomic64_t
+/k/include/linux/mm_types.h//34//struct page * typedef pgtable_t
+/k/fs/eventpoll.c//122//struct nested_calls
+/k/include/linux/sysctl.h//1016//struct ctl_table typedef ctl_table
+    [////long unsigned int 4] var inotify_table  /* A global variable */
+
+This scheme means that cv-quals and other modifiers applied to other types are
+always merged: if there are a dozen typedefs for a single type 'foo' with the
+same name declared in the same place, they all end up with the same type ID and
+are only emitted into the CTF once.
+
+The type_id() function can also accept a callback, which is called as the
+recursion unwinds, from base type up to derived type: so it might be called for
+"////unsigned int", then for "////unsigned int typedef __kernel_uid_t", and so
+on up to the DIE that was originally passed in.  Because type_id() returns a
+dynamically-allocated string, calls to type_id() made purely for the sake of
+invoking a callback are normally of the peculiar form "free(type_id(...))".
+
+type_id() is a very hot spot, so syscall results are cached in it (such as
+realpath(), as mentioned above), and when string appending is done, it is done
+all at once where possible, via str_appendn(), which calls realloc() only once
+no matter the number of strings being appended.
+
+Lots of core data structures in dwarf2ctf consist of hashes mapping type IDs to
+something else (predominantly CTF file/ID pairs and module names).  It would
+be possible to map from hashes of type IDs, saving some memory, but this would
+impair debugging so is not yet implemented.  (If it is implemented, it should
+probably be implemented only when DEBUG is not defined.)
+
+
+Duplicate detection
+-------------------
+
+   scan_duplicates()
+     process_file()                       /* Toplevel DWARF walkers */
+[C]    detect_duplicates_init()
+[R]    process_tu_func()
+[C]      assembly_filter_tab[]
+[C]      detect_duplicates()
+[ 1]       mark_shared()
+[R]          type_id()                    /* Type IDs */
+[C1]           mark_shared()
+[ 4]       type_id()
+[ 4]         detect_duplicates_typeid()
+[ 4]           detect_duplicates()
+[R]        mark_seen_contained()
+           member_blacklisted()
+[C]    detect_duplicates_done()
+
+     process_file()
+[C]    detect_duplicates_init()
+[R]    process_tu_func()
+[C]      assembly_filter_tab[]
+[C]      detect_duplicates_alias_fixup()
+[R]        type_id()
+[C]          is_named_struct_union_enum()
+[R]        type_id()
+[C]          detect_duplicates_alias_fixup_internal()
+               mark_shared() (see above)
+[C]    detect_duplicates_done()
+
+The job of the duplicate detection pass is to fill out the id_to_module hash,
+which maps type IDs to the module they appear in, with the two special cases
+that types that appear only in the core kernel are said to appear in the module
+'vmlinux', and types that appear in more than one module (or in a module and in
+the core kernel) are said to appear in the module 'shared_ctf', the shared type
+repository.  This is quite a tricky multi-pass process, because we must ensure
+that the shared type repository is self-contained: all types in the repository
+must not reference any types outside the repository.
+
+Detecting duplicates itself is easy: we consider two types duplicates if they
+have the same type ID: if they both reside in the same module, the resulting
+type resides in that module too.  However, detecting shared types is harder.
+We consider that a type belongs in the shared module if any of these conditions
+is true:
+
+ - the type appears multiple times in different modules
+ - a type for which this type is a base type is shared
+ - the type is referenced by a structure or union member, and the structure
+   or union is shared
+ - the type is a non-opaque type with an opaque variant ('struct foo'), or
+   vice versa, and either of these variants is shared: these two types will
+   get different type IDs, so explicit checking is necessary
+
+Note that we do *not* consider a type to belong in the shared module merely if
+*it* has a base type which is shared: indeed, this is the common case for
+unshared types (even unshared structures tend to have fields of shared types
+like int).
+
+It should be fairly easy to see that sharedness is a contagious property:
+e.g. if you mark a structure as shared, and one of its members is an
+otherwise-unshared opaque pointer to a structure, you have to mark that as
+shared: this causes the non-opaque definition of the structure, and all *its*
+members, to be shared, and so on.  So since dwarf2ctf does not track the members
+of structures itself (not until the CTF generation phase, anyway), this means
+walking over the DWARF DIEs multiple times, checking for sharedness over and
+over until we are done.
+
+We partition the problem into two parts, both of which are carried out by
+process_file() callback functions: detect_duplicates() and
+detect_duplicates_alias_fixup().
+
+
+detect_duplicates() is called first, once for every DIE in the kernel (via
+process_file()).  This identifies types that are duplicated but not shared, and
+identifies shared types without consideration of opaque struct/union aliasing.
+It also flags types that have been seen only once as 'seen': this is checked
+much later on by the CTF construction phase, since construction of CTF for
+any type which has not been inspected by the deduplicator is a sign of a bug in
+the deduplicator.
+
+This has several subtleties.
+
+If we are running for an out-of-tree module, we must still identify types as
+duplicated within the module, but must never mark them as shared: out-of-tree
+modules cannot contribute to the shared type repository nor even use types in
+it, since they are rebuilt independently from the kernel proper and thus cannot
+depend on a type currently in the repository remaining there (e.g. perhaps it
+has only two users, both in modules, and the kernel is rebuilt to not build one
+of those modules anymore: this should not require rebuilding of any out-of-tree
+modules).
+
+If we mark a structure or union type as seen, we must mark aggregate types that
+appear directly within that type's DIE as seen as well.  This is done by the
+recursive function mark_seen_contained().  You might wonder what the point of it
+is: such types surely cannot appear anywhere else, and any duplication will
+precisely match the duplication of the containing type.  The answer is that they
+can still be referenced as the type of structure members of their containing
+structure, e.g. in
+
+struct foo {
+	struct bar {
+	} *baz;
+	struct bar wombat[16];
+};
+
+Here, a reference to 'struct bar' appears in 'struct foo', and CTF is
+constructed for it, even though it is not a top-level DIE.  In GCC 4.8+, a
+reference to the 16-element array-of-struct-bar can also appear in 'struct foo':
+in fact almost anything can appear in there if used nowhere else in the
+translation unit, even base types.  So we look for the appearance of anything
+which we can assemble into CTF (anything in the assembly_tab) other than
+members, since members cannot be used as the type of anything else, and mark
+them all as seen in this module.  (Nearly everything in a structure or union is
+a member, so this ends up skipping almost but not quite everything.)
+
+
+If we find that a type has appeared more than once in different kernel modules
+(or in a module and in the core kernel), we must mark it as shared.  This is
+done via mark_shared(), which is both a function that can be directly called
+(e.g. from detect_duplicates()) and a type_id() callback.  If it is called
+directly, it immediately reinvokes itself as a type_id() callback, which calls
+it for the base type of the type in question and then for all qualifiers up the
+type ID stack, marking them all as shared if they weren't already.
+
+If a structure or union is marked as shared, the types of its members are also
+marked as shared via a recursive call (even if they have already been so marked:
+just because this structure is of a type we've already seen, in a location we've
+already seen, doesn't mean that someone might not have legitimately used
+#defines to add extra members to the end of it, and we need to mark them as
+shared too).  We track structures that have been seen in this translation unit
+and avoid recursing into them, to avoid an infinite loop in cases like this:
+
+struct one;
+struct two {
+	struct one *foo;
+};
+
+struct one {
+	struct two *foo;
+}
+
+The types being pointers does not help here -- the marking of 'struct one *' as
+shared will automatically mark 'struct one' as shared too, because otherwise we
+might have a structure in the shared type repository whose members' types
+could not be found there.
+
+
+The second pass is the 'alias fixup' pass, implemented by
+detect_duplicates_alias_fixup().  This pass serves to detect unshared opaque
+types whose non-opaque equivalents are shared, and vice versa.  It is executed
+repeatedly until no types have been marked as shared for an entire iteration,
+but is considerably faster per iteration than the first pass, which often
+consumes more than half of dwarf2ctf's total runtime.  We work in one direction
+only, looking for non-opaque structures, unions or enums which have structure
+tags.  (Structures without tags cannot have opaque variants, and structures
+which are opaque will have non-opaque cousins somewhere, or can be emitted to
+the CTF as an opaque structure harmlessly since they truly have no members and
+are probably manipulated only via casts.)
+
+We identify structures, unions or enums with tags via the type_id() callback
+is_named_struct_union_enum(), but cannot determine if something is an opaque
+structure at this stage.  Instead, we do that after the callback, checking to
+see if the first four characters of the type ID are "////": this relies on the
+fact that GCC never gives opaque structures line numbers in DWARF.  We do the
+actual checking and marking of each non-opaque structure using
+detect_duplicates_alias_fixup_internal(), which is yet another type_id()
+callback.
+
+This function directly synthesises the name which this structure's opaque cousin
+would have, if it existed, by stripping off the line number and filename and
+replacing them with '////', and sees if either of these types have been marked
+as shared while the other has not.  If the opaque type is shared, the non-opaque
+variant can be marked shared using the same recursive mark_shared() function as
+before (thus marking the types of all its members and types it depends upon as
+shared too).  If it is the opaque type that needs marking shared, this will not
+work, since mark_shared() takes a DWARF DIE, and we don't have one for the
+opaque type, just a faked-up type ID.  However, since an opaque type doesn't
+have any members that need recursively tracing, we don't need access to its
+DWARF DIE to figure them out, and can just mark it as shared directly, via an
+insert into the id_to_module hash.
+
+Since this function is a type_id() callback, it is called not just for
+structures but for types based on them (e.g. in type_id form, "struct foo const
+* [43] volatile *"); at every level of this declarator stack, a shared opaque
+base type will contaminate its non-opaque cousins with sharedness, and vice
+versa.  This handles situations in which, say, the opaque version of "struct foo
+const * [43]" was used by more than one module and was marked as shared: the
+marking process will have marked the opaque versions of "struct foo const *
+[43]", "struct foo const *", "struct foo const" and "struct foo" as shared, but
+will not have touched any non-opaque versions of these types which may exist
+until this routine runs.  It also handles typedefs to structures with no need
+for any extra code.
+
+This whole alias fixup process needs to be repeated, because whenever a
+non-opaque type is marked as shared and its member's types traced and marked
+shared, *those* may themselves be structure types with corresponding opaque or
+non-opaque variants, and when they are opaque types the non-opaque variant that
+alias fixup works from may already have passed under the DWARF walker's gaze: so
+another pass over the kernel's DWARF is necessary to be sure we catch it.
+mark_shared() thus sets a flag that scan_duplicates() recognizes and uses to
+trigger another run through the alias fixup pass.
+
+
+There are a very few modules that this algorithm doesn't work for.  One example
+is snd-ens1371, which reads, in toto
+
+#define CHIP1371
+#include "ens1370.c"
+
+and ens1370.c (itself a distinct kernel module) then defines a 'struct ensoniq'
+whose members vary depending on whether CHIP1371 is defined.  Obviously, it is
+impossible to share any such types between kernel modules even though their
+names are the same and they are defined in the same place in the same source
+file in both cases.  But this sort of trickery is very rare, so we simply
+implement a 'deduplication blacklist' of modules which will not introduce new
+types into the shared CTF repository, and who do not participate in alias fixup
+detection either.  Detecting these cases in order to blacklist them is harder:
+no automated system has yet been implemented, although instances where #defines
+of this nature introduce new types that are then used by later members will
+cause assertion failures inside dwarf2ctf which might be a clue.  So it is
+possible that some examples have been missed.  (The blacklist only applies to
+cases where structure members change within a single kernel build, so cases
+where structures have members whose presence depends on CONFIG_* values are
+quite all right, as are cases where #defines are introduced by one translation
+that #includes another that then goes on to define whole new structures: it is
+only cases where modules #define something that changes the definition of
+individual possibly-shared types that will need blacklisting.)
+
+
+There are a few even worse cases where a single structure is defined with
+different members in different translation units within a single module.  In
+this case we can do nothing at all, since our output representation describes
+only a single type per module: we implement a 'member blacklist' which bans
+emission of affected members entirely, leaving a description of a structure with
+an undescribed hole in it.
+
+
+CTF construction
+----------------
+
+   process_file()
+[R]  process_tu_func()
+[C]    assembly_filter_tab[]
+[C]    construct_ctf()
+[ 2]     construct_ctf_id()
+[R3]       die_to_ctf()
+             assembly_tab[]
+[C]           -> assemble_ctf_base()
+              -> assemble_ctf_pointer()
+               | assemble_ctf_array()
+               | assemble_ctf_array_dimension()
+               | assemble_ctf_typedef()
+               | assemble_ctf_cvr_qual()
+               | assemble_ctf_variable()
+                   lookup_ctf_type()
+[ 2]                 construct_ctf_id()
+              -> assemble_ctf_enumeration()
+              -> assemble_ctf_enumerator()
+              -> assemble_ctf_struct_union()
+              -> assemble_ctf_su_member()
+                   member_blacklisted()
+[ 3]               die_to_ctf()
+[ 2]               construct_ctf_id()
+[C]    cleanup_sou_member_count()
+
+The next stage after the detection of duplicate and cross-module shared types is
+to generate CTF.  We generate all CTF at once before emitting it: this is
+potentially somewhat wasteful of memory, but in practice has not proved to be a
+problem: substantially less memory is used than is used by other parts of the
+kernel build, unless -DDEBUG is enabled.  Its job is to look through the
+kernel's type DWARF (via process_file(), as usual) and create CTF for every
+file-or-global-scope type and every externally-visible variable in the CTF file
+in which the duplicate detection pass has said that type should appear.
+(Variables are treated exactly like types: it just so happens that they are
+never shared because no type or variable can depend upon them, so they always go
+directly into the appropriate module and never into the shared type repository.)
+
+At this stage, the 'CTF files' are not actually files but rather ctf_file_t
+structures maintained by libdtrace-ctf and tracked in the per_module hash, along
+with other information which varies by module name.  We track every single
+individual type in the CTF file in the id_to_type hash, which maps type IDs to
+pairs of (CTF file ID, ctf type ID): this lets us use the type IDs described
+above when considering cross-references within CTF files (e.g. from one CTF type
+to a type it depends upon).
+
+The most important functions in this phase are:
+
+ - construct_ctf_id(), the top-level process_file() callback which is given a
+   DWARF DIE, looks in module_to_ctf_file for the CTF file where this type
+   should land (creating it if necessary), makes sure a type with this type ID
+   has not already been created there, calls die_to_ctf() to create the CTF,
+   notes where it was created in id_to_type, and handles errors.
+
+ - die_to_ctf(), a recursive function which calls the assembly function for the
+   DIE it is given and all its immediate children, with special-case handling
+   for tagged structures and unions.  If you want to create a type but not note
+   where it was created for future lookups by lookup_ctf_type(), this is what to
+   call.  (This is only done currently for unnamed structures/unions.)
+
+ - lookup_ctf_type(), which is called by CTF assembly functions for those
+   types that depend upon other types: it calls construct_ctf_id() again
+   to construct the type, and double-checks that all such types appear
+   either in the module we are constructing types for, or in the shared CTF
+   module.  CTF represents all function pointers the same way, and has a
+   special type ID for 'void', so we special-case both of these cases.
+
+These functions are mostly straightforward (though highly recursive, with all
+three plus CTF construction functions participating in loop 2 above,
+die_to_ctf() calling itself directly, and even one situation, the
+already-mentioned unnamed structures/unions, in which die_to_ctf() is directly
+called back by a CTF construction function, in loop 3 above.)
+
+
+There are a few subtleties, though.  Firstly, error handling.  We consider that
+errors that will lead to unusable CTF are fatal: mostly, these are errors where
+a bug in the deduplicator has failed to trace types correctly and has left at
+least one type in the shared module depending on a type in a non-shared module,
+or has failed to mark a type as shared at all.  In all these cases, you'll
+eventually get an error from lookup_ctf_type() of the general form
+
+blah.c:413:foo_t: Internal error: lookup of flob found in different file.
+
+The first two parts of this error are the translation unit and line number the
+type being assembled (usually a structure or union) was found in: foo_t is the
+name of the type being assembled.  The type of the structure being looked up
+appears nowhere, because we don't know it, but the name of the member is given
+("flob" above, or "(unnamed)" if we don't know it).  If you want more
+information, you can pass -DDEBUG to the compilation of dwarf2ctf.c in
+scripts/dwarf2ctf/Makefile, and rerun dwarf2ctf, and you'll get the module and
+filename in which both the originating and the target types appear.  In order to
+actually track down the bug you'll probably have to run dwarf2ctf with
+DWARF2CTF_TRACE set in the environment, and look at the place where the target
+type was deduplicated, and try to figure out why the deduplicator didn't trace
+the reference to the type in foo_t correctly.
+
+There is another kind of error, though: a failure to assemble a single type,
+perhaps because DWARF was emitted that we don't know how to understand (this is
+particularly likely in structure assembly, where we are highly dependent on the
+form of the DWARF that GCC happens to emit for DW_AT_member_location).  We pass
+an 'enum skip_type' around, which has three possible values, one of which is
+SKIP_ABORT.  Before each type is assembled, we call ctf_snapshot() to take a
+snapshot of the variable-plus-type set in the CTF file we're working over.  If a
+SKIP_ABORT propagates up to construct_ctf_id(), we call ctf_rollback(), which
+throws away every type constructed since the last ctf_snapshot() -- i.e., the
+specific erroneous type we've just been working on.  (We might have emitted some
+parts of it and then failed, so we should try to clean up).
+
+A SKIP_ABORT is not fatal unless DEBUG is defined: its only effect is to omit
+one single type from the resulting CTF, which is probably still usable.
+
+libdtrace-ctf causes additional problems here.  It can only see the types we
+added once the notably expensive function ctf_update() is called.  This takes
+the in-memory structures and serializes them (all of them, every time).  This
+only affects libctf when structure and union members are added: libctf needs to
+know the sizes and alignments of the types of those members, which might quite
+possibly just have been added, e.g. if this structure contains a pointer to its
+own structure tag.  So, when we insert a member in assemble_ctf_su_member(), we
+note a bad type-ID error and do a ctf_update() on the file we're working over
+and try again: even then that can fail if the type was added to the shared
+repository, so we do a ctf_update() on *that* and try again, and only if that
+fails do we declare a SKIP_ABORT error.  (We check the shared repository last
+because it is very large, so takes longer to serialize than other CTF files do).
+
+The need to keep the number of calls to ctf_update() down means we must avoid
+all access to the CTF types we are assembling if we can possibly get at the same
+data another way.  Hence the member_counts hash, a member of the per_module
+state, which tracks the number of members in structures with a given C-style
+name and their CTF IDs.  This structure allows us to handle the (valid) C idiom
+of redeclaring the same structure with a different number of members, merging
+the definitions across translation units and discarding them (iff the structure
+was unshared) when we transition into a new module, without ever having to
+consult the CTF to see how many members we put into it.  (We have to use the
+C-style name here, because by definition the type IDs of such redeclared
+structures will be different, since a type ID contains a line number and
+translation unit name.)
+
+
+There's more error-handling complexity inside die_to_ctf(), where errors from
+libdtrace-ctf are actually reported (there may be multiple of them for a single
+type, e.g. if we are assembling a structure and several members somehow refer to
+a type we do not know about).
+
+die_to_ctf() itself has the sort of parameter list that can make people swear
+off C for life.  It is largely explained in the description of ctf_assembly_fun.
+Most parts of it are hardly used in the function itself, just passed down to CTF
+assembly functions.
+
+Finally, we must note the override flag.  Both die_to_ctf() and
+construct_ctf_id() return a CTF ID.  This is thrown away by the DWARF walking
+code (the function construct_ctf() exists just for that purpose), but when
+called by lookup_ctf_type(), this CTF ID is taken to be the single ID of the CTF
+type that's just been assembled.  Normally this is the same as the CTF ID
+returned by the CTF assembly function for the top-level DWARF DIE, but there are
+a few structures for which we want to return the result of some other CTF
+assembly function.
+
+The only currently-existing example is array dimensions, which DWARF represents
+as a typed array DIE whose child is a dimension, but which CTF represents as an
+array-with-dimensions that you can't change afterwards.  We can't assemble an
+'array' at the top level because we don't know how big it is, but we have to
+track the type recorded there somehow.  We handle this by having
+assemble_ctf_array(), the assembly function for the top-level DW_TAG_array_type
+DIE, simply look up the type of the array's members and return its ID as if it
+had just constructed it, after which assemble_ctf_array_dimension(), the
+assembly function for DW_TAG_subrange_type, actually constructs the array,
+wrapping it around the CTF 'ID' 'assembled' by the parent and setting the
+override flag to make sure that this is what is really recorded.
+
+
+CTF construction functions
+--------------------------
+
+Each CTF construction function takes a single DWARF DIE and turns it into CTF,
+somehow.  They are laid out in the assembly table described in 'toplevel DWARF
+walkers' above.  They all start the same way, with a series of CTF_DW_ENFORCE or
+CTF_DW_ENFORCE_NOT assertions.  These guard against corrupted DWARF missing some
+of the attributes we need, or DWARF containing attributes which indicate that we
+can't handle the content (e.g. DW_AT_signature or DW_AT_specification on
+structures, which would both indicate this is DWARF 4, which we can't handle
+yet.)
+
+We'll go through these functions one by one, pointing out anything that
+maintainers should be aware of.
+
+
+assemble_ctf_base() assembles all integral base types (DW_TAG_base_type) and
+transforms them into the corresponding CTF type.  The functions we need to call
+for this in the CTF API all have the same type signature but have different
+names; CTF also distinguishes between the various differently-sized
+floating-point types, so we must figure out from the type size which type a
+given DWARF base type is referring to.  We map from DWARF encoding to a triple
+of (CTF addition function, CTF integral type, type size) where the latter is
+optional and depends on the size of the DWARF type we are encoding and the size
+of various floating_point types on the current system.  (This does mean that
+cross-compilation using dwarf2ctf is likely to fail fairly often: we need
+machinery to determine the sizeof() types on the target system before that can
+function.)
+
+This sizeof()-based search procedure is why we do not currently support
+DW_AT_bit_size for base types: we could easily support it for sizes modulo 8,
+but GCC happens to emit DW_AT_byte_size in this case.  In C DW_AT_bit_size is
+likely to be emitted only for bitfields in structures anyway, not for base
+types.
+
+
+assemble_ctf_pointer() and assemble_ctf_typedef() are trivial: look up the
+associated type with lookup_ctf_type() and assemble the appropriate thing.
+assemble_ctf_cvr_qual() is almost as trivial, but has to figure out which of
+const, volatile or restrict it was called for and call the corresponding CTF API
+function.  assemble_ctf_enumeration() and assemble_ctf_enumerator() are quite
+simple too.
+
+
+assemble_ctf_variable() has a couple of extra complexities: we unconditionally
+set the skip parameter to SKIP_SKIP, suppressing recursion into containing DIEs,
+since we already know we won't care about any of them.  Also, while the
+deduplication pass unifies opaque and non-opaque structures into the same type,
+it never makes sure that variables declared in the same header by translation
+units which have opaque versus non-opaque structures in scope are deduplicated.
+e.g. you could well end up with these two type IDs, depending on whether
+<linux/pid_namespace.h> was included before <linux/pid.h> in a given translation
+unit:
+
+////struct pid_namespace var init_pid_ns
+/path/to/kernel/include/linux/pid_namespace.h//19//struct pid_namespace var init_pid_ns
+
+These variables both refer to the same type, but deduplicating them would
+require an additional deduplication pass.  Since variables are always terminal
+and nothing can refer to them, nothing will ever look up any of those type IDs
+(since the only thing that looks up type IDs is code that is searching for type
+that other types depend on).  So we don't care about this duplication and
+running an additional deduplication pass to eliminate it would slow down
+dwarf2ctf to no good end.  It's better just to ignore duplicate errors from
+ctf_add_variable().
+
+
+assemble_ctf_array() and assemble_ctf_array_dimension() we talked about
+above. One last subtlety remains, which is that figuring out the actual
+dimensionality of an array is complicated enough that it has been hived off into
+a private_subrange_dimension() function, called both from here and from
+type_id().  Arrays with neither a DW_AT_upper_bound nor a DW_AT_count, and
+arrays without an indexing type, are best considered flexible arrays; arrays
+whose upper bound or count is not unsigned or signed integral data are also
+flexible (perhaps they're using a full-blown location list, but we can't encode
+that in CTF so we treat it as flexible); and if an upper bound is used, we want
+to add one to its value before treating it as a count of elements.
+
+
+This leaves structure/union assembly, both of which are assembled by the same
+pair of functions, assemble_ctf_struct_union for the type itself and
+assemble_ctf_su_member() for the individual members.  As with
+assemble_ctf_cvr_qual(), we have to look at the tag to figure out which CTF
+function to use to do the assembly, but we have an extra constraint: it is
+perfectly idiomatic C to declare a structure repeatedly with a different number
+of members every time.  This is perfectly permissible as long as the leading
+portions of all declarations match.  We do not verify this (we hope that the
+compiler will diagnose it, which it will unless the conflicting declarations
+cross modules), though perhaps we should: we simply look up the structure in the
+CTF and the DWARF and skip assembly of the structure members via SKIP_SKIP if
+the already-assembled structure has at least as many members as the current one.
+
+assemble_ctf_su_member() is by far the most complex of the assembly functions.
+It has to handle members that already exist, members that need assembly, members
+that correspond to unnamed structure members, numerous different ways of
+representing structure offsets and members with no offset at all.
+
+The offset computation is quite laborious and by no means complete: a complete
+implementation would require an interpreter for DWARF location lists, which is
+total overkill given that in DWARF2 GCC emits a totally stereotyped location
+list, and in DWARF3+ we don't need location list parsing at all.  CTF wants an
+offset in bits.
+
+We have five cases:
+ - for DW_AT_data_bit_offset, we just use the offset unchanged.
+
+ - for DW_AT_data_member_location with an integral form (data2, data4, data8,
+   udata, or sdata) we just look it up and multiply it by eight, adding the
+   parent's DW_AT_bit_offset to handle structures nested inside other
+   structures.
+
+ - for DW_AT_data_member_location with a block form, we make sure that the list
+   is of one particular simple form (DW_OP_plus_uconst and a constant value in
+   bytes), and abort assembly otherwise.  The only case I know of where this
+   test will trip is C++ virtual bases: if people are using C++ code with
+   virtual bases inside the kernel they deserve sympathy, but probably not
+   support in the code.  CTF can't represent C++ types in any case.
+
+ - for expression location lists, or anything else that we don't understand, we
+   simply die (we could simply skip the type, but this seems serious enough that
+   dying is warranted).
+
+ - with none of these present, we have no offset: the member is at the same
+   location as the start of the structure.
+
+But where is the 'start of the structure'?  That depends on whether this is an
+unnamed struct/union member (usually a union).  If it is, we want to fold all
+its members directly into the parent structure, with their offsets increased by
+the offset of the unnamed member as a whole.  This is done by directly calling
+die_to_ctf() with the first child of the anonymous member's type and with all
+other parameters set as if the parent DIE was the current structure, thus
+fooling die_to_ctf() into believing that these members are members of the
+current structure, not of the anonymous one.  The offset-increasing magic is
+done via the parent_bias parameter to die_to_ctf() and all the CTF construction
+functions: it is ignored by all of them except for assemble_ctf_su_member()
+itself, which adds the parent bias onto the normally-computed offset, and is
+otherwise passed down unchanged to all children.  This means that even this
+terribly contrived case works:
+
+struct horror {
+	int spacer;
+	union {
+		struct {
+			int spacer;
+			struct {
+				int foo;
+				int bar;
+			} b;
+		} a;
+	};
+};
+
+In this situation, horror.a.b.bar may have:
+
+ - a nonzero parent_bias due to the offset of the anonymous union in 'struct
+   horror'
+ - a nonzero offset due to the offset of 'bar' in its containing structure
+ - if DW_AT_data_member_location with integral form is used, a nonzero
+   DW_AT_bit_offset of 'b' in 'a'
+
+If this is not an anonymous union, we are dealing with only one member: we look
+up its type and add it reasonably conventionally via ctf_add_member_offset().
+Even here there are subtleties: we use construct_ctf_id() directly rather than
+via lookup_ctf_type() so we can get a better error message on failure, and we
+ignore any duplicate-member errors because this is probably a sign that this
+structure has already been encountered and we are working through another
+instance of it with more members.
+
+
+Writeout
+--------
+
+   write_types()
+
+This couldn't really be simpler, as the trivial call graph shows.  We create an
+output directory with the requested name, then work over the entire
+module_to_ctf_file hash, writing out every CTF file into a new suitably-named
+file via zlib's compressed file I/O functions.
diff --git a/Documentation/process/changes.rst b/Documentation/process/changes.rst
index 8f68e728ae6b..f28053c6c421 100644
--- a/Documentation/process/changes.rst
+++ b/Documentation/process/changes.rst
@@ -55,9 +55,14 @@ iptables               1.4.2            iptables -V
 openssl & libcrypto    1.0.0            openssl version
 bc                     1.06.95          bc --version
 Sphinx\ [#f1]_	       1.3		sphinx-build --version
+elfutils\ [#f2]_       0.156		eu-readelf --version
+pkg-config\ [#f2]_     0.16		pkg-config --version
+glib\ [#f2]_           2.x		pkg-config --exists glib-2.0 && echo present
+libdtrace-ctf\ [#f2]_  1.1
 ====================== ===============  ========================================
 
 .. [#f1] Sphinx is needed only to build the Kernel documentation
+.. [#f2] This is needed at build-time when CTF or DTrace are enabled
 
 Kernel compilation
 ******************
@@ -84,7 +89,8 @@ pkg-config
 The build system, as of 4.18, requires pkg-config to check for installed
 kconfig tools and to determine flags settings for use in
 'make {g,x}config'.  Previously pkg-config was being used but not
-verified or documented.
+verified or documented.  dwarf2ctf also relies on it during 'make ctf' and
+while building out-of-tree modules with CONFIG_CTF enabled.
 
 Flex
 ----
@@ -356,6 +362,21 @@ OpenSSL
 
 - <https://www.openssl.org/>
 
+elfutils
+--------
+
+- <https://fedorahosted.org/elfutils/>
+
+glib 2.x
+--------
+
+- <http://www.gtk.org/>
+
+libdtrace-ctf
+-------------
+
+- <https://oss.oracle.com/git/?p=libdtrace-ctf.git>
+
 System utilities
 ****************
 
diff --git a/Makefile b/Makefile
index 2e279764ce7b..fb5e6df27702 100644
--- a/Makefile
+++ b/Makefile
@@ -1370,6 +1370,45 @@ modules.order: $(subdir-modorder) FORCE
 
 targets += modules.order
 
+ifneq (CONFIG_CTF@,'@')
+
+# We need to force everything to be built, since we need the .o files below.
+KBUILD_BUILTIN := 1
+
+# This contains all the object files that are built directly into the
+# kernel (including built-in modules), for consumption by dwarf2ctf in
+# Makefile.modpost.
+# This is made doubly annoying by the presence of '.o' files which are actually
+# thin ar archives, and the need to support file(1) versions too old to
+# recognize them as archives at all.  (So we assume that everything that is not
+# an ELF object is an archive.)
+ifeq ($(SRCARCH),x86)
+objects.builtin: $(vmlinux-dirs) $(if $(KBUILD_BUILTIN),bzImage) FORCE
+else
+objects.builtin: $(vmlinux-dirs) $(if $(KBUILD_BUILTIN),vmlinux) FORCE
+endif
+	@echo $(KBUILD_VMLINUX_OBJS) | \
+		tr " " "\n" | grep "\.o$$" | xargs -r file | \
+		grep ELF | cut -d: -f1 > objects.builtin
+	@for archive in $$(echo $(KBUILD_VMLINUX_OBJS) |\
+		tr " " "\n" | xargs -r file | grep -v ELF | cut -d: -f1); do \
+		$(AR) t "$$archive" >> objects.builtin; \
+	done
+
+ctf: vmlinux.ctfa
+PHONY += ctf
+
+# Making CTF needs the builtin files unless out-of-tree.
+ifeq ($(KBUILD_EXTMOD),)
+vmlinux.ctfa: modules_thick.builtin objects.builtin
+endif
+vmlinux.ctfa:
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modfinal vmlinux.ctfa
+else
+PHONY += objects.builtin
+objects.builtin:
+endif
+
 # Target to prepare building external modules
 PHONY += modules_prepare
 modules_prepare: prepare
@@ -1391,6 +1430,9 @@ _modinst_:
 	@sed 's:^:kernel/:' modules.order > $(MODLIB)/modules.order
 	@cp -f modules.builtin $(MODLIB)/
 	@cp -f $(objtree)/modules.builtin.modinfo $(MODLIB)/
+	@if [ -f $(objtree)/vmlinux.ctfa ] ; then \
+		cp -f $(objtree)/vmlinux.ctfa $(MODLIB)/kernel ; \
+	fi
 	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modinst
 
 # This depmod is only for convenience to give the initial
@@ -1448,7 +1490,7 @@ $(modthickbuiltin-dirs): include/config/tristate.conf
 # make distclean Remove editor backup files, patch leftover files and the like
 
 # Directories & files removed with 'make clean'
-CLEAN_FILES += include/ksym vmlinux.symvers \
+CLEAN_FILES += include/ksym vmlinux.symvers .ctf .ctf.filelist .ctf.filelist.raw \
 	       modules.builtin modules.builtin.modinfo modules.nsdeps
 
 # Directories & files removed with 'make mrproper'
@@ -1544,6 +1586,8 @@ help:
 	@echo  '                    (requires a recent binutils and recent build (System.map))'
 	@echo  '  dir/file.ko     - Build module including final link'
 	@echo  '  modules_prepare - Set up for building external modules'
+	@echo  '  ctf             - Generate CTF type information for DTrace, installed by '
+	@echo  '                    make modules_install'
 	@echo  '  tags/TAGS	  - Generate tags file for editors'
 	@echo  '  cscope	  - Generate cscope index'
 	@echo  '  gtags           - Generate GNU GLOBAL index'
@@ -1793,8 +1837,9 @@ clean: $(clean-dirs)
 		-o -name '*.asn1.[ch]' \
 		-o -name '*.symtypes' -o -name 'modules.order' \
 		-o -name '.tmp_*.o.*' -o -name modules_thick.builtin \
+		-o -name objects.builtin \
 		-o -name '*.c.[012]*.*' \
-		-o -name '*.ll' \
+		-o -name '*.ll' -o -name '*.ctfa' \
 		-o -name '*.gcno' \) -type f -print | xargs rm -f
 
 # Generate tags for editors
diff --git a/lib/Kconfig b/lib/Kconfig
index df3f3da95990..820df07a1f60 100644
--- a/lib/Kconfig
+++ b/lib/Kconfig
@@ -578,6 +578,18 @@ config DIMLIB
 #
 config LIBFDT
 	bool
+#
+# CTF support is select'ed if needed
+#
+config CTF
+        bool "Compact Type Format generation"
+        default y
+        select STRIP_ASM_SYMS
+        depends on DEBUG_INFO && !DEBUG_INFO_REDUCED && !DEBUG_INFO_SPLIT && !DEBUG_INFO_DWARF4
+        help
+          Emit a compact, compressed description of the kernel's datatypes and
+          global variables into the vmlinux.ctfa archive (for in-tree modules)
+          or into .ctf sections in kernel modules (for out-of-tree modules).
 
 config OID_REGISTRY
 	tristate
diff --git a/scripts/Makefile b/scripts/Makefile
index 95ecf970c74c..9d3c7026cb45 100644
--- a/scripts/Makefile
+++ b/scripts/Makefile
@@ -33,6 +33,7 @@ hostprogs += unifdef
 
 subdir-$(CONFIG_GCC_PLUGINS) += gcc-plugins
 subdir-$(CONFIG_MODVERSIONS) += genksyms
+subdir-$(CONFIG_CTF)         += dwarf2ctf
 subdir-$(CONFIG_SECURITY_SELINUX) += selinux
 
 # Let clean descend into subdirs
diff --git a/scripts/Makefile.modfinal b/scripts/Makefile.modfinal
index 411c1e600e7d..abe9dcc72bc0 100644
--- a/scripts/Makefile.modfinal
+++ b/scripts/Makefile.modfinal
@@ -1,11 +1,21 @@
 # SPDX-License-Identifier: GPL-2.0-only
 # ===========================================================================
-# Module final link
+# Module final link and CTF generation
 # ===========================================================================
+# 1) compile all <module>.mod.c files
+# 2) for external modules, generate CTF for the module (there is an extra,
+#    externally-invoked target that does this for the entire kernel but does
+#    not invoke the rst of the module-building process)
+# 3) final link of the module to a <module.ko> file
+
+# We need secondary expansion for 'module-ctfs-modular-prereq', below.
+
+.SECONDEXPANSION:
 
 PHONY := __modfinal
 __modfinal:
 
+include include/config/auto.conf
 include $(srctree)/scripts/Kbuild.include
 
 # for c_flags
@@ -27,6 +37,128 @@ quiet_cmd_cc_o_c = CC [M]  $@
 %.mod.o: %.mod.c FORCE
 	$(call if_changed_dep,cc_o_c)
 
+# Generate CTF for the entire kernel, or for the module alone if this is a
+# build of an external module.
+
+# These are overridden below for standalone modules only.
+module-ctfs-modular-prereq =
+module-ctfs-modular =
+module-ctf-flags =
+cmd_touch_ctf =
+ctf-dir = ///.nonexistent
+cmd-touch-ctf = @:
+
+ifdef CONFIG_CTF
+
+# This is quite tricky.  If called for non-external-modules, dwarf2ctf needs to
+# be told about all the built-in objects as well as all the external modules --
+# but Makefile.modpost only knows about the latter.  So the toplevel makefile
+# emits the names of the built-in objects into a temporary file, which is
+# then catted and its contents used as prerequisites by this rule.
+#
+# We write the names of the object files to be scanned for CTF content into a
+# file, then use that, to avoid hitting command-line length limits.
+
+ifeq ($(KBUILD_EXTMOD),)
+ctf-dir-mk :=
+quiet_cmd_ctf = CTFA
+      cmd_ctf = scripts/dwarf2ctf/dwarf2ctf vmlinux.ctfa $(srctree) objects.builtin modules_thick.builtin $(srctree)/scripts/dwarf2ctf/member.blacklist $(ctf-filelist)
+ctf-builtins := objects.builtin
+ctf-builtins-prereq := $(ctf-builtins)
+ ctf-modules := $(shell find . -name '*.ko' -print)
+ctf-filelist := .ctf.filelist
+ctf-filelist-raw := .ctf.filelist.raw
+ctf-stamp :=
+
+else
+ctf-dir := $(KBUILD_EXTMOD)/.ctf
+ctf-dir-mk := $(ctf-dir)
+quiet_cmd_ctf = CTF
+      cmd_ctf = scripts/dwarf2ctf/dwarf2ctf $(ctf-dir) -e $(ctf-filelist)
+ctf-builtins := ////.no-builtins
+ctf-builtins-prereq :=
+ctf-modules := $(modules:.ko=.o)
+ctf-filelist := $(ctf-dir)/$(notdir $(M)-extmod).ctf.filelist
+ctf-filelist-raw := $(ctf-dir)/$(notdir $(M)-extmod).ctf.filelist.raw
+ctf-stamp = $(ctf-dir)/$(notdir $(M)-extmod).stamp
+
+# All the modules' CTF depends on the stamp file.
+
+all-module-ctfs = $(addprefix $(ctf-dir)/,$(notdir $(modules:.ko=.mod.ctf)))
+$(all-module-ctfs): $(ctf-stamp)
+
+endif
+
+# Split a list up like shell xargs does.
+define xargs =
+$(1) $(wordlist 1,1024,$(2))
+$(if $(word 1025,$(2)),$(call xargs,$(1),$(wordlist 1025,$(words $(2)),$(2))))
+endef
+
+$(ctf-filelist-raw): $(ctf-builtins-prereq) $(ctf-modules)
+	@rm -f $(ctf-filelist-raw);
+	@if [[ -n "$(ctf-dir-mk)" ]]; then \
+		mkdir -p "$(ctf-dir-mk)"; \
+	fi
+	$(call xargs,@printf "%s\n" >> $(ctf-filelist-raw),$^)
+	@touch $(ctf-filelist-raw)
+
+$(ctf-filelist): $(ctf-filelist-raw)
+	@rm -f $(ctf-filelist);
+	@cat $(ctf-filelist-raw) | while read -r obj; do \
+		case $$obj in \
+		$(ctf-builtins)) cat $$obj >> $(ctf-filelist);; \
+		*.a) ar t $$obj > $(ctf-filelist);; \
+		*.builtin) cat $$obj >> $(ctf-filelist);; \
+		*) echo "$$obj" >> $(ctf-filelist);; \
+		esac; \
+	done
+	@touch $(ctf-filelist)
+
+ifeq ($(KBUILD_EXTMOD),)
+# The CTF depends on the output CTF file list, and that depends
+# on the .ko files for the modules.
+vmlinux.ctfa: $(ctf-filelist)
+	$(call if_changed,ctf)
+else
+
+# The CTF depends on the output CTF file list, and that depends
+# on the .o files for the modules
+$(ctf-stamp): $(ctf-filelist)
+	$(call if_changed,ctf)
+	@shopt -s nullglob; \
+	for name in $(ctf-dir)/*.ctf.new; do \
+		$(srctree)/scripts/move-if-change $$name $${name%.new}; \
+	done; \
+	touch $(ctf-stamp)
+
+# Expands to the names of the CTF files to be incorporated into this module.
+# The former is used in prerequisite lists, thanks to secondary expansion.
+
+module-ctfs-modular-prereq = $$(addprefix $(ctf-dir)/,$$(notdir $$*.mod.ctf))
+module-ctfs-modular = $(addprefix $(ctf-dir)/,$(notdir $*.mod.ctf))
+
+# Expands to the name of a CTF file, given a target of a module name given to
+# one of the link rules below.
+
+ctf-module-name = $(addprefix $(ctf-dir)/,$(notdir $(basename $@)).mod.ctf)
+
+# An objcopy --add-section argument to add the CTF section to a standalone
+# module.
+
+module-ctf-flags = --add-section .ctf=$(ctf-module-name)
+
+# We have to put content in our dummy no-CTF files because --add-section
+# in binutils 2.20 silently fails if asked to add an empty file as a section.
+
+cmd_touch_ctf = @for name in $(filter $(ctf-dir)/%,$(module-ctfs-modular)); do \
+		    test -f $$name || dd if=/dev/zero of=$$name bs=1 count=1 2>/dev/null; \
+		done
+
+endif		# KBUILD_EXTMOD
+
+endif		# !CONFIG_CTF
+
 ARCH_POSTLINK := $(wildcard $(srctree)/arch/$(SRCARCH)/Makefile.postlink)
 
 quiet_cmd_ld_ko_o = LD [M]  $@
@@ -34,10 +166,13 @@ quiet_cmd_ld_ko_o = LD [M]  $@
 	$(LD) -r $(KBUILD_LDFLAGS)					\
 		$(KBUILD_LDFLAGS_MODULE) $(LDFLAGS_MODULE)		\
 		$(addprefix -T , $(KBUILD_LDS_MODULE))			\
-		-o $@ $(filter %.o, $^);				\
+                 $(LDFLAGS_$(modname)) -o $@.tmp            		\
+		-o $@.tmp $(patsubst $(ctf-dir)/%,,$(filter %.o, $^)) && \
+        $(OBJCOPY) $(module-ctf-flags) $@.tmp $@ && rm -f $@.tmp ;	\
 	$(if $(ARCH_POSTLINK), $(MAKE) -f $(ARCH_POSTLINK) $@, true)
 
-$(modules): %.ko: %.o %.mod.o $(KBUILD_LDS_MODULE) FORCE
+$(modules): %.ko: %.o %.mod.o $(KBUILD_LDS_MODULE) $(module-ctfs-modular-prereq) FORCE
+	$(call cmd_touch_ctf)
 	+$(call if_changed,ld_ko_o)
 
 targets += $(modules) $(modules:.ko=.mod.o)
diff --git a/scripts/dwarf2ctf/.gitignore b/scripts/dwarf2ctf/.gitignore
new file mode 100644
index 000000000000..e37b47cf3028
--- /dev/null
+++ b/scripts/dwarf2ctf/.gitignore
@@ -0,0 +1 @@
+dwarf2ctf
diff --git a/scripts/dwarf2ctf/Makefile b/scripts/dwarf2ctf/Makefile
new file mode 100644
index 000000000000..d908050a271f
--- /dev/null
+++ b/scripts/dwarf2ctf/Makefile
@@ -0,0 +1,11 @@
+ifdef CONFIG_CTF
+hostprogs-y	:= dwarf2ctf
+always		:= $(hostprogs-y)
+
+dwarf2ctf-objs  := dwarf2ctf.o eu_simple.o
+
+HOSTCFLAGS_eu_simple.o := -I$(srctree)/scripts
+HOSTCFLAGS_dwarf2ctf.o := $(shell pkg-config --cflags glib-2.0) -I$(srctree)/scripts
+
+HOSTLDLIBS_dwarf2ctf := -ldtrace-ctf -lelf -ldw $(shell pkg-config --libs glib-2.0) -lz
+endif
diff --git a/scripts/dwarf2ctf/dwarf2ctf.c b/scripts/dwarf2ctf/dwarf2ctf.c
new file mode 100644
index 000000000000..cd523c67014e
--- /dev/null
+++ b/scripts/dwarf2ctf/dwarf2ctf.c
@@ -0,0 +1,4961 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * dwarf2ctf.c: Read in DWARF[23] debugging information from some set of ELF
+ * files, and generate CTF in correspondingly-named files, or in a single
+ * representation meant for mmapping.
+ *
+ * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#define _GNU_SOURCE 1
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <endian.h>
+#include <unistd.h>
+
+#include <libelf.h>
+#include <dwarf.h>
+#include <elfutils/libdwfl.h>
+#include <elfutils/libdw.h>
+#include <elfutils/version.h>
+#include <sys/ctf_api.h>
+#include <glib.h>
+
+#include <eu_simple.h>
+
+#ifndef PATH_MAX
+#define PATH_MAX 1024
+#endif
+
+#define __unused__ __attribute__((__unused__))
+
+/*
+ * If non-NULL, tracing is on.
+ */
+static const char *trace;
+
+/*
+ * Trace something.
+ */
+#ifdef DEBUG
+#define dw_ctf_trace(format, ...) do {				\
+	if (trace)						\
+		fprintf(stderr, (format), ## __VA_ARGS__);	\
+} while (0)
+#else
+#define dw_ctf_trace(format, ...)
+#endif
+
+/*
+ * Run dwarf2ctf over a single object file or set thereof.
+ *
+ * output_dir is the directory into which the CTF goes, if 'standalone', or the
+ * CTF archive file name otherwise.
+ */
+static void run(char *output, int standalone);
+
+/*
+ * Whether we are deduplicating.  We do not deduplicate if run over external
+ * modules.
+ */
+static int deduplicating;
+
+/*
+ * A fully descriptive CTF type ID: both file and type ID in one place.
+ */
+struct ctf_full_id {
+	ctf_file_t *ctf_file;
+	ctf_id_t ctf_id;
+#ifdef DEBUG
+	char module_name[PATH_MAX];
+	char file_name[PATH_MAX];
+#endif
+};
+
+/*
+ * A hash mapping 'atoms' (almost entirely type IDs) to nothing.
+ */
+static GHashTable *atoms;
+
+/*
+ * A mapping from the type ID of a DIE (see type_id()) to ctf_full_id_t's
+ * describing the type with that ID.  The type ID is an atom.
+ *
+ * This is used to look up types regardless of which CTF file they may reside
+ * in.  Not the same as a DWARF4 type signature because we must encode scope
+ * information which DWARF4 can encode in its DIE refs.
+ *
+ * (TODO: store a hash of the ID rather than the ID itself, to save memory.
+ * Makes debugging slightly harder though.)
+ */
+static GHashTable *id_to_type;
+
+/*
+ * A mapping from the type ID of a DIE (an atom) to the name of the module (and
+ * thus CTF table) incorporating that type.  (Modules in this context, and
+ * throughout dwarf2ctf, are DTrace modules: a name without suffix or path.)
+ *
+ * This is used to merge types identical across modules (e.g. those in global
+ * header files).
+ */
+static GHashTable *id_to_module;
+
+/*
+ * Module-specific state.  The module named 'vmlinux' is that corresponding to
+ * the types in always-built-in translation units; the module named 'shared_ctf'
+ * (not appearing in this mapping) is that corresponding to types shared between
+ * more than one module (even between two currently-built-in modules: we do not
+ * distinguish at this level between built-in modules and non-built-in modules.)
+ */
+static GHashTable *per_module;
+
+/*
+ * The data structure that per_module maps module names to.
+ */
+struct per_module {
+	/*
+	 * The CTF file containing the types in this module.
+	 */
+	ctf_file_t *ctf_file;
+
+	/*
+	 * A hash from a "CTF-form" structure name (in the form 's/u NAME') to
+	 * a struct ctf_memb_count (see below).
+	 */
+	GHashTable *member_counts;
+};
+
+/*
+ * A count associating a type ID relating to a structure or union with a count
+ * of members in that structure.
+ */
+struct ctf_memb_count {
+	ctf_id_t ctf_id;
+	size_t count;
+};
+
+/*
+ * A mapping from the absolute pathname of a TU to a hashtable mapping
+ * DIE offsets of child DIEs to DIE offsets of parents.  Populated on first
+ * iteration.  Contains only those DIEs that we know are necessary for other
+ * functions' use of this structure, to keep memory usage down.
+ */
+static GHashTable *fn_to_die_to_parent;
+
+/*
+ * Get a ctf_file out of the per_module hash for a given module.
+ */
+static ctf_file_t *lookup_ctf_file(const char *module_name);
+
+/*
+ * The names of the object files to run over.  Except in -e mode, this comes
+ * straight from the module filelist passed in.
+ */
+static char **object_names;
+static size_t object_names_cnt;
+
+/*
+ * Populate the object_names list from the module filelist.
+ */
+static void init_object_names(const char *object_names_file);
+
+/*
+ * Populate and object_to_module from the objects.builtin and modules.builtin
+ * file.
+ */
+static void init_builtin(const char *builtin_objects_file,
+			 const char *builtin_module_file);
+
+/*
+ * The member blacklist bans fields with specific names in specifically named
+ * structures, declared in specific source files, from being emitted.  The
+ * mapping is from absolute source file name:structure.member to NULL (this is
+ * safe because type names cannot contain a colon, and structure names cannot
+ * contain a period).
+ */
+static GHashTable *member_blacklist;
+
+/*
+ * Populate the member blacklist from the member_blacklist file.
+ */
+static void init_member_blacklist(const char *member_blacklist_file,
+				  const char *srcdir);
+
+/*
+ * Return 1 if a given DWARF DIE, which must be a DW_TAG_member, appears in the
+ * member blacklist.
+ */
+static int member_blacklisted(Dwarf_Die *die, Dwarf_Die *parent_die);
+
+/*
+ * The variable blacklist, like the others, is an automatically-maintained
+ * blacklist giving variables in specific modules which should not be emitted.
+ * (These are variables whose names are ambiguous within a module, and may
+ * appear multiple times in /proc/kallmodsyms, identical but for address and
+ * thus indistinguishable.)
+ *
+ * The mapping is from module`variable to NULL (safe because variable names
+ * cannot begin with a backtick, and even if they could DTrace's notation could
+ * not reference such variables).
+ */
+static GHashTable *variable_blacklist;
+
+/*
+ * A mapping from object file name to the name of the module that translation
+ * unit is part of.
+ *
+ * Actual, real, on-disk .ko modules do not appear here, because the translation
+ * is trivial for them.
+ */
+static GHashTable *object_to_module;
+
+/*
+ * Initialize a CTF type table, and possibly fill it with those special types
+ * that appear in CTF but not in DWARF (such as 'void').  (This filling happens
+ * only for the type table named "shared_ctf", unless deduplication is turned
+ * off.)
+ *
+ * If this is a local type table, and deduplication is active, make the global
+ * type table its parent.
+ */
+static void init_ctf_table(const char *module_name);
+
+/*
+ * A few useful singleton CTF type IDs in the global type table: a void pointer
+ * and a function pointer.  Constructed by init_ctf_table().
+ */
+static ctf_id_t ctf_void_type;
+static ctf_id_t ctf_funcptr_type;
+
+/*
+ * Initialize the child->parent DIE mapping for a single file.
+ */
+static void init_parent_die(const char *file_name, Dwfl *dwfl);
+
+/*
+ * Initialize one layer of a child->parent mapping.
+ */
+static int init_parent_die_internal(const char *file_name,
+				    GHashTable *offs, Dwarf_Die *parent,
+				    int depth, int found_subprogram);
+
+/*
+ * Override the presence and value of FORM_u/sdata attributes on DWARF DIEs,
+ * either adding to it, or replacing it.
+ *
+ * (Used so that a caller of construct_ctf_id() that wants a type to be created
+ * can override aspects of that type.)
+ *
+ * The 'chain', if set, causes the various private_*() functions that handle
+ * overrides to look back along the chain to find a suitable attribute.  The
+ * chain must be set on the last element in the array.  The search for
+ * attributes terminates at the first match.
+ *
+ * Note: this is not a particularly generic implementation: a better approach
+ * would be to keep walking the chain on DIE_OVERRIDE_ADD, and keep adding until
+ * we are done: but we have only one user of ADD, and it implements the addition
+ * itself because it is adding to a value from a different DIE: so this added
+ * generality is not needed yet.
+ */
+struct die_override {
+	int tag;
+	int attribute;
+	enum { DIE_OVERRIDE_REPLACE, DIE_OVERRIDE_ADD } op;
+	Dwarf_Sword value;
+	struct die_override *chain;
+};
+
+/*
+ * Compute the type ID of a DWARF DIE (with possibly-overridden attributes) and
+ * return it in a new dynamically-allocated string.
+ *
+ * Optionally, call a callback with the computed ID once we know it (this is a
+ * recursive process, so the callback can be called multiple times as the ID
+ * is built up).
+ *
+ * An ID of NULL indicates that this DIE has no ID and need not be considered.
+ */
+static char *type_id(Dwarf_Die *die, struct die_override *overrides,
+		     void (*fun)(Dwarf_Die *die,
+				 const char *id,
+				 struct die_override *overrides,
+				 void *data),
+		     void *data) __attribute__((__warn_unused_result__));
+
+/*
+ * Internal: allows flags to be passed to affect one (and only one) type ID
+ * recursion, without affecting other type_id()s launched from the 'fun'.
+ */
+static char *type_id_internal(Dwarf_Die *die,
+			      struct die_override *overrides,
+			      void (*fun)(Dwarf_Die *die,
+					  const char *id,
+					  struct die_override *overrides,
+					  void *data),
+			      void *data,
+			      int flags);
+
+/*
+ * Internal: generate the type ID for a type DIE.
+ *
+ * If there are no overrides, look for a bit_size and bit_offset and pass them
+ * down as well.
+ */
+static char *type_id_type_die(Dwarf_Die *die,
+			      Dwarf_Die *type_die,
+			      struct die_override *overrides,
+			      void (*fun)(Dwarf_Die *die,
+					  const char *id,
+					  struct die_override *overrides,
+					  void *data),
+			      void *data);
+
+/*
+ * Convert 'long unsigned int' to 'sizetype'.  Internal use within type_id().
+ */
+#define TI_COLLAPSE_SIZETYPE 0x1
+
+/*
+ * Process a file, calling the dwarf_process function for every type found
+ * therein (even types in functions).  Optionally call tu_init() at the start of
+ * each translation unit, and tu_done() at the end.
+ */
+static void process_file(const char *file_name,
+			 void (*dwarf_process)(const char *module_name,
+					       const char *file_name,
+					       Dwarf_Die *die,
+					       Dwarf_Die *parent_die,
+					       void *data),
+			 void (*tu_init)(const char *module_name,
+					 const char *file_name,
+					 Dwarf_Die *tu_die,
+					 void *data),
+			 void (*tu_done)(const char *module_name,
+					 const char *file_name,
+					 Dwarf_Die *tu_die,
+					 void *data),
+			 void *data);
+
+/*
+ * process_file() helper, walking over the top level and picking up types
+ * therein.
+ */
+static void process_tu_func(const char *module_name,
+			    const char *file_name,
+			    Dwarf *dwarf,
+			    Dwarf_Die *parent_die,
+			    Dwarf_Die *die,
+			    void (*dwarf_process)(const char *module_name,
+						  const char *file_name,
+						  Dwarf_Die *die,
+						  Dwarf_Die *parent_die,
+						  void *data),
+			    void *data);
+
+/*
+ * Records the type ID of interesting types, the files they are contained in,
+ * and their DWARF offset, so they can be found rapidly.
+ *
+ * Used to avoid rescanning files that can contain no duplicates.
+ */
+struct dedup_id_file {
+	char *file_name;
+	char *id;
+	Dwarf_Off dieoff;
+};
+
+/*
+ * The structure used as the data argument for dedup() and
+ * dedup_alias_fixup().
+ *
+ * structs_seen tracks the IDs of structures marked as duplicates within a given
+ * translation unit, in order that recursion terminates if two such structures
+ * have pointers to each other.
+ *
+ * vars_seen tracks variables seen in this module, mapping from unadorned name
+ * to a non-NULL pointer (for static, non-'external') or NULL (for non-static or
+ * 'extern').  If a static variable coexists with any other variable with the
+ * same name, static or not, the variable is blacklisted.  (Non-static
+ * coexistence is fine, because they are just different references to the same
+ * variable).  Note that management of this variable is a little annoying
+ * because it varies by module, not by TU, so we can't use tu_init/tu_done to
+ * manage its lifetime.
+ *
+ * named_structs tracks type IDs and contained modules for every type that may
+ * contain undetected duplicates and thus may require rescanning.
+ *
+ * dwfl and dwfl_file_name identify the opened DWARF file (if any) during the
+ * second duplicates detection pass.
+ *
+ * repeat_detection is set by each phase if it considers that another round of
+ * alias fixup detection is needed.
+ */
+struct dedup_state {
+	const char *file_name;
+	const char *module_name;
+	GHashTable *structs_seen;
+	GList *named_structs;
+	GHashTable *vars_seen;
+	char *dwfl_file_name;
+	Dwarf *dwarf;
+	Dwfl *dwfl;
+	int repeat_detection;
+};
+
+/*
+ * Scan and identify duplicates across the entire set of object files.
+ */
+static void scan_dups(void);
+
+/*
+ * Recursively detect duplicate types and types referenced by them, and
+ * determine which CTF file they should be located in, and request a
+ * dedup_alias_fixup() pass if any structures are shared.
+ * Determine the mapping from translation unit name to module name.
+ */
+static void dedup(const char *module_name, const char *file_name,
+		  Dwarf_Die *die, Dwarf_Die *parent_die, void *data);
+
+/*
+ * Do the underlying marking of a DIE as shared, iff need be.  (No variable
+ * blacklisting, non-opaque structure checks, or anything else needed only by
+ * top-level DIEs.)
+ *
+ * This function may be called multiple times for overridden DIEs that are
+ * dependent types of bitfields.
+ */
+static void dedup_mark_inner_die(const char *module_name, Dwarf_Die *die,
+				 const char *id,
+				 struct die_override *overrides,
+				 void *data);
+
+/*
+ * Note in the dedup_id_file list that we will rescan a DIE in a later duplicate
+ * detection pass.
+ *
+ * A type_id() callback.
+ */
+static void dedup_will_rescan(Dwarf_Die *die, const char *id,
+			      struct die_override *overrides, void *data);
+
+/*
+ * Note the variable referenced by this DIE in vars_seen: blacklist it if an
+ * entry for this variable already exists in vars_seen and this instance is
+ * static, or if a static entry already exists in vars_seen, whether this
+ * instance is static or not.
+ */
+static void dedup_blacklist_var_dups(Dwarf_Die *die,
+				     struct dedup_state *state);
+
+/*
+ * Detect duplicates and mark seen types for a given type, via a type_id()
+ * callback: used to detect dependent types (particularly those at child-DIE
+ * level) as duplicates.
+ */
+static void dedup_typeid(Dwarf_Die *die, const char *id,
+			 struct die_override *overrides, void *data);
+
+/*
+ * Mark any aggregates contained within a particular type DIE as seen.  This is
+ * needed since even nameless aggregates contained within other aggregates can
+ * be used as the type of members of the outer aggregate (though they cannot
+ * possibly be found in a module different from that of their containing
+ * aggregate, any more than a structure member can).
+ */
+static void mark_seen_contained(Dwarf_Die *die, const char *module_name,
+				struct die_override *overrides, void *data);
+
+/*
+ * Determine if some type (whose ultimate base type is an non-opaque structure,
+ * alias, or enum) has an opaque equivalent which is shared, and mark it and
+ * all its bases as shared too if so.
+ *
+ * A list_filter() filter function.
+ */
+static int dedup_alias_fixup(void *id_file_data, void *data);
+
+/*
+ * Mark a basic type shared by name and intern it in all relevant hashes.  (Used
+ * for marking basic types we don't have a DIE for.)
+ */
+static void mark_shared_by_name(ctf_file_t *ctf, ctf_id_t ctf_id,
+				const char *name);
+
+/*
+ * Determine if a type is a named struct, union, or enum.
+ *
+ * A type_id() callback.
+ */
+static void is_named_struct_union_enum(Dwarf_Die *die, const char *unused,
+				       struct die_override *overrides,
+				       void *data);
+
+/*
+ * Set up state for dedup().  A tu_init() callback.
+ */
+static void dedup_tu_init(const char *module_name, const char *file_name,
+			  Dwarf_Die *tu_die, void *data);
+
+/*
+ * Free state for dedup().  A tu_done() callback.
+ */
+static void dedup_tu_done(const char *module_name, const char *file_name,
+			  Dwarf_Die *tu_die, void *data);
+
+/*
+ * Free DWARF state for dedup().
+ */
+static void dedup_dwarf_free(struct dedup_state *state);
+
+/*
+ * Determine if a type is duplicated and needs sharing.
+ */
+enum needs_sharing { NS_NOT_SHARED, NS_NO_MARKING, NS_NEEDS_SHARING };
+static enum needs_sharing type_needs_sharing(const char *module_name,
+					     const char *id);
+
+/*
+ * Mark a type (optionally, with an already-known ID) as duplicated and located
+ * in the shared CTF table.
+ *
+ * A type_id() callback (though also called directly).
+ */
+static void mark_shared(Dwarf_Die *die, const char *id,
+			struct die_override *overrides, void *data);
+
+/*
+ * Construct CTF out of each type.
+ */
+static void construct_ctf(const char *module_name, const char *file_name,
+			  Dwarf_Die *die,
+			  Dwarf_Die *parent_die,
+			  void *unused __unused__);
+
+/*
+ * Write out the CTF files from the per_module->ctf_file into files in the
+ * output directory (if standalone), or into the output file (otherwise).
+ */
+static void write_types(char *output, int standalone);
+
+/*
+ * Construct CTF out of each type and return that type's ID and file.
+ */
+static struct ctf_full_id *construct_ctf_id(const char *module_name,
+					    const char *file_name,
+					    Dwarf_Die *die,
+					    Dwarf_Die *parent_die,
+					    struct die_override *overrides);
+
+/*
+ * Things to do after a CTF recursion step.
+ */
+enum skip_type { SKIP_CONTINUE = 0, SKIP_SKIP, SKIP_ABORT };
+
+/*
+ * Recursive over a given DWARF DIE and its children andconstruct CTF out of it.
+ *
+ * Most parameters are shared with the ctf_assembly_fun: see the comment below.
+ */
+static ctf_id_t die_to_ctf(const char *module_name, const char *file_name,
+			   Dwarf_Die *die, Dwarf_Die *parent_die,
+			   ctf_file_t *ctf, ctf_id_t parent_ctf_id,
+			   struct die_override *overrides, int top_level_type,
+			   int backwards, enum skip_type *skip, int *replace,
+			   const char *id);
+
+/*
+ * Return the next DIE, if that DIE needs to be emitted before this one.
+ */
+static Dwarf_Die *die_emit_next_backwards(Dwarf_Die *next, Dwarf_Die *die,
+					  struct die_override *overrides);
+
+/*
+ * Look up a type through its reference: return its ctf_id_t, or
+ * recursively construct it if need be.
+ *
+ * Must be called on a DIE with a type attribute.
+ */
+static ctf_id_t lookup_ctf_type(const char *module_name, const char *file_name,
+				Dwarf_Die *die, ctf_file_t *ctf,
+				struct die_override *overrides,
+				const char *locerrstr);
+
+/*
+ * Assemble a given DIE and its children into CTF in some fashion, returning the
+ * ID of the top-level piece of generated CTF (only relevant for aggregates).
+ *
+ * The parent_ctf_id is the ID of the CTF entity that was or is being generated
+ * from the enclosing DWARF DIE, or 0 if population succeeded but did not yield
+ * a type ID (e.g. for variable assembly), or -1 on error.  The parent_die is
+ * the parent of the current DWARF DIE, and is always populated (even if just
+ * with the CU's DIE).  The parent_ctf_id is always in the same CTF file as the
+ * ctf_id, just as the parent DWARF DIE is always in the same DWARF CU: this is
+ * lexical scope, not dynamic, so referenced types themselves located at the top
+ * level have the CU as their parent.
+ *
+ * Returning an error value (see below) indicates that no CTF was generated from
+ * this DWARF DIE.
+ *
+ * Setting skip to SKIP_ABORT indicates that the translation of this entity
+ * failed, and the entire top-level type of which it is a part should be
+ * skipped.  Setting it to SKIP_SKIP indicates that this entity does not need to
+ * be translated (perhaps because it already exists), so recursion into
+ * sub-entities can be skipped, but translation of the containing type should
+ * continue.  Setting it to SKIP_CONTINUE indicates no error.
+ *
+ * Setting 'replace' to 1 in a child DIE indicates that this type should
+ * entirely *replace* its parent's type (generally because it has wrapped it up
+ * in something).  This replacemenu takes immediate effect for later children of
+ * the same DIE.
+ *
+ * die_to_ctf() calls these functions repeatedly for every child of the
+ * requested DIE: the CTF ID eventually returned is whatever ID is returned by
+ * the last such function, and parent_ctf_id is repeatedly replaced with the ID
+ * returned by the last assembly function.  Thus, assembly functions that
+ * augment an already-present ctf_id should return parent_ctf_id: assembly
+ * functions that wrap it in a new ctf_id referring to the parent_ctf_id should
+ * return the new ID.  (Assembly functions should never entirely disregard the
+ * parent_ctf_id.)
+ */
+typedef ctf_id_t (*ctf_assembly_fun)(const char *module_name,
+				     const char *file_name,
+				     Dwarf_Die *die,
+				     Dwarf_Die *parent_die,
+				     ctf_file_t *ctf,
+				     ctf_id_t parent_ctf_id,
+				     const char *locerrstr,
+				     struct die_override *overrides,
+				     int top_level_type,
+				     enum skip_type *skip,
+				     int *replace);
+
+#define ASSEMBLY_FUN(name)							\
+	static ctf_id_t assemble_ctf_##name(const char *module_name,		\
+					    const char *file_name,		\
+					    Dwarf_Die *die,			\
+					    Dwarf_Die *parent_die,		\
+					    ctf_file_t *ctf,			\
+					    ctf_id_t parent_ctf_id,		\
+					    const char *locerrstr,		\
+					    struct die_override *overrides,	\
+					    int top_level_type,			\
+					    enum skip_type *skip,		\
+					    int *replace)
+
+/*
+ * Defined assembly functions.
+ */
+ASSEMBLY_FUN(base);
+ASSEMBLY_FUN(array);
+ASSEMBLY_FUN(array_dimension);
+ASSEMBLY_FUN(cvr_qual);
+ASSEMBLY_FUN(enumeration);
+ASSEMBLY_FUN(enumerator);
+ASSEMBLY_FUN(pointer);
+ASSEMBLY_FUN(struct_union);
+ASSEMBLY_FUN(su_member);
+ASSEMBLY_FUN(typedef);
+ASSEMBLY_FUN(variable);
+
+/*
+ * An assembly filter is an optional function called with the DIE and parent DIE
+ * of a top-level type alone, before calling down into the process_file()
+ * processing function: it can be used to rapidly determine that this DIE is not
+ * worth processing.  (It should return 0 in this case, and nonzero otherwise.)
+ */
+typedef int (*ctf_assembly_filter_fun)(const char *file_name,
+				       Dwarf *dwarf,
+				       Dwarf_Die *die,
+				       Dwarf_Die *parent_die);
+
+/*
+ * A CTF assembly filter function which excludes all types not at the global
+ * scope (i.e. whose immediate parent is not a CU DIE) and which does not have a
+ * structure or union as its ultimate dependent type.  (All structures and
+ * unions and everything dependent on them must be recorded, even inside
+ * functions, because GCC may emit references to the opaque variants of those
+ * types from file scope.)
+ */
+static int filter_ctf_file_scope(const char *file_name,
+				 Dwarf *dwarf,
+				 Dwarf_Die *die,
+				 Dwarf_Die *parent_die);
+
+/*
+ * A CTF assembly filter function which excludes all names not at the global
+ * scope, all static symbols, and all names whose names are unlikely to be
+ * interesting.  (DTrace userspace contains a similar list, but the two lists
+ * need not be in sync.)
+ */
+static int filter_ctf_uninteresting(const char *file_name,
+				    Dwarf *dwarf,
+				    Dwarf_Die *die,
+				    Dwarf_Die *parent_die);
+
+/*
+ * Error return values from CTF assembly functions.  These differ only in that
+ * die_to_ctf() reports the ctf_errmsg() if CTF_NO_ERROR_REPORTED is returned,
+ * but says nothing in the CTF_ERROR_REPORTED case.
+ */
+#define CTF_NO_ERROR_REPORTED CTF_ERR
+#define CTF_ERROR_REPORTED (-2L)
+
+/*
+ * The total number of type errors encountered.
+ */
+static long num_errors;
+
+/*
+ * A mapping from DW_TAG_* to functions which assemble this DW_TAG_* and
+ * possibly its children into the passed CTF.  This table is not used
+ * directly, but rather assembled into a lookup table.
+ */
+static struct assembly_tab_t
+{
+	int tag;
+	ctf_assembly_filter_fun filter;
+	ctf_assembly_fun fun;
+} assembly_tab_init[] =
+{{ DW_TAG_base_type, filter_ctf_file_scope, assemble_ctf_base },
+ { DW_TAG_array_type, filter_ctf_file_scope, assemble_ctf_array },
+ { DW_TAG_subrange_type, NULL, assemble_ctf_array_dimension },
+ { DW_TAG_const_type, filter_ctf_file_scope, assemble_ctf_cvr_qual },
+ { DW_TAG_restrict_type, filter_ctf_file_scope, assemble_ctf_cvr_qual },
+ { DW_TAG_enumeration_type, NULL, assemble_ctf_enumeration },
+ { DW_TAG_enumerator, NULL, assemble_ctf_enumerator },
+ { DW_TAG_pointer_type, filter_ctf_file_scope, assemble_ctf_pointer },
+ { DW_TAG_structure_type, NULL, assemble_ctf_struct_union },
+ { DW_TAG_union_type, NULL, assemble_ctf_struct_union },
+ { DW_TAG_member, NULL, assemble_ctf_su_member },
+ { DW_TAG_typedef, NULL, assemble_ctf_typedef },
+ { DW_TAG_variable, filter_ctf_uninteresting, assemble_ctf_variable },
+ { DW_TAG_volatile_type, filter_ctf_file_scope, assemble_ctf_cvr_qual },
+ { 0, NULL }};
+
+/*
+ * The CTF assembly and filter lookup tables, in constructed form.
+ */
+static ctf_assembly_fun *assembly_tab;
+static ctf_assembly_filter_fun *assembly_filter_tab;
+static size_t assembly_len;
+
+/*
+ * Populate the assembly_tab and assembly_filter_tab from the assembly_tab_init.
+ */
+static void init_assembly_tab(void);
+
+/*
+ * A mapping from sizeof() to CTF type encoding.
+ */
+struct type_encoding_tab {
+	size_t size;
+	int ctf_encoding;
+};
+
+/*
+ * Given a type encoding table, and a size, return the CTF encoding for that
+ * type, or 0 if none.
+ */
+static int find_ctf_encoding(struct type_encoding_tab *type_tab, size_t size);
+
+/*
+ * Count the number of members of a DWARF aggregate.
+ */
+static long count_dwarf_members(Dwarf_Die *die);
+
+/*
+ * Given a DIE that may contain a type attribute, look up the target of that
+ * attribute and return it, or NULL if none.
+ */
+static Dwarf_Die *private_dwarf_type(Dwarf_Die *die, Dwarf_Die *target_die);
+
+/*
+ * Check for existence of an attribute in a DIE, chasing through
+ * DW_AT_specification if need be.
+ */
+static inline int private_dwarf_hasattr(Dwarf_Die *die,
+					unsigned int search_name);
+
+/*
+ * Return a DIE attribute, chasing through DW_AT_specification if need be.
+ */
+static inline Dwarf_Attribute *private_dwarf_attr(Dwarf_Die *die,
+						  unsigned int search_name,
+						  Dwarf_Attribute *result);
+
+/*
+ * Given a DIE that contains a udata attribute, look up that attribute and
+ * return its value (optionally overridden or modified by the die_overrides).
+ */
+static inline Dwarf_Word private_dwarf_udata(Dwarf_Die *die, int attribute,
+					     struct die_override *overrides);
+
+/*
+ * Given a DIE, return its byte size, if known and interpretable, or -1
+ * otherwise.
+ */
+static inline long long private_dwarf_size(Dwarf_Die *die);
+
+/*
+ * Find an override in an override list.
+ */
+static struct die_override *
+private_find_override(Dwarf_Die *die,
+		      int attribute,
+		      struct die_override *overrides);
+
+/*
+ * Determine the dimensions of an array subrange, or 0 if variable.
+ */
+static Dwarf_Word private_subrange_dimensions(Dwarf_Die *die);
+
+/*
+ * A string appender working on dynamic strings.
+ */
+static char *str_append(char *s, const char *append)
+	__attribute__((__warn_unused_result__));
+
+/*
+ * A vararg string appender.
+ */
+static char *str_appendn(char *s, ...)
+	__attribute__((__warn_unused_result__, sentinel));
+
+/*
+ * An error-checking strdup().
+ */
+static char *xstrdup(const char *s) __attribute__((__nonnull__,
+						   __warn_unused_result__,
+						   __malloc__));
+
+/*
+ * Filter a GList, calling a predicate on it and removing all elements for which
+ * the predicate returns true, calling the free_func on them if set.
+ */
+typedef int (*filter_pred_fun) (void *element, void *data);
+static GList *list_filter(GList *list, filter_pred_fun fun,
+			  GDestroyNotify free_func, void *data);
+
+/*
+ * Intern an atom in the atoms table and return it, or free it and return the
+ * existing atom if one is already interned.    (Despite the type signature, this
+ * return value is constant and should not be freed.)
+ */
+static void *intern(char *atom);
+
+/*
+ * Figure out the (pathless, suffixless) module name for a given module file (.o
+ * or .ko), and return it in a new dynamically allocated string.
+ *
+ * Takes the object_to_module mapping into account.
+ */
+static char *fn_to_module(const char *file_name);
+
+/*
+ * Determine, and cache, absolute filenames.
+ */
+static const char *abs_file_name(const char *file_name);
+
+/*
+ * Determine absolute filenames relative to some other directory: do not cache
+ * them.  It is the caller's responsibility to free them.
+ */
+static char *rel_abs_file_name(const char *file_name, const char *relative_to);
+
+/*
+ * Free a per_module's contents.
+ */
+static void private_per_module_free(void *per_module);
+
+/*
+ * Free a dedup_id_file's contents.
+ */
+static void free_dups_id_file(void *id_file);
+
+/*
+ * Free a fn_to_die_to_parent subhash.
+ */
+static void private_fn_die_parent_free(void *ptr);
+
+/*
+ * dwarf_dieoffset() with a return type better for printf().
+ */
+#define DIEOFFSET(die) (unsigned long) dwarf_dieoffset((die))
+
+/*
+ * A line-shortener with a kernel-familiar name for fprintfing to stderr.
+ */
+#define pr_err(fmt, ...) fprintf(stderr, fmt, ## __VA_ARGS__);
+
+/* Initialization.  */
+
+int main(int argc, char *argv[])
+{
+	char *output;
+
+	trace = getenv("DWARF2CTF_TRACE");
+
+	if ((argc != 4 && argc != 7) ||
+	    (argc == 4 && strcmp(argv[2], "-e") != 0)) {
+		pr_err("Syntax: dwarf2ctf output-file srcdir objects.builtin\n");
+		pr_err("                  modules.builtin member.blacklist filelist\n");
+		pr_err("    or dwarf2ctf output-dir -e filelist\n"
+		       "for external module use\n");
+		exit(1);
+	}
+
+	output = argv[1];
+
+	elf_version(EV_CURRENT);
+
+	if (elf_errno()) {
+		pr_err("Version synchronization fault: %s\n",
+		       elf_errmsg(elf_errno()));
+		exit(1);
+	}
+
+	init_assembly_tab();
+	object_to_module = g_hash_table_new_full(g_str_hash, g_str_equal,
+						 free, free);
+
+	/*
+	 * When not building an external module, we run over all the arguments
+	 * at once, deduplicating them.  In external-module mode, we act as if
+	 * independently invoked with every argument.
+	 */
+	if (strcmp(argv[2], "-e") != 0) {
+		const char *srcdir;
+		char *builtin_objects_file;
+		char *builtin_module_file;
+		char *member_blacklist_file;
+
+		srcdir = argv[2];
+		builtin_objects_file = argv[3];
+		builtin_module_file = argv[4];
+		member_blacklist_file = argv[5];
+		deduplicating = 1;
+
+		init_builtin(builtin_objects_file, builtin_module_file);
+		init_member_blacklist(member_blacklist_file, srcdir);
+		init_object_names(argv[6]);
+
+		run(output, 0);
+	} else {
+		char *single_object_name;
+		char **all_object_names;
+		size_t all_object_names_cnt;
+		size_t i;
+
+		deduplicating = 0;
+		init_object_names(argv[3]);
+
+		/*
+		 * Repeatedly populate object_names with one object name, and
+		 * call run() with that.
+		 */
+		all_object_names = object_names;
+		all_object_names_cnt = object_names_cnt;
+		object_names = &single_object_name;
+		object_names_cnt = 1;
+
+		for (i = 0; i < all_object_names_cnt; i++) {
+			single_object_name = all_object_names[i];
+
+			run(output, 1);
+		}
+	}
+
+	g_hash_table_destroy(object_to_module);
+
+	if (num_errors > 0)
+		pr_err("%li CTF construction errors.\n", num_errors);
+
+	return 0;
+}
+
+/*
+ * Run dwarf2ctf over a single object file or set thereof.
+ *
+ * output is the directory into which the CTF goes, if 'standalone', or the
+ * CTF archive file name otherwise.
+ */
+static void run(char *output, int standalone)
+{
+	size_t i;
+
+	/*
+	 * Create all the hashes, assemble the translation unit->module list for
+	 * builtin modules, and create the shared CTF file if deduplicating.
+	 */
+
+	atoms = g_hash_table_new_full(g_str_hash, g_str_equal, free, NULL);
+	id_to_type = g_hash_table_new_full(g_str_hash, g_str_equal,
+					   NULL, free);
+	id_to_module = g_hash_table_new_full(g_str_hash, g_str_equal,
+					     NULL, free);
+	per_module = g_hash_table_new_full(g_str_hash, g_str_equal, free,
+					   private_per_module_free);
+	variable_blacklist = g_hash_table_new_full(g_str_hash, g_str_equal,
+						   free, free);
+	fn_to_die_to_parent = g_hash_table_new_full(g_str_hash,
+						    g_str_equal, free,
+						    private_fn_die_parent_free);
+
+	dw_ctf_trace("Initializing...\n");
+
+	if (deduplicating)
+		init_ctf_table("shared_ctf");
+
+	scan_dups();
+
+	/*
+	 * Now construct CTF out of the types.
+	 */
+	dw_ctf_trace("CTF construction.\n");
+	for (i = 0; i < object_names_cnt; i++)
+		process_file(object_names[i], construct_ctf, NULL, NULL, NULL);
+
+	/*
+	 * Finally, emit the types into their .ctf files, and generate the
+	 * necessary linker scripts.
+	 */
+	dw_ctf_trace("Writeout.\n");
+	write_types(output, standalone);
+
+	g_hash_table_destroy(id_to_type);
+	g_hash_table_destroy(id_to_module);
+	g_hash_table_destroy(per_module);
+	g_hash_table_destroy(variable_blacklist);
+	g_hash_table_destroy(fn_to_die_to_parent);
+	g_hash_table_destroy(atoms);
+}
+
+/*
+ * Populate the object_names list from the module filelist.
+ */
+static void init_object_names(const char *object_names_file)
+{
+	FILE *f;
+	char *line = NULL;
+	size_t line_size = 0;
+
+	f = fopen(object_names_file, "r");
+	if (f == NULL) {
+		pr_err("Cannot open object names file %s: %s\n",
+			object_names_file, strerror(errno));
+		exit(1);
+	}
+
+	/*
+	 * This needs no massaging other than linefeed removal, just reading and
+	 * stashing.
+	 */
+
+	while (getline(&line, &line_size, f) >= 0) {
+		size_t len = strlen(line);
+
+		if (len == 0)
+			continue;
+
+		if (line[len-1] == '\n')
+			line[len-1] = '\0';
+
+		object_names = realloc(object_names,
+				       ++object_names_cnt *
+				       sizeof(char *));
+
+		if (object_names == NULL) {
+			pr_err("Out of memory reading %s\n", object_names_file);
+			exit(1);
+		}
+
+		object_names[object_names_cnt-1] = xstrdup(line);
+	}
+	free(line);
+
+	if (ferror(f)) {
+		pr_err("Error reading from %s: %s\n", object_names_file,
+		       strerror(errno));
+		exit(1);
+	}
+
+	fclose(f);
+}
+
+/*
+ * Populate object_to_module from the objects.builtin and modules.builtin file.
+ */
+static void init_builtin(const char *builtin_objects_file,
+			 const char *builtin_module_file)
+{
+	FILE *f;
+	struct modules_thick_iter *i;
+	char *line = NULL;
+	size_t line_size = 0;
+	char *module_name = NULL;
+	char **paths;
+
+	/*
+	 * Iterate over all modules in modules_thick.builtin and add each to
+	 * object_to_module.
+	 */
+	i = modules_thick_iter_new(builtin_module_file);
+	if (i == NULL) {
+		pr_err("Cannot iterate over builtin module file.\n");
+		exit(1);
+	}
+
+	while ((paths = modules_thick_iter_next(i, &module_name)) != NULL) {
+		size_t j;
+
+		for (j = 0; paths[j] != NULL; j++) {
+			dw_ctf_trace("noting built-in module mapping %s -> %s\n",
+				     module_name, paths[j]);
+			g_hash_table_replace(object_to_module,
+					     strdup(paths[j]),
+					     xstrdup(module_name));
+		}
+		free(paths);
+	}
+	free(module_name);
+	modules_thick_iter_free(i);
+
+	f = fopen(builtin_objects_file, "r");
+	if (f == NULL) {
+		pr_err("Cannot open builtin objects file %s: %s\n",
+		       builtin_objects_file, strerror(errno));
+		exit(1);
+	}
+
+	/*
+	 * Those entries in builtin.objects that are not already known are
+	 * unconditionally-built-in object files.
+	 */
+	while (getline(&line, &line_size, f) >= 0) {
+		size_t len = strlen(line);
+
+		if (len == 0)
+			continue;
+
+		if (line[len-1] == '\n')
+			line[len-1] = '\0';
+
+		if (!g_hash_table_lookup(object_to_module, line))
+			g_hash_table_replace(object_to_module, xstrdup(line),
+					     xstrdup("vmlinux"));
+	}
+
+	if (ferror(f)) {
+		pr_err("Error reading from %s: %s\n", builtin_objects_file,
+		       strerror(errno));
+		exit(1);
+	}
+
+	free(line);
+	fclose(f);
+}
+
+/*
+ * Translate the assembly lookup table into the assembly_tab and
+ * assembly_filter_tab arrays.
+ */
+static void init_assembly_tab(void)
+{
+	struct assembly_tab_t *walk;
+
+	for (walk = assembly_tab_init; walk->fun != NULL; walk++) {
+		if (assembly_len < walk->tag)
+			assembly_len = walk->tag;
+	}
+
+	assembly_tab = calloc(sizeof(ctf_assembly_fun *), assembly_len + 1);
+	assembly_filter_tab = calloc(sizeof(ctf_assembly_filter_fun *),
+				     assembly_len + 1);
+	if ((assembly_tab == NULL) || (assembly_filter_tab == NULL)) {
+		pr_err("Out of memory allocating assembly table\n");
+		exit(1);
+	}
+
+	for (walk = assembly_tab_init; walk->fun != NULL; walk++) {
+		assembly_tab[walk->tag] = walk->fun;
+		assembly_filter_tab[walk->tag] = walk->filter;
+	}
+}
+
+/*
+ * Populate the member blacklist from the member_blacklist file.
+ */
+static void init_member_blacklist(const char *member_blacklist_file,
+				  const char *srcdir)
+{
+	FILE *f;
+	char *line = NULL;
+	size_t line_num = 0;
+	size_t line_size = 0;
+
+	/*
+	 * Not having a member blacklist is not an error.
+	 */
+	f = fopen(member_blacklist_file, "r");
+	if (f == NULL)
+		return;
+
+	member_blacklist = g_hash_table_new(g_str_hash, g_str_equal);
+
+	while (getline(&line, &line_size, f) >= 0) {
+		size_t len = strlen(line);
+		char *last_colon;
+		const char *last_dot;
+		char *absolutized;
+
+		line_num++;
+
+		if (len == 0)
+			continue;
+
+		if (line[len-1] == '\n')
+			line[len-1] = '\0';
+
+		last_colon = strrchr(line, ':');
+		last_dot = strrchr(last_colon + 1, '.');
+		if (!last_colon || !last_dot) {
+			pr_err("Syntax error on line %li of %s.\n"
+			       "Syntax: filename:structure.member.\n",
+			       line_num, member_blacklist_file);
+			continue;
+		}
+
+		*last_colon = '\0';
+		last_colon++;
+		absolutized = rel_abs_file_name(line, srcdir);
+		absolutized = str_appendn(absolutized, ":", last_colon, NULL);
+
+		g_hash_table_insert(member_blacklist, absolutized, NULL);
+	}
+	free(line);
+
+	if (ferror(f)) {
+		pr_err("Error reading from %s: %s\n", member_blacklist_file,
+		       strerror(errno));
+		exit(1);
+	}
+
+	fclose(f);
+}
+
+/*
+ * Return 1 if a given DWARF DIE, which must be a DW_TAG_member, appears in the
+ * member blacklist.
+ */
+static int member_blacklisted(Dwarf_Die *die, Dwarf_Die *parent_die)
+{
+	const char *fname = dwarf_decl_file(die);
+	char *id;
+	int blacklisted = 0;
+
+	/*
+	 * If there is no member blacklist, do nothing.
+	 */
+	if (!member_blacklist)
+		return 0;
+
+	/*
+	 * Unnamed structure and union members cannot be blacklisted, for now.
+	 */
+	if ((dwarf_diename(parent_die) == NULL) ||
+	    (dwarf_diename(die) == NULL))
+		return 0;
+
+	/*
+	 * The compiler can define its own structures, which appear in no
+	 * decl_file.
+	 *
+	 * We can't blacklist them with this mechanism, so skip them.
+	 */
+	if (__builtin_expect(fname == NULL, 0))
+		return 0;
+
+	fname = abs_file_name(fname);
+
+	if (dwarf_tag(die) != DW_TAG_member ||
+	    (dwarf_tag(parent_die) != DW_TAG_structure_type &&
+		dwarf_tag(parent_die) != DW_TAG_union_type)) {
+		pr_err("Warning: member_blacklisted() called on "
+		       "%s:%s.%s at offset %li, which is not a structure member.\n",
+		       fname, dwarf_diename(parent_die), dwarf_diename(die),
+		       DIEOFFSET(die));
+		return 0;
+	}
+
+	id = xstrdup(fname);
+	id = str_appendn(id, ":", dwarf_diename(parent_die), ".",
+	    dwarf_diename(die), NULL);
+
+	if (g_hash_table_lookup_extended(member_blacklist, id, NULL, NULL))
+		blacklisted = 1;
+
+	free(id);
+	return blacklisted;
+}
+
+/*
+ * Initialize a CTF type table, and possibly fill it with those special types
+ * that appear in CTF but not in DWARF (such as 'void').  (This filling happens
+ * only for the type table named "shared_ctf", unless deduplication is turned
+ * off.)
+ *
+ * If this is a local type table, and deduplication is active, make the global
+ * type table its parent.
+ */
+static void init_ctf_table(const char *module_name)
+{
+	ctf_file_t *ctf_file;
+	struct per_module *new_per_mod;
+	int ctf_err;
+
+	ctf_file = ctf_create(&ctf_err);
+	if (ctf_file == NULL) {
+		pr_err("Cannot create CTF file: %s\n", strerror(ctf_err));
+		exit(1);
+	}
+	new_per_mod = malloc(sizeof(struct per_module));
+	if (new_per_mod == NULL) {
+		pr_err("Out of memory allocating per-module CTF info\n");
+		exit(1);
+	}
+
+	new_per_mod->ctf_file = ctf_file;
+	new_per_mod->member_counts = g_hash_table_new_full(g_str_hash,
+							   g_str_equal,
+							   free, free);
+	g_hash_table_replace(per_module, xstrdup(module_name), new_per_mod);
+
+	dw_ctf_trace("Initializing module: %s\n", module_name);
+	if ((strcmp(module_name, "shared_ctf") == 0) ||
+	    !deduplicating) {
+		ctf_encoding_t void_encoding = { CTF_INT_SIGNED, 0, 0 };
+		ctf_encoding_t int_encoding = { CTF_INT_SIGNED, 0,
+						sizeof(int) * 8 };
+		ctf_id_t int_type;
+		ctf_id_t func_type;
+		ctf_funcinfo_t func_info;
+
+		/*
+		 * Global types module, or deduplication is disabled.  Add a
+		 * type for 'void *' to point to, and a type for the return
+		 * value of pointers to functions: then add the (single,
+		 * universal) pointer-to-function value.
+		 */
+		ctf_void_type = ctf_add_integer(ctf_file, CTF_ADD_ROOT,
+						"void", &void_encoding);
+		int_type = ctf_add_integer(ctf_file, CTF_ADD_ROOT, "int",
+					   &int_encoding);
+		mark_shared_by_name(ctf_file, ctf_void_type, "void");
+		mark_shared_by_name(ctf_file, int_type, "int");
+
+		func_info.ctc_return = int_type;
+		func_info.ctc_argc = 0;
+		func_info.ctc_flags = 0;
+		func_type = ctf_add_function(ctf_file, CTF_ADD_ROOT,
+					     &func_info, NULL);
+		ctf_funcptr_type = ctf_add_pointer(ctf_file, CTF_ADD_ROOT,
+						   func_type);
+
+		if (ctf_update(ctf_file) < 0) {
+			pr_err("Cannot initialize shared CTF file: %s\n",
+			       ctf_errmsg(ctf_errno(ctf_file)));
+			exit(1);
+		}
+	} else {
+		/*
+		 * Local types module with deduplication enabled: point the
+		 * parent at the global CTF file, which must exist by this
+		 * point.
+		 */
+		if (ctf_import(ctf_file, lookup_ctf_file("shared_ctf")) < 0) {
+			pr_err("Cannot set parent of CTF file for module %s: %s\n",
+			       module_name, ctf_errmsg(ctf_errno(ctf_file)));
+			exit(1);
+		}
+		ctf_parent_name_set(ctf_file, "shared_ctf");
+	}
+
+	dw_ctf_trace("Created CTF file for module %s: %p\n",
+		     module_name, ctf_file);
+}
+
+/* DWARF walkers.  */
+
+/*
+ * Initialize the child->parent DIE mapping for a single file.
+ */
+static void init_parent_die(const char *file_name, Dwfl *dwfl)
+{
+	GHashTable *offs;
+	Dwarf_Die *tu_die = NULL;
+	Dwarf_Addr junk;
+
+	offs = g_hash_table_new(g_direct_hash, g_direct_equal);
+	if (offs == NULL) {
+		pr_err("Out of memory creating DIE offset hash\n");
+		exit(1);
+	}
+
+	while ((tu_die = dwfl_nextcu(dwfl, tu_die, &junk)) != NULL) {
+		init_parent_die_internal(file_name, offs, tu_die, 0, 0);
+	}
+
+	g_hash_table_insert(fn_to_die_to_parent,
+			    strdup(abs_file_name(file_name)), offs);
+}
+
+/*
+ * Initialize one layer of a child->parent mapping.
+ *
+ * We traverse children of top-level subprograms hunting for anything we know
+ * how to emit, and record parent->child mappings for all intermediate DIEs.
+ */
+static int init_parent_die_internal(const char *file_name,
+				    GHashTable *offs, Dwarf_Die *parent,
+				    int depth, int found_subprogram)
+{
+	Dwarf_Die child;
+	int sib_ret;
+	Dwarf_Off parent_offset;
+	const char *err;
+	int add_parent = 0;
+
+	if (dwarf_tag(parent) == DW_TAG_subprogram)
+		found_subprogram = 1;
+
+	switch (dwarf_child(parent, &child)) {
+	case -1:
+		err = "child DIEs";
+		goto err;
+	case 1: /* This DIE has no children */
+		goto out;
+	}
+
+	parent_offset = dwarf_dieoffset(parent);
+
+	do {
+		int add_child = 0;
+
+		/*
+		 * Add links from the parent to all children for which a
+		 * recursive call says they should be added, and note that we
+		 * should add links to the parent too.  Always look down to
+		 * depth 2, since the topmost level is always
+		 * DW_TAG_compile_unit, and we are interested in
+		 * DW_TAG_subprograms one level below that.
+		 */
+		if (found_subprogram || depth < 2)
+			add_child = init_parent_die_internal(file_name, offs,
+							     &child, depth+1,
+							     found_subprogram);
+
+		if (add_child) {
+			g_hash_table_insert(offs,
+					    GUINT_TO_POINTER(dwarf_dieoffset(&child)),
+					    GUINT_TO_POINTER(parent_offset));
+			add_parent = 1;
+		}
+	} while ((sib_ret = dwarf_siblingof (&child, &child)) == 0);
+
+	if (sib_ret == -1) {
+		err = "sibling DIEs";
+		goto err;
+	}
+
+out:
+	/*
+	 * Emit a link for the next level up if we're under a subprogram and
+	 * either we emitted a child link or the parent is itself something we
+	 * know how to emit (and thus might possibly appear in a type DIE we
+	 * care about).
+	 */
+	return (found_subprogram &&
+		(add_parent ||
+		 (dwarf_tag(parent) <= assembly_len &&
+		  assembly_tab[dwarf_tag(parent)] != NULL)));
+err:
+	pr_err("Cannot fetch %s of DIE at offset %lu in %s: %s\n",
+	       err, DIEOFFSET(parent), file_name,
+	       dwarf_errmsg(dwarf_errno()));
+	exit(1);
+}
+
+/*
+ * Type ID computation.
+ *
+ * A type ID is a constant, recursively-constructed, dynamically-allocated
+ * string describing a given DWARF DIE in such a way that any DWARF file
+ * containing the same type will have the same type ID.  (It even works for
+ * variables!  Variables of the same name and referring to the same type have
+ * the same ID...)
+ *
+ * Optionally, call a callback with the computed ID once we know it (this is a
+ * recursive process, so the callback can be called multiple times as the ID is
+ * built up).
+ *
+ * An ID of NULL indicates that this DIE has no ID and need not be considered.
+ *
+ * It is probably an error for two DWARF DIEs representing top-level types to
+ * return the same ID, but for certain other DIEs (notably those representing
+ * the members of structures or unions), it is expected that they return the
+ * same ID as their type DIE.
+ *
+ * This function is the hottest hot spot in dwarf2ctf, so is somewhat
+ * aggressively optimized.
+ *
+ * The "overrides" allow the overriding of DWARF attributes, so that the
+ * machinery notices different DWARF from what actually appears in the
+ * debuginfo, so that the CTF that is emitted is suitably modified (and possibly
+ * duplicated).  This is mostly used by type_id() to generate different IDs for
+ * dependent types of bitfields, but can be used for other purposes too, such as
+ * adjusting the offsets of types in unnamed structures, etc.  Overrides are
+ * passed down if provided: overrides relating to bitfields are only applied by
+ * type_id() if no other overrides are provided.
+ *
+ * In general, you do not need to pass overrides down if you know you will only
+ * be called directly on top-level DIEs, but otherwise, you should do so.
+ */
+static char *type_id(Dwarf_Die *die,
+		     struct die_override *overrides,
+		     void (*fun)(Dwarf_Die *die,
+				 const char *id,
+				 struct die_override *overrides,
+				 void *data),
+		     void *data)
+{
+	return type_id_internal(die, overrides, fun, data, 0);
+}
+
+/*
+ * Internal: generate the type ID for a type DIE.
+ *
+ * If there are no overrides, look for a bit_size and bit_offset and pass them
+ * down as well.
+ */
+static char *type_id_type_die(Dwarf_Die *die,
+			      Dwarf_Die *type_die,
+			      struct die_override *overrides,
+			      void (*fun)(Dwarf_Die *die,
+					  const char *id,
+					  struct die_override *overrides,
+					  void *data),
+			      void *data)
+{
+	char *id;
+
+	/*
+	 * bit_size and bit_offset go together: we can assume that if a member
+	 * has the one, it has the other.
+	 */
+
+	if (private_dwarf_hasattr(die, DW_AT_bit_size)) {
+		Dwarf_Word size;
+		Dwarf_Word offset;
+
+		size = private_dwarf_udata(die, DW_AT_bit_size, NULL);
+		offset = private_dwarf_udata(die, DW_AT_bit_offset, NULL);
+		struct die_override o[] = {
+			{ DW_TAG_base_type,
+			  DW_AT_bit_size,
+			  DIE_OVERRIDE_REPLACE,
+			  size, NULL },
+			{ DW_TAG_base_type,
+			  DW_AT_bit_offset,
+			  DIE_OVERRIDE_REPLACE,
+			  offset, overrides },
+			{0}
+		};
+		id = type_id(type_die, o, fun, data);
+	} else
+		id = type_id(type_die, overrides, fun, data);
+	return id;
+}
+
+/*
+ * Internal: allows flags to be passed to affect one (and only one) type ID
+ * recursion, without affecting other type_id()s launched from the 'fun'.
+ */
+static char *type_id_internal(Dwarf_Die *die,
+			      struct die_override *overrides,
+			      void (*fun)(Dwarf_Die *die,
+					  const char *id,
+					  struct die_override *overrides,
+					  void *data),
+			      void *data,
+			      int flags)
+{
+	char *id = NULL;
+	int no_type_id = 0;
+	int decorated = 1;
+
+	/*
+	 * The ID of a null pointer is NULL.
+	 */
+	if (die == NULL)
+		return NULL;
+
+	/*
+	 * The ID of a function pointer is '//fp//', as a special case,
+	 * with no location or overrides, ever.
+	 */
+	if (dwarf_tag(die) == DW_TAG_subroutine_type) {
+		id = xstrdup("//fp//");
+		if (fun)
+			fun(die, id, NULL, data);
+		return id;
+	}
+
+	/*
+	 * If we have a type DIE, generate it first, passing any overrides down.
+	 * (Base types and enumerations don't have a type DIE that CTF can
+	 * encode the type of in any useful fashion.)
+	 *
+	 * Otherwise, note the location of this DIE, providing scoping
+	 * information for all types based upon this one.  Location elements are
+	 * separated by //, an element impossible in a Linux path.  The
+	 * blacklist type prefix (if set) follows this (which is a name which,
+	 * while not impossible in a Linux path, is very unlikely.)
+	 *
+	 * Array dimensions get none of this: they must be contained within
+	 * another DIE, so will always have a location attached via that DIE,
+	 * and get their type chased further down (so as to arrange that they
+	 * appear inside an [].)
+	 */
+	if (dwarf_tag(die) != DW_TAG_subrange_type) {
+		if ((dwarf_tag(die) != DW_TAG_base_type) &&
+		    (dwarf_tag(die) != DW_TAG_enumeration_type)) {
+			Dwarf_Die type_die;
+			Dwarf_Die *diep = private_dwarf_type(die, &type_die);
+
+			if (diep)
+				id = type_id_type_die(die, diep, overrides,
+						      fun, data);
+		}
+
+		/*
+		 * Location information.  We use cached realpath() results, and
+		 * call str_appendn() only once, minimizing the number of
+		 * strlen()s.
+		 */
+		if (id == NULL) {
+			const char *decl_file_name = dwarf_decl_file(die);
+			int decl_line_num;
+			const char *fname = "";
+			char line_num[21] = "";	 /* > than 2^64's digit count */
+
+			no_type_id = 1;
+			if (decl_file_name != NULL)
+				fname = abs_file_name(decl_file_name);
+
+			if (dwarf_decl_line(die, &decl_line_num) >= 0) {
+				snprintf(line_num, sizeof(line_num), "%i",
+					 decl_line_num);
+			}
+			id = str_appendn(id, fname, "//", line_num, "//", NULL);
+		}
+	}
+
+	/*
+	 * We implement this via a switch statement, rather than a jump table
+	 * like the assembly_tab, simply because most cases are so small that
+	 * splitting them into separate functions would do more harm than good
+	 * to readability.
+	 *
+	 * WARNING: The spaces in the strings in this switch statement are not
+	 * just for appearance: types with spaces in their names are impossible
+	 * in C.  If you move those spaces around for appearance's sake, please
+	 * adjust mark_shared_by_name and dedup_alias_fixup(), which
+	 * construct the IDs of basic types, structures, and unions by hand.
+	 */
+	switch (dwarf_tag(die)) {
+	case DW_TAG_base_type: {
+		Dwarf_Word bit_size = -1;
+		Dwarf_Word type_size = -1;
+		Dwarf_Word bit_offset = -1;
+		const char *diename = dwarf_diename(die);
+
+		if ((flags & TI_COLLAPSE_SIZETYPE) &&
+		    (strcmp(diename, "long unsigned int") == 0))
+			diename = "sizetype";
+
+		/*
+		 * CTF encodes the size and bitwise-offset of bit-fields in the
+		 * base type, so it must be stored once for each size, even if
+		 * it only appears once for all sizes in the DWARF.
+		 */
+		if (private_dwarf_hasattr(die, DW_AT_bit_size) ||
+		    private_find_override(die, DW_AT_bit_size,
+					  overrides))
+			bit_size = private_dwarf_udata(die, DW_AT_bit_size,
+						       overrides);
+		if (private_dwarf_hasattr(die, DW_AT_bit_offset) ||
+		    private_find_override(die, DW_AT_bit_offset,
+					  overrides))
+			bit_offset = private_dwarf_udata(die, DW_AT_bit_offset,
+							 overrides);
+
+		/*
+		 * Bitfields that occupy their entire containing type are not
+		 * bitfields, but just redundant DWARF.  GCC emits these now and
+		 * again, but the dups would trip CTF consistency checks, so
+		 * must be skipped.
+		 */
+		if (bit_size > -1) {
+			/*
+			 * This "may be omitted" in DWARF, but GCC doesn't:
+			 * bitfields always get both.  (See
+			 * gcc/dwarf2out.c:gen_field_die().)
+			 */
+			type_size = private_dwarf_udata(die, DW_AT_bit_size,
+							overrides);
+		}
+		if (bit_size != type_size) {
+			char bitsize[22];	/* > 2^64's digit count */
+			char bitoffset[22];	/* > 2^64's digit count */
+
+			snprintf(bitsize, sizeof(bitsize), "%li", bit_size);
+			id = str_appendn(id, diename, ":", bitsize, NULL);
+			if (bit_offset != -1) {
+				snprintf(bitoffset, sizeof(bitoffset), "%li",
+					bit_offset);
+				id = str_appendn(id, ":", bitoffset, NULL);
+			}
+			id = str_append(id, " ");
+		} else {
+			/*
+			 * Ordinary (non-bit-field) base type.
+			 */
+			id = str_appendn(id, diename, " ", NULL);
+		}
+		break;
+	}
+	case DW_TAG_enumeration_type:
+		id = str_appendn(id, "enum ", dwarf_diename(die), " ", NULL);
+		break;
+	case DW_TAG_structure_type:
+	case DW_TAG_union_type: {
+		/*
+		 * Incorporate the unaligned sizeof() the structure, if
+		 * statically known (the offset of the last member in the DWARF)
+		 * so that most structures which are redefined on the fly by
+		 * preprocessor defines are disambiguated despite being defined
+		 * in the same place.
+		 *
+		 * Only do this if this is a non-opaque structure/union
+		 * definition: opaque definitions cannot have a size, but if
+		 * they do by some mischance get one, notating it will mess up
+		 * the several other places that manually construct opaque
+		 * structure identifiers (and cannot incorporate a size, since
+		 * they don't know it).
+		 */
+		const char *sou;
+
+		if (strncmp(id, "////", 4) != 0) {
+			long long size;
+			char byte_size[24];
+
+			size = private_dwarf_size(die);
+			if (size > -1) {
+				sprintf(byte_size, "%lli", size);
+				id = str_appendn(id, byte_size, "//", NULL);
+			}
+		}
+
+		if (dwarf_tag(die) == DW_TAG_union_type)
+			sou = "union ";
+		else
+			sou = "struct ";
+
+		id = str_appendn(id, sou, dwarf_diename(die), " ", NULL);
+		break;
+	}
+	case DW_TAG_variable:
+		id = str_appendn(id, "var ", dwarf_diename(die), " ", NULL);
+		break;
+	case DW_TAG_typedef:
+		id = str_appendn(id, "typedef ", dwarf_diename(die), " ", NULL);
+		break;
+	case DW_TAG_const_type:
+		id = str_append(id, "const ");
+		break;
+	case DW_TAG_restrict_type:
+		id = str_append(id, "restrict ");
+		break;
+	case DW_TAG_volatile_type:
+		id = str_append(id, "volatile ");
+		break;
+	case DW_TAG_pointer_type:
+		if (no_type_id)
+			id = str_append(id, "void ");
+		id = str_append(id, "* ");
+		break;
+
+	case DW_TAG_array_type: {
+		/*
+		 * No explicit notation: all done per-dimension: so recurse to
+		 * those.
+		 */
+
+		int sib_ret;
+		int dimens = 0;
+		Dwarf_Die dim_die;
+
+		switch (dwarf_child(die, &dim_die)) {
+		case -1:
+			pr_err("Corrupt DWARF: Cannot get array dimensions: %s\n",
+			       dwarf_errmsg(dwarf_errno()));
+			exit(1);
+		case 1: /* No dimensions.  */
+			id = str_append(id, "[] ");
+			break;
+		default:
+			dimens = 1;
+		}
+
+		if (!dimens)
+			break;
+
+		do {
+			char *sub_id = type_id_internal(&dim_die, overrides,
+							fun, data,
+							TI_COLLAPSE_SIZETYPE);
+			id = str_append(id, sub_id);
+			free(sub_id);
+		} while ((sib_ret = dwarf_siblingof(&dim_die, &dim_die)) == 0);
+
+		if (sib_ret == -1) {
+			pr_err("Corrupt DWARF: Cannot get array dimensions: %s\n",
+			       dwarf_errmsg(dwarf_errno()));
+			exit(1);
+		}
+		break;
+	}
+	case DW_TAG_subrange_type: {
+		Dwarf_Word nelems = private_subrange_dimensions(die);
+
+		id = str_append(id, "[");
+
+		if (nelems > 0)	{
+			Dwarf_Die type_die;
+			char elems[22];	    /* bigger than 2^64's digit count */
+			char *sub_id = type_id_internal(private_dwarf_type(die, &type_die),
+							overrides, fun, data,
+							TI_COLLAPSE_SIZETYPE);
+
+			snprintf(elems, sizeof(elems), " %li", nelems);
+			id = str_appendn(id, sub_id, elems, NULL);
+			free(sub_id);
+		}
+		id = str_append(id, "] ");
+		break;
+	}
+	default:
+		/*
+		 * Some tags (e.g. structure members) get the same ID as their
+		 * associated type.  We don't need to call the hook function
+		 * again for such tags.
+		 */
+		decorated = 0;
+	}
+
+	if (fun && decorated)
+		fun(die, id, overrides, data);
+
+	return id;
+}
+
+/*
+ * Process a file, calling the dwarf_process function for every top-level type
+ * found therein.  Optionally call tu_init() at the start of each translation
+ * unit, and tu_done() at the end.
+ */
+static void process_file(const char *file_name,
+			 void (*dwarf_process)(const char *module_name,
+					       const char *file_name,
+					       Dwarf_Die *die,
+					       Dwarf_Die *parent_die,
+					       void *data),
+			 void (*tu_init)(const char *module_name,
+					 const char *file_name,
+					 Dwarf_Die *tu_die,
+					 void *data),
+			 void (*tu_done)(const char *module_name,
+					 const char *file_name,
+					 Dwarf_Die *tu_die,
+					 void *data),
+			 void *data)
+{
+	const char *err;
+	char *fn_module_name = fn_to_module(file_name);
+	const char *module_name = fn_module_name;
+
+	Dwfl_Module *mod;
+	Dwfl *dwfl;
+	Dwarf *dwarf;
+	GHashTable *seen_before = g_hash_table_new_full(g_str_hash, g_str_equal,
+							free, free);
+	Dwarf_Die *tu_die = NULL;
+	Dwarf_Addr junk;
+
+	if (seen_before == NULL) {
+		pr_err("Out of memory creating seen_before hash\n");
+		exit(1);
+	}
+
+	dwfl = simple_dwfl_new(file_name, &mod);
+	dwarf = dwfl_module_getdwarf(mod, &junk);
+
+	/*
+	 * On first traversal, make sure the DIE parent mapping is populated,
+	 * so that filter_ctf_file_scope can use it.
+	 */
+	if (!g_hash_table_lookup_extended(fn_to_die_to_parent,
+					  abs_file_name(file_name),
+					  NULL, NULL))
+		init_parent_die(file_name, dwfl);
+
+	while ((tu_die = dwfl_nextcu(dwfl, tu_die, &junk)) != NULL) {
+		const char *tu_name;
+
+		if (dwarf_tag(tu_die) != DW_TAG_compile_unit) {
+			err = "Malformed DWARF: non-compile_unit at top level";
+			goto fail;
+		}
+
+		tu_name = dwarf_diename(tu_die);
+
+		dw_ctf_trace("Processing %s\n", tu_name);
+
+		/*
+		 * If we have seen this TU before, skip it.  We assume that
+		 * types in multiple identical TUs are always entirely
+		 * identical.  This lets us skip cases where the same object
+		 * file is linked in multiple places without scanning every type
+		 * in it.  (Note: this may be inaccurate if a TU is built
+		 * repeatedly with different #defines in force.  I hope this
+		 * cannot happen, but if it does, a workaround a-la libtool is
+		 * simple: rename or symlink the TU for such repeated builds.)
+		 *
+		 * Otherwise, note the name of the module to which this TU maps,
+		 * if it is not already known: otherwise, extract that name.
+		 *
+		 * This is purely an optimization: it breaks somewhat for
+		 * multifile modules but this has no effect but a slight
+		 * slowdown.
+		 */
+		if (g_hash_table_lookup_extended(seen_before, tu_name,
+						 NULL, NULL))
+			continue;
+
+		g_hash_table_replace(seen_before, xstrdup(tu_name), NULL);
+
+		/*
+		 * We are only interested in top-level definitions within each
+		 * TU.
+		 */
+		Dwarf_Die die;
+
+		switch (dwarf_child(tu_die, &die)) {
+		case -1:
+			err = "fetch first child of TU";
+			goto fail;
+		case 1: /* No DIEs at all in this TU */
+			continue;
+		default: /* Child DIEs exist.  */
+			break;
+		}
+
+		if (tu_init != NULL)
+			tu_init(module_name, file_name, tu_die, data);
+
+		process_tu_func(module_name, file_name, dwarf, tu_die, &die,
+				dwarf_process, data);
+
+		if (tu_done != NULL)
+			tu_done(module_name, file_name, tu_die, data);
+	}
+
+	free(fn_module_name);
+	simple_dwfl_free(dwfl);
+	g_hash_table_destroy(seen_before);
+
+	return;
+
+ fail:
+	pr_err("Cannot %s for %s: %s\n", err, module_name,
+	       dwarf_errmsg(dwarf_errno()));
+	exit(1);
+}
+
+/*
+ * process_file() helper, walking over the top level and picking up types
+ * therein.
+ */
+static void process_tu_func(const char *module_name,
+			    const char *file_name,
+			    Dwarf *dwarf,
+			    Dwarf_Die *parent_die,
+			    Dwarf_Die *die,
+			    void (*dwarf_process)(const char *module_name,
+						  const char *file_name,
+						  Dwarf_Die *die,
+						  Dwarf_Die *parent_die,
+						  void *data),
+			    void *data)
+{
+	const char *err;
+	int sib_ret;
+
+	/*
+	 * We are only interested in definitions for which we can (eventually)
+	 * emit CTF: call the processing function for all such.
+	 */
+	do {
+		if ((dwarf_tag(die) <= assembly_len) &&
+		    (assembly_filter_tab[dwarf_tag(die)] == NULL ||
+		     assembly_filter_tab[dwarf_tag(die)](file_name, dwarf, die,
+							 parent_die)) &&
+		    (assembly_tab[dwarf_tag(die)] != NULL))
+			dwarf_process(module_name, file_name, die,
+				      parent_die, data);
+	} while ((sib_ret = dwarf_siblingof(die, die)) == 0);
+
+	if (sib_ret == -1) {
+		err = "fetch sibling";
+		goto fail;
+	}
+
+	return;
+ fail:
+	pr_err("Cannot %s for %s: %s\n", err, module_name,
+	       dwarf_errmsg(dwarf_errno()));
+	exit(1);
+}
+
+/* Duplicate detection. */
+
+/*
+ * Scan and identify duplicates across the entire set of object files.
+ */
+static void scan_dups(void)
+{
+	size_t i;
+
+	/*
+	 * First, determine which types are referenced by more than one
+	 * translation unit, and construct the mapping from translation unit to
+	 * non-builtin module name.
+	 *
+	 * The first pass detects duplicated types in need of sharing, without
+	 * considering opaque/transparent structure/union aliasing.  It requests
+	 * an alias detection pass if any structures, or typedefs to them, are
+	 * newly marked as shared.
+	 *
+	 * We must do this even when deduplication is disabled, because we need
+	 * the TU->module-name mapping, even if in this case it is trivial.
+	 */
+
+	struct dedup_state state = {0};
+
+	dw_ctf_trace("Duplicate detection: primary pass.\n");
+
+	/*
+	 * This is merely flushed between TUs, not recreated: we create it here.
+	 */
+	state.vars_seen = g_hash_table_new_full(g_str_hash,
+						g_str_equal,
+						free, NULL);
+
+	for (i = 0; i < object_names_cnt; i++)
+		process_file(object_names[i], dedup,
+			     dedup_tu_init, dedup_tu_done, &state);
+
+	if ((!state.repeat_detection) || !deduplicating)
+		goto out;
+
+	do {
+		/*
+		 * The second pass recognizes that opaque structures must be
+		 * shared if the transparent equivalents are, and vice versa,
+		 * and re-traces all transparent types that need sharing.
+		 *
+		 * It requests another alias detection pass if any non-opaque
+		 * structures are newly marked as shared.
+		 */
+		dw_ctf_trace("Duplicate detection: alias fixup pass.\n");
+
+		state.repeat_detection = 0;
+		state.named_structs = list_filter(state.named_structs,
+						  dedup_alias_fixup,
+						  free_dups_id_file, &state);
+	} while (state.repeat_detection);
+ out:
+	g_hash_table_destroy(state.vars_seen);
+	dedup_dwarf_free(&state);
+	dw_ctf_trace("Duplicate detection: complete.\n");
+	dw_ctf_trace("%llu distinct type IDs known.\n",
+		     (unsigned long long) g_hash_table_size(id_to_module));
+	dw_ctf_trace("%llu variables blacklisted for static/nonstatic conflicts.\n",
+		     (unsigned long long) g_hash_table_size(variable_blacklist));
+	g_list_free_full(state.named_structs, free_dups_id_file);
+}
+
+/*
+ * Set up state for dedup().  A tu_init() callback.
+ */
+static void dedup_tu_init(const char *module_name, const char *file_name,
+			  Dwarf_Die *tu_die, void *data)
+{
+	struct dedup_state *state = data;
+	struct per_module *per_mod;
+
+	/*
+	 * Make sure that even if this module has no types in it we still end up
+	 * generating a CTF file.  (Userspace depends on this, since a CTF file
+	 * with no types in means the module is known and typeless, while no CTF
+	 * file at all means the module is not known.)
+	 */
+
+	per_mod = g_hash_table_lookup(per_module, module_name);
+	if (per_mod == NULL) {
+		init_ctf_table(module_name);
+		dw_ctf_trace("%s: initialized CTF file.\n", module_name);
+	}
+
+	state->structs_seen = g_hash_table_new(g_str_hash, g_str_equal);
+	g_hash_table_remove_all(state->vars_seen);
+	state->module_name = module_name;
+}
+
+/*
+ * Free state for dedup().  A tu_done() callback.
+ */
+static void dedup_tu_done(const char *module_name, const char *file_name,
+			  Dwarf_Die *tu_die, void *data)
+{
+	struct dedup_state *state = data;
+
+	/*
+	 * We have to annul module_name because it is freed between object files
+	 * by process_file().  Since we use that to track whether vars_seen
+	 * needs reconstructing, that means we have to destroy that as well.
+	 */
+	g_hash_table_destroy(state->structs_seen);
+	state->structs_seen = NULL;
+	state->module_name = NULL;
+}
+
+/*
+ * Free DWARF state for dedup().
+ */
+static void dedup_dwarf_free(struct dedup_state *state)
+{
+	if (state->dwfl == NULL)
+		return;
+	simple_dwfl_free(state->dwfl);
+	state->dwfl = NULL;
+	state->dwarf = NULL;
+	free(state->dwfl_file_name);
+	state->dwfl_file_name = NULL;
+	if (state->structs_seen)
+		g_hash_table_destroy(state->structs_seen);
+	state->structs_seen = NULL;
+}
+
+/*
+ * Duplicate detection.
+ *
+ * Scan for duplicate types.  A duplicate type is defined as any type which
+ * appears in more than one module, or, more precisely, any type for which a
+ * type with the same ID already exists in another module.
+ *
+ * This pass also constructs the id_to_module table, so is essential even when
+ * deduplication is disabled (though then it need be run only once.)
+ */
+
+static void dedup(const char *module_name, const char *file_name,
+		  Dwarf_Die *die, Dwarf_Die *parent_die, void *data)
+{
+	struct dedup_state *state = data;
+	int is_sou = 0;
+	char *id = type_id(die, NULL, is_named_struct_union_enum, &is_sou);
+
+	state->file_name = file_name;
+	/*
+	 * If a DWARF-4 type signature is found, abort.  While we can support
+	 * DWARF-4 eventually, support in elfutils is insufficiently robust for
+	 * now (elfutils 0.152).
+	 */
+	if (private_dwarf_hasattr(die, DW_AT_type)) {
+		Dwarf_Attribute type_attr;
+
+		if ((private_dwarf_attr(die, DW_AT_type, &type_attr) != NULL) &&
+		    (dwarf_whatform(&type_attr) == DW_FORM_ref_sig8)) {
+			pr_err("Sorry, not yet implemented: %s contains DWARF-4 debugging information.\n",
+			       module_name);
+			exit(1);
+		}
+	}
+
+	/*
+	 * Non-anonymous, non-opaque structure/union/enum types in
+	 * non-dedup-blacklisted modules get their names and locations recorded
+	 * for subsequent passes; all type_id()-descendant types are similarly
+	 * noted.
+	 */
+	if (is_sou && strncmp(id, "////", strlen("////")) != 0)
+		free(type_id(die, NULL, dedup_will_rescan, state));
+
+	/*
+	 * Handle static variable blacklisting.  (We still shuffle blacklisted
+	 * variables into the right place in id_to_module because we check for
+	 * blacklisting at the lowest level, by which point we have already
+	 * depended on id_to_module being correctly populated.)
+	 *
+	 * Avoid calling this for recursive dependent-type scans: variables
+	 * cannot be dependent types.
+	 */
+	if (parent_die != NULL && dwarf_tag(die) == DW_TAG_variable)
+		dedup_blacklist_var_dups(die, state);
+
+	dedup_mark_inner_die(module_name, die, id, NULL, data);
+	free(id);
+}
+
+/*
+ * Do the underlying marking of a DIE as shared, iff need be.  (No variable
+ * blacklisting, non-opaque structure checks, or anything else needed only by
+ * top-level DIEs.)
+ *
+ * This function may be called multiple times for overridden DIEs that are
+ * dependent types of bitfields.  (On multiple calls for normal types, the
+ * second call will enter the NS_NO_MARKING case block and terminate recursion.)
+ */
+static void dedup_mark_inner_die(const char *module_name, Dwarf_Die *die,
+				 const char *id,
+				 struct die_override *overrides,
+				 void *data)
+{
+	/*
+	 * If we know of a single module incorporating this type, and it is not
+	 * the same as the module we are currently in, then this type is
+	 * duplicated across modules and belongs in the global type table.
+	 * (This means that duplicated types are repeatedly so marked: this
+	 * is unavoidable, because pass 3 requires re-marking structures that
+	 * have already been marked, to pick up unmarked intermediate types.)
+	 *
+	 * We never consider types in modules on the deduplication blacklist
+	 * to introduce duplicates.
+	 */
+	switch (type_needs_sharing(module_name, id)) {
+	case NS_NEEDS_SHARING:
+		mark_shared(die, NULL, overrides, data);
+		mark_seen_contained(die, "shared_ctf", overrides, data);
+		/* Fall through */
+	case NS_NO_MARKING:
+		/*
+		 * A duplicated type, but in the same module, or deduplication
+		 * is disabled, so id_to_module is already correct.  (When
+		 * deduplication is disabled, we will be running with only one
+		 * module at a time, and id_to_module will be a trivial
+		 * mapping.)
+		 */
+		return;
+	case NS_NOT_SHARED:
+		break;
+	}
+
+	/*
+	 * Record that we have seen this type, and all its dependent types, in
+	 * this module (or in the shared module if need be).
+	 */
+
+	dw_ctf_trace("Marking %s as seen in %s\n", id, module_name);
+	g_hash_table_replace(id_to_module, intern(xstrdup(id)),
+			     xstrdup(module_name));
+	mark_seen_contained(die, module_name, overrides, data);
+	free(type_id(die, overrides, dedup_typeid, data));
+}
+
+/*
+ * Note in the dedup_id_file list that we will rescan a DIE in a later duplicate
+ * detection pass.
+ *
+ * A type_id() callback.
+ */
+static void dedup_will_rescan(Dwarf_Die *die, const char *id,
+			      struct die_override *overrides, void *data)
+{
+	struct dedup_state *state = data;
+	struct dedup_id_file *id_file;
+
+	/*
+	 * We don't care about array index types, which will never be structures
+	 * in C.
+	 */
+	if (id[0] == '[')
+		return;
+
+	id_file = calloc(1, sizeof(struct dedup_id_file));
+	if (id_file == NULL) {
+		pr_err("Out of memory allocating id_file\n");
+		exit(1);
+	}
+	id_file->file_name = intern(xstrdup(state->file_name));
+	id_file->id = intern(xstrdup(id));
+	id_file->dieoff = dwarf_dieoffset(die);
+	state->named_structs = g_list_prepend(state->named_structs, id_file);
+}
+
+/*
+ * Note the variable referenced by this DIE in vars_seen: blacklist it if an
+ * entry for this variable already exists in vars_seen and this instance is
+ * static, or if a static entry already exists in vars_seen, whether this
+ * instance is static or not.
+ */
+static void dedup_blacklist_var_dups(Dwarf_Die *die,
+				     struct dedup_state *state)
+{
+	void *static_var;
+	int blacklist = 0;
+
+	if (g_hash_table_lookup_extended(state->vars_seen,
+					 dwarf_diename(die),
+					 NULL, &static_var)) {
+		if (!private_dwarf_hasattr(die, DW_AT_external) &&
+		    !private_dwarf_hasattr(die, DW_AT_declaration))
+			blacklist = 1;
+		if (static_var != NULL)
+			blacklist = 1;
+	} else
+	  /*
+	   * We need a non-NULL address here, but that is all we need.
+	   * The address of a random variable will do.
+	   */
+		g_hash_table_insert(state->vars_seen,
+				    xstrdup(dwarf_diename(die)),
+				    (!private_dwarf_hasattr(die, DW_AT_external) &&
+				     !private_dwarf_hasattr(die, DW_AT_declaration)) ?
+				    &static_var : NULL);
+
+	if (blacklist) {
+		char *var = NULL;
+		var = str_appendn(var, state->module_name, "`",
+				  dwarf_diename(die), NULL);
+		g_hash_table_replace(variable_blacklist, var, NULL);
+	}
+}
+
+/*
+ * Free a dedup_id_file's contents.
+ */
+static void free_dups_id_file(void *data)
+{
+	struct dedup_id_file *id_file = data;
+	free(id_file);
+}
+
+/*
+ * Determine if a type is duplicated and needs sharing.
+ */
+static enum needs_sharing type_needs_sharing(const char *module_name,
+					     const char *id)
+{
+	const char *existing_type_module;
+	existing_type_module = g_hash_table_lookup(id_to_module, id);
+
+	/*
+	 * Types not already known about do not need sharing.
+	 *
+	 * Types already in the current modules and any types in external-module
+	 * mode do not even need marking.
+	 */
+	if (existing_type_module == NULL)
+		return NS_NOT_SHARED;
+
+	if ((strcmp(existing_type_module, module_name) == 0) ||
+	    (strcmp(existing_type_module, "shared_ctf") == 0) ||
+	    !deduplicating)
+		return NS_NO_MARKING;
+
+	return NS_NEEDS_SHARING;
+}
+
+/*
+ * Detect duplicates and mark seen types for a given type, via a type_id()
+ * callback: used to detect dependent types (particularly those at child-DIE
+ * level) as duplicates.
+ */
+static void dedup_typeid(Dwarf_Die *die, const char *id,
+			 struct die_override *overrides, void *data)
+{
+	struct dedup_state *state = data;
+
+	dedup_mark_inner_die(state->module_name, die, id, overrides, data);
+}
+
+/*
+ * Mark any types contained within a particular type DIE as seen.  This is
+ * needed since even nameless types contained within other aggregates can be
+ * used as the type of members in any of their enclosing aggregates (though they
+ * cannot possibly be found in a module different from that of their containing
+ * aggregate, any more than a structure member can).
+ */
+static void mark_seen_contained(Dwarf_Die *die, const char *module_name,
+				struct die_override *overrides,
+				void *data)
+{
+	const char *err;
+	Dwarf_Die child;
+
+	if ((dwarf_tag(die) != DW_TAG_structure_type) &&
+	    (dwarf_tag(die) != DW_TAG_union_type))
+		return;
+
+	switch (dwarf_child(die, &child)) {
+	case -1:
+		err = "fetch first child of aggregate";
+		goto fail;
+	case 1: /* No DIEs at all in this aggregate */
+		return;
+	default: /* Child DIEs exist.  */
+		break;
+	}
+
+	/*
+	 * We iterate over all immediate children and recursively call ourselves
+	 * for all those of type DW_TAG_structure_type and DW_TAG_union_type.
+	 *
+	 * Further, everything with an entry in assembly_tab other than
+	 * non-bitfield members needs marking, since these may be declared at
+	 * structure scope rather than being confined to global scope.
+	 * Non-bitfield members are skipped because they cannot be used as the
+	 * type of another field.  These types cannot be duplicates if their
+	 * containing type is not a duplicate, and typedefs cannot occur at this
+	 * level so they cannot be aliased; thus we can mark them directly
+	 * without going back into the top of dedup().
+	 *
+	 * (Bit-field members are not skipped: they use different CTF from their
+	 * non-bitfield equivalents, even though they refer to the same
+	 * top-level DIE.  The actual different CTF is handled by type_id()
+	 * itself, but we do have to call it.)
+	 */
+	int sib_ret;
+
+	do
+		switch (dwarf_tag(&child)) {
+		case DW_TAG_member: {
+			/*
+			 * bit_size and bit_offset go together: we can assume
+			 * that if a member has the one, it has the other,
+			 * is a bitfield, and needs recursive marking.
+			 */
+			if (dwarf_tag(&child) == DW_TAG_member &&
+			    !private_dwarf_hasattr(&child, DW_AT_bit_size))
+				break;
+
+			free(type_id(&child, overrides, dedup_typeid, data));
+			break;
+		}
+		case DW_TAG_structure_type:
+		case DW_TAG_union_type:
+			mark_seen_contained(&child, module_name, overrides, data);
+			/* fall through */
+		default:
+			if (dwarf_tag(&child) <= assembly_len &&
+			    assembly_tab[dwarf_tag(&child)] != NULL) {
+
+				char *id = type_id(&child, overrides, NULL, NULL);
+
+				dw_ctf_trace("Marking member %s as seen in "
+					     "%s\n", id, module_name);
+				g_hash_table_replace(id_to_module, intern(id),
+						     xstrdup(module_name));
+			}
+		}
+	while ((sib_ret = dwarf_siblingof(&child, &child)) == 0);
+
+	if (sib_ret == -1) {
+		err = "iterate over members";
+		goto fail;
+	}
+
+	return;
+
+ fail:
+	pr_err("Cannot %s while marking aggregates as seen: %s\n",
+	       err, dwfl_errmsg(dwfl_errno()));
+	exit(1);
+}
+
+/*
+ * Mark a type as duplicated and located in the shared CTF table.  Recursive,
+ * via the type_id() callback mechanism.
+ *
+ * A type_id() callback (though also called directly).
+ */
+static void mark_shared(Dwarf_Die *die, const char *id,
+			struct die_override *overrides, void *data)
+{
+	struct dedup_state *state = data;
+	const char *existing_module;
+
+	/*
+	 * Non-recursive call.  Trigger type_id for its recursive callback,
+	 * throwing the result away.
+	 */
+	if (id == NULL) {
+		free(type_id(die, overrides, mark_shared, state));
+		return;
+	}
+
+	existing_module = g_hash_table_lookup(id_to_module, id);
+
+	if ((existing_module == NULL) ||
+	    (strcmp(existing_module, "shared_ctf") != 0)) {
+
+		dw_ctf_trace("Marking %s as duplicate\n", id);
+		g_hash_table_replace(id_to_module, intern(xstrdup(id)),
+				     xstrdup("shared_ctf"));
+
+		/*
+		 * Newly-marked structures/unions/enums must trigger a new
+		 * duplicate detection pass (even if they are opaque).
+		 */
+
+		if (((dwarf_tag(die) == DW_TAG_structure_type) ||
+		     (dwarf_tag(die) == DW_TAG_union_type) ||
+		     (dwarf_tag(die) == DW_TAG_enumeration_type)) &&
+		    (!state->repeat_detection)) {
+			dw_ctf_trace("Requesting another duplicate detection pass.\n");
+			state->repeat_detection = 1;
+		}
+	}
+
+	/*
+	 * If this is a structure or union, mark its members as duplicates too.
+	 *
+	 * Do this even if we've seen this structure before, as this instance of
+	 * the structure may have more members than the last we saw.  However,
+	 * if we have seen this structure before *in this translation unit*,
+	 * skip it, to avoid infinite recursion in mutually referential
+	 * structures.
+	 */
+	if ((dwarf_tag(die) == DW_TAG_structure_type) ||
+	    (dwarf_tag(die) == DW_TAG_union_type)) {
+		Dwarf_Die child;
+
+		if (g_hash_table_lookup_extended(state->structs_seen, id,
+						 NULL, NULL))
+			return;
+		g_hash_table_replace(state->structs_seen, intern(xstrdup(id)),
+				     NULL);
+
+		switch (dwarf_child(die, &child)) {
+		case -1:
+			goto fail;
+		case 1: /* No DIEs at all in this aggregate */
+			return;
+		}
+
+		/*
+		 * We are only interested in non-blacklisted children of type
+		 * DW_TAG_member.
+		 */
+		int sib_ret;
+
+		do
+			if ((dwarf_tag(&child) == DW_TAG_member) &&
+			    !member_blacklisted(&child, die))
+				free(type_id(&child, overrides,
+					     mark_shared, state));
+		while ((sib_ret = dwarf_siblingof(&child, &child)) == 0);
+
+		if (sib_ret == -1)
+			goto fail;
+	}
+
+	return;
+
+ fail:
+	pr_err("Cannot mark aggregate %s members as duplicated: %s\n",
+	       dwarf_diename(die), dwarf_errmsg(dwarf_errno()));
+	exit(1);
+}
+
+/*
+ * Determine if a type is a named struct, union, or enum.
+ *
+ * A type_id() callback.
+ */
+static void is_named_struct_union_enum(Dwarf_Die *die, const char *unused,
+				       struct die_override *overrides,
+				       void *data)
+{
+	int *is_sou = data;
+
+	if (((dwarf_tag(die) == DW_TAG_structure_type) ||
+	     (dwarf_tag(die) == DW_TAG_union_type) ||
+	     (dwarf_tag(die) == DW_TAG_enumeration_type)) &&
+	    (private_dwarf_hasattr(die, DW_AT_name)))
+		*is_sou = 1;
+}
+
+/*
+ * Duplicate detection alias fixup pass.  Once the first pass is complete, we
+ * may have marked an opaque 'struct/union/enum foo' for sharing but not caught
+ * the non-opaque instance, because no users of the non-opaque instance appeared
+ * in the DWARF after the opaque copy was detected as a duplicate.  This pass
+ * detects such cases, and marks their members as duplicates too.
+ *
+ * (The inverse case of a non-opaque structure/union/enum detected as a
+ * duplicate after the last usage of its opaque alias will be caught by this
+ * trap too.)
+ *
+ * Warning: this routine directly computes type_id()s without access to the
+ * corresponding type DIE, and as such is dependent on the format of type_id()s.
+ * (This is why it must run over non-opaque structures: given a non-opaque
+ * structure, its opaque alias is easy to compute, but the converse is not
+ * true.)
+ *
+ * As a list_filter() filter function, returns nonzero if this structure will
+ * not need to be checked again (because both its opaque and transparent
+ * variants are shared).
+ */
+static int dedup_alias_fixup(void *id_file_data, void *data)
+{
+	struct dedup_id_file *id_file = id_file_data;
+	struct dedup_state *state = data;
+
+	int transparent_shared = 0;
+	int opaque_shared = 0;
+	int made_shared = 0;
+
+	char *opaque_id;
+	const char *line_num;
+	const char *type_size;
+	const char *type_name;
+
+	/*
+	 * Compute the opaque variant corresponding to this transparent type,
+	 * and check to see if either is marked shared, then find the DIE and
+	 * mark both as shared if either is.  (Unfortunately this means a double
+	 * recursion in such cases, but this is unavoidable.)
+	 */
+
+	line_num = strstr(id_file->id, "//");
+	if (!line_num) {
+		pr_err("Internal error: type ID %s is corrupt.\n",
+		       id_file->id);
+		exit(1);
+	}
+
+	type_size = strstr(line_num + 2, "//");
+	if (!type_size) {
+		pr_err("Internal error: type ID %s is corrupt.\n",
+		       id_file->id);
+		exit(1);
+	}
+
+	type_name = strstr(type_size + 2, "//");
+	if (!type_name) {
+		/*
+		 * That's OK: the type size is optional, so what we thought was
+		 * the type size is actually the type name.
+		 */
+		type_name = type_size;
+	}
+	type_name += 2;
+
+	opaque_id = xstrdup("////");
+	opaque_id = str_append(opaque_id, type_name);
+
+	const char *transparent_module = g_hash_table_lookup(id_to_module,
+							     id_file->id);
+	const char *opaque_module = g_hash_table_lookup(id_to_module,
+							opaque_id);
+
+	transparent_shared = ((transparent_module != NULL) &&
+			      (strcmp(transparent_module, "shared_ctf") == 0));
+
+	opaque_shared = ((opaque_module != NULL) &&
+			 (strcmp(opaque_module, "shared_ctf") == 0));
+
+	/*
+	 * Transparent type needs sharing.
+	 */
+	if (opaque_shared && !transparent_shared) {
+		Dwarf_Die die;
+		Dwfl_Module *mod;
+		Dwarf_Addr dummy;
+
+		/*
+		 * Since we are not using process_file(), we must handle
+		 * translation unit switches by hand, including resetting
+		 * structs_seen.  We also need to open the DWARF file, since
+		 * type_id() needs access to the DIE of this type and all its
+		 * dependent types as well.
+		 */
+
+		if (state->dwfl != NULL &&
+		    strcmp(state->dwfl_file_name, id_file->file_name) != 0)
+			dedup_dwarf_free(state);
+
+		if (state->dwfl_file_name == NULL) {
+			state->dwfl = simple_dwfl_new(id_file->file_name, &mod);
+			state->dwarf = dwfl_module_getdwarf(mod, &dummy);
+			state->dwfl_file_name = xstrdup(id_file->file_name);
+			if (state->structs_seen)
+				g_hash_table_destroy(state->structs_seen);
+			state->structs_seen = g_hash_table_new(g_str_hash,
+							       g_str_equal);
+		}
+		if (!dwarf_offdie(state->dwarf, id_file->dieoff,
+				  &die)) {
+			pr_err("Cannot look up offset %li in %s for type with ID %s\n",
+			       id_file->dieoff, id_file->file_name, id_file->id);
+			exit(1);
+		}
+		mark_shared(&die, NULL, NULL, state);
+		made_shared = 1;
+	}
+
+	/*
+	 * We don't have the opaque type's DIE, so we can't use mark_shared():
+	 * this is also good since this triggers another duplicate detection
+	 * pass, and we don't want to trigger another pass merely because of a
+	 * nonshared opaque type (since they don't have members that may have
+	 * structure or union type themselves and thus force more unshared
+	 * types to become shared).
+	 *
+	 * Instead, do it by hand: this is simple, as member recursion is
+	 * guaranteed not to be required for an opaque type.
+	 */
+	if (transparent_shared && !opaque_shared) {
+		dw_ctf_trace("Marking %s as duplicate\n", opaque_id);
+		g_hash_table_replace(id_to_module, intern(xstrdup(opaque_id)),
+				     xstrdup("shared_ctf"));
+		made_shared = 1;
+	}
+
+	free(opaque_id);
+
+	return made_shared || (opaque_shared && transparent_shared);
+}
+
+/*
+ * Mark a basic type shared by name and intern it in all relevant hashes.  (Used
+ * for marking basic types we don't have a DIE for.)
+ */
+static void mark_shared_by_name(ctf_file_t *ctf, ctf_id_t ctf_id,
+				const char *name)
+{
+	struct ctf_full_id static_ctf_id = { ctf, ctf_id };
+	struct ctf_full_id *full_ctf_id;
+	char *id = NULL;
+
+	full_ctf_id = malloc(sizeof(struct ctf_full_id));
+	if (full_ctf_id == NULL) {
+		pr_err("%s: out of memory\n", __func__);
+		exit(1);
+	}
+	*full_ctf_id = static_ctf_id;
+
+	id = str_appendn(id, "////", name, " ", NULL);
+#ifdef DEBUG
+	strcpy(full_ctf_id->module_name, "shared_ctf");
+	strcpy(full_ctf_id->file_name, "<built-in type>");
+#endif
+	g_hash_table_replace(id_to_module, intern(xstrdup(id)), xstrdup("shared_ctf"));
+	g_hash_table_replace(id_to_type, intern(id), full_ctf_id);
+}
+
+/*
+ * Type assembly.
+ *
+ * Given a DWARF DIE corresponding to a top-level type, call the appropriate
+ * construction function, passing it the appropriate ctf_file_t, constructing it
+ * if necessary, and stashing them in the appropriate hashes.  Return the
+ * ctf_file_t and ctf_id_t of this type.
+ *
+ * Indirectly recursively called for types depending on other types, and for
+ * the types of variables (which for the sake of argument we call 'types' here
+ * too, since we treat them exactly like types, and dealing with types is our
+ * most important function).  In such calls, the module_name may be 'shared_ctf'
+ * if this type is in the shared CTF repository.
+ *
+ * Select properties of the DIE can be overridden via the overrides array, if
+ * needed.
+ */
+static struct ctf_full_id *construct_ctf_id(const char *module_name,
+					    const char *file_name,
+					    Dwarf_Die *die,
+					    Dwarf_Die *parent_die,
+					    struct die_override *overrides)
+{
+	char *id = type_id(die, overrides, NULL, NULL);
+	char *ctf_module;
+	ctf_file_t *ctf;
+	ctf_snapshot_id_t snapshot;
+
+	dw_ctf_trace("    %p: %s: looking up %s: %s\n", &id,
+		     module_name ? module_name : "(no module)",
+		     dwarf_diename(die), id);
+	/*
+	 * Make sure this type does not already exist.  (Recursive chasing for
+	 * referenced types can lead to construct_ctf() being called on them
+	 * more than once.)
+	 */
+	struct ctf_full_id *ctf_id;
+
+	ctf_id = g_hash_table_lookup(id_to_type, id);
+	if (ctf_id != NULL) {
+		dw_ctf_trace("    %p: %p:%i found in module %s, file %s\n", &id,
+			     ctf_id->ctf_file, (int) ctf_id->ctf_id,
+			     ctf_id->module_name, ctf_id->file_name);
+		free(id);
+		return ctf_id;
+	}
+
+	/*
+	 * Create the CTF file for this type, if it does not exist.  Verify that
+	 * the duplicate-detection pass scanned this type, and that this is
+	 * either the current module or the shared CTF module.
+	 */
+
+	ctf_module = g_hash_table_lookup(id_to_module, id);
+
+	if (ctf_module == NULL) {
+		pr_err("Internal error: within file %s, module %s, type at DIE offset %lx\n"
+		       "with ID %s was not already noted by dedup().\n",
+		       file_name, module_name, DIEOFFSET(die), id);
+		pr_err("dedup() is probably buggy.\n");
+		exit(1);
+	}
+
+	if ((strcmp(ctf_module, module_name) != 0) &&
+	    (strcmp(ctf_module, "shared_ctf") != 0)) {
+		pr_err("Internal error: within file %s, module %s, type at DIE offset %lx\n"
+		       "with ID %s is in a different non-shared module, %s.\n",
+		       file_name, module_name, DIEOFFSET(die), id, ctf_module);
+		pr_err("dedup() is probably buggy.\n");
+		exit(1);
+	}
+
+	ctf = lookup_ctf_file(ctf_module);
+
+	/*
+	 * Construct the CTF, then insert the top-level CTF entity into the
+	 * id->type hash so that references from other types can find it, and
+	 * update the CTF container.  If conversion failed, roll back all
+	 * changes made since the last successful call to this function.
+	 *
+	 * NOTE: references within DWARF to non-top-level types will currently
+	 * fail, but I'm not sure if these can exist.  (The type ID
+	 * representation implicitly assumes that they cannot.)
+	 */
+
+	snapshot = ctf_snapshot(ctf);
+
+	enum skip_type skip = SKIP_CONTINUE;
+
+	dw_ctf_trace("%p: into die_to_ctf() for %s\n", &id, id);
+	ctf_id_t this_ctf_id = die_to_ctf(ctf_module, file_name, die,
+					  parent_die, ctf, -1, overrides,
+					  1, 0, &skip, NULL, id);
+	dw_ctf_trace("%p: out of die_to_ctf()\n", &id);
+
+	ctf_id = malloc(sizeof(struct ctf_full_id));
+	if (ctf_id == NULL) {
+		pr_err("Out of memory\n");
+		exit(1);
+	}
+
+	if (skip != SKIP_ABORT) {
+		ctf_id->ctf_file = ctf;
+		ctf_id->ctf_id = this_ctf_id;
+#ifdef DEBUG
+		strcpy(ctf_id->module_name, ctf_module);
+		strcpy(ctf_id->file_name, file_name);
+#endif
+		dw_ctf_trace("    %lx: %s: new type added, CTF ID %p:%li\n",
+			     DIEOFFSET(die), id, ctf_id->ctf_file,
+			     ctf_id->ctf_id);
+
+                g_hash_table_replace(id_to_type, intern(id), ctf_id);
+	} else {
+		/*
+		 * Failure.  Remove the type from the id_to_type mapping, if it
+		 * is there, and discard any added types from the CTF.
+		 *
+		 * If we have had to ctf_update() due to a new type getting
+		 * used, the rollback will fail: discard instead. It might leave
+		 * some spurious types hanging around but it will clean up as
+		 * much as we can at this point.  (This cannot happen when
+		 * LIBDTRACE_CTF_OMISSIBLE_CTF_UPDATE, but it costs nothing to
+		 * leave in: failure is a rare case.)
+		 */
+
+		if (ctf_rollback(ctf, snapshot) < 0)
+			if (ctf_errno(ctf) == ECTF_OVERROLLBACK)
+				ctf_discard(ctf);
+
+		free(ctf_id);
+		ctf_id = NULL;
+
+		g_hash_table_remove(id_to_type, id);
+		free(id);
+
+		dw_ctf_trace("    %p: (failure)\n", &id);
+	}
+
+	return ctf_id;
+}
+
+/*
+ * Given a DWARF DIE corresponding to a top-level type, or to an aggregate
+ * member, and the ctf_file_t where it is to be placed, call the appropriate
+ * construction function to place it and (for aggregates) its siblings there,
+ * recursing to handle contained aggregates.
+ *
+ * The parameters to this function are:
+ *
+ * module_name: The kernel module.
+ * file_name: The object file.
+ * die: The DWARF DIE.
+ * parent_die: Its parent, i.e. if a structure member, this is a structure: if
+ * top-level, this is a CU DIE.
+ * ctf: The CTF file this object should go into (possibly shared_ctf).
+ * parent_ctf_id: The CTF ID of the parent DIE, or -1 if none.
+ * struct die_override: Overrides for DWARF attributes (a NULL-terminated array,
+ * or NULL).
+ * top_level_type: 1 if this is a top-level type that can have a name and be
+ * referred to by other types.
+ * backwards: if 1, this is an internal call to process a series of bitfields
+ *            with descending bit_offset and identical data_member_location.
+ * skip: The error-handling / skipping enum.
+ * replace: if 1, this type should replace its parent type entirely.
+ * id: the ID of this type.
+ *
+ * Note: id is only defined when top_level_type is 1.  (We never use it
+ * in other situations, and computing it is quite expensive.)
+ */
+static ctf_id_t die_to_ctf(const char *module_name, const char *file_name,
+			   Dwarf_Die *die, Dwarf_Die *parent_die,
+			   ctf_file_t *ctf, ctf_id_t parent_ctf_id,
+			   struct die_override *overrides, int top_level_type,
+			   int backwards, enum skip_type *skip, int *replace,
+			   const char *id)
+{
+	int sib_ret = 0;
+	ctf_id_t this_ctf_id;
+	int dummy;
+
+	do {
+		const char *id_name;
+		const char *decl_file_name = dwarf_decl_file(die);
+		int decl_line_num;
+		int emitted_backwards = 0;
+		char locerrstr[1024];
+		Dwarf_Die next_die;
+
+		/*
+		 * If the next DWARF DIE is at the same location as this one but
+		 * with a lower bit_offset, we need to process the set of DIEs
+		 * at this location in *reverse*, because DWARF has the DIEs in
+		 * declaration order, while CTF wants them in in-memory order:
+		 * so recurse to handle the next until we get to an element with
+		 * a sibling at a different data_member_location (safe because
+		 * there can't be that many of them per data_member_location),
+		 * then (at the end of die_to_ctf()) exit the recursion and skip
+		 * over the lot.
+		 *
+		 * We can ignore 'replace' and the return value of die_to_ctf
+		 * because bitfields must be structure or union members and
+		 * cannot be array dimensions.
+		 */
+		if (die_emit_next_backwards(&next_die, die,
+					    overrides) != NULL) {
+			ctf_id_t dummy;
+
+			dw_ctf_trace("Emitting %s:%s:%lx backwards\n",
+				     module_name, file_name,
+				     DIEOFFSET(&next_die));
+
+			dummy = die_to_ctf(module_name, file_name, &next_die,
+					   parent_die, ctf, parent_ctf_id,
+					   overrides, top_level_type, 1, skip,
+					   replace, NULL);
+			if (*skip == SKIP_ABORT)
+				return dummy;
+			emitted_backwards = 1;
+		}
+
+		/*
+		 * Compute a name for our current location, for error messages.
+		 * (The type representation could be used, but is likely to be
+		 * hard for users to comprehend, and should we move to a hashed
+		 * representation would be entirely useless for this purpose.)
+		 */
+		if ((decl_file_name == NULL) ||
+		    (dwarf_decl_line(die, &decl_line_num) < 0)) {
+			decl_file_name = "global";
+			decl_line_num = 0;
+		}
+
+		id_name = dwarf_diename(die);
+		if (id_name == NULL)
+			id_name = "(unnamed type)";
+
+		snprintf(locerrstr, sizeof(locerrstr), "%s:%i:%s",
+			 decl_file_name, decl_line_num, id_name);
+
+		dw_ctf_trace("Working over %s:%s:%s:%lx:%x with CTF file %p\n",
+			     module_name, file_name,
+			     dwarf_diename(die)==NULL?"NULL":dwarf_diename(die),
+			     DIEOFFSET(die), dwarf_tag(die), ctf);
+
+		/*
+		 * Only process a given node, or its children, if we know how to
+		 * do so.
+		 */
+		if ((dwarf_tag(die) >= assembly_len) ||
+		    (assembly_tab[dwarf_tag(die)] == NULL)) {
+			pr_err("%s:%i: warning: skipping identifier "
+			       "%s with unknown DWARF tag %lx.\n",
+			       decl_file_name, decl_line_num, id_name,
+			       (unsigned long) dwarf_tag(die));
+			return -1;
+		}
+
+		*skip = SKIP_CONTINUE;
+
+		this_ctf_id = assembly_tab[dwarf_tag(die)](module_name,
+							   file_name,
+							   die, parent_die,
+							   ctf, parent_ctf_id,
+							   locerrstr,
+							   overrides,
+							   top_level_type,
+							   skip,
+							   replace ? replace :
+							   &dummy);
+		dw_ctf_trace("%s: out of assembly function for tag %lx with type ID %li\n",
+			     locerrstr, (unsigned long) dwarf_tag(die),
+			     this_ctf_id);
+
+		if (this_ctf_id < 0) {
+			if ((this_ctf_id == CTF_NO_ERROR_REPORTED) &&
+			    (ctf_errno(ctf) != 0))
+				pr_err("%s: CTF error in assembly of item with tag %i: %s\n",
+				       locerrstr, dwarf_tag(die),
+				       ctf_errmsg(ctf_errno(ctf)));
+
+			num_errors++;
+#ifdef DEBUG
+			exit(1);
+#endif
+			*skip = SKIP_ABORT;
+		}
+
+		/*
+		 * Add newly-added non-skipped top-level structure or union CTF
+		 * IDs to the type table at once.  This allows circular type
+		 * references via pointers in structure/union member DIEs to be
+		 * looked up correctly.
+		 */
+		if (top_level_type && (*skip == SKIP_CONTINUE) &&
+		    ((dwarf_tag(die) == DW_TAG_structure_type) ||
+		     (dwarf_tag(die) == DW_TAG_union_type))) {
+			struct ctf_full_id full_ctf_id = { ctf, this_ctf_id };
+			struct ctf_full_id *ctf_id;
+
+#ifdef DEBUG
+			strcpy(full_ctf_id.module_name, module_name);
+			strcpy(full_ctf_id.file_name, file_name);
+#endif
+
+			ctf_id = malloc(sizeof(struct ctf_full_id));
+			if (ctf_id == NULL) {
+				fprintf(stderr,
+					"Out of memory allocating type ID\n");
+				exit(1);
+			}
+
+			dw_ctf_trace("    %s: immediate addition of %s, CTF ID "
+				     "%p:%li in module %s, file %s\n", __func__,
+				     id, full_ctf_id.ctf_file, full_ctf_id.ctf_id,
+				     module_name, file_name);
+			*ctf_id = full_ctf_id;
+
+			g_hash_table_replace(id_to_type, intern(xstrdup(id)),
+					     ctf_id);
+		}
+
+		/*
+		 * Recurse to handle contained DIEs.
+		 */
+
+		if ((dwarf_haschildren(die)) && (*skip == SKIP_CONTINUE)) {
+			Dwarf_Die child_die;
+			ctf_id_t new_id;
+			int replace = 0;
+
+			if (dwarf_child(die, &child_die) < 0) {
+				pr_err("%s: Cannot recurse to DWARF DIE children: %s\n",
+				       locerrstr, dwarf_errmsg(dwarf_errno()));
+				exit(1);
+			}
+
+			new_id = die_to_ctf(module_name, file_name, &child_die,
+					    die, ctf, this_ctf_id, overrides, 0,
+					    0, skip, &replace, NULL);
+			if (replace)
+				this_ctf_id = new_id;
+		}
+
+		/*
+		 * If we are walking backwards over a bunch of bitfields, this
+		 * is a recursive walk, not an iterative one: return.
+		 */
+		if (backwards)
+			return this_ctf_id;
+
+		/*
+		 * We are not walking backwards, but this is the final stage of
+		 * a bunch of backwards emissions: walk forwards until we hit
+		 * the last one again.
+		 */
+		if (emitted_backwards)
+			while (die_emit_next_backwards(&next_die, die,
+						       overrides) != NULL)
+				*die = next_die;
+
+		/*
+		 * Walk siblings of non-top-level types only: the sibling walk
+		 * of top-level types is done by process_file(), so that
+		 * construct_ctf_id() gets a chance to put each such type in the
+		 * right CTF file.
+		 */
+	} while (*skip != SKIP_ABORT && !top_level_type &&
+		 (sib_ret = dwarf_siblingof(die, die)) == 0);
+
+	if (sib_ret == -1) {
+		pr_err("In module %s, failure walking the sibling list: %s\n",
+		       module_name, dwarf_errmsg(dwarf_errno()));
+		exit(1);
+	}
+
+	dw_ctf_trace("New type ID: %p:%li\n", ctf, this_ctf_id);
+	return this_ctf_id;
+}
+
+/*
+ * Calls construct_ctf_id() and throws the ID away.  Used as a process_file()
+ * callback.
+ */
+static void construct_ctf(const char *module_name, const char *file_name,
+			  Dwarf_Die *die, Dwarf_Die *parent_die,
+			  void *unused __unused__)
+{
+	construct_ctf_id(module_name, file_name, die, parent_die, NULL);
+}
+
+/*
+ * Return the next DIE, if that DIE needs to be emitted before this one.
+ */
+static Dwarf_Die *die_emit_next_backwards(Dwarf_Die *next, Dwarf_Die *die,
+					  struct die_override *overrides)
+{
+	if (dwarf_tag(die) == DW_TAG_member &&
+	    dwarf_siblingof(die, next) == 0 &&
+	    dwarf_tag(next) == DW_TAG_member &&
+	    private_dwarf_hasattr(die, DW_AT_data_member_location) &&
+	    private_dwarf_hasattr(next, DW_AT_data_member_location) &&
+	    private_dwarf_udata(die, DW_AT_data_member_location, overrides) ==
+	    private_dwarf_udata(next, DW_AT_data_member_location, overrides) &&
+	    private_dwarf_hasattr(die, DW_AT_bit_offset) &&
+	    private_dwarf_hasattr(next, DW_AT_bit_offset) &&
+	    private_dwarf_udata(die, DW_AT_bit_offset, overrides) >
+	    private_dwarf_udata(next, DW_AT_bit_offset, overrides))
+		return next;
+	return NULL;
+}
+
+/*
+ * Look up a type through its reference: return its ctf_id, or recursively
+ * construct it if need be.
+ */
+static ctf_id_t lookup_ctf_type(const char *module_name, const char *file_name,
+				Dwarf_Die *die, ctf_file_t *ctf,
+				struct die_override *overrides,
+				const char *locerrstr)
+{
+	Dwarf_Die tmp;
+	Dwarf_Die *type_die = private_dwarf_type(die, &tmp);
+	Dwarf_Die cu_die;
+	struct ctf_full_id *type_ref;
+
+	/*
+	 * Pointers to functions and void are special cases: there is only one
+	 * of each of these in CTF, so we can use global singletons.
+	 */
+
+	if (type_die == NULL)
+		return ctf_void_type;
+
+	if (dwarf_tag(type_die) == DW_TAG_subroutine_type)
+		return ctf_funcptr_type;
+
+	/*
+	 * Look up or construct CTF for this type.
+	 */
+
+	dwarf_diecu(type_die, &cu_die, NULL, NULL);
+
+	dw_ctf_trace("    %s: Looking up dependent type at offset %lx for type %s at module %s, file %s\n",
+		     locerrstr, DIEOFFSET(type_die),
+		     dwarf_diename(die) ? dwarf_diename(die) : "NULL",
+		     module_name, file_name);
+
+	type_ref = construct_ctf_id(module_name, file_name,
+				    type_die, &cu_die, overrides);
+
+	/*
+	 * Pass any error back up.
+	 */
+	if (type_ref == NULL) {
+		pr_err("%s: type lookup failed.\n", locerrstr);
+		return -1;
+	}
+
+	if ((type_ref->ctf_file != ctf) &&
+	    type_ref->ctf_file != lookup_ctf_file("shared_ctf")) {
+#ifdef DEBUG
+		pr_err("%s: Internal error: lookup of %s found in different file: "
+		       "%s/%s versus %s/%s.\n", locerrstr,
+		       dwarf_diename(die) ? dwarf_diename(die) : "(unnamed)",
+		       type_ref->module_name, type_ref->file_name,
+		       module_name, file_name);
+#else
+		pr_err("%s: Internal error: lookup of %s found in different file.\n",
+		       locerrstr, dwarf_diename(die) ? dwarf_diename(die) :
+		       "(unnamed)");
+#endif
+		pr_err("dedup() is probably buggy.\n");
+		exit(1);
+	}
+
+	return type_ref->ctf_id;
+}
+
+/* Assembly functions.  */
+
+#define CTF_DW_ENFORCE(attribute) do					\
+		if (!private_dwarf_hasattr(die, (DW_AT_##attribute))) {	\
+			pr_err("%s: %s: %lx: skipping type, %s attribute not present.\n", \
+			       locerrstr, __func__,  DIEOFFSET(die),	\
+			       #attribute);				\
+			*skip = SKIP_ABORT;				\
+			return CTF_ERROR_REPORTED;			\
+		}							\
+	while (0)
+
+#define CTF_DW_ENFORCE_NOT(attribute) do				\
+		if (private_dwarf_hasattr(die, (DW_AT_##attribute))) {	\
+			pr_err("%s: %s: %lx: skipping type, %s attribute not supported.\n", \
+			       locerrstr, __func__, DIEOFFSET(die),	\
+			       #attribute);				\
+			*skip = SKIP_ABORT;				\
+			return CTF_ERROR_REPORTED;			\
+		}							\
+	while (0)
+
+#define ROOT_TYPE(x) (x) ? CTF_ADD_ROOT : CTF_ADD_NONROOT
+
+/*
+ * A CTF assembly filter function which excludes all types not at the global
+ * scope (i.e. whose immediate parent is not a CU DIE), and all types which
+ * reference a type which is not at the global scope (thus ruling out local type
+ * definitions for which the compiler is not consistently emitting all
+ * intermediate types at the local scope).
+ */
+static int filter_ctf_file_scope(const char *file_name, Dwarf *dwarf,
+				 Dwarf_Die *die, Dwarf_Die *parent_die)
+{
+	Dwarf_Die type_die;
+	GHashTable *parents;
+
+	/*
+	 * A type not dependent on another is acceptable iff it is at the global
+	 * scope.
+	 */
+	if (private_dwarf_type(die, &type_die) == NULL)
+		return (dwarf_tag(parent_die) == DW_TAG_compile_unit);
+
+	/*
+	 * No type we reference may have a subprogram DIE as any of its parents.
+	 */
+	parents = g_hash_table_lookup(fn_to_die_to_parent,
+				      abs_file_name(file_name));
+
+	do {
+		Dwarf_Die parent = type_die;
+		Dwarf_Off parent_off = 0;
+
+		do {
+			if (parent_off != 0 &&
+			    !dwarf_offdie(dwarf, parent_off, &parent))
+				break;
+			if (dwarf_tag(&parent) == DW_TAG_subprogram)
+				return 0;
+		} while ((parent_off = GPOINTER_TO_UINT(g_hash_table_lookup(parents,
+					  GUINT_TO_POINTER(dwarf_dieoffset(&parent)))))
+			!= 0);
+	} while (private_dwarf_type(&type_die, &type_die) != NULL);
+
+	return 1;
+}
+
+/*
+ * A CTF assembly filter function which excludes all names not at the global
+ * scope, and all names whose names are unlikely to be interesting.  (DTrace
+ * userspace contains a similar list, but the two lists need not be in sync.)
+ */
+static int filter_ctf_uninteresting(const char *file_name __unused__,
+				    Dwarf *dwarf __unused__,
+				    Dwarf_Die *die, Dwarf_Die *parent_die)
+{
+	const char *sym_name = dwarf_diename(die);
+
+	/*
+	 * 'Variables' with no name are not interesting.
+	 */
+	if (sym_name == NULL)
+		return 0;
+
+#define strstarts(var, x) (strncmp(var, x, strlen(x)) == 0)
+	return ((dwarf_tag(parent_die) == DW_TAG_compile_unit) &&
+		!((strcmp(sym_name, "__per_cpu_start") == 0) ||
+		  (strcmp(sym_name, "__per_cpu_end") == 0) ||
+		  (strcmp(sym_name, "_sdt_probes") == 0) ||
+		  (strstarts(sym_name, "__crc_")) ||
+		  (strstarts(sym_name, "__ksymtab_")) ||
+		  (strstarts(sym_name, "__kcrctab_")) ||
+		  (strstarts(sym_name, "__kstrtab_")) ||
+		  (strstarts(sym_name, "__param_")) ||
+		  (strstarts(sym_name, "__syscall_meta__")) ||
+		  (strstarts(sym_name, "__p_syscall_meta__")) ||
+		  (strstarts(sym_name, "__event_")) ||
+		  (strstarts(sym_name, "event_")) ||
+		  (strstarts(sym_name, "ftrace_event_")) ||
+		  (strstarts(sym_name, "types__")) ||
+		  (strstarts(sym_name, "args__")) ||
+		  (strstarts(sym_name, "__tracepoint_")) ||
+		  (strstarts(sym_name, "__tpstrtab_")) ||
+		  (strstarts(sym_name, "__tpstrtab__")) ||
+		  (strstarts(sym_name, "__initcall_")) ||
+		  (strstarts(sym_name, "__setup_")) ||
+		  (strstarts(sym_name, "__pci_fixup_")) ||
+		  (strstr(sym_name, ".") != NULL)));
+#undef strstarts
+}
+
+/*
+ * Assemble base types.
+ */
+static ctf_id_t assemble_ctf_base(const char *module_name,
+				  const char *file_name, Dwarf_Die *die,
+				  Dwarf_Die *parent_die, ctf_file_t *ctf,
+				  ctf_id_t parent_ctf_id, const char *locerrstr,
+				  struct die_override *overrides,
+				  int top_level_type, enum skip_type *skip,
+				  int *replace)
+{
+	typedef ctf_id_t (*ctf_add_fun)(ctf_file_t *, uint_t,
+					const char *, const ctf_encoding_t *);
+
+	const char *name = dwarf_diename(die);
+	Dwarf_Word encoding, size;
+	ctf_add_fun ctf_add_func;
+	ctf_encoding_t ctf_encoding;
+	size_t encoding_search;
+	struct die_override *bit_size_override, *bit_offset_override;
+
+	struct dwarf_encoding_tab {
+		Dwarf_Word encoding;
+		ctf_add_fun func;
+		uint_t encoding_fixed;
+		struct type_encoding_tab *size_lookup;
+	};
+
+	struct type_encoding_tab float_encoding[] = {
+		{sizeof(float), CTF_FP_SINGLE },
+		{sizeof(double), CTF_FP_DOUBLE },
+		{sizeof(long double), CTF_FP_LDOUBLE },
+		{0, 0}
+	};
+
+	struct type_encoding_tab float_cplx_encoding[] = {
+		{sizeof(float), CTF_FP_CPLX },
+		{sizeof(double), CTF_FP_DCPLX },
+		{sizeof(long double), CTF_FP_LDCPLX },
+		{0, 0}
+	};
+
+	struct type_encoding_tab float_imagry_encoding[] = {
+		{sizeof(float), CTF_FP_IMAGRY },
+		{sizeof(double), CTF_FP_DIMAGRY },
+		{sizeof(long double), CTF_FP_LDIMAGRY },
+		{0, 0}
+	};
+
+	struct dwarf_encoding_tab all_encodings[] = {
+		{DW_ATE_boolean, ctf_add_integer, CTF_INT_BOOL, NULL},
+		{DW_ATE_signed, ctf_add_integer, CTF_INT_SIGNED, NULL},
+		{DW_ATE_signed_char, ctf_add_integer,
+		 CTF_INT_SIGNED | CTF_INT_CHAR, NULL},
+		{DW_ATE_unsigned, ctf_add_integer, 0, NULL},
+		{DW_ATE_unsigned_char, ctf_add_integer, CTF_INT_CHAR, NULL},
+		{DW_ATE_float, ctf_add_float, 0, float_encoding},
+		{DW_ATE_complex_float, ctf_add_float, 0, float_cplx_encoding},
+		{DW_ATE_imaginary_float, ctf_add_float, 0,
+		 float_imagry_encoding},
+		{0, 0, 0, 0}
+	};
+
+	CTF_DW_ENFORCE(name);
+	CTF_DW_ENFORCE(encoding);
+	CTF_DW_ENFORCE(byte_size);
+	CTF_DW_ENFORCE_NOT(endianity);
+
+	encoding = private_dwarf_udata(die, DW_AT_encoding, overrides);
+	size = private_dwarf_udata(die, DW_AT_byte_size, overrides);
+
+	for (encoding_search = 0; all_encodings[encoding_search].func != 0;
+	     encoding_search++) {
+		if (all_encodings[encoding_search].encoding == encoding) {
+			ctf_add_func = all_encodings[encoding_search].func;
+			if (all_encodings[encoding_search].size_lookup != NULL)
+				ctf_encoding.cte_format =
+					find_ctf_encoding(all_encodings[encoding_search].size_lookup,
+							  size);
+			else
+				ctf_encoding.cte_format =
+					all_encodings[encoding_search].encoding_fixed;
+			break;
+		}
+	}
+
+	if (all_encodings[encoding_search].func == 0) {
+		pr_err("%s: skipping type, base type %li not yet implemented.\n",
+		       locerrstr, (long) encoding);
+		*skip = SKIP_ABORT;
+		return CTF_ERROR_REPORTED;
+	}
+
+	/*
+	 * Handle bitfields.  Only look at overrides, since bitfields can only
+	 * be members of structures in C, thus derived from the referencing DIE.
+	 * Bitfields are never top-level types in C, even though they are in
+	 * DWARF.
+	 */
+	bit_size_override = private_find_override(die, DW_AT_bit_size,
+						  overrides);
+	bit_offset_override = private_find_override(die, DW_AT_bit_offset,
+						    overrides);
+	if (bit_size_override) {
+		ctf_encoding.cte_bits = bit_size_override->value;
+		top_level_type = 0;
+	} else
+		ctf_encoding.cte_bits = size * 8;
+
+	if (bit_offset_override) {
+#if __BYTE_ORDER == __BIG_ENDIAN
+		ctf_encoding.cte_offset = bit_offset_override->value;
+#else
+		/*
+		 * The figure here counts from the left to the leftmost edge of
+		 * the bitfield: we want to count from the right to the
+		 * rightmost edge.
+		 */
+		ctf_encoding.cte_offset = (size * 8) -
+			bit_offset_override->value - ctf_encoding.cte_bits;
+		dw_ctf_trace("Endianizing cte_offset from %x to %x\n",
+			     (unsigned int) bit_offset_override->value,
+			     ctf_encoding.cte_offset);
+#endif
+	} else
+		ctf_encoding.cte_offset = 0;
+
+#ifdef DEBUG
+	if (bit_size_override || bit_offset_override)
+		dw_ctf_trace("Bitfield overrides: bit size %i; bit offset %i\n",
+			     ctf_encoding.cte_bits, ctf_encoding.cte_offset);
+#endif
+
+	return ctf_add_func(ctf, ROOT_TYPE(top_level_type), name,
+			    &ctf_encoding);
+}
+
+/*
+ * Assemble pointer types.
+ */
+static ctf_id_t assemble_ctf_pointer(const char *module_name,
+				     const char *file_name,
+				     Dwarf_Die *die, Dwarf_Die *parent_die,
+				     ctf_file_t *ctf, ctf_id_t parent_ctf_id,
+				     const char *locerrstr,
+				     struct die_override *overrides,
+				     int top_level_type,
+				     enum skip_type *skip, int *replace)
+{
+	ctf_id_t type_ref;
+
+	type_ref = lookup_ctf_type(module_name, file_name, die, ctf,
+				   overrides, locerrstr);
+	if (type_ref < 0) {
+		*skip = SKIP_ABORT;
+		return CTF_ERROR_REPORTED;
+	}
+
+	/*
+	 * Pointers to functions are all the same type in CTF: don't bother
+	 * adding it over again.
+	 */
+	if (type_ref == ctf_funcptr_type)
+		return type_ref;
+
+	return ctf_add_pointer(ctf, ROOT_TYPE(top_level_type), type_ref);
+}
+
+/*
+ * Assemble array types.  This function looks up the array type, but does not do
+ * any array construction: that is left to assemble_ctf_array_dimension().
+ */
+static ctf_id_t assemble_ctf_array(const char *module_name,
+				   const char *file_name, Dwarf_Die *die,
+				   Dwarf_Die *parent_die, ctf_file_t *ctf,
+				   ctf_id_t parent_ctf_id,
+				   const char *locerrstr,
+				   struct die_override *overrides,
+				   int top_level_type,
+				   enum skip_type *skip, int *replace)
+{
+	ctf_id_t type_ref;
+
+	CTF_DW_ENFORCE_NOT(ordering);
+	CTF_DW_ENFORCE_NOT(bit_stride);
+	CTF_DW_ENFORCE_NOT(byte_stride);
+
+	type_ref = lookup_ctf_type(module_name, file_name, die, ctf,
+				   overrides, locerrstr);
+	if (type_ref < 0) {
+		*skip = SKIP_ABORT;
+		return CTF_ERROR_REPORTED;
+	}
+	return type_ref;
+}
+
+/*
+ * Assemble an array dimension, wrapping an array round the parent_ctf_id and
+ * replacing it.
+ */
+static ctf_id_t assemble_ctf_array_dimension(const char *module_name,
+					     const char *file_name,
+					     Dwarf_Die *die,
+					     Dwarf_Die *parent_die,
+					     ctf_file_t *ctf,
+					     ctf_id_t parent_ctf_id,
+					     const char *locerrstr,
+					     struct die_override *overrides,
+					     int top_level_type,
+					     enum skip_type *skip,
+					     int *replace)
+{
+	ctf_arinfo_t arinfo;
+
+	CTF_DW_ENFORCE_NOT(bit_size);
+	CTF_DW_ENFORCE_NOT(byte_size);
+	CTF_DW_ENFORCE_NOT(bit_stride);
+	CTF_DW_ENFORCE_NOT(byte_stride);
+	CTF_DW_ENFORCE_NOT(lower_bound);
+	CTF_DW_ENFORCE_NOT(threads_scaled);
+
+	arinfo.ctr_contents = parent_ctf_id;
+
+	arinfo.ctr_index = lookup_ctf_type(module_name, file_name,
+					   die, ctf, overrides, locerrstr);
+	if (arinfo.ctr_index < 0) {
+		*skip = SKIP_ABORT;
+		return CTF_ERROR_REPORTED;
+	}
+
+	arinfo.ctr_nelems = private_subrange_dimensions(die);
+
+	/*
+	 * For each array dimension, construct an appropriate array of the
+	 * type-so-far, overriding the parent type.
+	 */
+
+	*replace = 1;
+	return ctf_add_array(ctf, ROOT_TYPE(top_level_type), &arinfo);
+}
+
+/*
+ * Assemble an enumeration.
+ */
+static ctf_id_t assemble_ctf_enumeration(const char *module_name,
+					 const char *file_name,
+					 Dwarf_Die *die,
+					 Dwarf_Die *parent_die,
+					 ctf_file_t *ctf,
+					 ctf_id_t parent_ctf_id,
+					 const char *locerrstr,
+					 struct die_override *overrides,
+					 int top_level_type,
+					 enum skip_type *skip,
+					 int *replace)
+{
+	const char *name = dwarf_diename(die);
+
+	return ctf_add_enum(ctf, ROOT_TYPE(top_level_type), name);
+}
+
+/*
+ * Assemble an enumeration value.
+ */
+static ctf_id_t assemble_ctf_enumerator(const char *module_name,
+					const char *file_name,
+					Dwarf_Die *die,
+					Dwarf_Die *parent_die,
+					ctf_file_t *ctf,
+					ctf_id_t parent_ctf_id,
+					const char *locerrstr,
+					struct die_override *overrides,
+					int top_level_type,
+					enum skip_type *skip,
+					int *replace)
+{
+	const char *name = dwarf_diename(die);
+	Dwarf_Word value;
+	int err;
+
+	CTF_DW_ENFORCE(name);
+	CTF_DW_ENFORCE(const_value);
+	CTF_DW_ENFORCE_NOT(bit_stride);
+	CTF_DW_ENFORCE_NOT(byte_stride);
+
+	value = private_dwarf_udata(die, DW_AT_const_value, overrides);
+	err = ctf_add_enumerator(ctf, parent_ctf_id, name, value);
+
+	if (err != 0)
+		return err;
+
+	return parent_ctf_id;
+}
+
+/*
+ * Assemble a typedef.
+ */
+static ctf_id_t assemble_ctf_typedef(const char *module_name,
+				     const char *file_name,
+				     Dwarf_Die *die,
+				     Dwarf_Die *parent_die,
+				     ctf_file_t *ctf,
+				     ctf_id_t parent_ctf_id,
+				     const char *locerrstr,
+				     struct die_override *overrides,
+				     int top_level_type,
+				     enum skip_type *skip,
+				     int *replace)
+{
+	const char *name = dwarf_diename(die);
+	ctf_id_t type_ref;
+
+	CTF_DW_ENFORCE(name);
+
+	type_ref = lookup_ctf_type(module_name, file_name, die, ctf,
+				   overrides, locerrstr);
+	if (type_ref < 0) {
+		*skip = SKIP_ABORT;
+		return CTF_ERROR_REPORTED;
+	}
+
+	return ctf_add_typedef(ctf, ROOT_TYPE(top_level_type), name, type_ref);
+}
+
+/*
+ * Assemble a const/volatile/restrict qualifier.
+ */
+static ctf_id_t assemble_ctf_cvr_qual(const char *module_name,
+				      const char *file_name,
+				      Dwarf_Die *die,
+				      Dwarf_Die *parent_die,
+				      ctf_file_t *ctf,
+				      ctf_id_t parent_ctf_id,
+				      const char *locerrstr,
+				      struct die_override *overrides,
+				      int top_level_type,
+				      enum skip_type *skip,
+				      int *replace)
+{
+	ctf_id_t (*ctf_cvr_fun)(ctf_file_t *fp, uint_t flag, ctf_id_t ref);
+	ctf_id_t type_ref;
+
+	switch (dwarf_tag(die)) {
+	case DW_TAG_const_type: ctf_cvr_fun = ctf_add_const; break;
+	case DW_TAG_volatile_type: ctf_cvr_fun = ctf_add_volatile; break;
+	case DW_TAG_restrict_type: ctf_cvr_fun = ctf_add_restrict; break;
+	default:
+		pr_err("%s: internal error: assemble_ctf_cvr_qual() called with\n"
+		       "non-const/volatile/restrict: %i\n", locerrstr, dwarf_tag(die));
+		exit(1);
+	}
+
+	type_ref = lookup_ctf_type(module_name, file_name, die, ctf,
+				   overrides, locerrstr);
+	if (type_ref < 0) {
+		*skip = SKIP_ABORT;
+		return CTF_ERROR_REPORTED;
+	}
+
+	return ctf_cvr_fun(ctf, ROOT_TYPE(top_level_type), type_ref);
+}
+
+/*
+ * Assemble a structure or union type.  This assembles only the type itself, not
+ * its constituent members: that is done by assemble_ctf_su_member().
+ *
+ * We assume that if a structure or union type is discovered with more members
+ * than an earlier-discovered type, that it is compatible with that earlier type
+ * and a superset of it.
+ *
+ * FIXME: in debug mode we should not assume this.
+ */
+static ctf_id_t assemble_ctf_struct_union(const char *module_name,
+					  const char *file_name,
+					  Dwarf_Die *die,
+					  Dwarf_Die *parent_die,
+					  ctf_file_t *ctf,
+					  ctf_id_t parent_ctf_id,
+					  const char *locerrstr,
+					  struct die_override *overrides,
+					  int top_level_type,
+					  enum skip_type *skip,
+					  int *replace)
+{
+	ctf_id_t (*ctf_add_sou)(ctf_file_t *fp, uint_t flag, const char *name,
+				size_t size);
+
+	const char *name = dwarf_diename(die);
+	int is_union = (dwarf_tag(die) == DW_TAG_union_type);
+	struct ctf_memb_count *member_count = NULL;
+	ctf_id_t id;
+	long long size;
+
+	/*
+	 * FIXME: these both need handling for DWARF4 support.
+	 */
+	CTF_DW_ENFORCE_NOT(specification);
+	CTF_DW_ENFORCE_NOT(signature);
+
+	/*
+	 * Figure out the size of the type (if possible) and force it into the
+	 * CTF to ensure that struct/union padding is added appropriately.
+	 *
+	 * If we don't know it, force a size of zero, which is interpreted as
+	 * being equivalent to a call to the unsized struct/union addition
+	 * function, letting libdtrace-ctf figure out a likely size as best it
+	 * can.
+	 */
+	size = private_dwarf_size(die);
+	if (size < 0)
+		size = 0;
+
+	/*
+	 * Possibly we should ignore this entire structure, if we already know
+	 * of one with the same name and at least as many members.  If we
+	 * already know of one and it is shorter, we want to use its ID rather
+	 * than creating a new one.
+	 *
+	 * Note; by this point, the deduplicator has long run: thus we know for
+	 * sure what module a potentially-shared type will end up in, and
+	 * there's no need to double-check the shared CTF repository for types.
+	 * We also know that the module must exist in the per_module hash.
+	 */
+
+	if (name != NULL) {
+		char *structized_name = NULL;
+		struct per_module *ctf_pm;
+
+		structized_name = str_appendn(structized_name,
+					      is_union ? "u " : "s ",
+					      name, NULL);
+
+		ctf_pm = g_hash_table_lookup(per_module, module_name);
+		member_count = g_hash_table_lookup(ctf_pm->member_counts,
+						   structized_name);
+
+		if (member_count) {
+			free(structized_name);
+			dw_ctf_trace("%s: already exists (with ID %li) with %zi members\n"
+				     "versus current %li members\n",
+				     locerrstr, member_count->ctf_id,
+				     member_count->count,
+				     count_dwarf_members(die));
+
+			if (member_count->count < count_dwarf_members(die))
+				return member_count->ctf_id;
+
+			*skip = SKIP_SKIP;
+			return member_count->ctf_id;
+		}
+
+		/*
+		 * Not in existence yet.  Create it.
+		 */
+		member_count = malloc(sizeof(struct ctf_memb_count));
+		if (member_count == NULL) {
+			pr_err("Out of memory allocating structure/union member count\n");
+			exit(1);
+		}
+		member_count->count = 0;
+		g_hash_table_insert(ctf_pm->member_counts,
+				    structized_name, member_count);
+	}
+
+	dw_ctf_trace("%s: adding structure %s\n", locerrstr, name);
+
+	if (is_union)
+		ctf_add_sou = ctf_add_union_sized;
+	else
+		ctf_add_sou = ctf_add_struct_sized;
+
+	id = ctf_add_sou(ctf, ROOT_TYPE(top_level_type), name, size);
+
+	if (member_count != NULL)
+		member_count->ctf_id = id;
+
+	return id;
+}
+
+/*
+ * Figure out the offset of this type, in bits.  (This is split in two
+ * for bitfields, where the bitfield itself gets represented elsewhere,
+ * in the CTF type of the member itself.)
+ *
+ * DW_AT_data_bit_offset is the simple case.  DW_AT_data_member_location
+ * is trickier, and, alas, the DWARF2 variation is the complex one.
+ */
+static int ctf_su_offset(Dwarf_Die *die, const char *locerrstr,
+			 struct die_override *overrides, ulong_t *offset,
+			 ulong_t *bit_offset)
+{
+	struct die_override *o;
+
+	if (private_dwarf_hasattr(die, DW_AT_data_bit_offset))
+		*offset = private_dwarf_udata(die, DW_AT_data_bit_offset, NULL);
+	else if (private_dwarf_hasattr(die, DW_AT_data_member_location)) {
+		Dwarf_Attribute location_attr;
+
+		private_dwarf_attr(die, DW_AT_data_member_location,
+				   &location_attr);
+
+		switch (dwarf_whatform(&location_attr)) {
+		case DW_FORM_data1:
+		case DW_FORM_data2:
+		case DW_FORM_data4:
+		case DW_FORM_data8:
+		case DW_FORM_udata:
+		case DW_FORM_sdata:
+		{
+			/*
+			 * Byte offset, with bit_offset of containing
+			 * structure/union added, if present.
+			 *
+			 * (No overrides supported here, yet, due to lack of
+			 * sdata overrides and the desire for consistency.
+			 * We can add them if we start passing down
+			 * DW_AT_data_member_location overrides.)
+			 */
+			if (dwarf_whatform(&location_attr) == DW_FORM_sdata) {
+				Dwarf_Sword location;
+
+				dwarf_formsdata(&location_attr, &location);
+				*offset = location * 8;
+			} else {
+				Dwarf_Word location;
+
+				dwarf_formudata(&location_attr, &location);
+				*offset = location * 8;
+			}
+			break;
+		}
+		case DW_FORM_block1:
+		case DW_FORM_block2:
+		case DW_FORM_block4:
+		{
+			Dwarf_Op *location;
+			size_t nlocs;
+
+			/*
+			 * DWARF 2 block-based data_member_location.  This can
+			 * be quite complicated in some situations (notably C++
+			 * virtual bases), but for normal structure members it
+			 * is simple.  FIXME for userspace tracing of C++.
+			 *
+			 * This is thoroughly specific to the forms of DWARF2
+			 * emitted by GCC.  We don't need to feel guilty about
+			 * this because elfutils does just the same thing.
+			 */
+
+			if (dwarf_getlocation(&location_attr, &location,
+					      &nlocs) < 0) {
+				pr_err("%s: offset not a valid location expression: %s\n",
+				       locerrstr, dwarf_errmsg(dwarf_errno()));
+				return CTF_ERROR_REPORTED;
+			}
+
+			if ((nlocs != 1) ||
+			    ((location[0].atom != DW_OP_plus_uconst) &&
+			     (location[0].atom != DW_OP_constu))) {
+				pr_err("%s: complex location lists not supported:\n"
+				       "either C++ or non-GCC output: skipped\n", locerrstr);
+				return CTF_ERROR_REPORTED;
+			}
+
+			*offset = location[0].number * 8;
+			break;
+		}
+		case DW_FORM_exprloc:
+		{
+			/*
+			 * We need a full DWARF expression list interpreter to
+			 * handle this.
+			 */
+			pr_err("DWARF 4 expression location lists not supported.\n");
+			exit(1);
+		}
+		default:
+		{
+			pr_err("%s: expression location lists in form %u not supported.\n",
+			       locerrstr, dwarf_whatform(&location_attr));
+			exit(1);
+		}
+		}
+	}
+
+	/*
+	 * Handle the bit offset.
+	 */
+	if (private_dwarf_hasattr(die, DW_AT_bit_offset)) {
+	  Dwarf_Attribute bit_attr;
+	  Dwarf_Word bit;
+
+	  private_dwarf_attr(die, DW_AT_bit_offset,
+			     &bit_attr);
+	  dwarf_formudata(&bit_attr, &bit);
+	  *bit_offset = bit;
+	}
+
+	/*
+	 * Handle the offset value override.  It does not matter which method
+	 * has been used to get the value.  At this point offset is always
+	 * the bit distance of the member from the structure/union start.
+	 *
+	 * The DW_AT_data_bit_offset override is always used to pass the offset
+	 * around, so that we don't need to add special override handling for
+	 * various forms of the DW_AT_data_member_location as a special case.
+	 * This is safe as it is not possible to have both attributes attached
+	 * to the same DIE per the DWARF4 standard, and if we have one attached
+	 * as an override to a DIE that has the other, we will only ever need to
+	 * use one (since no DIE can be both an unnamed struct/union and a
+	 * bitfield at the same time).
+	 */
+	o = private_find_override(die, DW_AT_data_bit_offset, overrides);
+	if (o != NULL) {
+		if (o->op == DIE_OVERRIDE_REPLACE)
+			*offset = o->value;
+		else
+			*offset += o->value;
+	}
+
+	return 0;
+}
+
+/*
+ * Assemble a structure or union member.
+ *
+ * We only assemble a member of a given name if a member by that name does not
+ * already exist, and if the member is not blacklisted.
+ */
+static ctf_id_t assemble_ctf_su_member(const char *module_name,
+				       const char *file_name,
+				       Dwarf_Die *die,
+				       Dwarf_Die *parent_die,
+				       ctf_file_t *ctf,
+				       ctf_id_t parent_ctf_id,
+				       const char *locerrstr,
+				       struct die_override *overrides,
+				       int top_level_type,
+				       enum skip_type *skip,
+				       int *replace)
+{
+	ulong_t offset = 0;
+	ulong_t bit_offset = 0;
+	struct ctf_full_id *new_type;
+	Dwarf_Attribute type_attr;
+	Dwarf_Die type_die;
+	Dwarf_Die cu_die;
+	int err;
+	struct ctf_memb_count *member_count;
+	const char *struct_name = dwarf_diename(parent_die);
+
+	CTF_DW_ENFORCE(type);
+
+	/*
+	 * Increment the member count of named structures.  This is the number
+	 * of members in the DWARF, not in the CTF: blacklisted members are
+	 * counted too.
+	 */
+	if (struct_name != NULL) {
+		int is_union = (dwarf_tag(parent_die) == DW_TAG_union_type);
+		char *structized_name = NULL;
+		struct per_module *ctf_pm;
+
+		structized_name = str_appendn(structized_name,
+					      is_union ? "u " : "s ",
+					      struct_name, NULL);
+
+		ctf_pm = g_hash_table_lookup(per_module, module_name);
+		member_count = g_hash_table_lookup(ctf_pm->member_counts,
+						   structized_name);
+		member_count->count++;
+		free(structized_name);
+	}
+
+	/*
+	 * If this member is blacklisted, just skip it.
+	 */
+	if (member_blacklisted(die, parent_die)) {
+		dw_ctf_trace("%s: blacklisted, skipping.\n", locerrstr);
+		return parent_ctf_id;
+	}
+
+	/*
+	 * Find the associated type so we can either add a member with that type
+	 * (if it is named) or add its members directly (for unnamed types,
+	 * which must be unnamed structs/unions): then figure out the member's
+	 * offset.
+	 */
+	private_dwarf_attr(die, DW_AT_type, &type_attr);
+	if (dwarf_formref_die(&type_attr, &type_die) == NULL) {
+		pr_err("%s: nonexistent type reference.\n"
+		       "Corrupted DWARF, cannot continue.\n", locerrstr);
+		exit(1);
+	}
+	dwarf_diecu(&type_die, &cu_die, NULL, NULL);
+
+	err = ctf_su_offset(die, locerrstr, overrides, &offset, &bit_offset);
+	if (err < 0) {
+		*skip = SKIP_ABORT;
+		return err;
+	}
+
+	/*
+	 * If this is an unnamed struct/union, call directly back to
+	 * die_to_ctf() to add this struct's members to the current structure,
+	 * merging it seamlessly with its parent (excepting only the member
+	 * offsets).  Use DW_AT_data_bit_offset because it does not require
+	 * the complexity of DW_AT_data_member_location to be faked.
+	 */
+	if (!private_dwarf_hasattr(die, DW_AT_name)) {
+		Dwarf_Die child_die;
+		int dummy = 0;
+
+		if ((dwarf_tag(&type_die) != DW_TAG_structure_type) &&
+		    (dwarf_tag(&type_die) != DW_TAG_union_type)) {
+			pr_err("%s:%lx: not supported: anonymous structure member\n"
+			       "not a structure or union.\n", locerrstr,
+			       DIEOFFSET(die));
+			*skip = SKIP_ABORT;
+			return CTF_ERROR_REPORTED;
+		}
+
+		/*
+		 * Anonymous structure or union with no members. Silently skip.
+		 */
+		switch (dwarf_child(&type_die, &child_die)) {
+		case -1:
+			*skip = SKIP_ABORT;
+			return CTF_ERROR_REPORTED;
+		case 1: /* No DIEs at all in this aggregate */
+			return parent_ctf_id;
+		default: /* Child DIEs exist.  */
+			break;
+		}
+
+		/*
+		 * Add override that will adjust offset of the anonymous
+		 * struct/union members during inlining.  The bit_offset is
+		 * ignored here as it is not expected that a nested
+		 * structure/union will start on a non-byte-aligned boundary.
+		 */
+		struct die_override o[] = {{ dwarf_tag(&child_die),
+					     DW_AT_data_bit_offset,
+					     DIE_OVERRIDE_ADD,
+					     offset, overrides }, {0}};
+
+		die_to_ctf(module_name, file_name, &child_die, parent_die, ctf,
+			   parent_ctf_id, o, 0, 0, skip, &dummy, NULL);
+
+		return parent_ctf_id;
+	}
+
+	/*
+	 * Get the CTF ID of this member's type, by recursive lookup.
+	 *
+	 * If this is a bitfield, we want to note that said type's size and
+	 * bit-offset should be adjusted.
+	 */
+	if (private_dwarf_hasattr(die, DW_AT_bit_size)) {
+		struct die_override o[] = {
+			{ DW_TAG_base_type,
+			  DW_AT_bit_size,
+			  DIE_OVERRIDE_REPLACE,
+			  private_dwarf_udata(die, DW_AT_bit_size,
+					      NULL),
+			  NULL },
+			{ DW_TAG_base_type,
+			  DW_AT_bit_offset,
+			  DIE_OVERRIDE_REPLACE,
+			  bit_offset,
+			  overrides },
+			{0}
+		};
+
+		new_type = construct_ctf_id(module_name, file_name, &type_die,
+					    &cu_die, o);
+	} else {
+		if (bit_offset != 0) {
+			pr_err("%s:%s: error in member %s: No DW_AT_bit_size, but nonzero bit offset\n"
+			       "of %lx in overall offset of %lx\n", locerrstr,
+			       dwarf_diename(&cu_die), dwarf_diename(die),
+			       bit_offset, offset);
+			return CTF_ERROR_REPORTED;
+		}
+		new_type = construct_ctf_id(module_name, file_name, &type_die,
+					    &cu_die, NULL);
+	}
+
+	if (new_type == NULL) {
+		*skip = SKIP_ABORT;
+		return CTF_ERROR_REPORTED;
+	}
+
+	if ((new_type->ctf_file != ctf) &&
+	    (new_type->ctf_file != lookup_ctf_file("shared_ctf"))) {
+		pr_err("%s:%s: internal error: referenced type lookup for member %s\n"
+		       "yields a different CTF file: %p versus %p\n",
+		       locerrstr, dwarf_diename(&cu_die), dwarf_diename(die),
+		       ctf, new_type->ctf_file);
+		pr_err("dedup() is probably buggy.\n");
+		exit(1);
+	}
+
+	if (ctf_add_member_offset(ctf, parent_ctf_id, dwarf_diename(die),
+				  new_type->ctf_id, offset) < 0) {
+		/*
+		 * If we have seen this member before, as part of another
+		 * definition somewhere else, that's fine.  We cannot recurse
+		 * from this point, so we can just return the parent CTF ID, the
+		 * ID of the containing structure.
+		 */
+		if (ctf_errno(ctf) == ECTF_DUPLICATE)
+			return parent_ctf_id;
+
+		/*
+		 * We have special handling for cases where CTF doesn't know of
+		 * either this member's type or the enclosing structure: when
+		 * libdtrace-ctf is old enough to need it, we try a ctf_update()
+		 * in case this is recently added, but no special handling for
+		 * other errors, which the caller must report.
+		 */
+
+		if (ctf_errno(ctf) != ECTF_BADID &&
+		    ctf_errno(ctf) != ECTF_NOTSOU)
+			return CTF_NO_ERROR_REPORTED;
+
+#ifndef LIBDTRACE_CTF_OMISSIBLE_CTF_UPDATE
+		ctf_file_t *shared_ctf;
+
+		/*
+		 * Try an update of the current CTF file first, to bring the
+		 * type ID table up to date: if that doesn't work, try an update
+		 * of the shared table.  (If none is needed, this is cheap.)
+		 */
+
+		if (ctf_update(new_type->ctf_file) < 0) {
+			pr_err("Cannot update CTF file: %s\n",
+			       ctf_errmsg(ctf_errno(ctf)));
+			exit(1);
+		}
+
+		if (ctf_add_member_offset(ctf, parent_ctf_id,
+					  dwarf_diename(die),
+					  new_type->ctf_id,
+					  offset) == 0)
+			return parent_ctf_id;
+
+		shared_ctf = lookup_ctf_file("shared_ctf");
+		if (ctf_update(shared_ctf) < 0) {
+			pr_err("Cannot update shared CTF: %s\n",
+			       ctf_errmsg(ctf_errno(shared_ctf)));
+			exit(1);
+		}
+
+		if (ctf_add_member_offset(ctf, parent_ctf_id,
+					  dwarf_diename(die),
+					  new_type->ctf_id,
+					  offset) == 0)
+			return parent_ctf_id;
+#endif
+#ifdef DEBUG
+		pr_err("%s: Internal error: %s %s:%s:%p:%i\n"
+		       "on member addition to ctf_file %p.\n",
+		       locerrstr, ctf_errmsg(ctf_errno(ctf)),
+		       new_type->module_name, new_type->file_name,
+		       new_type->ctf_file, (int) new_type->ctf_id, ctf);
+#else
+		pr_err("%s: Internal error: %s %p:%i\n"
+		       "on member addition to ctf_file %p.\n",
+		       locerrstr, ctf_errmsg(ctf_errno(ctf)),
+		       new_type->ctf_file, (int) new_type->ctf_id,
+		       ctf);
+#endif
+		return CTF_ERROR_REPORTED;
+	}
+
+	return parent_ctf_id;
+}
+
+/*
+ * Assemble a variable.
+ */
+static ctf_id_t assemble_ctf_variable(const char *module_name,
+				      const char *file_name,
+				      Dwarf_Die *die,
+				      Dwarf_Die *parent_die,
+				      ctf_file_t *ctf,
+				      ctf_id_t parent_ctf_id,
+				      const char *locerrstr,
+				      struct die_override *overrides,
+				      int top_level_type,
+				      enum skip_type *skip,
+				      int *replace)
+{
+	const char *name = dwarf_diename(die);
+	char *blacklist_name = NULL;
+	ctf_id_t type_ref;
+	int err;
+
+	CTF_DW_ENFORCE(name);
+
+	/*
+	 * If blacklisted, just skip it.
+	 */
+	blacklist_name = str_appendn(blacklist_name, module_name, "`",
+				     dwarf_diename(die), NULL);
+	if (g_hash_table_lookup_extended(variable_blacklist, blacklist_name,
+					 NULL, NULL)) {
+		dw_ctf_trace("%s: variable %s is blacklisted for static/non-static ambiguity.\n",
+			     file_name, blacklist_name);
+		free(blacklist_name);
+		return 0;
+	}
+	free(blacklist_name);
+
+	type_ref = lookup_ctf_type(module_name, file_name, die, ctf,
+				   overrides, locerrstr);
+	if (type_ref < 0) {
+		*skip = SKIP_ABORT;
+		return CTF_ERROR_REPORTED;
+	}
+
+	/*
+	 * This isn't a type: full DWARF child recursion and type-id addition is
+	 * not called for.
+	 */
+	*skip = SKIP_SKIP;
+
+	err = ctf_add_variable(ctf, name, type_ref);
+
+	if (err == 0)
+		dw_ctf_trace("%p: Added variable %s, type %i\n", ctf, name,
+			     (int)type_ref);
+
+	/*
+	 * Variable references to opaque versus non-opaque structures could only
+	 * get deduplicated with yet another deduplication pass.  This seems
+	 * pointlessly expensive when nothing can refer to them: just skip
+	 * duplicates instead.
+	 */
+	if ((err < 0) && (ctf_errno(ctf) == ECTF_DUPLICATE))
+		return 0;
+
+	return err;
+
+}
+
+/* Writeout.  */
+
+static void write_types(char *output, int standalone)
+{
+	GHashTableIter module_iter;
+	char *module;
+	struct per_module *per_mod;
+	ctf_file_t **ctfs;
+	const char **names;
+	size_t i = 0;
+	size_t ctf_count = g_hash_table_size(per_module);
+
+	/*
+	 * Work over all the modules and write their compressed CTF data out.
+	 * Standalone modules get placed in files in the output directory named
+	 * with names ending in .mod.ctf.new, and the makefile moves .ctf.new
+	 * over the top of .ctf iff it has changed; built-in modules and the
+	 * core kernel and shared type repository are placed into a CTF archive.
+	 */
+	if (standalone) {
+		if ((mkdir(output, 0777) < 0) && errno != EEXIST) {
+			perror("Cannot create .ctf directory");
+			exit(1);
+		}
+	} else {
+		ctfs = calloc(ctf_count, sizeof(ctf_file_t *));
+		names = calloc(ctf_count, sizeof(char *));
+		if (!ctfs || !names)
+			pr_err("Out of memory in CTF writeout\n");
+	}
+
+	/*
+	 * Write the files out (in standalone mode), or construct the arrays of
+	 * module names and files to put in the archive (otherwise).
+	 */
+	g_hash_table_iter_init(&module_iter, per_module);
+	while (g_hash_table_iter_next(&module_iter, (void **) &module,
+				      (void **)&per_mod)) {
+		int fd;
+
+		dw_ctf_trace("Writing out %s\n", module);
+
+		if (ctf_update(per_mod->ctf_file) < 0) {
+			pr_err("Cannot serialize CTF file %s: %s\n",
+			       module, ctf_errmsg(ctf_errno(per_mod->ctf_file)));
+			exit(1);
+		}
+
+		if (!standalone) {
+			names[i] = module;
+			ctfs[i] = per_mod->ctf_file;
+			i++;
+		} else {
+			char *path = NULL;
+
+			path = str_appendn(path, output, "/", module,
+					   ".mod.ctf.new", NULL);
+
+			fd = open(path, O_WRONLY | O_CREAT | O_TRUNC | O_CLOEXEC,
+				  0666);
+			if (fd < 0) {
+				pr_err("Cannot open CTF file %s for writing: %s\n",
+				       path, strerror(errno));
+				exit(1);
+			}
+			if (ctf_compress_write(per_mod->ctf_file, fd) < 0) {
+				pr_err("Cannot write to CTF file %s: "
+				       "%s\n", path,
+				       ctf_errmsg(ctf_errno(per_mod->ctf_file)));
+				exit(1);
+			}
+			if (close(fd) != 0) {
+				pr_err("Cannot close CTF file %s: %s\n",
+				       path, strerror(errno));
+				exit(1);
+			}
+			free(path);
+		}
+	}
+
+	if (!standalone) {
+		int err;
+
+		err = ctf_arc_write(output, ctfs, ctf_count, names, 4096);
+		if (err != 0) {
+			pr_err("Cannot write to CTF archive %s: %s\n",
+			       output, err < ECTF_BASE ? strerror(err) :
+			       ctf_errmsg(err));
+			exit(1);
+		}
+		free(names);
+		free(ctfs);
+	}
+}
+
+/* Utilities.  */
+
+/*
+ * Given a DIE that may contain a type attribute, look up the target of that
+ * attribute and return it, or NULL if none.
+ */
+static Dwarf_Die *private_dwarf_type(Dwarf_Die *die, Dwarf_Die *target_die)
+{
+	Dwarf_Attribute type_ref_attr;
+
+	if (private_dwarf_attr(die, DW_AT_type, &type_ref_attr) != NULL) {
+		if (dwarf_formref_die(&type_ref_attr, target_die) == NULL) {
+			pr_err("Corrupt DWARF at offset %lx: ref with no target.\n",
+			       DIEOFFSET(die));
+			exit(1);
+		}
+		return target_die;
+	}
+
+	return NULL;
+}
+
+/*
+ * Check for existence of an attribute in a DIE, chasing through
+ * DW_AT_specification if need be.
+ */
+static inline int private_dwarf_hasattr(Dwarf_Die *die,
+					unsigned int search_name)
+{
+	int hasattr = 0;
+	Dwarf_Attribute spec_ref_attr;
+	Dwarf_Die spec_die;
+
+	/*
+	 * DW_AT_declaration is not forwarded, because non-declarations can
+	 * reference declarations via DW_AT_specification, without implying that
+	 * the referencing DIE is a declaration.
+	 */
+	hasattr = dwarf_hasattr(die, search_name);
+	if (hasattr || (search_name == DW_AT_declaration))
+		return hasattr;
+
+	if (dwarf_attr(die, DW_AT_specification, &spec_ref_attr) != NULL) {
+		if (dwarf_formref_die(&spec_ref_attr, &spec_die) == NULL) {
+			pr_err("Corrupt DWARF at offset %lx: ref with no target.\n",
+			       DIEOFFSET(die));
+			exit(1);
+		}
+		return dwarf_hasattr(&spec_die, search_name);
+	}
+	return hasattr;
+}
+
+/*
+ * Return a DIE attribute, chasing through DW_AT_specification if need be.
+ */
+static inline Dwarf_Attribute *private_dwarf_attr(Dwarf_Die *die,
+						  unsigned int search_name,
+						  Dwarf_Attribute *result)
+{
+	Dwarf_Attribute spec_ref_attr;
+	Dwarf_Die spec_die;
+	Dwarf_Attribute *ret;
+
+	ret = dwarf_attr(die, search_name, result);
+	if (ret != NULL || (search_name == DW_AT_declaration))
+		return ret;
+
+	if (dwarf_attr(die, DW_AT_specification, &spec_ref_attr) != NULL) {
+		if (dwarf_formref_die(&spec_ref_attr, &spec_die) == NULL) {
+			pr_err("Corrupt DWARF at offset %lx: ref with no target.\n",
+			       DIEOFFSET(die));
+			exit(1);
+		}
+		return dwarf_attr(&spec_die, search_name, result);
+	}
+
+	return NULL;
+}
+
+/*
+ * Given a DIE that contains a udata attribute, look up that attribute and
+ * return its value (optionally overridden or modified by the die_overrides).
+ */
+static inline Dwarf_Word private_dwarf_udata(Dwarf_Die *die, int attribute,
+					     struct die_override *overrides)
+{
+	Dwarf_Attribute attr;
+	Dwarf_Word value;
+	struct die_override *override;
+
+	override = private_find_override(die, attribute, overrides);
+
+	if (override && override->op == DIE_OVERRIDE_REPLACE)
+		return override->value;
+
+	private_dwarf_attr(die, attribute, &attr);
+	dwarf_formudata(&attr, &value);
+
+	if (override)
+		value += override->value;
+
+	return value;
+}
+
+/*
+ * Given a DIE, return its byte size, if known and interpretable, or -1
+ * otherwise.
+ */
+static inline long long
+private_dwarf_size(Dwarf_Die *die)
+{
+	Dwarf_Attribute size_attr;
+
+	if (private_dwarf_hasattr(die, DW_AT_byte_size)) {
+		private_dwarf_attr(die, DW_AT_byte_size, &size_attr);
+
+		switch (dwarf_whatform(&size_attr)) {
+		case DW_FORM_data1:
+		case DW_FORM_data2:
+		case DW_FORM_data4:
+		case DW_FORM_data8:
+		case DW_FORM_udata: {
+			Dwarf_Word dw_size;
+
+			dwarf_formudata(&size_attr, &dw_size);
+			return dw_size;
+		}
+		case DW_FORM_sdata: {
+			Dwarf_Sword dw_size;
+
+			dwarf_formsdata(&size_attr, &dw_size);
+			return dw_size;
+		}
+		}
+	}
+
+	/*
+	 * exprloc or other type we don't know how to interpret yet.
+	 */
+	return -1;
+}
+
+/*
+ * Find an override in an override list, walking up the chained overrides if
+ * need be, until one is found.
+ */
+static struct die_override *
+private_find_override(Dwarf_Die *die,
+		      int attribute,
+		      struct die_override *overrides)
+{
+	size_t i;
+
+	if (overrides == NULL)
+		return NULL;
+
+	while (overrides) {
+		struct die_override *chain = NULL;
+		for (i = 0; overrides[i].tag != 0; i++) {
+			chain = overrides[i].chain;
+			if ((overrides[i].tag == dwarf_tag(die)) &&
+			    (overrides[i].attribute == attribute))
+				return &overrides[i];
+		}
+		overrides = chain;
+	}
+
+	return NULL;
+}
+
+/*
+ * Determine the dimensions of an array subrange, or 0 if variable.
+ */
+static Dwarf_Word private_subrange_dimensions(Dwarf_Die *die)
+{
+	int flexible_array = 0;
+	Dwarf_Attribute nelem_attr;
+	Dwarf_Word nelems;
+
+	if (((private_dwarf_attr(die, DW_AT_upper_bound,
+				 &nelem_attr) == NULL) &&
+	     (private_dwarf_attr(die, DW_AT_count,
+				 &nelem_attr) == NULL)) ||
+	    (!private_dwarf_hasattr(die, DW_AT_type)))
+		flexible_array = 1;
+
+	if (!flexible_array)
+		switch (dwarf_whatform(&nelem_attr)) {
+		case DW_FORM_data1:
+		case DW_FORM_data2:
+		case DW_FORM_data4:
+		case DW_FORM_data8:
+		case DW_FORM_udata:
+			break;
+		default:
+			flexible_array = 1;
+		}
+
+	if (flexible_array)
+		return 0;
+
+	dwarf_formudata(&nelem_attr, &nelems);
+
+	/*
+	 * Upper bounds indicate that we have one more element than that, since
+	 * C starts counting at zero.
+	 */
+	if (private_dwarf_hasattr(die, DW_AT_upper_bound))
+		nelems++;
+
+	return nelems;
+}
+
+/*
+ * Intern an atom in the atoms table and return it, or free it and return the
+ * existing atom if one is already interned.  (Despite the type signature, this
+ * return value is constant and should not be freed.)
+ */
+static void *intern(char *atom)
+{
+	void *foo;
+
+	if (!g_hash_table_lookup_extended(atoms, atom, &foo, NULL)) {
+		g_hash_table_insert(atoms, atom, NULL);
+		foo = atom;
+	} else
+		free(atom);
+
+	return foo;
+}
+
+/*
+ * An error checking strdup().
+ */
+static char *xstrdup(const char *s)
+{
+	char *s2 = strdup(s);
+
+	if (s2 == NULL) {
+		pr_err("%s: Out of memory\n", __func__);
+		exit(1);
+	}
+
+	return s2;
+}
+
+/*
+ * A string appender working on dynamic strings.
+ */
+static char *str_append(char *s, const char *append)
+{
+	size_t s_len = 0;
+
+	if (append == NULL)
+		return s;
+
+	if (s != NULL)
+		s_len = strlen(s);
+
+	size_t append_len = strlen(append);
+
+	s = realloc(s, s_len + append_len + 1);
+
+	if (s == NULL) {
+		pr_err("Out of memory appending a string of length %li to one of length %li\n",
+		       strlen(append), s_len);
+		exit(1);
+	}
+
+	memcpy(s + s_len, append, append_len);
+	s[s_len+append_len] = '\0';
+
+	return s;
+}
+
+/*
+ * A vararg string appender.
+ */
+static char *str_appendn(char *s, ...)
+{
+	va_list ap;
+	const char *append;
+	size_t len, s_len = 0;
+
+	va_start(ap, s);
+	if (s)
+		s_len = strlen(s);
+	len = s_len;
+
+	append = va_arg(ap, const char *);
+	while (append != NULL) {
+		len += strlen(append);
+		append = va_arg(ap, char *);
+	}
+	va_end(ap);
+
+	s = realloc(s, len + 1);
+	if (s == NULL) {
+		pr_err("Out of memory appending a string of length %li to one of length %li\n",
+		       len - s_len, s_len);
+		exit(1);
+	}
+
+	va_start(ap, s);
+	append = va_arg(ap, const char *);
+	while (append != NULL) {
+		size_t append_len = strlen(append);
+
+		memcpy(s + s_len, append, append_len);
+		s_len += append_len;
+
+		append = va_arg(ap, char *);
+	}
+	s[len] = '\0';
+	va_end(ap);
+
+	return s;
+}
+
+/*
+ * Filter a GList, calling a predicate on it and removing all elements for which
+ * the predicate returns true, calling the free_func on them if set.
+ */
+static GList *list_filter(GList *list, filter_pred_fun fun,
+			  GDestroyNotify free_func, void *data)
+{
+	GList *cur = list;
+
+	while (cur) {
+		GList *next = cur->next;
+
+		if (fun(cur->data, data)) {
+			if (free_func)
+				free_func(cur->data);
+			list = g_list_delete_link(list, cur);
+		}
+		cur = next;
+	}
+
+	return list;
+}
+
+/*
+ * Figure out the (pathless, suffixless) module name for a given module file (.o
+ * or .ko), and return it in a new dynamically allocated string.
+ *
+ * Takes the object_to_module mapping into account.
+ */
+static char *fn_to_module(const char *file_name)
+{
+	char *module_name;
+	char *chop, *dash;
+
+	module_name = g_hash_table_lookup(object_to_module, file_name);
+	if (module_name != NULL)
+		return xstrdup(module_name);
+
+	chop = strrchr(file_name, '/');
+	if (chop != NULL)
+		module_name = xstrdup(++chop);
+	else
+		module_name = xstrdup(file_name);
+
+	chop = strrchr(module_name, '.');
+	if (chop != NULL)
+		*chop = '\0';
+
+	dash = module_name;
+	while (dash != NULL) {
+		dash = strchr(dash, '-');
+		if (dash != NULL)
+			*dash = '_';
+	}
+
+	return module_name;
+}
+
+/*
+ * Determine, and cache, absolute filenames.  This is called in very hot
+ * paths, notably type_id(), and must be kept fast.
+ */
+static const char *abs_file_name(const char *file_name)
+{
+	static GHashTable *abs_file_names;
+	const char *abs_name;
+
+	if (abs_file_names == NULL)
+		abs_file_names = g_hash_table_new_full(g_str_hash, g_str_equal,
+						       free, free);
+
+	abs_name = g_hash_table_lookup(abs_file_names, file_name);
+
+	if (abs_name == NULL) {
+		char abspath[PATH_MAX] = "";
+
+		if (realpath(file_name, abspath) == NULL)
+			strcpy(abspath, file_name);
+		g_hash_table_replace(abs_file_names,
+		    xstrdup(file_name), xstrdup(abspath));
+
+		abs_name = g_hash_table_lookup(abs_file_names, file_name);
+	}
+
+	return abs_name;
+}
+
+/*
+ * Determine absolute filenames relative to some other directory.  This does not
+ * need to be fast.  The returned name is dynamically allocated, and must be
+ * freed by the caller.
+ */
+static char *rel_abs_file_name(const char *file_name, const char *relative_to)
+{
+	int dir = -1;
+	static int warned = 0;
+	char *abspath;
+	/*
+	 * If we can't get this name relatively, we might as well *try* to do it
+	 * absolutely: but print a warning.
+	 */
+	dir = open(".", O_RDONLY | O_DIRECTORY);
+	if (dir < 0) {
+		if (!warned) {
+			perror("Cannot open current directory");
+			warned = 1;
+		}
+	} else {
+		if (chdir(relative_to) < 0)
+			if (!warned) {
+				pr_err("Cannot change directory to "
+				       "%s: %s\n", relative_to,
+				       strerror(errno));
+				warned = 1;
+			}
+	}
+
+	abspath = realpath(file_name, NULL);
+	if (abspath == NULL)
+		abspath = xstrdup(file_name);
+
+	if ((dir > -1) && (fchdir(dir) < 0)) {
+		perror("Cannot return to original directory after relative realpath()");
+		exit(1);
+	}
+
+	close(dir);
+
+	return abspath;
+}
+
+/*
+ * Given a type encoding table, and a size, return the CTF encoding for that
+ * type, or 0 if none.
+ */
+static int find_ctf_encoding(struct type_encoding_tab *type_tab, size_t size)
+{
+	size_t i;
+
+	for (i = 0; type_tab[i].size != 0; i++) {
+		if (type_tab[i].size == size)
+			return type_tab[i].ctf_encoding;
+	}
+	return 0;
+}
+
+/*
+ * Count the number of members of a DWARF aggregate.
+ */
+static long count_dwarf_members(Dwarf_Die *d)
+{
+	const char *err;
+	Dwarf_Die die;
+
+	switch (dwarf_child(d, &die)) {
+	case -1:
+		err = "fetch first child of aggregate";
+		goto fail;
+	case 1: /* No DIEs at all in this aggregate */
+		return 0;
+	default: /* Child DIEs exist.  */
+		break;
+	}
+
+	/*
+	 * We are only interested in children of type DW_TAG_member.
+	 */
+	int sib_ret;
+	long count = 0;
+
+	do
+		if (dwarf_tag(&die) == DW_TAG_member)
+			count++;
+	while ((sib_ret = dwarf_siblingof(&die, &die)) == 0);
+
+	if (sib_ret == -1) {
+		err = "count members";
+		goto fail;
+	}
+
+	return count;
+
+ fail:
+	pr_err("Cannot %s: %s\n", err, dwarf_errmsg(dwarf_errno()));
+	exit(1);
+}
+
+/*
+ * Free a per_module's contents.
+ */
+static void private_per_module_free(void *per_module)
+{
+	struct per_module *per_mod = per_module;
+
+	ctf_close(per_mod->ctf_file);
+	g_hash_table_destroy(per_mod->member_counts);
+	free(per_module);
+}
+
+/*
+ * Free a fn_to_die_to_parent subhash.
+ */
+static void private_fn_die_parent_free(void *ptr)
+{
+	g_hash_table_destroy((GHashTable *) ptr);
+}
+
+/*
+ * Get a ctf_file out of the per_module hash for a given module.
+ */
+static ctf_file_t *lookup_ctf_file(const char *module_name)
+{
+	struct per_module *per_mod;
+
+	per_mod = g_hash_table_lookup(per_module, module_name);
+	if (per_mod == NULL)
+		return NULL;
+	return per_mod->ctf_file;
+}
diff --git a/scripts/dwarf2ctf/eu_simple.c b/scripts/dwarf2ctf/eu_simple.c
new file mode 100644
index 000000000000..49886e5e5411
--- /dev/null
+++ b/scripts/dwarf2ctf/eu_simple.c
@@ -0,0 +1,2 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#include "../eu_simple.c"
diff --git a/scripts/dwarf2ctf/member.blacklist b/scripts/dwarf2ctf/member.blacklist
new file mode 100644
index 000000000000..85122def7b5f
--- /dev/null
+++ b/scripts/dwarf2ctf/member.blacklist
@@ -0,0 +1 @@
+include/linux/netfilter/ipset/ip_set_ahash.h:ip_set_hash.next
diff --git a/scripts/eu_simple.c b/scripts/eu_simple.c
new file mode 100644
index 000000000000..e2736f29d001
--- /dev/null
+++ b/scripts/eu_simple.c
@@ -0,0 +1,356 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Convenience wrappers for functions in elfutils.
+ *
+ * (C) 2014, 2017 Oracle, Inc.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <elfutils/libdwfl.h>
+#include <elfutils/version.h>
+
+#include <eu_simple.h>
+
+#define __unused__ __attribute__((__unused__))
+
+/*
+ * A version of dwfl_report_elf() that compensates for parameter changes in
+ * newer elfutils.
+ */
+static Dwfl_Module *private_dwfl_report_elf(Dwfl *dwfl, const char *name,
+					    const char *file_name, int fd,
+					    GElf_Addr base)
+{
+#if _ELFUTILS_PREREQ(0,156)
+	return dwfl_report_elf(dwfl, name, file_name, fd, base, 0);
+#else
+	return dwfl_report_elf(dwfl, name, file_name, fd, base);
+#endif
+}
+
+/*
+ * Stub libdwfl callback, use only the ELF handle passed in.
+ */
+static int no_debuginfo(Dwfl_Module *mod __unused__,
+			void **userdata __unused__,
+			const char *modname __unused__,
+			Dwarf_Addr base __unused__,
+			const char *file_name __unused__,
+			const char *debuglink_file __unused__,
+			GElf_Word debuglink_crc __unused__,
+			char **debuginfo_file_name __unused__)
+{
+	return -1;
+}
+
+/*
+ * Wrap up dwfl_new() complexities.
+ */
+Dwfl *simple_dwfl_new(const char *file_name, Dwfl_Module **module)
+{
+	const char *err;
+
+	static Dwfl_Callbacks cb = {
+		.find_debuginfo = no_debuginfo,
+		.section_address = dwfl_offline_section_address
+	};
+	Dwfl *dwfl = dwfl_begin(&cb);
+	Dwfl_Module *mod;
+
+	if (dwfl == NULL) {
+		err = "initialize libdwfl";
+		goto fail;
+	}
+
+	mod = private_dwfl_report_elf(dwfl, "", file_name, -1, 0);
+	if (mod == NULL) {
+		err = "open object file with libdwfl";
+		goto fail;
+	}
+	if (module)
+		*module = mod;
+
+	if (dwfl_report_end(dwfl, NULL, NULL) != 0) {
+		err = "finish opening object file with libdwfl";
+		goto fail;
+	}
+
+	return dwfl;
+ fail:
+	fprintf(stderr, "Cannot %s for %s: %s\n", err, file_name,
+		dwfl_errmsg(dwfl_errno()));
+	exit(1);
+}
+
+/*
+ * A variant of simple_dwfl_new() that iterates over multiple object files.
+ * (Used for thin archives.)
+ *
+ * Takes ownership of the paths, until free.
+ */
+struct simple_dwfl_multi *
+simple_dwfl_new_multi(char **paths)
+{
+	struct simple_dwfl_multi *multi;
+
+	multi = malloc(sizeof(struct simple_dwfl_multi));
+	if (multi == NULL)
+		return NULL;
+
+	multi->paths = paths;
+	multi->i = -1;
+	multi->dwfl = NULL;
+	multi->last_die = NULL;
+
+	return multi;
+}
+
+/*
+ * A variant of dwfl_nextcu() that crosses file boundaries as needed,
+ * using the state in the simple_dwfl_multi.
+ */
+Dwarf_Die *
+simple_dwfl_nextcu(struct simple_dwfl_multi *multi)
+{
+	Dwarf_Addr junk;
+
+	/*
+	 * Switch object files as needed (and always, the first time).
+	 */
+
+	if (multi->i >= 0)
+		multi->last_die = dwfl_nextcu(multi->dwfl, multi->last_die,
+					      &junk);
+
+	while (multi->last_die == NULL) {
+		simple_dwfl_free(multi->dwfl);
+		if (multi->paths[++multi->i] == NULL) {
+			multi->i = -1;
+			multi->dwfl = NULL;
+			multi->last_die = NULL;
+			return NULL;
+		}
+
+		multi->dwfl = simple_dwfl_new(multi->paths[multi->i], NULL);
+		multi->last_die = dwfl_nextcu(multi->dwfl, multi->last_die,
+					      &junk);
+	}
+	return multi->last_die;
+}
+
+/*
+ * Free a simple_dwfl_new_multi: return its contained paths so the caller can
+ * free them again.  (They are not changed, so the caller can just hang on to
+ * them if preferred.)
+ */
+char **
+simple_dwfl_free_multi(struct simple_dwfl_multi *multi)
+{
+	char **paths = multi->paths;
+	simple_dwfl_free(multi->dwfl);
+	free(multi);
+	return paths;
+}
+
+/*
+ * The converse of simple_dwfl_new().
+ */
+void simple_dwfl_free(Dwfl *dwfl)
+{
+	if (dwfl != NULL) {
+		dwfl_report_end(dwfl, NULL, NULL);
+		dwfl_end(dwfl);
+	}
+}
+
+
+/*
+ * Read a modules_thick.builtin file and translate it into a stream of
+ * arguments suitable for simple_dwfl_new_multi().
+ */
+
+/*
+ * Construct a modules_thick.builtin iterator.
+ */
+struct modules_thick_iter *
+modules_thick_iter_new(const char *modules_thick_file)
+{
+	struct modules_thick_iter *i;
+
+	i = calloc(1, sizeof(struct modules_thick_iter));
+	if (i == NULL)
+		return NULL;
+
+	i->f = fopen(modules_thick_file, "r");
+
+	if (i->f == NULL) {
+		fprintf(stderr, "Cannot open builtin module file %s: %s\n",
+			modules_thick_file, strerror(errno));
+		return NULL;
+	}
+
+	return i;
+}
+
+/*
+ * Iterate, returning a new null-terminated array of object file names, and a
+ * new dynamically-allocated module name.  (The module name passed in is freed.)
+ *
+ * The array of object file names should be freed by the caller: the strings it
+ * points to are owned by the iterator, and should not be freed.
+ */
+
+char ** __attribute__((__nonnull__))
+modules_thick_iter_next(struct modules_thick_iter *i, char **module_name)
+{
+	size_t npaths = 1;
+	char **module_paths;
+	char *last_slash;
+	char *last_dot;
+	char *trailing_linefeed;
+	char *object_name = i->line;
+	char *dash;
+	int composite = 0;
+
+	/*
+	 * Read in all module entries, computing the suffixless, pathless name
+	 * of the module and building the next arrayful of object file names for
+	 * return.
+	 *
+	 * Modules can consist of multiple files: in this case, the portion
+	 * before the colon is the path to the module (as before): the portion
+	 * after the colon is a space-separated list of files that should be *
+	 * considered part of this module.  In this case, the portion before the
+	 * name is an "object file" that does not actually exist: it is merged
+	 * into built-in.a without ever being written out.
+	 *
+	 * All module names have - translated to _, to match what is done to the
+	 * names of the same things when built as modules.
+	 */
+
+	/*
+	 * Reinvocation of exhausted iterator. Return NULL, once.
+	 */
+retry:
+	if (getline(&i->line, &i->line_size, i->f) < 0) {
+		if (ferror(i->f)) {
+			fprintf(stderr, "Error reading from modules_thick file:"
+				" %s\n", strerror(errno));
+			exit(1);
+		}
+		rewind(i->f);
+		return NULL;
+	}
+
+	if (i->line[0] == '\0')
+		goto retry;
+
+	/*
+	 * Slice the line in two at the colon, if any.  If there is anything
+	 * past the ': ', this is a composite module.  (We allow for no colon
+	 * for robustness, even though one should always be present.)
+	 */
+	if (strchr(i->line, ':') != NULL) {
+		char *name_start;
+
+		object_name = strchr(i->line, ':');
+		*object_name = '\0';
+		object_name++;
+		name_start = object_name + strspn(object_name, " \n");
+		if (*name_start != '\0') {
+			composite = 1;
+			object_name = name_start;
+		}
+	}
+
+	/*
+	 * Figure out the module name.
+	 */
+	last_slash = strrchr(i->line, '/');
+	last_slash = (!last_slash) ? i->line :
+		last_slash + 1;
+	free(*module_name);
+	*module_name = strdup(last_slash);
+	dash = *module_name;
+
+	while (dash != NULL) {
+		dash = strchr(dash, '-');
+		if (dash != NULL)
+			*dash = '_';
+	}
+
+	last_dot = strrchr(*module_name, '.');
+	if (last_dot != NULL)
+		*last_dot = '\0';
+
+	trailing_linefeed = strchr(object_name, '\n');
+	if (trailing_linefeed != NULL)
+		*trailing_linefeed = '\0';
+
+	/*
+	 * Multifile separator? Object file names explicitly stated:
+	 * slice them up and shuffle them in.
+	 *
+	 * The array size may be an overestimate if any object file
+	 * names start or end with spaces (very unlikely) but cannot be
+	 * an underestimate.  (Check for it anyway.)
+	 */
+	if (composite) {
+		char *one_object;
+
+		for (npaths = 0, one_object = object_name;
+		     one_object != NULL;
+		     npaths++, one_object = strchr(one_object + 1, ' '));
+	}
+
+	module_paths = malloc((npaths + 1) * sizeof(char *));
+	if (!module_paths) {
+		fprintf(stderr, "%s: out of memory on module %s\n", __func__,
+			*module_name);
+		exit(1);
+	}
+
+	if (composite) {
+		char *one_object;
+		size_t i = 0;
+
+		while ((one_object = strsep(&object_name, " ")) != NULL) {
+			if (i >= npaths) {
+				fprintf(stderr, "%s: num_objs overflow on module "
+					"%s: this is a bug.\n", __func__,
+					*module_name);
+				exit(1);
+			}
+
+			module_paths[i++] = one_object;
+		}
+	} else
+		module_paths[0] = i->line;	/* untransformed module name */
+
+	module_paths[npaths] = NULL;
+
+	return module_paths;
+}
+
+/*
+ * Free an iterator. Can be called while iteration is underway, so even
+ * state that is freed at the end of iteration must be freed here too.
+ */
+void
+modules_thick_iter_free(struct modules_thick_iter *i)
+{
+	if (i == NULL)
+		return;
+	fclose(i->f);
+	free(i->line);
+	free(i);
+}
diff --git a/scripts/eu_simple.h b/scripts/eu_simple.h
new file mode 100644
index 000000000000..8ef9f9655077
--- /dev/null
+++ b/scripts/eu_simple.h
@@ -0,0 +1,91 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Simplifying wrappers for functions in elfutils, and functions to
+ * feed them data.
+ *
+ * (C) 2014, 2017 Oracle, Inc.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef _LINUX_EU_SIMPLE_H
+#define _LINUX_EU_SIMPLE_H
+
+#include <stdio.h>
+#include <stddef.h>
+#include <elfutils/libdwfl.h>
+
+/*
+ * Iteration state for simple_dwfl_new_multi().
+ */
+struct simple_dwfl_multi {
+	char **paths;
+	ssize_t i;
+	Dwfl *dwfl;
+	Dwarf_Die *last_die;
+};
+
+/*
+ * Wrap up dwfl_new() complexities.
+ */
+Dwfl *simple_dwfl_new(const char *file_name, Dwfl_Module **module);
+
+/*
+ * A variant of simple_dwfl_new() that iterates over multiple object files.
+ * (Used for thin archives.)
+ *
+ * Takes ownership of the paths, until free.
+ */
+struct simple_dwfl_multi *simple_dwfl_new_multi(char **paths);
+
+/*
+ * A variant of dwfl_nextcu() that crosses file boundaries as needed,
+ * using the state in the simple_dwfl_multi.
+ */
+Dwarf_Die *simple_dwfl_nextcu(struct simple_dwfl_multi *multi);
+
+/*
+ * Free a simple_dwfl_new_multi: return its contained paths so the caller
+ * free them again.  (They are not changed, so the caller can just hang on to
+ * them if preferred.)
+ */
+char **simple_dwfl_free_multi(struct simple_dwfl_multi *multi);
+
+/*
+ * The converse of simple_dwfl_new().
+ */
+void simple_dwfl_free(Dwfl *dwfl);
+
+/*
+ * modules_thick.builtin iteration state.
+ */
+struct modules_thick_iter {
+	FILE *f;
+	char *line;
+	size_t line_size;
+};
+
+/*
+ * Construct a modules_thick.builtin iterator.
+ */
+struct modules_thick_iter *
+modules_thick_iter_new(const char *modules_thick_file);
+
+/*
+ * Iterate, returning a new null-terminated array of object file names, and a
+ * new dynamically-allocated module name.  (The module name passed in is freed.)
+ *
+ * The array of object file names should be freed by the caller: the strings it
+ * points to are owned by the iterator, and should not be freed.
+ */
+
+char ** __attribute__((__nonnull__))
+modules_thick_iter_next(struct modules_thick_iter *i, char **module_name);
+
+void
+modules_thick_iter_free(struct modules_thick_iter *i);
+
+#endif
diff --git a/scripts/move-if-change b/scripts/move-if-change
new file mode 100755
index 000000000000..eb745af5d972
--- /dev/null
+++ b/scripts/move-if-change
@@ -0,0 +1,8 @@
+#!/bin/sh
+# SPDX-License-Identifier: GPL-2.0+
+
+if test -r "$2" && cmp -s "$1" "$2"; then
+  rm -f "$1"
+else
+  mv -f "$1" "$2"
+fi
diff --git a/scripts/package/mkspec b/scripts/package/mkspec
index 8640c278f1aa..63511c885a37 100755
--- a/scripts/package/mkspec
+++ b/scripts/package/mkspec
@@ -27,6 +27,13 @@ if grep -q CONFIG_DRM=y .config; then
 	PROVIDES=kernel-drm
 fi
 
+# set CTF when configured
+if grep -q CONFIG_CTF=y .config; then
+	C=
+else
+	C=DEL
+fi
+
 PROVIDES="$PROVIDES kernel-$KERNELRELEASE"
 __KERNELRELEASE=$(echo $KERNELRELEASE | sed -e "s/-/_/g")
 EXCLUDES="$RCS_TAR_IGNORE --exclude=*vmlinux* --exclude=*.mod \
@@ -38,6 +45,7 @@ EXCLUDES="$RCS_TAR_IGNORE --exclude=*vmlinux* --exclude=*.mod \
 # Labels:
 #  $S: this line is enabled only when building source package
 #  $M: this line is enabled only when CONFIG_MODULES is enabled
+#  $C: this line is enabled only when CONFIG_CTF is enabled
 sed -e '/^DEL/d' -e 's/^\t*//' <<EOF
 	Name: kernel
 	Summary: The Linux Kernel
@@ -48,6 +56,8 @@ sed -e '/^DEL/d' -e 's/^\t*//' <<EOF
 	Vendor: The Linux Community
 	URL: http://www.kernel.org
 $S	Source: kernel-$__KERNELRELEASE.tar.gz
+$C	BuildRequires: libdtrace-ctf >= 0.5.0
+$C	BuildRequires: libdtrace-ctf-devel >= 0.5.0
 	Provides: $PROVIDES
 	%define __spec_install_post /usr/lib/rpm/brp-compress || :
 	%define debug_package %{nil}
@@ -74,12 +84,14 @@ $S$M	AutoReqProv: no
 $S$M	%description -n kernel-devel
 $S$M	This package provides kernel headers and makefiles sufficient to build modules
 $S$M	against the $__KERNELRELEASE kernel package.
+$C	Requires: libdtrace-ctf >= 0.5.0
 $S$M
 $S	%prep
 $S	%setup -q
 $S
 $S	%build
 $S	$MAKE %{?_smp_mflags} KBUILD_BUILD_VERSION=%{release}
+$S$C	$MAKE %{?_smp_mflags} ctf
 $S
 	%install
 	mkdir -p %{buildroot}/boot
-- 
2.28.0

