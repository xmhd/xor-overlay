From 157815093bf4ffa662a6bfc9d949b59861ff145e Mon Sep 17 00:00:00 2001
From: Kris Van Hees <kris.van.hees@oracle.com>
Date: Mon, 19 Nov 2018 17:52:54 +0000
Subject: [PATCH 05/20] dtrace: modular components and x86 support

This implements the core DTrace module (including the entire DIF
interpreter and support for all built-in D variables and functions) and
one test provider, dt_test.ko.  It uses the machinery added in the last
few commits.  An x86 implementation of the architecture-dependent parts
is also added so that one platform at least can compile it.

At this stage, almost no probes will exist: they are added by the
following commits, that add providers and SDT probes.

Signed-off-by: Kris Van Hees <kris.van.hees@oracle.com>
Signed-off-by: Nick Alcock <nick.alcock@oracle.com>
Signed-off-by: Tomas Jedlicka <tomas.jedlicka@oracle.com>
Signed-off-by: Eugene Loh <eugene.loh@oracle.com>
Signed-off-by: David Mc Lean <david.mclean@oracle.com>
Signed-off-by: Vincent Lim <vincent.lim@oracle.com>
---
 Makefile                            |    1 +
 arch/x86/dtrace/Makefile.arch       |   11 +
 arch/x86/dtrace/dtrace_asm_x86_64.S |  228 ++
 arch/x86/dtrace/dtrace_isa_x86_64.c |  228 ++
 dtrace/Makefile                     |   19 +
 dtrace/ctf_api.h                    |   33 +
 dtrace/dt_test.h                    |   30 +
 dtrace/dt_test_dev.c                |  176 +
 dtrace/dt_test_mod.c                |   52 +
 dtrace/dtrace.h                     |   35 +
 dtrace/dtrace_actdesc.c             |   91 +
 dtrace/dtrace_anon.c                |  144 +
 dtrace/dtrace_buffer.c              |  490 +++
 dtrace/dtrace_debug.h               |  118 +
 dtrace/dtrace_dev.c                 | 1599 +++++++++
 dtrace/dtrace_dev.h                 |   35 +
 dtrace/dtrace_dif.c                 | 4905 +++++++++++++++++++++++++++
 dtrace/dtrace_dof.c                 | 2504 ++++++++++++++
 dtrace/dtrace_ecb.c                 |  936 +++++
 dtrace/dtrace_enable.c              |  449 +++
 dtrace/dtrace_fmt.c                 |  104 +
 dtrace/dtrace_hash.c                |  266 ++
 dtrace/dtrace_isa.c                 |  361 ++
 dtrace/dtrace_match.c               |  364 ++
 dtrace/dtrace_mod.c                 |   45 +
 dtrace/dtrace_predicate.c           |   80 +
 dtrace/dtrace_priv.c                |  120 +
 dtrace/dtrace_probe.c               | 1542 +++++++++
 dtrace/dtrace_probe_ctx.c           |  659 ++++
 dtrace/dtrace_ptofapi.c             |  649 ++++
 dtrace/dtrace_spec.c                |  434 +++
 dtrace/dtrace_state.c               | 1108 ++++++
 dtrace/dtrace_util.c                |  283 ++
 33 files changed, 18099 insertions(+)
 create mode 100644 arch/x86/dtrace/Makefile.arch
 create mode 100644 arch/x86/dtrace/dtrace_asm_x86_64.S
 create mode 100644 arch/x86/dtrace/dtrace_isa_x86_64.c
 create mode 100644 dtrace/Makefile
 create mode 100644 dtrace/ctf_api.h
 create mode 100644 dtrace/dt_test.h
 create mode 100644 dtrace/dt_test_dev.c
 create mode 100644 dtrace/dt_test_mod.c
 create mode 100644 dtrace/dtrace.h
 create mode 100644 dtrace/dtrace_actdesc.c
 create mode 100644 dtrace/dtrace_anon.c
 create mode 100644 dtrace/dtrace_buffer.c
 create mode 100644 dtrace/dtrace_debug.h
 create mode 100644 dtrace/dtrace_dev.c
 create mode 100644 dtrace/dtrace_dev.h
 create mode 100644 dtrace/dtrace_dif.c
 create mode 100644 dtrace/dtrace_dof.c
 create mode 100644 dtrace/dtrace_ecb.c
 create mode 100644 dtrace/dtrace_enable.c
 create mode 100644 dtrace/dtrace_fmt.c
 create mode 100644 dtrace/dtrace_hash.c
 create mode 100644 dtrace/dtrace_isa.c
 create mode 100644 dtrace/dtrace_match.c
 create mode 100644 dtrace/dtrace_mod.c
 create mode 100644 dtrace/dtrace_predicate.c
 create mode 100644 dtrace/dtrace_priv.c
 create mode 100644 dtrace/dtrace_probe.c
 create mode 100644 dtrace/dtrace_probe_ctx.c
 create mode 100644 dtrace/dtrace_ptofapi.c
 create mode 100644 dtrace/dtrace_spec.c
 create mode 100644 dtrace/dtrace_state.c
 create mode 100644 dtrace/dtrace_util.c

diff --git a/Makefile b/Makefile
index d6b9a7d2c973..dc05d9af9d1b 100644
--- a/Makefile
+++ b/Makefile
@@ -623,6 +623,7 @@ net-y		:= net/
 libs-y		:= lib/
 core-y		:= usr/
 virt-y		:= virt/
+dtrace-y	:= dtrace/
 endif # KBUILD_EXTMOD
 
 # The all: target is the default when no target is given on the
diff --git a/arch/x86/dtrace/Makefile.arch b/arch/x86/dtrace/Makefile.arch
new file mode 100644
index 000000000000..ffb9ef4d1722
--- /dev/null
+++ b/arch/x86/dtrace/Makefile.arch
@@ -0,0 +1,11 @@
+#
+# Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.
+#
+
+DTARCHDIR = ../arch/x86/dtrace
+
+ccflags-y	+= -I$(srctree)/arch/x86/dtrace/include -Idtrace
+
+dtrace-obj	+= dtrace_asm_x86_64.o dtrace_isa_x86_64.o
+
+dtrace-y	+= $(addprefix $(DTARCHDIR)/, $(dtrace-obj))
diff --git a/arch/x86/dtrace/dtrace_asm_x86_64.S b/arch/x86/dtrace/dtrace_asm_x86_64.S
new file mode 100644
index 000000000000..46d3fe1b9703
--- /dev/null
+++ b/arch/x86/dtrace/dtrace_asm_x86_64.S
@@ -0,0 +1,228 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Dynamic Tracing for Linux - x86 specific assembly
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/linkage.h>
+#include <asm/smap.h>
+
+#define CPU_DTRACE_BADADDR	0x0004	/* DTrace fault: bad address */
+
+#if defined(__x86_64__)
+	SYM_CODE_START(dtrace_caller)
+	movq	$-1, %rax
+	ret
+	SYM_CODE_END(dtrace_caller)
+
+#elif defined(__i386__)
+
+	SYM_CODE_START(dtrace_caller)
+	movl	$-1, %eax
+	ret
+	SYM_CODE_END(dtrace_caller)
+
+#endif	/* __i386__ */
+
+#if defined(__x86_64__)
+
+	SYM_FUNC_START(dtrace_copy)
+	pushq	%rbp
+	movq	%rsp, %rbp
+
+	ASM_STAC
+	xchgq	%rdi, %rsi		# make %rsi source, %rdi dest
+	movq	%rdx, %rcx		# load count
+	repz				# repeat for count ...
+	smovb				#   move from %ds:rsi to %ed:rdi
+	ASM_CLAC
+	leave
+	ret
+	SYM_FUNC_END(dtrace_copy)
+
+#elif defined(__i386__)
+
+	SYM_FUNC_START(dtrace_copy)
+	pushl	%ebp
+	movl	%esp, %ebp
+	pushl	%esi
+	pushl	%edi
+
+	movl	8(%ebp), %esi		# Load source address
+	movl	12(%ebp), %edi		# Load destination address
+	movl	16(%ebp), %ecx		# Load count
+	repz				# Repeat for count...
+	smovb				#   move from %ds:si to %es:di
+
+	popl	%edi
+	popl	%esi
+	movl	%ebp, %esp
+	popl	%ebp
+	ret
+	SYM_FUNC_END(dtrace_copy)
+
+#endif	/* __i386__ */
+
+#if defined(__x86_64__)
+
+	SYM_FUNC_START(dtrace_copystr)
+	pushq	%rbp
+	movq	%rsp, %rbp
+
+	ASM_STAC
+0:
+	movb	(%rdi), %al		# load from source
+	movb	%al, (%rsi)		# store to destination
+	addq	$1, %rdi		# increment source pointer
+	addq	$1, %rsi		# increment destination pointer
+	subq	$1, %rdx		# decrement remaining count
+	cmpb	$0, %al
+	je	2f
+	testq	$0xfff, %rdx		# test if count is 4k-aligned
+	jnz	1f			# if not, continue with copying
+	testq	$CPU_DTRACE_BADADDR, (%rcx) # load and test dtrace flags
+	jnz	2f
+1:
+	cmpq	$0, %rdx
+	jne	0b
+2:
+	ASM_CLAC
+	leave
+	ret
+
+	SYM_FUNC_END(dtrace_copystr)
+
+#elif defined(__i386__)
+
+	SYM_FUNC_START(dtrace_copystr)
+
+	pushl	%ebp			# Setup stack frame
+	movl	%esp, %ebp
+	pushl	%ebx			# Save registers
+
+	movl	8(%ebp), %ebx		# Load source address
+	movl	12(%ebp), %edx		# Load destination address
+	movl	16(%ebp), %ecx		# Load count
+
+0:
+	movb	(%ebx), %al		# Load from source
+	movb	%al, (%edx)		# Store to destination
+	incl	%ebx			# Increment source pointer
+	incl	%edx			# Increment destination pointer
+	decl	%ecx			# Decrement remaining count
+	cmpb	$0, %al
+	je	2f
+	testl	$0xfff, %ecx		# Check if count is 4k-aligned
+	jnz	1f
+	movl	20(%ebp), %eax		# load flags pointer
+	testl	$CPU_DTRACE_BADADDR, (%eax) # load and test dtrace flags
+	jnz	2f
+1:
+	cmpl	$0, %ecx
+	jne	0b
+
+2:
+	popl	%ebx
+	movl	%ebp, %esp
+	popl	%ebp
+	ret
+
+	SYM_FUNC_END(dtrace_copystr)
+
+#endif	/* __i386__ */
+
+#if defined(__x86_64__)
+
+	SYM_CODE_START(dtrace_fuword8_nocheck)
+	xorq	%rax, %rax
+	ASM_STAC
+	movb	(%rdi), %al
+	ASM_CLAC
+	ret
+	SYM_CODE_END(dtrace_fuword8_nocheck)
+
+#elif defined(__i386__)
+
+	SYM_CODE_START(dtrace_fuword8_nocheck)
+	movl	4(%esp), %ecx
+	xorl	%eax, %eax
+	movzbl	(%ecx), %eax
+	ret
+	SYM_CODE_END(dtrace_fuword8_nocheck)
+
+#endif	/* __i386__ */
+
+#if defined(__x86_64__)
+
+	SYM_CODE_START(dtrace_fuword16_nocheck)
+	xorq	%rax, %rax
+	ASM_STAC
+	movw	(%rdi), %ax
+	ASM_CLAC
+	ret
+	SYM_CODE_END(dtrace_fuword16_nocheck)
+
+#elif defined(__i386__)
+
+	SYM_CODE_START(dtrace_fuword16_nocheck)
+	movl	4(%esp), %ecx
+	xorl	%eax, %eax
+	movzwl	(%ecx), %eax
+	ret
+	SYM_CODE_END(dtrace_fuword16_nocheck)
+
+#endif	/* __i386__ */
+
+#if defined(__x86_64__)
+
+	SYM_CODE_START(dtrace_fuword32_nocheck)
+	xorq	%rax, %rax
+	ASM_STAC
+	movl	(%rdi), %eax
+	ASM_CLAC
+	ret
+	SYM_CODE_END(dtrace_fuword32_nocheck)
+
+#elif defined(__i386__)
+
+	SYM_CODE_START(dtrace_fuword32_nocheck)
+	movl	4(%esp), %ecx
+	xorl	%eax, %eax
+	movl	(%ecx), %eax
+	ret
+	SYM_CODE_END(dtrace_fuword32_nocheck)
+
+#endif	/* __i386__ */
+
+#if defined(__x86_64__)
+
+	SYM_CODE_START(dtrace_fuword64_nocheck)
+	ASM_STAC
+	movq	(%rdi), %rax
+	ASM_CLAC
+	ret
+	SYM_CODE_END(dtrace_fuword64_nocheck)
+
+#elif defined(__i386__)
+
+	SYM_CODE_START(dtrace_fuword64_nocheck)
+	movl	4(%esp), %ecx
+	xorl	%eax, %eax
+	xorl	%edx, %edx
+	movl	(%ecx), %eax
+	movl	4(%ecx), %edx
+	ret
+	SYM_CODE_END(dtrace_fuword64_nocheck)
+
+#endif	/* __i386__ */
diff --git a/arch/x86/dtrace/dtrace_isa_x86_64.c b/arch/x86/dtrace/dtrace_isa_x86_64.c
new file mode 100644
index 000000000000..5accadc9f121
--- /dev/null
+++ b/arch/x86/dtrace/dtrace_isa_x86_64.c
@@ -0,0 +1,228 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_isa_x86_64.c
+ * DESCRIPTION:	DTrace - x86_64 architecture specific support functions
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dtrace_cpu.h>
+#include <asm/unwind.h>
+
+#include "dtrace.h"
+
+/* Register indices */
+#define REG_TRAPNO	25
+#define REG_GS		24
+#define REG_FS		23
+#define REG_ES		22
+#define REG_DS		21
+#define REG_SS		20
+#define REG_RSP		19
+#define REG_RFL		18
+#define REG_CS		17
+#define REG_RIP		16
+#define REG_ERR		15
+#define REG_RDI		14
+#define REG_RSI		13
+#define REG_RDX		12
+#define REG_RCX		11
+#define REG_RAX		10
+#define REG_R8		9
+#define REG_R9		8
+#define REG_R10		7
+#define REG_R11		6
+#define REG_RBX		5
+#define REG_RBP		4
+#define REG_R12		3
+#define REG_R13		2
+#define REG_R14		1
+#define REG_R15		0
+
+extern void	dtrace_copy(uintptr_t, uintptr_t, size_t);
+extern void	dtrace_copystr(uintptr_t, uintptr_t, size_t,
+			       volatile uint16_t *);
+
+uintptr_t _userlimit = 0x00007fffffffffffLL;
+uintptr_t kernelbase = 0xffff880000000000LL;
+
+static int dtrace_copycheck(uintptr_t uaddr, uintptr_t kaddr, size_t size)
+{
+#ifdef FIXME
+	ASSERT(kaddr >= kernelbase && kaddr + size >= kaddr);
+#else
+	if (kaddr < kernelbase || kaddr + size < kaddr) {
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);
+		this_cpu_core->cpuc_dtrace_illval = kaddr;
+		return 0;
+	}
+#endif
+
+	if (uaddr + size >= kernelbase || uaddr + size < uaddr) {
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);
+		this_cpu_core->cpuc_dtrace_illval = uaddr;
+		return 0;
+	}
+
+	return 1;
+}
+
+void dtrace_copyin_arch(uintptr_t uaddr, uintptr_t kaddr, size_t size,
+			volatile uint16_t *flags)
+{
+	if (dtrace_copycheck(uaddr, kaddr, size))
+		dtrace_copy(uaddr, kaddr, size);
+}
+
+void dtrace_copyout(uintptr_t uaddr, uintptr_t kaddr, size_t size,
+		    volatile uint16_t *flags)
+{
+	if (dtrace_copycheck(uaddr, kaddr, size))
+		dtrace_copy(kaddr, uaddr, size);
+}
+
+void dtrace_copyinstr_arch(uintptr_t uaddr, uintptr_t kaddr, size_t size,
+			   volatile uint16_t *flags)
+{
+	if (dtrace_copycheck(uaddr, kaddr, size))
+		dtrace_copystr(uaddr, kaddr, size, flags);
+}
+
+void dtrace_copyoutstr(uintptr_t uaddr, uintptr_t kaddr, size_t size,
+		       volatile uint16_t *flags)
+{
+	if (dtrace_copycheck(uaddr, kaddr, size))
+		dtrace_copystr(kaddr, uaddr, size, flags);
+}
+
+#define DTRACE_FUWORD(bits) \
+	uint##bits##_t dtrace_fuword##bits(void *uaddr)			      \
+	{								      \
+		extern uint##bits##_t	dtrace_fuword##bits##_nocheck(void *);\
+									      \
+		if ((uintptr_t)uaddr > _userlimit) {			      \
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);		      \
+			this_cpu_core->cpuc_dtrace_illval = (uintptr_t)uaddr; \
+			return 0;					      \
+		}							      \
+									      \
+		return dtrace_fuword##bits##_nocheck(uaddr);		      \
+	}
+
+DTRACE_FUWORD(8)
+DTRACE_FUWORD(16)
+DTRACE_FUWORD(32)
+DTRACE_FUWORD(64)
+
+uint64_t dtrace_getarg(int argno, int aframes)
+{
+	unsigned long		bp;
+	uint64_t		*st;
+	uint64_t		val;
+	int			i;
+	struct unwind_state	state;
+
+	if (this_cpu_core->cpu_dtrace_regs)
+		bp = this_cpu_core->cpu_dtrace_regs->bp;
+	else {
+		unwind_start(&state, current, NULL, NULL);
+		for (i = 0; !unwind_done(&state) && i < aframes;
+		     unwind_next_frame(&state)) {
+			i++;
+		}
+
+		bp = (unsigned long)state.bp;
+	}
+
+	ASSERT(argno >= 5);
+
+	/*
+	 * The first 5 arguments (arg0 through arg4) are passed in registers
+	 * to dtrace_probe().  The remaining arguments (arg5 through arg9) are
+	 * passed on the stack.
+	 *
+	 * Stack layout:
+	 * bp[0] = pushed bp from caller
+	 * bp[1] = return address
+	 * bp[2] = 6th argument (arg5 -> argno = 5)
+	 * bp[3] = 7th argument (arg6 -> argno = 6)
+	 * ...
+	 */
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+	st = (uint64_t *)bp;
+	val = st[2 + (argno - 5)];
+	DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+
+	return val;
+}
+
+ulong_t dtrace_getreg(struct task_struct *task, uint_t reg)
+{
+	struct pt_regs	*rp = task_pt_regs(task);
+
+	int	regmap[] = {
+				REG_RBX,	/*  0 -> EBX */
+				REG_RCX,	/*  1 -> ECX */
+				REG_RDX,	/*  2 -> EDX */
+				REG_RSI,	/*  3 -> ESI */
+				REG_RDI,	/*  4 -> EDI */
+				REG_RBP,	/*  5 -> EBP */
+				REG_RAX,	/*  6 -> EAX */
+				REG_DS,		/*  7 -> DS */
+				REG_ES,		/*  8 -> ES */
+				REG_FS,		/*  9 -> FS */
+				REG_GS,		/* 10 -> GS */
+				REG_TRAPNO,	/* 11 -> TRAPNO */
+				REG_RIP,	/* 12 -> EIP */
+				REG_CS,		/* 13 -> CS */
+				REG_RFL,	/* 14 -> EFL */
+				REG_RSP,	/* 15 -> UESP */
+				REG_SS,		/* 16 -> SS */
+			   };
+
+	if (reg > REG_TRAPNO) {
+		/*
+		 * Convert register alias index into register mapping index.
+		 */
+		reg -= REG_GS + 1;
+
+		if (reg >= sizeof(regmap) / sizeof(int)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
+			return 0;
+		}
+
+		reg = regmap[reg];
+	}
+
+	/*
+	 * Most common case: direct index into pt_regs structure.
+	 */
+	if (reg <= REG_SS)
+		return (&rp->r15)[reg];
+
+	switch (reg) {
+	case REG_DS:
+		return task->thread.ds;
+	case REG_ES:
+		return task->thread.es;
+	case REG_FS:
+		return task->thread.fsbase;
+	case REG_GS:
+		return task->thread.gsbase;
+	case REG_TRAPNO:
+		return task->thread.trap_nr;
+	default:
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
+		return 0;
+	}
+}
diff --git a/dtrace/Makefile b/dtrace/Makefile
new file mode 100644
index 000000000000..36a4b97b922c
--- /dev/null
+++ b/dtrace/Makefile
@@ -0,0 +1,19 @@
+#
+# Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
+#
+
+obj-$(CONFIG_DT_CORE)		+= dtrace.o
+obj-$(CONFIG_DT_DT_TEST)	+= dt_test.o
+
+dtrace-y			:= dtrace_mod.o dtrace_dev.o \
+				   dtrace_actdesc.o dtrace_anon.o \
+				   dtrace_buffer.o dtrace_dif.o dtrace_dof.o \
+				   dtrace_ecb.o dtrace_enable.o \
+				   dtrace_fmt.o dtrace_hash.o dtrace_isa.o \
+				   dtrace_match.o dtrace_priv.o \
+				   dtrace_probe.o dtrace_probe_ctx.o \
+				   dtrace_ptofapi.o dtrace_predicate.o \
+				   dtrace_spec.o dtrace_state.o dtrace_util.o
+dt_test-y			:= dt_test_mod.o dt_test_dev.o
+
+-include arch/$(SRCARCH)/dtrace/Makefile.arch
diff --git a/dtrace/ctf_api.h b/dtrace/ctf_api.h
new file mode 100644
index 000000000000..e09bafc676f4
--- /dev/null
+++ b/dtrace/ctf_api.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Compact C Type format
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __CTF_API_H_
+#define __CTF_API_H_
+
+/*
+ * The CTF data model is inferred to be the caller's data model or the data
+ * model of the given object, unless ctf_setmodel() is explicitly called.
+ */
+#define CTF_MODEL_ILP32		1	/* object data model is ILP32 */
+#define CTF_MODEL_LP64		2	/* object data model is LP64 */
+#ifdef CONFIG_64BIT
+# define CTF_MODEL_NATIVE	CTF_MODEL_LP64
+#else
+# define CTF_MODEL_NATIVE	CTF_MODEL_ILP32
+#endif
+
+#endif /* __CTF_API_H_ */
diff --git a/dtrace/dt_test.h b/dtrace/dt_test.h
new file mode 100644
index 000000000000..6efe4656001b
--- /dev/null
+++ b/dtrace/dt_test.h
@@ -0,0 +1,30 @@
+/*
+ * Dynamic Tracing for Linux - test provider
+ *
+ * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DT_TEST_H_
+#define _DT_TEST_H_
+
+extern void dt_test_provide(void *, const struct dtrace_probedesc *);
+extern int dt_test_enable(void *arg, dtrace_id_t, void *);
+extern void dt_test_disable(void *arg, dtrace_id_t, void *);
+extern void dt_test_destroy(void *, dtrace_id_t, void *);
+
+extern dtrace_provider_id_t	dt_test_id;
+
+extern int dt_test_dev_init(void);
+extern void dt_test_dev_exit(void);
+
+#endif /* _DT_TEST_H_ */
diff --git a/dtrace/dt_test_dev.c b/dtrace/dt_test_dev.c
new file mode 100644
index 000000000000..8e1f5bab8a12
--- /dev/null
+++ b/dtrace/dt_test_dev.c
@@ -0,0 +1,176 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dt_test_dev.c
+ * DESCRIPTION:	DTrace - test provider device driver
+ *
+ * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/types.h>
+#include <trace/syscall.h>
+#include <asm/unistd.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "dt_test.h"
+
+static dtrace_id_t	pid = DTRACE_IDNONE;
+static int		enabled;
+
+/*
+ * Some arrays of structures of different sizes populated with
+ * unchanging randomly-chosen numbers, for padding tests.
+ */
+
+static struct dt_test_int_char
+{
+	int foo;
+	char bar;
+} intish[2] __attribute__((used)) = { { 47204473, 48 },
+				       { 18472, 62 } };
+
+static struct dt_test_long_int
+{
+	long foo;
+	int bar;
+} longish[2] __attribute__((used)) = { { 43737975, 240724 },
+					{ 24924709, 526 } };
+
+static struct dt_test_longlong_long
+{
+	long long foo;
+	long bar;
+} longlongish[2] __attribute__((used)) = { { 4294479287, 4395957 },
+					    { 5239637, 249750 } };
+
+static struct dt_test_like_a_scatterlist
+{
+	unsigned long	a;
+	unsigned int	b;
+	unsigned int	c;
+	u64	d;
+	unsigned int	e;
+} scatter_failure[2] __attribute__((used)) = { { .a = 1, .b = 2,
+						 .c = 3, .d = 4, .e = 5 },
+					       { .a = 6, .b = 7,
+						 .c = 8, .d = 9, .e = 10 } };
+
+void dt_test_provide(void *arg, const struct dtrace_probedesc *desc)
+{
+	dtrace_id_t probe;
+
+	probe = dtrace_probe_lookup(dt_test_id, "dt_test", NULL, "test");
+	if (probe != DTRACE_IDNONE)
+		return;
+
+	pid = dtrace_probe_create(dt_test_id, "dt_test", NULL, "test", 1, NULL);
+}
+
+int dt_test_enable(void *arg, dtrace_id_t id, void *parg)
+{
+	enabled = 1;
+
+	return 0;
+}
+
+void dt_test_disable(void *arg, dtrace_id_t id, void *parg)
+{
+	enabled = 0;
+}
+
+void dt_test_destroy(void *arg, dtrace_id_t id, void *parg)
+{
+}
+
+void probe_p(dtrace_id_t pid, uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
+	      uintptr_t arg3, uintptr_t arg4, uintptr_t arg5, uintptr_t arg6,
+	      uintptr_t arg7, uintptr_t arg8, uintptr_t arg9)
+{
+}
+
+/*
+ * Direct calling into dtrace_probe() when passing more than 5 parameters to
+ * the probe requires a stub function.  Otherwise we may not be able to get
+ * to the value of all arguments correctly.
+ */
+void dt_test_probe(uintptr_t arg0, uintptr_t arg1, uintptr_t arg2,
+		   uintptr_t arg3, uintptr_t arg4, uintptr_t arg5,
+		   uintptr_t arg6, uintptr_t arg7, uintptr_t arg8,
+		   uintptr_t arg9)
+{
+	/*
+	 * Yes, this is not nice.
+	 * Not at all...
+	 * But we're doing it anyway...
+	 */
+	typeof(probe_p) *probe_fn = (void *)&dtrace_probe;
+
+	probe_fn(pid, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
+		 arg9);
+}
+
+static long dt_test_ioctl(struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	if (enabled) {
+		dt_test_probe(cmd, arg, 2ULL, 3ULL, 4ULL, 5ULL, 6ULL, 7ULL,
+					8ULL, 9ULL);
+
+		return 0;
+	}
+
+	return -EAGAIN;
+}
+
+static int dt_test_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int dt_test_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations dt_test_fops = {
+	.owner  = THIS_MODULE,
+	.unlocked_ioctl = dt_test_ioctl,
+	.open   = dt_test_open,
+	.release = dt_test_close,
+};
+
+static struct miscdevice dt_test_dev = {
+	.minor = DT_DEV_DT_TEST_MINOR,
+	.name = "dt_test",
+	.nodename = "dtrace/provider/dt_test",
+	.fops = &dt_test_fops,
+};
+
+int dt_test_dev_init(void)
+{
+	int	ret = 0;
+
+	ret = misc_register(&dt_test_dev);
+	if (ret)
+		pr_err("%s: Can't register misc device %d\n",
+		       dt_test_dev.name, dt_test_dev.minor);
+
+	return ret;
+}
+
+void dt_test_dev_exit(void)
+{
+	misc_deregister(&dt_test_dev);
+}
diff --git a/dtrace/dt_test_mod.c b/dtrace/dt_test_mod.c
new file mode 100644
index 000000000000..d8af71665a37
--- /dev/null
+++ b/dtrace/dt_test_mod.c
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dt_test_mod.c
+ * DESCRIPTION:	DTrace - test provider kernel module
+ *
+ * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+
+#include "dtrace.h"
+#include "dtrace_dev.h"
+#include "dt_test.h"
+
+MODULE_AUTHOR("Kris Van Hees (kris.van.hees@oracle.com)");
+MODULE_DESCRIPTION("DTrace Test Probe");
+MODULE_VERSION("v0.1");
+MODULE_LICENSE("GPL");
+
+static const struct dtrace_pattr dt_test_attr = {
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_COMMON },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_ISA },
+{ DTRACE_STABILITY_EVOLVING, DTRACE_STABILITY_EVOLVING, DTRACE_CLASS_COMMON },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_ISA },
+};
+
+static struct dtrace_pops dt_test_pops = {
+	.dtps_provide = dt_test_provide,
+	.dtps_provide_module = NULL,
+	.dtps_destroy_module = NULL,
+	.dtps_enable = dt_test_enable,
+	.dtps_disable = dt_test_disable,
+	.dtps_suspend = NULL,
+	.dtps_resume = NULL,
+	.dtps_getargdesc = NULL,
+	.dtps_getargval = NULL,
+	.dtps_usermode = NULL,
+	.dtps_destroy = dt_test_destroy
+};
+
+DT_PROVIDER_MODULE(dt_test, DTRACE_PRIV_USER)
diff --git a/dtrace/dtrace.h b/dtrace/dtrace.h
new file mode 100644
index 000000000000..f632b910ac30
--- /dev/null
+++ b/dtrace/dtrace.h
@@ -0,0 +1,35 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Dynamic Tracing for Linux
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DTRACE_H_
+#define _DTRACE_H_
+
+#include <linux/dtrace_cpu.h>
+#include <linux/dtrace_os.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+
+#include "dtrace_debug.h"
+
+#include <dtrace/types.h>
+
+#include <linux/dtrace/dtrace.h>
+
+#include <dtrace/provider.h>
+#include <dtrace/dtrace_impl.h>
+
+#endif /* _DTRACE_H_ */
diff --git a/dtrace/dtrace_actdesc.c b/dtrace/dtrace_actdesc.c
new file mode 100644
index 000000000000..fada47a6e5eb
--- /dev/null
+++ b/dtrace/dtrace_actdesc.c
@@ -0,0 +1,91 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_actdesc.c
+ * DESCRIPTION:	DTrace - action implementation
+ *
+ * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#include "dtrace.h"
+
+struct dtrace_actdesc *dtrace_actdesc_create(dtrace_actkind_t kind,
+                                             uint32_t ntuple,
+                                             uint64_t uarg, uint64_t arg)
+{
+	struct dtrace_actdesc	*act;
+
+#ifdef FIXME
+	ASSERT(!DTRACEACT_ISPRINTFLIKE(kind) ||
+	       (arg != 0 && (uintptr_t)arg >= KERNELBASE) ||
+	       (arg == 0 && kind == DTRACEACT_PRINTA));
+#else
+	ASSERT(!DTRACEACT_ISPRINTFLIKE(kind) ||
+	       (arg != 0) ||
+	       (arg == 0 && kind == DTRACEACT_PRINTA));
+#endif
+
+	act = kzalloc(sizeof(struct dtrace_actdesc), GFP_KERNEL);
+	if (act == NULL)
+		return NULL;
+
+	act->dtad_kind = kind;
+	act->dtad_ntuple = ntuple;
+	act->dtad_uarg = uarg;
+	act->dtad_arg = arg;
+	act->dtad_refcnt = 1;
+
+	return act;
+}
+
+void dtrace_actdesc_hold(struct dtrace_actdesc *act)
+{
+	ASSERT(act->dtad_refcnt >= 1);
+
+	act->dtad_refcnt++;
+}
+
+void dtrace_actdesc_release(struct dtrace_actdesc *act,
+			    struct dtrace_vstate *vstate)
+{
+	dtrace_actkind_t	kind = act->dtad_kind;
+	struct dtrace_difo	*dp;
+
+	ASSERT(act->dtad_refcnt >= 1);
+
+	if (--act->dtad_refcnt != 0)
+		return;
+
+	dp = act->dtad_difo;
+	if (dp != NULL)
+		dtrace_difo_release(dp, vstate);
+
+	if (DTRACEACT_ISPRINTFLIKE(kind)) {
+		char	*str = (char *)(uintptr_t)act->dtad_arg;
+
+#ifdef FIXME
+		ASSERT((str != NULL && (uintptr_t)str >= KERNELBASE) ||
+		       (str == NULL && act->dtad_kind == DTRACEACT_PRINTA));
+#else
+		ASSERT((str != NULL) ||
+		       (str == NULL && act->dtad_kind == DTRACEACT_PRINTA));
+#endif
+
+		if (str != NULL)
+			vfree(str);
+	}
+
+	kfree(act);
+}
diff --git a/dtrace/dtrace_anon.c b/dtrace/dtrace_anon.c
new file mode 100644
index 000000000000..80d0d9c1a9fd
--- /dev/null
+++ b/dtrace/dtrace_anon.c
@@ -0,0 +1,144 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_anon.c
+ * DESCRIPTION:	DTrace - Anonymous state implementation
+ *
+ * Copyright (c) 2010, 2012, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "dtrace.h"
+
+struct dtrace_anon	dtrace_anon;
+
+struct dtrace_state *dtrace_anon_grab(void)
+{
+	struct dtrace_state	*state;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	state = dtrace_anon.dta_state;
+	if (state == NULL) {
+		ASSERT(dtrace_anon.dta_enabling == NULL);
+
+		return NULL;
+	}
+
+	ASSERT(dtrace_anon.dta_enabling != NULL);
+	ASSERT(dtrace_retained != NULL);
+
+	dtrace_enabling_destroy(dtrace_anon.dta_enabling);
+	dtrace_anon.dta_enabling = NULL;
+	dtrace_anon.dta_state = NULL;
+
+	return state;
+}
+
+void dtrace_anon_property(void)
+{
+	int			i, rv;
+	struct dtrace_state	*state;
+	struct dof_hdr		*dof;
+	char			c[32];		/* enough for "dof-data-" + digits */
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(MUTEX_HELD(&cpu_lock));
+
+	for (i = 0; ; i++) {
+		snprintf(c, sizeof(c), "dof-data-%d", i);
+
+		dtrace_err_verbose = 1;
+
+		dof = dtrace_dof_property(c);
+		if (dof == NULL) {
+			dtrace_err_verbose = 0;
+			break;
+		}
+
+#ifdef FIXME
+		/*
+		 * We want to create anonymous state, so we need to transition
+		 * the kernel debugger to indicate that DTrace is active.  If
+		 * this fails (e.g. because the debugger has modified text in
+		 * some way), we won't continue with the processing.
+		 */
+		if (kdi_dtrace_set(KDI_DTSET_DTRACE_ACTIVATE) != 0) {
+			pr_info("kernel debugger active; "
+				"anonymous enabling ignored.");
+			dtrace_dof_destroy(dof);
+			break;
+		}
+#endif
+
+		/*
+		 * If we haven't allocated an anonymous state, we'll do so now.
+		 */
+		state = dtrace_anon.dta_state;
+		if (state == NULL) {
+			state = dtrace_state_create(NULL);
+			dtrace_anon.dta_state = state;
+
+			if (state == NULL) {
+				/*
+				 * This basically shouldn't happen: there is no
+				 * failure mode from dtrace_state_create().
+				 * Still, the interface allows for a failure
+				 * mode, and we want to fail as gracefully as
+				 * possible: we'll emit an error message and
+				 * cease processing anonymous state in this
+				 * case.
+				 */
+				pr_warn("failed to create anonymous state");
+				dtrace_dof_destroy(dof);
+				break;
+			}
+		}
+
+		rv = dtrace_dof_slurp(dof, &state->dts_vstate, current_cred(),
+				      &dtrace_anon.dta_enabling, 0, TRUE);
+
+		if (rv == 0)
+			rv = dtrace_dof_options(dof, state);
+
+		dtrace_err_verbose = 0;
+		dtrace_dof_destroy(dof);
+
+		if (rv != 0) {
+			/*
+			 * This is malformed DOF; chuck any anonymous state
+			 * that we created.
+			 */
+			ASSERT(dtrace_anon.dta_enabling == NULL);
+			dtrace_state_destroy(state);
+			dtrace_anon.dta_state = NULL;
+			break;
+		}
+
+		ASSERT(dtrace_anon.dta_enabling != NULL);
+	}
+
+	if (dtrace_anon.dta_enabling != NULL) {
+		int	rval;
+
+		/*
+		 * dtrace_enabling_retain() can only fail because we are
+		 * trying to retain more enablings than are allowed -- but
+		 * we only have one anonymous enabling, and we are guaranteed
+		 * to be allowed at least one retained enabling; we assert
+		 * that dtrace_enabling_retain() returns success.
+		 */
+		rval = dtrace_enabling_retain(dtrace_anon.dta_enabling);
+		ASSERT(rval == 0);
+
+		dtrace_enabling_dump(dtrace_anon.dta_enabling);
+	}
+}
diff --git a/dtrace/dtrace_buffer.c b/dtrace/dtrace_buffer.c
new file mode 100644
index 000000000000..9e7faebc51b7
--- /dev/null
+++ b/dtrace/dtrace_buffer.c
@@ -0,0 +1,490 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_buffer.c
+ * DESCRIPTION:	DTrace - buffer implementation
+ *
+ * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/vmalloc.h>
+
+#include "dtrace.h"
+
+dtrace_optval_t		dtrace_nonroot_maxsize = (16 * 1024 * 1024);
+
+/*
+ * Note:  called from cross call context.  This function switches the two
+ * buffers on a given CPU.  The atomicity of this operation is assured by
+ * disabling interrupts while the actual switch takes place; the disabling of
+ * interrupts serializes the execution with any execution of dtrace_probe() on
+ * the same CPU.
+ */
+void dtrace_buffer_switch(struct dtrace_buffer *buf)
+{
+	caddr_t			tomax = buf->dtb_tomax;
+	caddr_t			xamot = buf->dtb_xamot;
+	dtrace_icookie_t	cookie;
+
+	ASSERT(!(buf->dtb_flags & DTRACEBUF_NOSWITCH));
+	ASSERT(!(buf->dtb_flags & DTRACEBUF_RING));
+
+	local_irq_save(cookie);
+
+	dt_dbg_buf("Switch (CPU %d): tomax %p (%lld) <-> xamot %p (%lld)\n",
+		   smp_processor_id(), tomax, buf->dtb_offset,
+		   xamot, buf->dtb_xamot_offset);
+
+	buf->dtb_tomax = xamot;
+	buf->dtb_xamot = tomax;
+	buf->dtb_xamot_drops = buf->dtb_drops;
+	buf->dtb_xamot_offset = buf->dtb_offset;
+	buf->dtb_xamot_errors = buf->dtb_errors;
+	buf->dtb_xamot_flags = buf->dtb_flags;
+	buf->dtb_offset = 0;
+	buf->dtb_drops = 0;
+	buf->dtb_errors = 0;
+	buf->dtb_flags &= ~(DTRACEBUF_ERROR | DTRACEBUF_DROPPED);
+
+	local_irq_restore(cookie);
+}
+
+/*
+ * Note:  called from cross call context.  This function activates a buffer
+ * on a CPU.  As with dtrace_buffer_switch(), the atomicity of the operation
+ * is guaranteed by the disabling of interrupts.
+ */
+void dtrace_buffer_activate(struct dtrace_state *state)
+{
+	struct dtrace_buffer	*buf;
+	dtrace_icookie_t	cookie;
+
+	local_irq_save(cookie);
+
+	buf = &state->dts_buffer[smp_processor_id()];
+
+	if (buf->dtb_tomax != NULL)
+		/*
+		 * We might like to assert that the buffer is marked inactive,
+		 * but this isn't necessarily true:  the buffer for the CPU
+		 * that processes the BEGIN probe has its buffer activated
+		 * manually.  In this case, we take the (harmless) action
+		 * re-clearing the bit INACTIVE bit.
+		 */
+		 buf->dtb_flags &= ~DTRACEBUF_INACTIVE;
+
+	local_irq_restore(cookie);
+}
+
+int dtrace_buffer_alloc(struct dtrace_buffer *bufs, size_t size, int flags,
+			processorid_t cpuid)
+{
+	processorid_t	cpu;
+	struct dtrace_buffer	*buf;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(MUTEX_HELD(&cpu_lock));
+
+#ifdef FIXME
+	if (size > dtrace_nonroot_maxsize &&
+	    !PRIV_POLICY_CHOICE(current_cred(), PRIV_ALL, FALSE))
+		return -EFBIG;
+#endif
+
+	for_each_online_cpu(cpu) {
+		if (cpuid != DTRACE_CPUALL && cpuid != cpu)
+			continue;
+
+		buf = &bufs[cpu];
+
+		/*
+		 * If there is already a buffer allocated for this CPU, it
+		 * is only possible that this is a DR event.  In this case,
+		 * the buffer size must match our specified size.
+		 */
+		if (buf->dtb_tomax != NULL) {
+			ASSERT(buf->dtb_size == size);
+			continue;
+		}
+
+		ASSERT(buf->dtb_xamot == NULL);
+
+		buf->dtb_tomax = dtrace_vzalloc_try(size);
+		if (buf->dtb_tomax == NULL)
+			goto err;
+
+		buf->dtb_size = size;
+		buf->dtb_flags = flags;
+		buf->dtb_offset = 0;
+		buf->dtb_drops = 0;
+
+		if (flags & DTRACEBUF_NOSWITCH)
+			continue;
+
+		buf->dtb_xamot = dtrace_vzalloc_try(size);
+		if (buf->dtb_xamot == NULL)
+			goto err;
+	}
+
+	return 0;
+
+err:
+	for_each_online_cpu(cpu) {
+		if (cpuid != DTRACE_CPUALL && cpuid != cpu)
+			continue;
+
+		buf = &bufs[cpu];
+
+		if (buf->dtb_xamot != NULL) {
+			ASSERT(buf->dtb_tomax != NULL);
+			ASSERT(buf->dtb_size == size);
+			vfree(buf->dtb_xamot);
+		}
+
+		if (buf->dtb_tomax != NULL) {
+			ASSERT(buf->dtb_size == size);
+			vfree(buf->dtb_tomax);
+		}
+
+		buf->dtb_tomax = NULL;
+		buf->dtb_xamot = NULL;
+		buf->dtb_size = 0;
+	}
+
+	return -ENOMEM;
+}
+void dtrace_buffer_drop(struct dtrace_buffer *buf)
+{
+	buf->dtb_drops++;
+}
+
+intptr_t dtrace_buffer_reserve(struct dtrace_buffer *buf, size_t needed,
+			       size_t align, struct dtrace_state *state,
+			       struct dtrace_mstate *mstate)
+{
+	intptr_t	offs = buf->dtb_offset, soffs;
+	intptr_t	woffs;
+	caddr_t		tomax;
+	size_t		total;
+
+	if (buf->dtb_flags & DTRACEBUF_INACTIVE)
+		return -1;
+
+	tomax = buf->dtb_tomax;
+	if (tomax == NULL) {
+		dtrace_buffer_drop(buf);
+		return -1;
+	}
+
+	if (!(buf->dtb_flags & (DTRACEBUF_RING | DTRACEBUF_FILL))) {
+		while (offs & (align - 1)) {
+			/*
+			 * Assert that our alignment is off by a number which
+			 * is itself sizeof (uint32_t) aligned.
+			 */
+			ASSERT(!((align - (offs & (align - 1))) &
+				(sizeof(uint32_t) - 1)));
+			DTRACE_STORE(uint32_t, tomax, offs, DTRACE_EPIDNONE);
+			dt_dbg_buf("    Store: %p[%ld .. %ld] <- EPIDNONE "
+				   "(from %s::%d)\n",
+				   buf, offs, offs + sizeof(uint32_t) - 1,
+				   __func__, __LINE__);
+			offs += sizeof(uint32_t);
+		}
+
+		soffs = offs + needed;
+		if (soffs > buf->dtb_size) {
+			dtrace_buffer_drop(buf);
+			return -1;
+		}
+
+		if (mstate == NULL) {
+			dt_dbg_buf("  Reserve: %p[%ld .. %ld]\n",
+				   buf, offs, offs + needed - 1);
+			return offs;
+		}
+
+		mstate->dtms_scratch_base = (uintptr_t)tomax + soffs;
+		mstate->dtms_scratch_size = buf->dtb_size - soffs;
+		mstate->dtms_scratch_ptr = mstate->dtms_scratch_base;
+
+		dt_dbg_buf("  Reserve: %p[%ld .. %ld]\n",
+			   buf, offs, offs + needed - 1);
+		return offs;
+	}
+
+	if (buf->dtb_flags & DTRACEBUF_FILL) {
+		if (state->dts_activity != DTRACE_ACTIVITY_COOLDOWN &&
+		    (buf->dtb_flags & DTRACEBUF_FULL))
+			return -1;
+
+		goto out;
+	}
+
+	total = needed + (offs & (align - 1));
+
+	/*
+	 * For a ring buffer, life is quite a bit more complicated.  Before
+	 * we can store any padding, we need to adjust our wrapping offset.
+	 * (If we've never before wrapped or we're not about to, no adjustment
+	 * is required.)
+	 */
+	if ((buf->dtb_flags & DTRACEBUF_WRAPPED) ||
+	    offs + total > buf->dtb_size) {
+		woffs = buf->dtb_xamot_offset;
+
+		if (offs + total > buf->dtb_size) {
+			/*
+			 * We can't fit in the end of the buffer.  First, a
+			 * sanity check that we can fit in the buffer at all.
+			 */
+			if (total > buf->dtb_size) {
+				dtrace_buffer_drop(buf);
+				return -1;
+			}
+
+			/*
+			 * We're going to be storing at the top of the buffer,
+			 * so now we need to deal with the wrapped offset.  We
+			 * only reset our wrapped offset to 0 if it is
+			 * currently greater than the current offset.  If it
+			 * is less than the current offset, it is because a
+			 * previous allocation induced a wrap -- but the
+			 * allocation didn't subsequently take the space due
+			 * to an error or false predicate evaluation.  In this
+			 * case, we'll just leave the wrapped offset alone: if
+			 * the wrapped offset hasn't been advanced far enough
+			 * for this allocation, it will be adjusted in the
+			 * lower loop.
+			 */
+			if (buf->dtb_flags & DTRACEBUF_WRAPPED) {
+				if (woffs >= offs)
+					woffs = 0;
+			} else
+				woffs = 0;
+
+			/*
+			 * Now we know that we're going to be storing to the
+			 * top of the buffer and that there is room for us
+			 * there.  We need to clear the buffer from the current
+			 * offset to the end (there may be old gunk there).
+			 */
+			while (offs < buf->dtb_size)
+				tomax[offs++] = 0;
+
+			/*
+			 * We need to set our offset to zero.  And because we
+			 * are wrapping, we need to set the bit indicating as
+			 * much.  We can also adjust our needed space back
+			 * down to the space required by the ECB -- we know
+			 * that the top of the buffer is aligned.
+			 */
+			offs = 0;
+			total = needed;
+			buf->dtb_flags |= DTRACEBUF_WRAPPED;
+		} else {
+			/*
+			 * There is room for us in the buffer, so we simply
+			 * need to check the wrapped offset.
+			 */
+			if (woffs < offs) {
+				/*
+				 * The wrapped offset is less than the offset.
+				 * This can happen if we allocated buffer space
+				 * that induced a wrap, but then we didn't
+				 * subsequently take the space due to an error
+				 * or false predicate evaluation.  This is
+				 * okay; we know that _this_ allocation isn't
+				 * going to induce a wrap.  We still can't
+				 * reset the wrapped offset to be zero,
+				 * however: the space may have been trashed in
+				 * the previous failed probe attempt.  But at
+				 * least the wrapped offset doesn't need to
+				 * be adjusted at all...
+				 */
+				goto out;
+			}
+		}
+
+		while (offs + total > woffs) {
+			dtrace_epid_t	epid = *(uint32_t *)(tomax + woffs);
+			size_t		size;
+
+			if (epid == DTRACE_EPIDNONE)
+				size = sizeof(uint32_t);
+			else {
+				ASSERT(epid <= state->dts_necbs);
+				ASSERT(state->dts_ecbs[epid - 1] != NULL);
+
+				size = state->dts_ecbs[epid - 1]->dte_size;
+			}
+
+			ASSERT(woffs + size <= buf->dtb_size);
+			ASSERT(size != 0);
+
+			if (woffs + size == buf->dtb_size) {
+				/*
+				 * We've reached the end of the buffer; we want
+				 * to set the wrapped offset to 0 and break
+				 * out.  However, if the offs is 0, then we're
+				 * in a strange edge-condition:  the amount of
+				 * space that we want to reserve plus the size
+				 * of the record that we're overwriting is
+				 * space but subsequently don't consume it (due
+				 * to a failed predicate or error) the wrapped
+				 * offset will be 0 -- yet the EPID at offset 0
+				 * will not be committed.  This situation is
+				 * relatively easy to deal with:  if we're in
+				 * this case, the buffer is indistinguishable
+				 * from one that hasn't wrapped; we need only
+				 * finish the job by clearing the wrapped bit,
+				 * explicitly setting the offset to be 0, and
+				 * zero'ing out the old data in the buffer.
+				 */
+				if (offs == 0) {
+					buf->dtb_flags &= ~DTRACEBUF_WRAPPED;
+					buf->dtb_offset = 0;
+					woffs = total;
+
+					while (woffs < buf->dtb_size)
+						tomax[woffs++] = 0;
+				}
+
+				woffs = 0;
+				break;
+			}
+
+			woffs += size;
+		}
+
+		/*
+		 * We have a wrapped offset.  It may be that the wrapped offset
+		 * has become zero -- that's okay.
+		 */
+		buf->dtb_xamot_offset = woffs;
+	}
+
+out:
+	/*
+	 * Now we can plow the buffer with any necessary padding.
+	 */
+	while (offs & (align - 1)) {
+		/*
+		 * Assert that our alignment is off by a number which
+		 * is itself sizeof(uint32_t) aligned.
+		 */
+		ASSERT(!((align - (offs & (align - 1))) &
+			(sizeof(uint32_t) - 1)));
+		DTRACE_STORE(uint32_t, tomax, offs, DTRACE_EPIDNONE);
+		dt_dbg_buf("    Store: %p[%ld .. %ld] <- EPIDNONE "
+			   "(from %s::%d)\n",
+			   buf, offs, offs + sizeof(uint32_t) - 1,
+			   __func__, __LINE__);
+		offs += sizeof(uint32_t);
+	}
+
+	if (buf->dtb_flags & DTRACEBUF_FILL) {
+		if (offs + needed > buf->dtb_size - state->dts_reserve) {
+			buf->dtb_flags |= DTRACEBUF_FULL;
+			return -1;
+		}
+	}
+
+	if (mstate == NULL) {
+		dt_dbg_buf("  Reserve: %p[%ld .. %ld]\n",
+			   buf, offs, offs + needed - 1);
+		return offs;
+	}
+
+	/*
+	 * For ring buffers and fill buffers, the scratch space is always
+	 * the inactive buffer.
+	 */
+	mstate->dtms_scratch_base = (uintptr_t)buf->dtb_xamot;
+	mstate->dtms_scratch_size = buf->dtb_size;
+	mstate->dtms_scratch_ptr = mstate->dtms_scratch_base;
+
+	dt_dbg_buf("  Reserve: %p[%ld .. %ld]\n",
+		   buf, offs, offs + needed - 1);
+	return offs;
+}
+
+void dtrace_buffer_polish(struct dtrace_buffer *buf)
+{
+	ASSERT(buf->dtb_flags & DTRACEBUF_RING);
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	if (!(buf->dtb_flags & DTRACEBUF_WRAPPED))
+		return;
+
+	/*
+	 * We need to polish the ring buffer.  There are three cases:
+	 *
+	 * - The first (and presumably most common) is that there is no gap
+	 *   between the buffer offset and the wrapped offset.  In this case,
+	 *   there is nothing in the buffer that isn't valid data; we can
+	 *   mark the buffer as polished and return.
+	 *
+	 * - The second (less common than the first but still more common
+	 *   than the third) is that there is a gap between the buffer offset
+	 *   and the wrapped offset, and the wrapped offset is larger than the
+	 *   buffer offset.  This can happen because of an alignment issue, or
+	 *   can happen because of a call to dtrace_buffer_reserve() that
+	 *   didn't subsequently consume the buffer space.  In this case,
+	 *   we need to zero the data from the buffer offset to the wrapped
+	 *   offset.
+	 *
+	 * - The third (and least common) is that there is a gap between the
+	 *   buffer offset and the wrapped offset, but the wrapped offset is
+	 *   _less_ than the buffer offset.  This can only happen because a
+	 *   call to dtrace_buffer_reserve() induced a wrap, but the space
+	 *   was not subsequently consumed.  In this case, we need to zero the
+	 *   space from the offset to the end of the buffer _and_ from the
+	 *   top of the buffer to the wrapped offset.
+	 */
+	if (buf->dtb_offset < buf->dtb_xamot_offset)
+		memset(buf->dtb_tomax + buf->dtb_offset, 0,
+		       buf->dtb_xamot_offset - buf->dtb_offset);
+
+	if (buf->dtb_offset > buf->dtb_xamot_offset) {
+		memset(buf->dtb_tomax + buf->dtb_offset, 0,
+		       buf->dtb_size - buf->dtb_offset);
+		memset(buf->dtb_tomax, 0, buf->dtb_xamot_offset);
+	}
+}
+
+void dtrace_buffer_free(struct dtrace_buffer *bufs)
+{
+	int	cpu;
+
+	for_each_online_cpu(cpu) {
+		struct dtrace_buffer	*buf = &bufs[cpu];
+
+		if (buf->dtb_tomax == NULL) {
+			ASSERT(buf->dtb_xamot == NULL);
+			ASSERT(buf->dtb_size == 0);
+
+			continue;
+		}
+
+		if (buf->dtb_xamot != NULL) {
+			ASSERT(!(buf->dtb_flags & DTRACEBUF_NOSWITCH));
+
+			vfree(buf->dtb_xamot);
+			buf->dtb_xamot = NULL;
+		}
+
+		vfree(buf->dtb_tomax);
+		buf->dtb_size = 0;
+		buf->dtb_tomax = NULL;
+	}
+}
diff --git a/dtrace/dtrace_debug.h b/dtrace/dtrace_debug.h
new file mode 100644
index 000000000000..a55fd1a0436f
--- /dev/null
+++ b/dtrace/dtrace_debug.h
@@ -0,0 +1,118 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Dynamic Tracing for Linux
+ *
+ * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DTRACE_DEBUG_H_
+#define _DTRACE_DEBUG_H_
+
+#ifdef CONFIG_DT_DEBUG
+
+/*
+ * Enable all output and use dynamic debug when supported.
+ */
+# ifdef CONFIG_DYNAMIC_DEBUG
+
+#  define DT_DBG_AGG
+#  define DT_DBG_BUF
+#  define DT_DBG_DIF
+#  define DT_DBG_DOF
+#  define DT_DBG_ENABLE
+#  define DT_DBG_IOCTL
+#  define DT_DBG_PROBE
+#  define DT_DBG_PROVIDER
+
+#  define dt_dbg_print(fmt, ...)	pr_debug(fmt, ## __VA_ARGS__)
+
+# else /* CONFIG_DYNAMIC_DEBUG */
+
+#  undef DT_DBG_AGG
+#  undef DT_DBG_BUF
+#  undef DT_DBG_DIF
+#  undef DT_DBG_DOF
+#  undef DT_DBG_ENABLE
+#  undef DT_DBG_IOCTL
+#  undef DT_DBG_PROBE
+#  undef DT_DBG_PROVIDER
+
+#  define dt_dbg_print(fmt, ...)	pr_info(fmt, ## __VA_ARGS__)
+
+# endif /* CONFIG_DYNAMIC_DEBUG */
+
+#else /* CONFIG_DT_DEBUG */
+
+# undef DT_DBG_AGG
+# undef DT_DBG_BUF
+# undef DT_DBG_DIF
+# undef DT_DBG_DOF
+# undef DT_DBG_ENABLE
+# undef DT_DBG_IOCTL
+# undef DT_DBG_PROBE
+# undef DT_DBG_PROVIDER
+
+#endif /* CONFIG_DT_DEBUG */
+
+/*
+ * Here are the actual actions for the various debug cases.
+ */
+#ifdef DT_DBG_AGG
+# define dt_dbg_agg(fmt, ...)		dt_dbg_print(fmt, ## __VA_ARGS__)
+#else
+# define dt_dbg_agg(fmt, ...)
+#endif
+
+#ifdef DT_DBG_BUF
+# define dt_dbg_buf(fmt, ...)		dt_dbg_print(fmt, ## __VA_ARGS__)
+#else
+# define dt_dbg_buf(fmt, ...)
+#endif
+
+#ifdef DT_DBG_DIF
+# define dt_dbg_dif(fmt, ...)		dt_dbg_print(fmt, ## __VA_ARGS__)
+#else
+# define dt_dbg_dif(fmt, ...)
+#endif
+
+#ifdef DT_DBG_DOF
+# define dt_dbg_dof(fmt, ...)		dt_dbg_print(fmt, ## __VA_ARGS__)
+#else
+# define dt_dbg_dof(fmt, ...)
+#endif
+
+#ifdef DT_DBG_ENABLE
+# define dt_dbg_enable(fmt, ...)	dt_dbg_print(fmt, ## __VA_ARGS__)
+#else
+# define dt_dbg_enable(fmt, ...)
+#endif
+
+#ifdef DT_DBG_IOCTL
+# define dt_dbg_ioctl(fmt, ...)		dt_dbg_print(fmt, ## __VA_ARGS__)
+#else
+# define dt_dbg_ioctl(fmt, ...)
+#endif
+
+#ifdef DT_DBG_PROBE
+# define dt_dbg_probe(fmt, ...)		dt_dbg_print(fmt, ## __VA_ARGS__)
+#else
+# define dt_dbg_probe(fmt, ...)
+#endif
+
+#ifdef DT_DBG_PROVIDER
+# define dt_dbg_prov(fmt, ...)		dt_dbg_print(fmt, ## __VA_ARGS__)
+#else
+# define dt_dbg_prov(fmt, ...)
+#endif
+
+#endif /* _DTRACE_DEBUG_H_ */
diff --git a/dtrace/dtrace_dev.c b/dtrace/dtrace_dev.c
new file mode 100644
index 000000000000..0e52c936b9e0
--- /dev/null
+++ b/dtrace/dtrace_dev.c
@@ -0,0 +1,1599 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_dev.c
+ * DESCRIPTION:	DTrace - Framework device driver
+ *
+ * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/delay.h>
+#include <dtrace/types.h>
+#include <linux/dtrace/ioctl.h>
+#include <linux/fs.h>
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/uaccess.h>
+
+#include "ctf_api.h"
+#include "dtrace.h"
+#include "dtrace_dev.h"
+
+extern char			*dtrace_helptrace_buffer;
+extern int			dtrace_helptrace_bufsize;
+extern int			dtrace_helptrace_enabled;
+
+int				dtrace_opens;
+int				dtrace_err_verbose;
+
+struct dtrace_pops		dtrace_provider_ops = {
+	(void (*)(void *, const struct dtrace_probedesc *))dtrace_nullop,
+	(void (*)(void *, struct module *))dtrace_nullop,
+	(int (*)(void *, dtrace_id_t, void *))dtrace_enable_nullop,
+	(void (*)(void *, dtrace_id_t, void *))dtrace_nullop,
+	(void (*)(void *, dtrace_id_t, void *))dtrace_nullop,
+	(void (*)(void *, dtrace_id_t, void *))dtrace_nullop,
+	NULL,
+	NULL,
+	NULL,
+	(void (*)(void *, dtrace_id_t, void *))dtrace_nullop,
+	(void (*)(void *, struct module *))dtrace_nullop,
+};
+
+static size_t			dtrace_retain_max = 1024;
+
+struct dtrace_toxrange		*dtrace_toxrange;
+int				dtrace_toxranges;
+static int			dtrace_toxranges_max;
+
+struct kmem_cache		*dtrace_state_cachep;
+
+struct user_namespace		*init_user_namespace;
+
+static struct dtrace_pattr	dtrace_provider_attr = {
+{ DTRACE_STABILITY_STABLE, DTRACE_STABILITY_STABLE, DTRACE_CLASS_COMMON },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_PRIVATE, DTRACE_STABILITY_PRIVATE, DTRACE_CLASS_UNKNOWN },
+{ DTRACE_STABILITY_STABLE, DTRACE_STABILITY_STABLE, DTRACE_CLASS_COMMON },
+{ DTRACE_STABILITY_STABLE, DTRACE_STABILITY_STABLE, DTRACE_CLASS_COMMON },
+};
+
+DEFINE_MUTEX(dtrace_lock);
+
+void dtrace_nullop(void)
+{
+}
+
+int dtrace_enable_nullop(void)
+{
+	return 0;
+}
+
+
+#ifdef CONFIG_DT_DEBUG
+static void dtrace_ioctl_sizes(void)
+{
+#define DBG_PRINT(x) dt_dbg_ioctl("Size of %s: %lx\n", #x, sizeof(x))
+	DBG_PRINT(struct dtrace_providerdesc);
+	DBG_PRINT(struct dtrace_probedesc);
+	DBG_PRINT(struct dtrace_bufdesc);
+	DBG_PRINT(struct dtrace_eprobedesc);
+	DBG_PRINT(struct dtrace_argdesc);
+	DBG_PRINT(struct dtrace_conf);
+	DBG_PRINT(struct dtrace_status);
+	DBG_PRINT(processorid_t);
+	DBG_PRINT(struct dtrace_aggdesc);
+	DBG_PRINT(struct dtrace_fmtdesc);
+	DBG_PRINT(struct dof_hdr);
+#undef DBG_PRINT
+}
+
+#endif
+
+static int dtrace_open(struct inode *inode, struct file *file)
+{
+	struct dtrace_state	*state;
+	uint32_t		priv;
+	kuid_t			uid;
+
+	dtrace_cred2priv(file->f_cred, &priv, &uid);
+	if (priv == DTRACE_PRIV_NONE)
+		return -EACCES;
+
+#ifdef CONFIG_DT_DEBUG
+	dtrace_ioctl_sizes();
+#endif
+	mutex_lock(&module_mutex);
+	mutex_lock(&dtrace_provider_lock);
+	dtrace_probe_provide(NULL, NULL);
+	mutex_unlock(&dtrace_provider_lock);
+	mutex_unlock(&module_mutex);
+
+	mutex_lock(&cpu_lock);
+	mutex_lock(&dtrace_lock);
+
+	/*
+	 * Do not let a consumer continue if it is not possible to enable
+	 * DTrace.
+	 */
+	if (dtrace_enable() != 0) {
+		mutex_unlock(&dtrace_lock);
+		mutex_unlock(&cpu_lock);
+		return -EBUSY;
+	}
+
+	dtrace_opens++;
+	dtrace_membar_producer();
+
+	state = dtrace_state_create(file);
+	mutex_unlock(&cpu_lock);
+
+	if (state == NULL) {
+		if (--dtrace_opens == 0 && dtrace_anon.dta_enabling == NULL)
+			dtrace_disable();
+		mutex_unlock(&dtrace_lock);
+
+		return -EAGAIN;
+	}
+
+	file->private_data = state;
+	mutex_unlock(&dtrace_lock);
+
+	return 0;
+}
+
+static long dtrace_ioctl(struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	struct dtrace_state 	*state;
+	int 			rval;
+	void __user		*argp = (void __user *)arg;
+
+	state = (struct dtrace_state *) file->private_data;
+	if (state->dts_anon) {
+		ASSERT(dtrace_anon.dta_state == NULL);
+		state = state->dts_anon;
+	}
+
+	switch (cmd) {
+	case DTRACEIOC_PROVIDER: {
+		struct dtrace_providerdesc	pvd;
+		struct dtrace_provider		*pvp;
+
+		dt_dbg_ioctl("IOCTL PROVIDER (cmd %#x), argp %p\n", cmd, argp);
+
+		if (copy_from_user(&pvd, argp, sizeof(pvd)) != 0)
+			return -EFAULT;
+
+		pvd.dtvd_name[DTRACE_PROVNAMELEN - 1] = '\0';
+		mutex_lock(&dtrace_provider_lock);
+
+		for (pvp = dtrace_provider; pvp != NULL; pvp = pvp->dtpv_next) {
+			if (strcmp(pvp->dtpv_name, pvd.dtvd_name) == 0)
+				break;
+		}
+
+		mutex_unlock(&dtrace_provider_lock);
+
+		dt_dbg_ioctl("  Provider '%s' %sfound\n",
+			     pvd.dtvd_name, pvp ? "" : "not ");
+		if (pvp == NULL)
+			return -ESRCH;
+
+		memcpy(&pvd.dtvd_priv, &pvp->dtpv_priv,
+		       sizeof(struct dtrace_ppriv));
+		memcpy(&pvd.dtvd_attr, &pvp->dtpv_attr,
+		       sizeof(struct dtrace_pattr));
+
+		if (copy_to_user(argp, &pvd, sizeof(pvd)) != 0)
+			return -EFAULT;
+
+		return 0;
+	}
+
+	case DTRACEIOC_EPROBE: {
+		struct dtrace_eprobedesc epdesc;
+		struct dtrace_ecb	*ecb;
+		struct dtrace_action	*act;
+		void			*buf;
+		size_t			size;
+		uint8_t			*dest;
+		int			nrecs;
+
+		dt_dbg_ioctl("IOCTL EPROBE (cmd %#x), argp %p\n", cmd, argp);
+
+		if (copy_from_user(&epdesc, argp, sizeof(epdesc)) != 0)
+			return -EFAULT;
+
+		mutex_lock(&dtrace_lock);
+
+		ecb = dtrace_epid2ecb(state, epdesc.dtepd_epid);
+		if (ecb == NULL) {
+			mutex_unlock(&dtrace_lock);
+			return -EINVAL;
+		}
+
+		if (ecb->dte_probe == NULL) {
+			mutex_unlock(&dtrace_lock);
+			return -EINVAL;
+		}
+
+		epdesc.dtepd_probeid = ecb->dte_probe->dtpr_id;
+		epdesc.dtepd_uarg = ecb->dte_uarg;
+		epdesc.dtepd_size = ecb->dte_size;
+
+		nrecs = epdesc.dtepd_nrecs;
+		epdesc.dtepd_nrecs = 0;
+		for (act = ecb->dte_action; act != NULL; act = act->dta_next) {
+			if (DTRACEACT_ISAGG(act->dta_kind) || act->dta_intuple)
+				continue;
+
+			epdesc.dtepd_nrecs++;
+		}
+
+		/*
+		 * Now that we have the size, we need to allocate a temporary
+		 * buffer in which to store the complete description.  We need
+		 * the temporary buffer to be able to drop dtrace_lock()
+		 * across the copy_to_user(), below.
+		 */
+		size = sizeof(struct dtrace_eprobedesc) +
+		       (epdesc.dtepd_nrecs * sizeof(struct dtrace_recdesc));
+
+		buf = vmalloc(size);
+		if (buf == NULL)
+			return -ENOMEM;
+
+		dest = buf;
+		memcpy(dest, &epdesc, sizeof(epdesc));
+		dest += offsetof(struct dtrace_eprobedesc, dtepd_rec[0]);
+
+		for (act = ecb->dte_action; act != NULL; act = act->dta_next) {
+			if (DTRACEACT_ISAGG(act->dta_kind) || act->dta_intuple)
+				continue;
+
+			if (nrecs-- == 0)
+				break;
+
+			memcpy(dest, &act->dta_rec,
+			       sizeof(struct dtrace_recdesc));
+			dest += sizeof(struct dtrace_recdesc);
+		}
+
+		mutex_unlock(&dtrace_lock);
+
+		if (copy_to_user(argp, buf,
+				 (uintptr_t)(dest - (uint8_t *)buf)) != 0) {
+			vfree(buf);
+			return -EFAULT;
+		}
+
+		vfree(buf);
+		return 0;
+	}
+
+	case DTRACEIOC_AGGDESC: {
+		struct dtrace_aggdesc	aggdesc;
+		struct dtrace_action	*act;
+		struct dtrace_aggregation *agg;
+		int			nrecs;
+		uint32_t		offs;
+		struct dtrace_recdesc	*lrec;
+		void			*buf;
+		size_t			size;
+		uint8_t			*dest;
+
+		dt_dbg_ioctl("IOCTL AGGDESC (cmd %#x), argp %p\n", cmd, argp);
+
+		if (copy_from_user(&aggdesc, argp, sizeof(aggdesc)) != 0)
+			return -EFAULT;
+
+		mutex_lock(&dtrace_lock);
+
+		agg = dtrace_aggid2agg(state, aggdesc.dtagd_id);
+		if (agg == NULL) {
+			mutex_unlock(&dtrace_lock);
+			return -EINVAL;
+		}
+
+		aggdesc.dtagd_epid = agg->dtag_ecb->dte_epid;
+
+		nrecs = aggdesc.dtagd_nrecs;
+		aggdesc.dtagd_nrecs = 0;
+
+		offs = agg->dtag_base;
+		lrec = &agg->dtag_action.dta_rec;
+		aggdesc.dtagd_size = lrec->dtrd_offset + lrec->dtrd_size -
+				     offs;
+
+		for (act = agg->dtag_first; ; act = act->dta_next) {
+			ASSERT(act->dta_intuple ||
+			       DTRACEACT_ISAGG(act->dta_kind));
+
+			/*
+			 * If this action has a record size of zero, it
+			 * denotes an argument to the aggregating action.
+			 * Because the presence of this record doesn't (or
+			 * shouldn't) affect the way the data is interpreted,
+			 * we don't copy it out to save user-level the
+			 * confusion of dealing with a zero-length record.
+			 */
+			if (act->dta_rec.dtrd_size == 0) {
+				ASSERT(agg->dtag_hasarg);
+				continue;
+			}
+
+			aggdesc.dtagd_nrecs++;
+
+			if (act == &agg->dtag_action)
+				break;
+		}
+
+		/*
+		 * Now that we have the size, we need to allocate a temporary
+		 * buffer in which to store the complete description.  We need
+		 * the temporary buffer to be able to drop dtrace_lock()
+		 * across the copyout(), below.
+		 */
+		size = sizeof(struct dtrace_aggdesc) +
+		       (aggdesc.dtagd_nrecs * sizeof(struct dtrace_recdesc));
+
+		buf = vmalloc(size);
+		if (buf == NULL)
+			return -ENOMEM;
+
+		dest = buf;
+		memcpy(dest, &aggdesc, sizeof(aggdesc));
+		dest += offsetof(struct dtrace_aggdesc, dtagd_rec[0]);
+
+		for (act = agg->dtag_first; ; act = act->dta_next) {
+			struct dtrace_recdesc	rec = act->dta_rec;
+
+			/*
+			 * See the comment in the above loop for why we pass
+			 * over zero-length records.
+			 */
+			if (rec.dtrd_size == 0) {
+				ASSERT(agg->dtag_hasarg);
+				continue;
+			}
+
+			if (nrecs-- == 0)
+				break;
+
+			rec.dtrd_offset -= offs;
+			memcpy(dest, &rec, sizeof(rec));
+			dest += sizeof(struct dtrace_recdesc);
+
+			if (act == &agg->dtag_action)
+				break;
+		}
+
+		mutex_unlock(&dtrace_lock);
+
+		if (copy_to_user(argp, buf,
+				 (uintptr_t)(dest - (uint8_t *)buf)) != 0) {
+			vfree(buf);
+			return -EFAULT;
+		}
+
+		vfree(buf);
+		return 0;
+	}
+
+	case DTRACEIOC_ENABLE: {
+		struct dof_hdr		*dof;
+		struct dtrace_enabling	*enab = NULL;
+		struct dtrace_vstate	*vstate;
+		int			err = 0;
+		int			rv;
+
+		dt_dbg_ioctl("IOCTL ENABLE (cmd %#x), argp %p\n", cmd, argp);
+
+		rv = 0;
+
+		/*
+		 * If a NULL argument has been passed, we take this as our
+		 * cue to reevaluate our enablings.
+		 */
+		if (argp == NULL) {
+			dtrace_enabling_matchall();
+
+			return 0;
+		}
+
+		dof = dtrace_dof_copyin(argp, &rval);
+		if (dof == NULL)
+			return rval;
+
+		mutex_lock(&cpu_lock);
+		mutex_lock(&dtrace_lock);
+		vstate = &state->dts_vstate;
+
+		if (state->dts_activity != DTRACE_ACTIVITY_INACTIVE) {
+			mutex_unlock(&dtrace_lock);
+			mutex_unlock(&cpu_lock);
+			dtrace_dof_destroy(dof);
+			return -EBUSY;
+		}
+
+		if (dtrace_dof_slurp(dof, vstate, file->f_cred, &enab, 0,
+				     TRUE) != 0) {
+			mutex_unlock(&dtrace_lock);
+			mutex_unlock(&cpu_lock);
+			dtrace_dof_destroy(dof);
+			return -EINVAL;
+		}
+
+		rval = dtrace_dof_options(dof, state);
+		if (rval != 0) {
+			dtrace_enabling_destroy(enab);
+			mutex_unlock(&dtrace_lock);
+			mutex_unlock(&cpu_lock);
+			dtrace_dof_destroy(dof);
+			return rval;
+		}
+
+		err = dtrace_enabling_match(enab, &rv);
+		if (err == 0)
+			err = dtrace_enabling_retain(enab);
+		else
+			dtrace_enabling_destroy(enab);
+
+		mutex_unlock(&dtrace_lock);
+		mutex_unlock(&cpu_lock);
+		dtrace_dof_destroy(dof);
+
+		return err == 0 ? rv : err;
+	}
+
+	case DTRACEIOC_REPLICATE: {
+		struct dtrace_repldesc	desc;
+		struct dtrace_probedesc	*match = &desc.dtrpd_match;
+		struct dtrace_probedesc	*create = &desc.dtrpd_create;
+		int			err;
+
+		dt_dbg_ioctl("IOCTL REPLICATE (cmd %#x), argp %p\n",
+			     cmd, argp);
+
+		if (copy_from_user(&desc, argp, sizeof(desc)) != 0)
+			return -EFAULT;
+
+		match->dtpd_provider[DTRACE_PROVNAMELEN - 1] = '\0';
+		match->dtpd_mod[DTRACE_MODNAMELEN - 1] = '\0';
+		match->dtpd_func[DTRACE_FUNCNAMELEN - 1] = '\0';
+		match->dtpd_name[DTRACE_NAMELEN - 1] = '\0';
+
+		create->dtpd_provider[DTRACE_PROVNAMELEN - 1] = '\0';
+		create->dtpd_mod[DTRACE_MODNAMELEN - 1] = '\0';
+		create->dtpd_func[DTRACE_FUNCNAMELEN - 1] = '\0';
+		create->dtpd_name[DTRACE_NAMELEN - 1] = '\0';
+
+		mutex_lock(&dtrace_lock);
+		err = dtrace_enabling_replicate(state, match, create);
+		mutex_unlock(&dtrace_lock);
+
+		return err;
+	}
+
+	case DTRACEIOC_PROBEMATCH:
+	case DTRACEIOC_PROBES: {
+		int			id;
+		struct dtrace_probe	*probe = NULL;
+		struct dtrace_probedesc	desc;
+		struct dtrace_probekey	pkey;
+		uint32_t		priv;
+		kuid_t			uid;
+
+		dt_dbg_ioctl("IOCTL %s (cmd %#x), argp %p\n",
+			     cmd == DTRACEIOC_PROBES ? "PROBES"
+						     : "PROBEMATCH",
+			     cmd, argp);
+
+		if (copy_from_user(&desc, argp, sizeof(desc)) != 0)
+			return -EFAULT;
+
+		desc.dtpd_provider[DTRACE_PROVNAMELEN - 1] = '\0';
+		desc.dtpd_mod[DTRACE_MODNAMELEN - 1] = '\0';
+		desc.dtpd_func[DTRACE_FUNCNAMELEN - 1] = '\0';
+		desc.dtpd_name[DTRACE_NAMELEN - 1] = '\0';
+		dt_dbg_ioctl("  Probe ID %d %s:%s:%s:%s\n",
+			     desc.dtpd_id, desc.dtpd_provider, desc.dtpd_mod,
+			     desc.dtpd_func, desc.dtpd_name);
+
+		/*
+		 * Before we attempt to match this probe, we want to give
+		 * all providers the opportunity to provide it.
+		 */
+		if (desc.dtpd_id == DTRACE_IDNONE) {
+			mutex_lock(&module_mutex);
+			mutex_lock(&dtrace_provider_lock);
+			dtrace_probe_provide(&desc, NULL);
+			mutex_unlock(&dtrace_provider_lock);
+			mutex_unlock(&module_mutex);
+		}
+
+		if (cmd == DTRACEIOC_PROBEMATCH)  {
+			dtrace_probekey(&desc, &pkey);
+			pkey.dtpk_id = DTRACE_IDNONE;
+		}
+
+		dtrace_cred2priv(file->f_cred, &priv, &uid);
+
+		mutex_lock(&dtrace_lock);
+
+		id = desc.dtpd_id;
+		if (cmd == DTRACEIOC_PROBEMATCH)  {
+			int	m = 0;
+
+			while ((probe = dtrace_probe_get_next(&id))
+			       != NULL) {
+				m = dtrace_match_probe(probe, &pkey, priv, uid);
+				if (m)
+					break;
+
+				id++;
+			}
+
+			if (m < 0) {
+				mutex_unlock(&dtrace_lock);
+				return -EINVAL;
+			}
+		} else {
+			while ((probe = dtrace_probe_get_next(&id))
+			       != NULL) {
+				if (dtrace_match_priv(probe, priv, uid))
+					break;
+
+				id++;
+			}
+		}
+
+		if (probe == NULL) {
+			mutex_unlock(&dtrace_lock);
+			return -ESRCH;
+		}
+
+		dtrace_probe_description(probe, &desc);
+		mutex_unlock(&dtrace_lock);
+
+		if (copy_to_user(argp, &desc, sizeof(desc)) != 0)
+			return -EFAULT;
+
+		return 0;
+	}
+
+	case DTRACEIOC_PROBEARG: {
+		struct dtrace_argdesc	desc;
+		struct dtrace_probe	*probe;
+		struct dtrace_provider	*prov;
+
+		dt_dbg_ioctl("IOCTL PROBEARG (cmd %#x), argp %p\n", cmd, argp);
+
+		if (copy_from_user(&desc, argp, sizeof(desc)) != 0)
+			return -EFAULT;
+
+		if (desc.dtargd_id == DTRACE_IDNONE)
+			return -EINVAL;
+
+		if (desc.dtargd_ndx == DTRACE_ARGNONE)
+			return -EINVAL;
+
+		mutex_lock(&module_mutex);
+		mutex_lock(&dtrace_provider_lock);
+		mutex_lock(&dtrace_lock);
+
+		probe = dtrace_probe_lookup_id(desc.dtargd_id);
+		if (probe == NULL) {
+			mutex_unlock(&dtrace_lock);
+			mutex_unlock(&dtrace_provider_lock);
+			mutex_unlock(&module_mutex);
+
+			return -EINVAL;
+		}
+
+		mutex_unlock(&dtrace_lock);
+
+		prov = probe->dtpr_provider;
+
+		if (prov->dtpv_pops.dtps_getargdesc == NULL) {
+			/*
+			 * There isn't any typed information for this probe.
+			 * Set the argument number to DTRACE_ARGNONE.
+			 */
+			desc.dtargd_ndx = DTRACE_ARGNONE;
+		} else {
+			desc.dtargd_native[0] = '\0';
+			desc.dtargd_xlate[0] = '\0';
+			desc.dtargd_mapping = desc.dtargd_ndx;
+
+			prov->dtpv_pops.dtps_getargdesc(
+				prov->dtpv_arg, probe->dtpr_id,
+				probe->dtpr_arg, &desc);
+		}
+
+		mutex_unlock(&dtrace_provider_lock);
+		mutex_unlock(&module_mutex);
+
+		if (copy_to_user(argp, &desc, sizeof(desc)) != 0)
+			return -EFAULT;
+
+		return 0;
+	}
+
+	case DTRACEIOC_GO: {
+		processorid_t	cpuid;
+
+		dt_dbg_ioctl("IOCTL GO (cmd %#x), argp %p\n", cmd, argp);
+
+		rval = dtrace_state_go(state, &cpuid);
+
+		if (rval != 0)
+			return rval;
+
+		if (copy_to_user(argp, &cpuid, sizeof(cpuid)) != 0)
+			return -EFAULT;
+
+		return 0;
+	}
+
+	case DTRACEIOC_STOP: {
+		processorid_t	cpuid;
+
+		dt_dbg_ioctl("IOCTL STOP (cmd %#x), argp %p\n", cmd, argp);
+
+		mutex_lock(&dtrace_lock);
+		rval = dtrace_state_stop(state, &cpuid);
+		mutex_unlock(&dtrace_lock);
+
+		if (rval != 0)
+			return rval;
+
+		if (copy_to_user(argp, &cpuid, sizeof(cpuid)) != 0)
+			return -EFAULT;
+
+		return 0;
+	}
+
+	case DTRACEIOC_DOFGET: {
+		struct dof_hdr	hdr, *dof;
+		uint64_t	len;
+
+		dt_dbg_ioctl("IOCTL DOFGET (cmd %#x), argp %p\n", cmd, argp);
+
+		if (copy_from_user(&hdr, argp, sizeof(hdr)) != 0)
+			return -EFAULT;
+
+		mutex_lock(&dtrace_lock);
+		dof = dtrace_dof_create(state);
+		mutex_unlock(&dtrace_lock);
+		if (dof == NULL)
+			return -ENOMEM;
+
+		len = min(hdr.dofh_loadsz, dof->dofh_loadsz);
+		rval = copy_to_user(argp, dof, len);
+		dtrace_dof_destroy(dof);
+
+		return rval == 0 ? 0 : -EFAULT;
+	}
+
+	case DTRACEIOC_AGGSNAP:
+	case DTRACEIOC_BUFSNAP: {
+		struct dtrace_bufdesc	desc;
+		caddr_t			cached;
+		struct dtrace_buffer	*buf;
+
+		dt_dbg_ioctl("IOCTL %s (cmd %#x), argp %p\n",
+			     cmd == DTRACEIOC_AGGSNAP ? "AGGSNAP"
+						      : "BUFSNAP",
+			     cmd, argp);
+
+		if (copy_from_user(&desc, argp, sizeof(desc)) != 0)
+			return -EFAULT;
+
+		if (desc.dtbd_cpu < 0 || desc.dtbd_cpu >= NR_CPUS)
+			return -EINVAL;
+
+		mutex_lock(&dtrace_lock);
+
+		if (cmd == DTRACEIOC_BUFSNAP)
+			buf = &state->dts_buffer[desc.dtbd_cpu];
+		else
+			buf = &state->dts_aggbuffer[desc.dtbd_cpu];
+
+		if (buf->dtb_flags & (DTRACEBUF_RING | DTRACEBUF_FILL)) {
+			size_t	sz = buf->dtb_offset;
+
+			if (state->dts_activity != DTRACE_ACTIVITY_STOPPED) {
+				mutex_unlock(&dtrace_lock);
+				return -EBUSY;
+			}
+
+			/*
+			 * If this buffer has already been consumed, we're
+			 * going to indicate that there's nothing left here
+			 * to consume.
+			 */
+			if (buf->dtb_flags & DTRACEBUF_CONSUMED) {
+				mutex_unlock(&dtrace_lock);
+
+				desc.dtbd_size = 0;
+				desc.dtbd_drops = 0;
+				desc.dtbd_errors = 0;
+				desc.dtbd_oldest = 0;
+				sz = sizeof(desc);
+
+				if (copy_to_user(argp, &desc, sz) != 0)
+					return -EFAULT;
+
+				return 0;
+			}
+
+			/*
+			 * If this is a ring buffer that has wrapped, we want
+			 * to copy the whole thing out.
+			 */
+			if (buf->dtb_flags & DTRACEBUF_WRAPPED) {
+				dtrace_buffer_polish(buf);
+				sz = buf->dtb_size;
+			}
+
+			if (copy_to_user(desc.dtbd_data, buf->dtb_tomax,
+					 sz) != 0) {
+				mutex_unlock(&dtrace_lock);
+				return -EFAULT;
+			}
+
+			desc.dtbd_size = sz;
+			desc.dtbd_drops = buf->dtb_drops;
+			desc.dtbd_errors = buf->dtb_errors;
+			desc.dtbd_oldest = buf->dtb_xamot_offset;
+
+			mutex_unlock(&dtrace_lock);
+
+			if (copy_to_user(argp, &desc, sizeof(desc)) != 0)
+				return -EFAULT;
+
+			buf->dtb_flags |= DTRACEBUF_CONSUMED;
+
+			return 0;
+		}
+
+		if (buf->dtb_tomax == NULL) {
+			ASSERT(buf->dtb_xamot == NULL);
+			mutex_unlock(&dtrace_lock);
+			return -ENOENT;
+		}
+
+		cached = buf->dtb_tomax;
+
+		dtrace_xcall(desc.dtbd_cpu,
+			     (dtrace_xcall_t)dtrace_buffer_switch, buf);
+
+		state->dts_errors += buf->dtb_xamot_errors;
+
+		/*
+		 * If the buffers did not actually switch, then the cross call
+		 * did not take place -- presumably because the given CPU is
+		 * not in the ready set.  If this is the case, we'll return
+		 * ENOENT.
+		 */
+		if (buf->dtb_tomax == cached) {
+			ASSERT(buf->dtb_xamot != cached);
+			mutex_unlock(&dtrace_lock);
+			return -ENOENT;
+		}
+
+		ASSERT(cached == buf->dtb_xamot);
+
+		/*
+		 * We have our snapshot; now copy it out.
+		 */
+		if (copy_to_user(desc.dtbd_data, buf->dtb_xamot,
+				 buf->dtb_xamot_offset) != 0) {
+			mutex_unlock(&dtrace_lock);
+			return -EFAULT;
+		}
+
+		desc.dtbd_size = buf->dtb_xamot_offset;
+		desc.dtbd_drops = buf->dtb_xamot_drops;
+		desc.dtbd_errors = buf->dtb_xamot_errors;
+		desc.dtbd_oldest = 0;
+
+		mutex_unlock(&dtrace_lock);
+
+		/*
+		 * Finally, copy out the buffer description.
+		 */
+		if (copy_to_user(argp, &desc, sizeof(desc)) != 0)
+			return -EFAULT;
+
+		return 0;
+	}
+
+	case DTRACEIOC_CONF: {
+		struct dtrace_conf	conf;
+
+		dt_dbg_ioctl("IOCTL CONF (cmd %#x), argp %p\n", cmd, argp);
+
+		memset(&conf, 0, sizeof(conf));
+		conf.dtc_difversion = DIF_VERSION;
+		conf.dtc_difintregs = DIF_DIR_NREGS;
+		conf.dtc_diftupregs = DIF_DTR_NREGS;
+		conf.dtc_ctfmodel = CTF_MODEL_NATIVE;
+		conf.dtc_maxbufs = nr_cpu_ids;
+
+		if (copy_to_user(argp, &conf, sizeof(conf)) != 0)
+			return -EFAULT;
+
+		return 0;
+	}
+
+	case DTRACEIOC_STATUS: {
+		struct dtrace_status	stat;
+		struct dtrace_dstate	*dstate;
+		int			i, j;
+		uint64_t		nerrs;
+
+		dt_dbg_ioctl("IOCTL STATUS (cmd %#x), argp %p\n", cmd, argp);
+
+		/*
+		 * See the comment in dtrace_state_deadman() for the reason
+		 * for setting dts_laststatus to UINT64_MAX before setting
+		 * it to the correct value.
+		 */
+		state->dts_laststatus = ns_to_ktime(UINT64_MAX);
+		dtrace_membar_producer();
+		state->dts_laststatus = dtrace_gethrtime();
+
+		memset(&stat, 0, sizeof(stat));
+
+		mutex_lock(&dtrace_lock);
+
+		if (state->dts_activity == DTRACE_ACTIVITY_INACTIVE) {
+			mutex_unlock(&dtrace_lock);
+			return -ENOENT;
+		}
+
+		if (state->dts_activity == DTRACE_ACTIVITY_DRAINING)
+			stat.dtst_exiting = 1;
+
+		nerrs = state->dts_errors;
+		dstate = &state->dts_vstate.dtvs_dynvars;
+
+		for (i = 0; i < NR_CPUS; i++) {
+			struct dtrace_dstate_percpu *dcpu;
+
+			dcpu = &dstate->dtds_percpu[i];
+			stat.dtst_dyndrops += dcpu->dtdsc_drops;
+			stat.dtst_dyndrops_dirty += dcpu->dtdsc_dirty_drops;
+			stat.dtst_dyndrops_rinsing += dcpu->dtdsc_rinsing_drops;
+
+			if (state->dts_buffer[i].dtb_flags & DTRACEBUF_FULL)
+				stat.dtst_filled++;
+
+			nerrs += state->dts_buffer[i].dtb_errors;
+
+			for (j = 0; j < state->dts_nspeculations; j++) {
+				struct dtrace_speculation	*spec;
+				struct dtrace_buffer		*buf;
+
+				spec = &state->dts_speculations[j];
+				buf = &spec->dtsp_buffer[i];
+				stat.dtst_specdrops += buf->dtb_xamot_drops;
+			}
+		}
+
+		stat.dtst_specdrops_busy = state->dts_speculations_busy;
+		stat.dtst_specdrops_unavail = state->dts_speculations_unavail;
+		stat.dtst_stkstroverflows = state->dts_stkstroverflows;
+		stat.dtst_dblerrors = state->dts_dblerrors;
+		stat.dtst_killed = (state->dts_activity ==
+				    DTRACE_ACTIVITY_KILLED);
+		stat.dtst_errors = nerrs;
+
+		mutex_unlock(&dtrace_lock);
+
+		if (copy_to_user(argp, &stat, sizeof(stat)) != 0)
+			return -EFAULT;
+
+		return 0;
+	}
+
+	case DTRACEIOC_FORMAT: {
+		struct dtrace_fmtdesc	fmt;
+		char			*str;
+		int			len;
+
+		dt_dbg_ioctl("IOCTL FORMAT (cmd %#x), argp %p\n", cmd, argp);
+
+		if (copy_from_user(&fmt, argp, sizeof(fmt)) != 0)
+			return -EFAULT;
+
+		mutex_lock(&dtrace_lock);
+
+		if (fmt.dtfd_format == 0 ||
+		    fmt.dtfd_format > state->dts_nformats) {
+			mutex_unlock(&dtrace_lock);
+			return -EINVAL;
+		}
+
+		/*
+		 * Format strings are allocated contiguously and they are
+		 * never freed; if a format index is less than the number
+		 * of formats, we can assert that the format map is non-NULL
+		 * and that the format for the specified index is non-NULL.
+		 */
+		ASSERT(state->dts_formats != NULL);
+		str = state->dts_formats[fmt.dtfd_format - 1];
+		ASSERT(str != NULL);
+
+		len = strlen(str) + 1;
+
+		if (len > fmt.dtfd_length) {
+			fmt.dtfd_length = len;
+
+			if (copy_to_user(argp, &fmt, sizeof(fmt)) != 0) {
+				mutex_unlock(&dtrace_lock);
+				return -EINVAL;
+			}
+		} else {
+			if (copy_to_user(fmt.dtfd_string, str, len) != 0) {
+				mutex_unlock(&dtrace_lock);
+				return -EINVAL;
+			}
+		}
+
+		mutex_unlock(&dtrace_lock);
+
+		return 0;
+	}
+
+	default:
+		dt_dbg_ioctl("IOCTL ??? (cmd %#x), argp %p\n",
+			     cmd, argp);
+		break;
+	}
+
+	return -ENOTTY;
+}
+
+static int dtrace_close(struct inode *inode, struct file *file)
+{
+	struct dtrace_state	*state = file->private_data;
+
+	mutex_lock(&cpu_lock);
+	mutex_lock(&dtrace_lock);
+
+	/*
+	 * If there is anonymous state, destroy that first.
+	 */
+	if (state->dts_anon) {
+		ASSERT(dtrace_anon.dta_state == NULL);
+		dtrace_state_destroy(state->dts_anon);
+	}
+
+	dtrace_state_destroy(state);
+	ASSERT(dtrace_opens > 0);
+
+	if (--dtrace_opens == 0 && dtrace_anon.dta_enabling == NULL)
+		dtrace_disable();
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&cpu_lock);
+
+	return 0;
+}
+
+static int dtrace_helper_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static long dtrace_helper_ioctl(struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	int		rval;
+	struct dof_helper help, *dhp = NULL;
+	void __user	*argp = (void __user *)arg;
+
+	switch (cmd) {
+	case DTRACEHIOC_ADDDOF:
+		dt_dbg_ioctl("Helper IOCTL ADDDOF (cmd %#x), argp %p\n",
+			     cmd, argp);
+
+		if (copy_from_user(&help, argp, sizeof(help)) != 0) {
+			dtrace_dof_error(NULL, "failed to copy DOF helper");
+			return -EFAULT;
+		}
+
+		dhp = &help;
+		argp = (void __user *)help.dofhp_dof;
+
+		/* fallthrough */
+
+	case DTRACEHIOC_ADD: {
+		struct dof_hdr	*dof = dtrace_dof_copyin(argp, &rval);
+
+		if (dof == NULL)
+			return rval;
+
+		if (cmd == DTRACEHIOC_ADD)
+			dt_dbg_ioctl("Helper IOCTL ADD (cmd %#x), argp %p\n",
+				     cmd, argp);
+
+		mutex_lock(&dtrace_lock);
+
+		/*
+		 * The dtrace_helper_slurp() routine takes responsibility for
+		 * the dof -- it may free it now, or it may save it and free it
+		 * later.
+		 */
+		rval = dtrace_helper_slurp(dof, dhp);
+		if (rval == -1)
+			rval = -EINVAL;
+
+		mutex_unlock(&dtrace_lock);
+
+		dt_dbg_ioctl("Helper IOCTL %s returning %d\n",
+			     cmd == DTRACEHIOC_ADD ? "ADD"
+						   : "ADDDOF",
+			     rval);
+
+		return rval;
+	}
+
+	case DTRACEHIOC_REMOVE:
+		dt_dbg_ioctl("Helper IOCTL REMOVE (cmd %#x), argp %p\n",
+			     cmd, argp);
+
+		mutex_lock(&dtrace_lock);
+
+		rval = dtrace_helper_destroygen((uintptr_t)argp);
+
+		mutex_unlock(&dtrace_lock);
+
+		dt_dbg_ioctl("Helper IOCTL REMOVE returning %d\n", rval);
+
+		return rval;
+	default:
+		dt_dbg_ioctl("Helper IOCTL ??? (cmd %#x), argp %p\n",
+			     cmd, argp);
+		break;
+	}
+
+	return -ENOTTY;
+}
+
+static int dtrace_helper_close(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations dtrace_fops = {
+	.owner  = THIS_MODULE,
+	.unlocked_ioctl = dtrace_ioctl,
+	.open   = dtrace_open,
+	.release = dtrace_close,
+};
+
+static const struct file_operations helper_fops = {
+	.owner  = THIS_MODULE,
+	.unlocked_ioctl = dtrace_helper_ioctl,
+	.compat_ioctl = dtrace_helper_ioctl,
+	.open   = dtrace_helper_open,
+	.release = dtrace_helper_close,
+};
+
+static struct miscdevice dtrace_dev = {
+	.minor = DT_DEV_DTRACE_MINOR,
+	.name = "dtrace",
+	.nodename = "dtrace/dtrace",
+	.fops = &dtrace_fops,
+};
+
+static struct miscdevice helper_dev = {
+	.minor = DT_DEV_HELPER_MINOR,
+	.name = "helper",
+	.nodename = "dtrace/helper",
+	.fops = &helper_fops,
+};
+
+static void dtrace_module_loaded(struct module *mp)
+{
+	struct dtrace_provider *prv;
+
+	mutex_lock(&module_mutex);
+	mutex_lock(&dtrace_provider_lock);
+
+	/*
+	 * Give all providers a chance to register probes for this module.
+	 */
+	for (prv = dtrace_provider; prv != NULL; prv = prv->dtpv_next)
+		prv->dtpv_pops.dtps_provide_module(prv->dtpv_arg, mp);
+
+	mutex_unlock(&dtrace_provider_lock);
+	mutex_unlock(&module_mutex);
+
+	/*
+	 * If we have any retained enablings, we need to match against them.
+	 */
+	mutex_lock(&dtrace_lock);
+
+	if (dtrace_retained == NULL) {
+		mutex_unlock(&dtrace_lock);
+		return;
+	}
+
+	mutex_unlock(&dtrace_lock);
+	dtrace_enabling_matchall();
+}
+
+static void dtrace_module_unloaded(struct module *mp)
+{
+	struct dtrace_probe	template, *probe, *first, *next;
+	struct dtrace_provider	*prv;
+
+	template.dtpr_mod = mp->name;
+
+	mutex_lock(&module_mutex);
+	mutex_lock(&dtrace_provider_lock);
+	mutex_lock(&dtrace_lock);
+
+	if (dtrace_bymod == NULL) {
+		/*
+		 * The DTrace module is loaded (obviously) but not attached;
+		 * we don't have any work to do.
+		 */
+		mutex_unlock(&dtrace_lock);
+		mutex_unlock(&dtrace_provider_lock);
+		mutex_unlock(&module_mutex);
+		return;
+	}
+
+	for (probe = first = dtrace_hash_lookup(dtrace_bymod, &template);
+	     probe != NULL; probe = probe->dtpr_nextmod) {
+		if (probe->dtpr_ecb != NULL) {
+			mutex_unlock(&dtrace_lock);
+			mutex_unlock(&dtrace_provider_lock);
+			mutex_unlock(&module_mutex);
+
+			/*
+			 * This shouldn't _actually_ be possible -- we're
+			 * unloading a module that has an enabled probe in it.
+			 * (It's normally up to the provider to make sure that
+			 * this can't happen.)  However, because dtps_enable()
+			 * doesn't have a failure mode, there can be an
+			 * enable/unload race.  Upshot:  we don't want to
+			 * assert, but we're not going to disable the
+			 * probe, either.
+			 */
+			if (dtrace_err_verbose) {
+				pr_warn("unloaded module '%s' "
+					"had enabled probes", mp->name);
+			}
+
+			return;
+		}
+	}
+
+	probe = first;
+
+	for (first = NULL; probe != NULL; probe = next) {
+		dtrace_probe_remove_id(probe->dtpr_id);
+
+		next = probe->dtpr_nextmod;
+		dtrace_hash_remove(dtrace_bymod, probe);
+		dtrace_hash_remove(dtrace_byfunc, probe);
+		dtrace_hash_remove(dtrace_byname, probe);
+
+		if (first == NULL) {
+			first = probe;
+			probe->dtpr_nextmod = NULL;
+		} else {
+			probe->dtpr_nextmod = first;
+			first = probe;
+		}
+	}
+
+	/*
+	 * We've removed all of the module's probes from the hash chains and
+	 * from the probe array.  Now issue a dtrace_sync() to be sure that
+	 * everyone has cleared out from any probe array processing.
+	 */
+	dtrace_sync();
+
+	for (probe = first; probe != NULL; probe = first) {
+		first = probe->dtpr_nextmod;
+		prv = probe->dtpr_provider;
+		prv->dtpv_pops.dtps_destroy(prv->dtpv_arg, probe->dtpr_id,
+		    probe->dtpr_arg);
+		kfree(probe->dtpr_mod);
+		kfree(probe->dtpr_func);
+		kfree(probe->dtpr_name);
+		kfree(probe);
+	}
+
+	/*
+	 * Notify providers to cleanup per-module data for this module.
+	 */
+	for (prv = dtrace_provider; prv != NULL; prv = prv->dtpv_next)
+		if (prv->dtpv_pops.dtps_destroy_module != NULL)
+			prv->dtpv_pops.dtps_destroy_module(prv->dtpv_arg, mp);
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&dtrace_provider_lock);
+	mutex_unlock(&module_mutex);
+}
+
+/*
+ * Register a toxic range.
+ */
+static void dtrace_toxrange_add(uintptr_t base, uintptr_t limit)
+{
+	if (dtrace_toxranges >= dtrace_toxranges_max) {
+		int			osize, nsize;
+		struct dtrace_toxrange	*range;
+
+		osize = dtrace_toxranges_max * sizeof(struct dtrace_toxrange);
+
+		if (osize == 0) {
+			ASSERT(dtrace_toxrange == NULL);
+			ASSERT(dtrace_toxranges_max == 0);
+
+			dtrace_toxranges_max = 1;
+		} else
+			dtrace_toxranges_max <<= 1;
+
+		nsize = dtrace_toxranges_max * sizeof(struct dtrace_toxrange);
+		range = vzalloc(nsize);
+		if (range == NULL) {
+			pr_warn("Failed to add toxic range: out of memory\n");
+			return;
+		}
+
+		if (dtrace_toxrange != NULL) {
+			ASSERT(osize != 0);
+
+			memcpy(range, dtrace_toxrange, osize);
+			vfree(dtrace_toxrange);
+		}
+
+		dtrace_toxrange = range;
+	}
+
+	ASSERT(dtrace_toxrange[dtrace_toxranges].dtt_base == (uintptr_t)NULL);
+	ASSERT(dtrace_toxrange[dtrace_toxranges].dtt_limit == (uintptr_t)NULL);
+
+	dtrace_toxrange[dtrace_toxranges].dtt_base = base;
+	dtrace_toxrange[dtrace_toxranges].dtt_limit = limit;
+	dtrace_toxranges++;
+}
+
+/*
+ * Check if an address falls within a toxic region.
+ */
+int dtrace_istoxic(uintptr_t kaddr, size_t size)
+{
+	uintptr_t	taddr, tsize;
+	int		i;
+
+	for (i = 0; i < dtrace_toxranges; i++) {
+		taddr = dtrace_toxrange[i].dtt_base;
+		tsize = dtrace_toxrange[i].dtt_limit - taddr;
+
+		if (kaddr - taddr < tsize) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);
+			this_cpu_core->cpuc_dtrace_illval = kaddr;
+			return 1;
+		}
+
+		if (taddr - kaddr < size) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_BADADDR);
+			this_cpu_core->cpuc_dtrace_illval = kaddr;
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static int dtrace_mod_notifier(struct notifier_block *nb, unsigned long val,
+			       void *args)
+{
+	struct module	*mp = args;
+
+	if (!mp)
+		return NOTIFY_DONE;
+
+	switch (val) {
+	case MODULE_STATE_LIVE:
+		dtrace_module_loaded(mp);
+		break;
+
+	case MODULE_STATE_GOING:
+		dtrace_module_unloaded(mp);
+		break;
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block    dtrace_modmgmt = {
+	.notifier_call = dtrace_mod_notifier,
+};
+
+/*
+ * Initialize the DTrace core.
+ *
+ * Equivalent to: dtrace_attach()
+ */
+int dtrace_dev_init(void)
+{
+	dtrace_provider_id_t	id;
+	int			rc = 0;
+	struct cred		*cred;
+
+	/*
+	 * Register the device for the DTrace core.
+	 */
+	rc = misc_register(&dtrace_dev);
+	if (rc) {
+		pr_err("%s: Can't register misc device %d\n",
+		       dtrace_dev.name, dtrace_dev.minor);
+
+		return rc;
+	}
+
+	/*
+	 * Register the device for the DTrace helper.
+	 */
+	rc = misc_register(&helper_dev);
+	if (rc) {
+		pr_err("%s: Can't register misc device %d\n",
+		       helper_dev.name, helper_dev.minor);
+
+		misc_deregister(&dtrace_dev);
+		return rc;
+	}
+
+	mutex_lock(&cpu_lock);
+	mutex_lock(&module_mutex);
+	mutex_lock(&dtrace_provider_lock);
+	mutex_lock(&dtrace_lock);
+
+	rc = dtrace_probe_init();
+	if (rc) {
+		pr_err("Failed to initialize DTrace core\n");
+
+		goto errout;
+	}
+
+#if IS_ENABLED(CONFIG_DT_FASTTRAP)
+	dtrace_helpers_cleanup = dtrace_helpers_destroy;
+	dtrace_helpers_fork = dtrace_helpers_duplicate;
+#endif
+#ifdef FIXME
+	dtrace_cpu_init = dtrace_cpu_setup_initial;
+	dtrace_cpustart_init = dtrace_suspend;
+	dtrace_cpustart_fini = dtrace_resume;
+	dtrace_debugger_init = dtrace_suspend;
+	dtrace_debugger_fini = dtrace_resume;
+
+	register_cpu_setup_func((cpu_setup_func_t *)dtrace_cpu_setup, NULL);
+#endif
+
+#ifdef FIXME
+	dtrace_taskq = taskq_create("dtrace_taskq", 1, maxclsyspri, 1, INT_MAX,
+				    0);
+#endif
+
+	dtrace_state_cachep = kmem_cache_create("dtrace_state_cache",
+				sizeof(struct dtrace_dstate_percpu) * NR_CPUS,
+				0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);
+
+	/* From now on the failures are results of failed allocations. */
+	rc = -ENOMEM;
+
+	/*
+	 * Create the probe hashtables.
+	 */
+	dtrace_bymod = dtrace_hash_create(
+				offsetof(struct dtrace_probe, dtpr_mod),
+				offsetof(struct dtrace_probe, dtpr_nextmod),
+				offsetof(struct dtrace_probe, dtpr_prevmod));
+	if (dtrace_bymod == NULL)
+		goto errout;
+
+	dtrace_byfunc = dtrace_hash_create(
+				offsetof(struct dtrace_probe, dtpr_func),
+				offsetof(struct dtrace_probe, dtpr_nextfunc),
+				offsetof(struct dtrace_probe, dtpr_prevfunc));
+	if (dtrace_byfunc == NULL)
+		goto errout;
+
+	dtrace_byname = dtrace_hash_create(
+				offsetof(struct dtrace_probe, dtpr_name),
+				offsetof(struct dtrace_probe, dtpr_nextname),
+				offsetof(struct dtrace_probe, dtpr_prevname));
+	if (dtrace_byname == NULL)
+		goto errout;
+
+	/*
+	 * Initialize cred.
+	 */
+	cred = prepare_kernel_cred(NULL);
+	if (cred == NULL)
+		goto errout;
+
+	init_user_namespace = cred->user_ns;
+	put_cred(cred);
+
+	/*
+	 * Ensure that the X configuration parameter has a legal value.
+	 */
+	if (dtrace_retain_max < 1) {
+		pr_warn("Illegal value (%lu) for dtrace_retain_max; "
+			"setting to 1", (unsigned long)dtrace_retain_max);
+
+		dtrace_retain_max = 1;
+	}
+
+	/*
+	 * Discover our toxic ranges.
+	 */
+	dtrace_toxic_ranges(dtrace_toxrange_add);
+
+	/*
+	 * Register ourselves as a provider.
+	 */
+	dtrace_register("dtrace", &dtrace_provider_attr, DTRACE_PRIV_NONE, 0,
+			&dtrace_provider_ops, NULL, &id);
+
+	ASSERT(dtrace_provider != NULL);
+	ASSERT((dtrace_provider_id_t)dtrace_provider == id);
+
+	/*
+	 * Create BEGIN, END, and ERROR probes.
+	 */
+	dtrace_probeid_begin = dtrace_probe_create(
+				(dtrace_provider_id_t)dtrace_provider, NULL,
+				NULL, "BEGIN", 0, NULL);
+	if (dtrace_probeid_begin == DTRACE_IDNONE)
+		goto errout;
+
+	dtrace_probeid_end = dtrace_probe_create(
+				(dtrace_provider_id_t)dtrace_provider, NULL,
+				NULL, "END", 0, NULL);
+	if (dtrace_probeid_end == DTRACE_IDNONE)
+		goto errout;
+
+	dtrace_probeid_error = dtrace_probe_create(
+				(dtrace_provider_id_t)dtrace_provider, NULL,
+				NULL, "ERROR", 1, NULL);
+	if (dtrace_probeid_error == DTRACE_IDNONE)
+		goto errout;
+
+	dtrace_anon_property();
+
+	/*
+	 * If DTrace helper tracing is enabled, we need to allocate a trace
+	 * buffer.
+	 */
+	if (dtrace_helptrace_enabled) {
+		ASSERT(dtrace_helptrace_buffer == NULL);
+
+		dtrace_helptrace_buffer = vzalloc(dtrace_helptrace_bufsize);
+
+		if (dtrace_helptrace_buffer == NULL) {
+			pr_warn("Cannot allocate helptrace buffer; "
+				"disabling dtrace_helptrace\n");
+			dtrace_helptrace_enabled = 0;
+		}
+	}
+
+#ifdef FIXME
+	/*
+	 * There is usually code here to handle the case where there already
+	 * are providers when we get to this code.  On Linux, that does not
+	 * seem to be possible since the DTrace core module (this code) is
+	 * loaded as a dependency for each provider, and thus this
+	 * initialization code is executed prior to the initialization code of
+	 * the first provider causing the core to be loaded.
+	 */
+#endif
+
+	if (register_module_notifier(&dtrace_modmgmt))
+		goto errout;
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&dtrace_provider_lock);
+	mutex_unlock(&module_mutex);
+	mutex_unlock(&cpu_lock);
+
+	return 0;
+
+errout:
+	if (dtrace_provider != NULL)
+		(void) dtrace_unregister((dtrace_provider_id_t)dtrace_provider);
+
+	dtrace_hash_destroy(dtrace_bymod);
+	dtrace_hash_destroy(dtrace_byfunc);
+	dtrace_hash_destroy(dtrace_byname);
+
+	misc_deregister(&helper_dev);
+	misc_deregister(&dtrace_dev);
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&dtrace_provider_lock);
+	mutex_unlock(&module_mutex);
+	mutex_unlock(&cpu_lock);
+
+	return rc;
+}
+
+void dtrace_dev_exit(void)
+{
+	mutex_lock(&cpu_lock);
+	mutex_lock(&module_mutex);
+	mutex_lock(&dtrace_provider_lock);
+	mutex_lock(&dtrace_lock);
+
+	dtrace_unregister((dtrace_provider_id_t)dtrace_provider);
+	dtrace_provider = NULL;
+
+	dtrace_probe_exit();
+
+	unregister_module_notifier(&dtrace_modmgmt);
+
+#if IS_ENABLED(CONFIG_DT_FASTTRAP)
+	dtrace_helpers_cleanup = NULL;
+	dtrace_helpers_fork = NULL;
+#endif
+#ifdef FIXME
+	dtrace_cpu_init = NULL;
+	dtrace_cpustart_init = NULL;
+	dtrace_cpustart_fini = NULL;
+	dtrace_debugger_init = NULL;
+	dtrace_debugger_fini = NULL;
+
+	unregister_cpu_setup_func((cpu_setup_func_t *)dtrace_cpu_setup, NULL);
+#endif
+
+	mutex_unlock(&cpu_lock);
+
+	dtrace_hash_destroy(dtrace_bymod);
+	dtrace_hash_destroy(dtrace_byfunc);
+	dtrace_hash_destroy(dtrace_byname);
+	dtrace_bymod = NULL;
+	dtrace_byfunc = NULL;
+	dtrace_byname = NULL;
+
+	/*
+	 * If DTrace helper tracing is enabled, we need to free the trace
+	 * buffer.
+	 */
+	if (dtrace_helptrace_enabled || dtrace_helptrace_buffer)
+		vfree(dtrace_helptrace_buffer);
+
+	kmem_cache_destroy(dtrace_state_cachep);
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&dtrace_provider_lock);
+	mutex_unlock(&module_mutex);
+
+	misc_deregister(&helper_dev);
+	misc_deregister(&dtrace_dev);
+}
diff --git a/dtrace/dtrace_dev.h b/dtrace/dtrace_dev.h
new file mode 100644
index 000000000000..11ae2deb17a1
--- /dev/null
+++ b/dtrace/dtrace_dev.h
@@ -0,0 +1,35 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Dynamic Tracing for Linux
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DTRACE_DEV_H_
+#define _DTRACE_DEV_H_
+
+#define DT_DEV_DTRACE_MINOR	(16)
+#define DT_DEV_HELPER_MINOR	(DT_DEV_DTRACE_MINOR + 1)
+#define DT_DEV_PROFILE_MINOR	(DT_DEV_HELPER_MINOR + 1)
+#define DT_DEV_SYSTRACE_MINOR	(DT_DEV_PROFILE_MINOR + 1)
+#define DT_DEV_FBT_MINOR	(DT_DEV_SYSTRACE_MINOR + 1)
+#define DT_DEV_SDT_MINOR	(DT_DEV_FBT_MINOR + 1)
+#define DT_DEV_FASTTRAP_MINOR	(DT_DEV_SDT_MINOR + 1)
+#define DT_DEV_LOCKSTAT_MINOR	(DT_DEV_FASTTRAP_MINOR + 1)
+#define DT_DEV_DT_TEST_MINOR	(DT_DEV_LOCKSTAT_MINOR + 1)
+#define DT_DEV_DT_PERF_MINOR	(DT_DEV_DT_TEST_MINOR + 1)
+
+extern int dtrace_dev_init(void);
+extern void dtrace_dev_exit(void);
+
+#endif /* _DTRACE_DEV_H_ */
diff --git a/dtrace/dtrace_dif.c b/dtrace/dtrace_dif.c
new file mode 100644
index 000000000000..ae7f01b4ed9b
--- /dev/null
+++ b/dtrace/dtrace_dif.c
@@ -0,0 +1,4905 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_dif.c
+ * DESCRIPTION:	DTrace - DIF object implementation
+ *
+ * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dtrace_cpu.h>
+#include <linux/dtrace_task_impl.h>
+#include <linux/fdtable.h>
+#include <linux/hardirq.h>
+#include <linux/if_arp.h>
+#include <linux/if_ether.h>
+#include <linux/if_infiniband.h>
+#include <linux/in6.h>
+#include <linux/inet.h>
+#include <linux/kdev_t.h>
+#include <linux/slab.h>
+#include <linux/socket.h>
+#include <linux/vmalloc.h>
+#include <net/ipv6.h>
+#include <asm/byteorder.h>
+
+#include <linux/mount.h>
+
+#include "dtrace.h"
+
+size_t				dtrace_global_maxsize = 16 * 1024;
+
+/*
+ * This externally visible variable (accessible through the backtick (`)
+ * syntax is provided as a source of well-known, zero-filled memory.  Some
+ * translators use this in their implementation.
+ */
+const char			dtrace_zero[256] = { 0, };
+
+uint64_t			dtrace_vtime_references;
+
+static const char		hexdigits[] = "0123456789abcdef";
+
+static int dtrace_difo_err(uint_t pc, const char *format, ...)
+{
+	char	buf[256];
+
+	if (dtrace_err_verbose) {
+		va_list	alist;
+		size_t	len = strlen(format);
+
+		pr_err("dtrace DIF object error: [%u]: ", pc);
+
+		if (len >= 256 - sizeof(KERN_ERR)) {
+			pr_err("<invalid format string>");
+			return 1;
+		}
+
+		memcpy(buf, KERN_ERR, sizeof(KERN_ERR));
+		memcpy(buf + sizeof(KERN_ERR), format, len);
+
+		va_start(alist, format);
+		vprintk(buf, alist);
+		va_end(alist);
+	}
+
+	return 1;
+}
+
+/*
+ * Validate a DTrace DIF object by checking the IR instructions.  The following
+ * rules are currently enforced by dtrace_difo_validate():
+ *
+ * 1. Each instruction must have a valid opcode
+ * 2. Each register, string, variable, or subroutine reference must be valid
+ * 3. No instruction can modify register %r0 (must be zero)
+ * 4. All instruction reserved bits must be set to zero
+ * 5. The last instruction must be a "ret" instruction
+ * 6. All branch targets must reference a valid instruction _after_ the branch
+ */
+int dtrace_difo_validate(struct dtrace_difo *dp, struct dtrace_vstate *vstate,
+			 uint_t nregs, const struct cred *cr)
+{
+	int	err = 0, i;
+	int	(*efunc)(uint_t pc, const char *, ...) = dtrace_difo_err;
+	int	kcheckload = 0;
+	uint_t	pc;
+
+	kcheckload = cr == NULL ||
+		     (vstate->dtvs_state->dts_cred.dcr_visible &
+		      DTRACE_CRV_KERNEL) == 0;
+
+	dp->dtdo_destructive = 0;
+
+	for (pc = 0; pc < dp->dtdo_len && err == 0; pc++) {
+		dif_instr_t	instr = dp->dtdo_buf[pc];
+		uint_t		r1 = DIF_INSTR_R1(instr);
+		uint_t		r2 = DIF_INSTR_R2(instr);
+		uint_t		rd = DIF_INSTR_RD(instr);
+		uint_t		rs = DIF_INSTR_RS(instr);
+		uint_t		label = DIF_INSTR_LABEL(instr);
+		uint_t		v = DIF_INSTR_VAR(instr);
+		uint_t		subr = DIF_INSTR_SUBR(instr);
+		uint_t		diftype = DIF_INSTR_TYPE(instr);
+		uint_t		op = DIF_INSTR_OP(instr);
+
+		switch (op) {
+		case DIF_OP_OR:
+		case DIF_OP_XOR:
+		case DIF_OP_AND:
+		case DIF_OP_SLL:
+		case DIF_OP_SRL:
+		case DIF_OP_SRA:
+		case DIF_OP_SUB:
+		case DIF_OP_ADD:
+		case DIF_OP_MUL:
+		case DIF_OP_SDIV:
+		case DIF_OP_UDIV:
+		case DIF_OP_SREM:
+		case DIF_OP_UREM:
+		case DIF_OP_COPYS:
+			if (r1 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r1);
+			if (r2 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r2);
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to %r0\n");
+			break;
+		case DIF_OP_NOT:
+		case DIF_OP_MOV:
+		case DIF_OP_ALLOCS:
+			if (r1 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r1);
+			if (r2 != 0)
+				err += efunc(pc, "non-zero reserved bits\n");
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to %r0\n");
+			break;
+		case DIF_OP_LDSB:
+		case DIF_OP_LDSH:
+		case DIF_OP_LDSW:
+		case DIF_OP_LDUB:
+		case DIF_OP_LDUH:
+		case DIF_OP_LDUW:
+		case DIF_OP_LDX:
+			if (r1 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r1);
+			if (r2 != 0)
+				err += efunc(pc, "non-zero reserved bits\n");
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to %r0\n");
+			if (kcheckload)
+				dp->dtdo_buf[pc] = DIF_INSTR_LOAD(
+							op + DIF_OP_RLDSB -
+							     DIF_OP_LDSB,
+							r1, rd);
+			break;
+		case DIF_OP_RLDSB:
+		case DIF_OP_RLDSH:
+		case DIF_OP_RLDSW:
+		case DIF_OP_RLDUB:
+		case DIF_OP_RLDUH:
+		case DIF_OP_RLDUW:
+		case DIF_OP_RLDX:
+			if (r1 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r1);
+			if (r2 != 0)
+				err += efunc(pc, "non-zero reserved bits\n");
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to %r0\n");
+			break;
+		case DIF_OP_ULDSB:
+		case DIF_OP_ULDSH:
+		case DIF_OP_ULDSW:
+		case DIF_OP_ULDUB:
+		case DIF_OP_ULDUH:
+		case DIF_OP_ULDUW:
+		case DIF_OP_ULDX:
+			if (r1 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r1);
+			if (r2 != 0)
+				err += efunc(pc, "non-zero reserved bits\n");
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to %r0\n");
+			break;
+		case DIF_OP_STB:
+		case DIF_OP_STH:
+		case DIF_OP_STW:
+		case DIF_OP_STX:
+			if (r1 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r1);
+			if (r2 != 0)
+				err += efunc(pc, "non-zero reserved bits\n");
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to 0 address\n");
+			break;
+		case DIF_OP_CMP:
+		case DIF_OP_SCMP:
+			if (r1 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r1);
+			if (r2 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r2);
+			if (rd != 0)
+				err += efunc(pc, "non-zero reserved bits\n");
+			break;
+		case DIF_OP_TST:
+			if (r1 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r1);
+			if (r2 != 0 || rd != 0)
+				err += efunc(pc, "non-zero reserved bits\n");
+			break;
+		case DIF_OP_BA:
+		case DIF_OP_BE:
+		case DIF_OP_BNE:
+		case DIF_OP_BG:
+		case DIF_OP_BGU:
+		case DIF_OP_BGE:
+		case DIF_OP_BGEU:
+		case DIF_OP_BL:
+		case DIF_OP_BLU:
+		case DIF_OP_BLE:
+		case DIF_OP_BLEU:
+			if (label >= dp->dtdo_len)
+				err += efunc(pc, "invalid branch target %u\n",
+					     label);
+			if (label <= pc)
+				err += efunc(pc, "backward branch to %u\n",
+					     label);
+			break;
+		case DIF_OP_RET:
+			if (r1 != 0 || r2 != 0)
+				err += efunc(pc, "non-zero reserved bits\n");
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			break;
+		case DIF_OP_NOP:
+		case DIF_OP_POPTS:
+		case DIF_OP_FLUSHTS:
+			if (r1 != 0 || r2 != 0 || rd != 0)
+				err += efunc(pc, "non-zero reserved bits\n");
+			break;
+		case DIF_OP_SETX:
+			if (DIF_INSTR_INTEGER(instr) >= dp->dtdo_intlen)
+				err += efunc(pc, "invalid integer ref %u\n",
+					     DIF_INSTR_INTEGER(instr));
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to %r0\n");
+			break;
+		case DIF_OP_SETS:
+			if (DIF_INSTR_STRING(instr) >= dp->dtdo_strlen)
+				err += efunc(pc, "invalid string ref %u\n",
+					     DIF_INSTR_STRING(instr));
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to %r0\n");
+			break;
+		case DIF_OP_LDGA:
+		case DIF_OP_LDTA:
+			if (r1 > DIF_VAR_ARRAY_MAX)
+				err += efunc(pc, "invalid array %u\n", r1);
+			if (r2 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r2);
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to %r0\n");
+			break;
+		case DIF_OP_LDGS:
+		case DIF_OP_LDTS:
+		case DIF_OP_LDLS:
+		case DIF_OP_LDGAA:
+		case DIF_OP_LDTAA:
+			if (v < DIF_VAR_OTHER_MIN || v > DIF_VAR_OTHER_MAX)
+				err += efunc(pc, "invalid variable %u\n", v);
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to %r0\n");
+			break;
+		case DIF_OP_STGS:
+		case DIF_OP_STTS:
+		case DIF_OP_STLS:
+		case DIF_OP_STGAA:
+		case DIF_OP_STTAA:
+			if (v < DIF_VAR_OTHER_UBASE || v > DIF_VAR_OTHER_MAX)
+				err += efunc(pc, "invalid variable %u\n", v);
+			if (rs >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			break;
+		case DIF_OP_CALL:
+			if (subr > DIF_SUBR_MAX)
+				err += efunc(pc, "invalid subr %u\n", subr);
+			if (rd >= nregs)
+				err += efunc(pc, "invalid register %u\n", rd);
+			if (rd == 0)
+				err += efunc(pc, "cannot write to %r0\n");
+
+			if (subr == DIF_SUBR_COPYOUT ||
+			    subr == DIF_SUBR_COPYOUTSTR)
+				dp->dtdo_destructive = 1;
+			break;
+		case DIF_OP_PUSHTR:
+			if (diftype != DIF_TYPE_STRING && diftype != DIF_TYPE_CTF)
+				err += efunc(pc, "invalid ref type %u\n",
+					     diftype);
+			if (r2 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r2);
+			if (rs >= nregs)
+				err += efunc(pc, "invalid register %u\n", rs);
+			break;
+		case DIF_OP_PUSHTV:
+			if (diftype != DIF_TYPE_CTF)
+				err += efunc(pc, "invalid val type %u\n",
+					     diftype);
+			if (r2 >= nregs)
+				err += efunc(pc, "invalid register %u\n", r2);
+			if (rs >= nregs)
+				err += efunc(pc, "invalid register %u\n", rs);
+			break;
+		default:
+			err += efunc(pc, "invalid opcode %u\n",
+				     DIF_INSTR_OP(instr));
+		}
+	}
+
+	if (dp->dtdo_len != 0 &&
+	    DIF_INSTR_OP(dp->dtdo_buf[dp->dtdo_len - 1]) != DIF_OP_RET) {
+		err += efunc(dp->dtdo_len - 1,
+			     "expected 'ret' as last DIF instruction\n");
+	}
+
+	if (!(dp->dtdo_rtype.dtdt_flags & DIF_TF_BYREF)) {
+		/*
+		 * If we're not returning by reference, the size must be either
+		 * 0 or the size of one of the base types.
+		 */
+		switch (dp->dtdo_rtype.dtdt_size) {
+		case 0:
+		case sizeof(uint8_t):
+		case sizeof(uint16_t):
+		case sizeof(uint32_t):
+		case sizeof(uint64_t):
+			break;
+
+		default:
+			err += efunc(dp->dtdo_len - 1, "bad return size\n");
+		}
+	}
+
+	for (i = 0; i < dp->dtdo_varlen && err == 0; i++) {
+		struct dtrace_difv	*v = &dp->dtdo_vartab[i],
+					*existing = NULL;
+		struct dtrace_diftype	*vt, *et;
+		uint_t			id, ndx;
+
+		if (v->dtdv_scope != DIFV_SCOPE_GLOBAL &&
+		    v->dtdv_scope != DIFV_SCOPE_THREAD &&
+		    v->dtdv_scope != DIFV_SCOPE_LOCAL) {
+			err += efunc(i, "unrecognized variable scope %d\n",
+				     v->dtdv_scope);
+			break;
+		}
+
+		if (v->dtdv_kind != DIFV_KIND_ARRAY &&
+		    v->dtdv_kind != DIFV_KIND_SCALAR) {
+			err += efunc(i, "unrecognized variable type %d\n",
+				     v->dtdv_kind);
+			break;
+		}
+
+		id = v->dtdv_id;
+		if (id > DIF_VARIABLE_MAX) {
+			err += efunc(i, "%d exceeds variable id limit\n", id);
+			break;
+		}
+
+		if (id < DIF_VAR_OTHER_UBASE)
+			continue;
+
+		/*
+		 * For user-defined variables, we need to check that this
+		 * definition is identical to any previous definition that we
+		 * encountered.
+		 */
+		ndx = id - DIF_VAR_OTHER_UBASE;
+
+		switch (v->dtdv_scope) {
+		case DIFV_SCOPE_GLOBAL:
+			if (ndx < vstate->dtvs_nglobals) {
+				struct dtrace_statvar	*svar;
+
+				svar = vstate->dtvs_globals[ndx];
+				if (svar != NULL)
+					existing = &svar->dtsv_var;
+			}
+
+			break;
+
+		case DIFV_SCOPE_THREAD:
+			if (ndx < vstate->dtvs_ntlocals)
+				existing = &vstate->dtvs_tlocals[ndx];
+			break;
+
+		case DIFV_SCOPE_LOCAL:
+			if (ndx < vstate->dtvs_nlocals) {
+				struct dtrace_statvar	*svar;
+
+				svar = vstate->dtvs_locals[ndx];
+				if (svar != NULL)
+					existing = &svar->dtsv_var;
+			}
+
+			break;
+		}
+
+		vt = &v->dtdv_type;
+
+		if (vt->dtdt_flags & DIF_TF_BYREF) {
+			if (vt->dtdt_size == 0) {
+				err += efunc(i, "zero-sized variable\n");
+				break;
+			}
+
+			if (v->dtdv_scope == DIFV_SCOPE_GLOBAL &&
+			    vt->dtdt_size > dtrace_global_maxsize) {
+				err += efunc(i, "oversized by-ref global\n");
+				break;
+			}
+		}
+
+		if (existing == NULL || existing->dtdv_id == 0)
+			continue;
+
+		ASSERT(existing->dtdv_id == v->dtdv_id);
+		ASSERT(existing->dtdv_scope == v->dtdv_scope);
+
+		if (existing->dtdv_kind != v->dtdv_kind)
+			err += efunc(i, "%d changed variable kind\n", id);
+
+		et = &existing->dtdv_type;
+
+		if (vt->dtdt_flags != et->dtdt_flags) {
+			err += efunc(i, "%d changed variable type flags\n", id);
+			break;
+		}
+
+		if (vt->dtdt_size != 0 && vt->dtdt_size != et->dtdt_size) {
+			err += efunc(i, "%d changed variable type size\n", id);
+			break;
+		}
+	}
+
+	return err;
+}
+
+/*
+ * Validate a DTrace DIF object that it is to be used as a helper.  Helpers
+ * are much more constrained than normal DIFOs.  Specifically, they may
+ * not:
+ *
+ * 1. Make calls to subroutines other than copyin(), copyinstr() or
+ *    miscellaneous string routines
+ * 2. Access DTrace variables other than the args[] array, and the
+ *    curthread, pid, ppid, tid, execname, zonename, uid and gid variables.
+ * 3. Have thread-local variables.
+ * 4. Have dynamic variables.
+ */
+int dtrace_difo_validate_helper(struct dtrace_difo *dp)
+{
+	int	(*efunc)(uint_t pc, const char *, ...) = dtrace_difo_err;
+	int	err = 0;
+	uint_t	pc;
+
+	for (pc = 0; pc < dp->dtdo_len; pc++) {
+		dif_instr_t	instr = dp->dtdo_buf[pc];
+		uint_t		v = DIF_INSTR_VAR(instr);
+		uint_t		subr = DIF_INSTR_SUBR(instr);
+		uint_t		op = DIF_INSTR_OP(instr);
+
+		switch (op) {
+		case DIF_OP_OR:
+		case DIF_OP_XOR:
+		case DIF_OP_AND:
+		case DIF_OP_SLL:
+		case DIF_OP_SRL:
+		case DIF_OP_SRA:
+		case DIF_OP_SUB:
+		case DIF_OP_ADD:
+		case DIF_OP_MUL:
+		case DIF_OP_SDIV:
+		case DIF_OP_UDIV:
+		case DIF_OP_SREM:
+		case DIF_OP_UREM:
+		case DIF_OP_COPYS:
+		case DIF_OP_NOT:
+		case DIF_OP_MOV:
+		case DIF_OP_RLDSB:
+		case DIF_OP_RLDSH:
+		case DIF_OP_RLDSW:
+		case DIF_OP_RLDUB:
+		case DIF_OP_RLDUH:
+		case DIF_OP_RLDUW:
+		case DIF_OP_RLDX:
+		case DIF_OP_ULDSB:
+		case DIF_OP_ULDSH:
+		case DIF_OP_ULDSW:
+		case DIF_OP_ULDUB:
+		case DIF_OP_ULDUH:
+		case DIF_OP_ULDUW:
+		case DIF_OP_ULDX:
+		case DIF_OP_STB:
+		case DIF_OP_STH:
+		case DIF_OP_STW:
+		case DIF_OP_STX:
+		case DIF_OP_ALLOCS:
+		case DIF_OP_CMP:
+		case DIF_OP_SCMP:
+		case DIF_OP_TST:
+		case DIF_OP_BA:
+		case DIF_OP_BE:
+		case DIF_OP_BNE:
+		case DIF_OP_BG:
+		case DIF_OP_BGU:
+		case DIF_OP_BGE:
+		case DIF_OP_BGEU:
+		case DIF_OP_BL:
+		case DIF_OP_BLU:
+		case DIF_OP_BLE:
+		case DIF_OP_BLEU:
+		case DIF_OP_RET:
+		case DIF_OP_NOP:
+		case DIF_OP_POPTS:
+		case DIF_OP_FLUSHTS:
+		case DIF_OP_SETX:
+		case DIF_OP_SETS:
+		case DIF_OP_LDGA:
+		case DIF_OP_LDLS:
+		case DIF_OP_STGS:
+		case DIF_OP_STLS:
+		case DIF_OP_PUSHTR:
+		case DIF_OP_PUSHTV:
+			break;
+
+		case DIF_OP_LDGS:
+			if (v >= DIF_VAR_OTHER_UBASE)
+				break;
+
+			if (v >= DIF_VAR_ARG0 && v <= DIF_VAR_ARG9)
+				break;
+
+			if (v == DIF_VAR_CURTHREAD || v == DIF_VAR_PID ||
+			    v == DIF_VAR_PPID || v == DIF_VAR_TID ||
+			    v == DIF_VAR_EXECNAME || v == DIF_VAR_ZONENAME ||
+			    v == DIF_VAR_UID || v == DIF_VAR_GID)
+				break;
+
+			err += efunc(pc, "illegal variable %u\n", v);
+			break;
+
+		case DIF_OP_LDTA:
+		case DIF_OP_LDGAA:
+		case DIF_OP_LDTAA:
+			err += efunc(pc, "illegal dynamic variable load\n");
+			break;
+
+		case DIF_OP_STTS:
+		case DIF_OP_STGAA:
+		case DIF_OP_STTAA:
+			err += efunc(pc, "illegal dynamic variable store\n");
+			break;
+
+		case DIF_OP_CALL:
+			if (subr == DIF_SUBR_ALLOCA ||
+			    subr == DIF_SUBR_BCOPY ||
+			    subr == DIF_SUBR_COPYIN ||
+			    subr == DIF_SUBR_COPYINTO ||
+			    subr == DIF_SUBR_COPYINSTR ||
+			    subr == DIF_SUBR_INDEX ||
+			    subr == DIF_SUBR_INET_NTOA ||
+			    subr == DIF_SUBR_INET_NTOA6 ||
+			    subr == DIF_SUBR_INET_NTOP ||
+			    subr == DIF_SUBR_LINK_NTOP ||
+			    subr == DIF_SUBR_LLTOSTR ||
+			    subr == DIF_SUBR_RINDEX ||
+			    subr == DIF_SUBR_STRCHR ||
+			    subr == DIF_SUBR_STRJOIN ||
+			    subr == DIF_SUBR_STRRCHR ||
+			    subr == DIF_SUBR_STRSTR ||
+			    subr == DIF_SUBR_HTONS ||
+			    subr == DIF_SUBR_HTONL ||
+			    subr == DIF_SUBR_HTONLL ||
+			    subr == DIF_SUBR_NTOHS ||
+			    subr == DIF_SUBR_NTOHL ||
+			    subr == DIF_SUBR_NTOHLL)
+				break;
+
+			err += efunc(pc, "invalid subr %u\n", subr);
+			break;
+
+		default:
+			err += efunc(pc, "invalid opcode %u\n",
+				     DIF_INSTR_OP(instr));
+		}
+	}
+
+	return err;
+}
+
+/*
+ * Returns 1 if the expression in the DIF object can be cached on a per-thread
+ * basis; 0 if not.
+ */
+int dtrace_difo_cacheable(struct dtrace_difo *dp)
+{
+	int	i;
+
+	if (dp == NULL)
+		return 0;
+
+	for (i = 0; i < dp->dtdo_varlen; i++) {
+		struct dtrace_difv *v = &dp->dtdo_vartab[i];
+
+		if (v->dtdv_scope != DIFV_SCOPE_GLOBAL)
+			continue;
+
+		switch (v->dtdv_id) {
+		case DIF_VAR_CURTHREAD:
+		case DIF_VAR_PID:
+		case DIF_VAR_TID:
+		case DIF_VAR_EXECNAME:
+		case DIF_VAR_ZONENAME:
+			break;
+
+		default:
+			return 0;
+		}
+	}
+
+	/*
+	 * This DIF object may be cacheable.  Now we need to look for any
+	 * array loading instructions, any memory loading instructions, or
+	 * any stores to thread-local variables.
+	 */
+	for (i = 0; i < dp->dtdo_len; i++) {
+		uint_t	op = DIF_INSTR_OP(dp->dtdo_buf[i]);
+
+		if ((op >= DIF_OP_LDSB && op <= DIF_OP_LDX) ||
+		    (op >= DIF_OP_ULDSB && op <= DIF_OP_ULDX) ||
+		    (op >= DIF_OP_RLDSB && op <= DIF_OP_RLDX) ||
+		    op == DIF_OP_LDGA || op == DIF_OP_STTS)
+			return 0;
+	}
+
+	return 1;
+}
+
+/*
+ * This routine calculates the dynamic variable chunksize for a given DIF
+ * object.  The calculation is not fool-proof, and can probably be tricked by
+ * malicious DIF -- but it works for all compiler-generated DIF.  Because this
+ * calculation is likely imperfect, dtrace_dynvar() is able to gracefully fail
+ * if a dynamic variable size exceeds the chunksize.
+ */
+static void dtrace_difo_chunksize(struct dtrace_difo *dp,
+				  struct dtrace_vstate *vstate)
+{
+	uint64_t		sval = 0;
+	struct dtrace_key	tupregs[DIF_DTR_NREGS + 2]; /* + thread + id */
+	const dif_instr_t	*text = dp->dtdo_buf;
+	uint_t			pc, srd = 0;
+	uint_t			ttop = 0;
+	size_t			size, ksize;
+	uint_t			id, i;
+
+	for (pc = 0; pc < dp->dtdo_len; pc++) {
+		dif_instr_t	instr = text[pc];
+		uint_t		op = DIF_INSTR_OP(instr);
+		uint_t		rd = DIF_INSTR_RD(instr);
+		uint_t		r1 = DIF_INSTR_R1(instr);
+		uint_t		nkeys = 0;
+		uchar_t		scope;
+		struct dtrace_key *key = tupregs;
+
+		switch (op) {
+		case DIF_OP_SETX:
+			sval = dp->dtdo_inttab[DIF_INSTR_INTEGER(instr)];
+			srd = rd;
+			continue;
+
+		case DIF_OP_STTS:
+			key = &tupregs[DIF_DTR_NREGS];
+			key[0].dttk_size = 0;
+			key[1].dttk_size = 0;
+			nkeys = 2;
+			scope = DIFV_SCOPE_THREAD;
+			break;
+
+		case DIF_OP_STGAA:
+		case DIF_OP_STTAA:
+			nkeys = ttop;
+
+			if (DIF_INSTR_OP(instr) == DIF_OP_STTAA)
+				key[nkeys++].dttk_size = 0;
+
+			key[nkeys++].dttk_size = 0;
+
+			if (op == DIF_OP_STTAA)
+				scope = DIFV_SCOPE_THREAD;
+			else
+				scope = DIFV_SCOPE_GLOBAL;
+
+			break;
+
+		case DIF_OP_PUSHTR:
+			if (ttop == DIF_DTR_NREGS)
+				return;
+
+			/*
+			 * If the register for the size of the "pushtr" is %r0
+			 * (or the value is 0) and the type is a string, we'll
+			 * use the system-wide default string size.
+			 */
+			if ((srd == 0 || sval == 0) && r1 == DIF_TYPE_STRING)
+				tupregs[ttop++].dttk_size =
+						dtrace_strsize_default;
+			else {
+				if (srd == 0)
+					return;
+
+				tupregs[ttop++].dttk_size = sval;
+			}
+
+			break;
+
+		case DIF_OP_PUSHTV:
+			if (ttop == DIF_DTR_NREGS)
+				return;
+
+			tupregs[ttop++].dttk_size = 0;
+			break;
+
+		case DIF_OP_FLUSHTS:
+			ttop = 0;
+			break;
+
+		case DIF_OP_POPTS:
+			if (ttop != 0)
+				ttop--;
+			break;
+		}
+
+		sval = 0;
+		srd = 0;
+
+		if (nkeys == 0)
+			continue;
+
+		/*
+		 * We have a dynamic variable allocation; calculate its size.
+		 */
+		for (ksize = 0, i = 0; i < nkeys; i++)
+			ksize += P2ROUNDUP(key[i].dttk_size, sizeof(uint64_t));
+
+		size = sizeof(struct dtrace_dynvar);
+		size += sizeof(struct dtrace_key) * (nkeys - 1);
+		size += ksize;
+
+		/*
+		 * Now we need to determine the size of the stored data.
+		 */
+		id = DIF_INSTR_VAR(instr);
+
+		for (i = 0; i < dp->dtdo_varlen; i++) {
+			struct dtrace_difv *v = &dp->dtdo_vartab[i];
+
+			if (v->dtdv_id == id && v->dtdv_scope == scope) {
+				size += v->dtdv_type.dtdt_size;
+				break;
+			}
+		}
+
+		if (i == dp->dtdo_varlen)
+			return;
+
+		/*
+		 * We have the size.  If this is larger than the chunk size
+		 * for our dynamic variable state, reset the chunk size.
+		 */
+		size = P2ROUNDUP(size, sizeof(uint64_t));
+
+		if (size > vstate->dtvs_dynvars.dtds_chunksize)
+			vstate->dtvs_dynvars.dtds_chunksize = size;
+	}
+}
+
+void dtrace_difo_hold(struct dtrace_difo *dp)
+{
+	int	i;
+
+	dp->dtdo_refcnt++;
+	ASSERT(dp->dtdo_refcnt != 0);
+
+	for (i = 0; i < dp->dtdo_varlen; i++) {
+		struct dtrace_difv	*v = &dp->dtdo_vartab[i];
+
+		if (v->dtdv_id != DIF_VAR_VTIMESTAMP)
+			continue;
+
+		if (dtrace_vtime_references++ == 0)
+			dtrace_vtime_enable();
+	}
+}
+
+void dtrace_difo_init(struct dtrace_difo *dp, struct dtrace_vstate *vstate)
+{
+	int	i, oldsvars, osz, nsz, otlocals, ntlocals;
+	uint_t	id;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(dp->dtdo_buf != NULL && dp->dtdo_len != 0);
+
+	for (i = 0; i < dp->dtdo_varlen; i++) {
+		struct dtrace_difv	*v = &dp->dtdo_vartab[i];
+		struct dtrace_statvar	*svar, ***svarp;
+		size_t			dsize = 0;
+		uint8_t			scope = v->dtdv_scope;
+		int			*np;
+
+		id = v->dtdv_id;
+		if (id < DIF_VAR_OTHER_UBASE)
+			continue;
+
+		id -= DIF_VAR_OTHER_UBASE;
+
+		switch (scope) {
+		case DIFV_SCOPE_THREAD:
+			while (id >= (otlocals = vstate->dtvs_ntlocals)) {
+				struct dtrace_difv *tlocals;
+
+				ntlocals = otlocals << 1;
+				if (ntlocals == 0)
+					ntlocals = 1;
+
+				osz = otlocals * sizeof(struct dtrace_difv);
+				nsz = ntlocals * sizeof(struct dtrace_difv);
+
+				tlocals = vzalloc(nsz);
+
+				if (osz != 0) {
+					memcpy(tlocals, vstate->dtvs_tlocals,
+					       osz);
+					vfree(vstate->dtvs_tlocals);
+				}
+
+				vstate->dtvs_tlocals = tlocals;
+				vstate->dtvs_ntlocals = ntlocals;
+			}
+
+			vstate->dtvs_tlocals[id] = *v;
+			continue;
+
+		case DIFV_SCOPE_LOCAL:
+			np = &vstate->dtvs_nlocals;
+			svarp = &vstate->dtvs_locals;
+
+			if (v->dtdv_type.dtdt_flags & DIF_TF_BYREF)
+				dsize = NR_CPUS *
+					(v->dtdv_type.dtdt_size +
+					 sizeof(uint64_t));
+			else
+				dsize = NR_CPUS * sizeof(uint64_t);
+
+			break;
+
+		case DIFV_SCOPE_GLOBAL:
+			np = &vstate->dtvs_nglobals;
+			svarp = &vstate->dtvs_globals;
+
+			if (v->dtdv_type.dtdt_flags & DIF_TF_BYREF)
+				dsize = v->dtdv_type.dtdt_size +
+					sizeof(uint64_t);
+
+			break;
+
+		default:
+			ASSERT(0);
+			continue; /* not reached */
+		}
+
+		while (id >= (oldsvars = *np)) {
+			struct dtrace_statvar	**statics;
+			int			newsvars, oldsize, newsize;
+
+			newsvars = oldsvars << 1;
+			if (newsvars == 0)
+				newsvars = 1;
+
+			oldsize = oldsvars * sizeof(struct dtrace_statvar *);
+			newsize = newsvars * sizeof(struct dtrace_statvar *);
+
+			statics = vzalloc(newsize);
+
+			if (oldsize != 0) {
+				memcpy(statics, *svarp, oldsize);
+				vfree(*svarp);
+			}
+
+			*svarp = statics;
+			*np = newsvars;
+		}
+
+		svar = (*svarp)[id];
+		if (svar == NULL) {
+			svar = kzalloc(sizeof(struct dtrace_statvar),
+				       GFP_KERNEL);
+			svar->dtsv_var = *v;
+
+			svar->dtsv_size = dsize;
+			if (svar->dtsv_size != 0) {
+				svar->dtsv_data =
+					(uint64_t)(uintptr_t)vzalloc(dsize);
+			}
+
+			(*svarp)[id] = svar;
+		}
+
+		svar->dtsv_refcnt++;
+	}
+
+	dtrace_difo_chunksize(dp, vstate);
+	dtrace_difo_hold(dp);
+}
+
+struct dtrace_difo *dtrace_difo_duplicate(struct dtrace_difo *dp,
+                                          struct dtrace_vstate *vstate)
+{
+	struct dtrace_difo	*new;
+	size_t			sz;
+
+	ASSERT(dp->dtdo_buf != NULL);
+	ASSERT(dp->dtdo_refcnt != 0);
+
+	new = kzalloc(sizeof(struct dtrace_difo), GFP_KERNEL);
+
+	ASSERT(dp->dtdo_buf != NULL);
+	sz = dp->dtdo_len * sizeof(dif_instr_t);
+	new->dtdo_buf = vmalloc(sz);
+	memcpy(new->dtdo_buf, dp->dtdo_buf, sz);
+	new->dtdo_len = dp->dtdo_len;
+
+	if (dp->dtdo_strtab != NULL) {
+		ASSERT(dp->dtdo_strlen != 0);
+		new->dtdo_strtab = vmalloc(dp->dtdo_strlen);
+		memcpy(new->dtdo_strtab, dp->dtdo_strtab, dp->dtdo_strlen);
+		new->dtdo_strlen = dp->dtdo_strlen;
+	}
+
+	if (dp->dtdo_inttab != NULL) {
+		ASSERT(dp->dtdo_intlen != 0);
+		sz = dp->dtdo_intlen * sizeof(uint64_t);
+		new->dtdo_inttab = vmalloc(sz);
+		memcpy(new->dtdo_inttab, dp->dtdo_inttab, sz);
+		new->dtdo_intlen = dp->dtdo_intlen;
+	}
+
+	if (dp->dtdo_vartab != NULL) {
+		ASSERT(dp->dtdo_varlen != 0);
+		sz = dp->dtdo_varlen * sizeof(struct dtrace_difv);
+		new->dtdo_vartab = vmalloc(sz);
+		memcpy(new->dtdo_vartab, dp->dtdo_vartab, sz);
+		new->dtdo_varlen = dp->dtdo_varlen;
+	}
+
+	dtrace_difo_init(new, vstate);
+
+	return new;
+}
+
+void dtrace_difo_destroy(struct dtrace_difo *dp, struct dtrace_vstate *vstate)
+{
+	int	i;
+
+	ASSERT(dp->dtdo_refcnt == 0);
+
+	for (i = 0; i < dp->dtdo_varlen; i++) {
+		struct dtrace_difv	*v = &dp->dtdo_vartab[i];
+		struct dtrace_statvar	*svar, **svarp;
+		uint_t			id;
+		uint8_t			scope = v->dtdv_scope;
+		int			*np;
+
+		switch (scope) {
+		case DIFV_SCOPE_THREAD:
+			continue;
+
+		case DIFV_SCOPE_LOCAL:
+			np = &vstate->dtvs_nlocals;
+			svarp = vstate->dtvs_locals;
+			break;
+
+		case DIFV_SCOPE_GLOBAL:
+			np = &vstate->dtvs_nglobals;
+			svarp = vstate->dtvs_globals;
+			break;
+
+		default:
+			BUG();
+		}
+
+		id = v->dtdv_id;
+		if (id < DIF_VAR_OTHER_UBASE)
+			continue;
+
+		id -= DIF_VAR_OTHER_UBASE;
+		ASSERT(id < *np);
+
+		svar = svarp[id];
+		ASSERT(svar != NULL);
+		ASSERT(svar->dtsv_refcnt > 0);
+
+		if (--svar->dtsv_refcnt > 0)
+			continue;
+
+		if (svar->dtsv_size != 0) {
+			ASSERT((void *)(uintptr_t)svar->dtsv_data != NULL);
+			vfree((void *)(uintptr_t)svar->dtsv_data);
+		}
+
+		kfree(svar);
+		svarp[id] = NULL;
+	}
+
+	vfree(dp->dtdo_buf);
+	vfree(dp->dtdo_inttab);
+	vfree(dp->dtdo_strtab);
+	vfree(dp->dtdo_vartab);
+	kfree(dp);
+}
+
+void dtrace_difo_release(struct dtrace_difo *dp, struct dtrace_vstate *vstate)
+{
+	int	i;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(dp->dtdo_refcnt != 0);
+
+	for (i = 0; i < dp->dtdo_varlen; i++) {
+		struct dtrace_difv *v = &dp->dtdo_vartab[i];
+
+		if (v->dtdv_id != DIF_VAR_VTIMESTAMP)
+			continue;
+
+		ASSERT(dtrace_vtime_references > 0);
+
+		if (--dtrace_vtime_references == 0)
+			dtrace_vtime_disable();
+	}
+
+	if (--dp->dtdo_refcnt == 0)
+		dtrace_difo_destroy(dp, vstate);
+}
+
+/*
+ * The key for a thread-local variable consists of the lower 60 bits of the
+ * task pid, prefixed by a 4 bits indicating whether a hard_irq is active.
+ * This accounts for a case where some older drivers re-enable interrupts
+ * and can nest in hard irq context.
+ *
+ * All per-cpu idle threads share same pid 0. In this special case we replace
+ * the pid with cpu id (an idle thread is bound to a single cpu). If pid is
+ * not 0 then a NR_CPUS is added. This assures that the thread key for idle
+ * thread never conflicts with regular pids in range 0..NR_CPUS.
+ *
+ * We add DIF_VARIABLE_MAX to the pid to assure that the thread key is never
+ * equal to a variable identifier.  This is necessary (but not sufficient) to
+ * assure that global associative arrays never collide with thread-local
+ * variables.  To guarantee that they cannot collide, we must also define the
+ * order for keying dynamic variables.  That order is:
+ *
+ *   [ key0 ] ... [ keyn ] [ variable-key ] [ tls-key ]
+ *
+ * Because the variable-key and the tls-key are in orthogonal spaces, there is
+ * no way for a global variable key signature to match a thread-local key
+ * signature.
+ */
+#define DTRACE_TLS_THRKEY(where)					\
+	{								\
+		uint_t	intr = hardirq_count() >> HARDIRQ_SHIFT;	\
+		uint_t	cpu = (current->flags & PF_IDLE) ?		\
+				smp_processor_id() : NR_CPUS;		\
+									\
+		(where) = ((current->pid + cpu + DIF_VARIABLE_MAX) &	\
+			   (((uint64_t)1 << 60) - 1)) |			\
+			  ((uint64_t)intr << 60);			\
+	}
+
+#ifndef FIXME
+# define DTRACE_ALIGNCHECK(addr, size, flags)
+#endif
+
+/*
+ * Test whether a range of memory starting at testaddr of size testsz falls
+ * within the range of memory described by addr, sz.  We take care to avoid
+ * problems with overflow and underflow of the unsigned quantities, and
+ * disallow all negative sizes.  Ranges of size 0 are allowed.
+ */
+#define DTRACE_INRANGE(testaddr, testsz, baseaddr, basesz) \
+	((testaddr) - (baseaddr) < (basesz) && \
+	 (testaddr) + (testsz) - (baseaddr) <= (basesz) && \
+	 (testaddr) + (testsz) >= (testaddr))
+
+#define DTRACE_LOADFUNC(bits)						\
+	uint##bits##_t dtrace_load##bits(uintptr_t addr)		\
+	{								\
+		size_t			size = bits / NBBY;		\
+		uint##bits##_t		rval;				\
+		int			i;				\
+		volatile uint16_t	*flags = (volatile uint16_t *)	\
+			    &this_cpu_core->cpuc_dtrace_flags;		\
+									\
+		/*							\
+		 * Deviation from the OpenSolaris code...  Protect	\
+		 * against dereferencing the NULL pointer since that	\
+		 * really causes us a lot of grief (crash).		\
+		 */							\
+		if (addr == 0) {					\
+			*flags |= CPU_DTRACE_BADADDR;			\
+			this_cpu_core->cpuc_dtrace_illval = addr;	\
+			return 0;					\
+		}							\
+									\
+		DTRACE_ALIGNCHECK(addr, size, flags);			\
+									\
+		for (i = 0; i < dtrace_toxranges; i++) {		\
+			if (addr >= dtrace_toxrange[i].dtt_limit)	\
+				continue;				\
+									\
+			if (addr + size <= dtrace_toxrange[i].dtt_base)	\
+				continue;				\
+									\
+			/*						\
+			 * This address falls within a toxic region.	\
+			 */						\
+			*flags |= CPU_DTRACE_BADADDR;			\
+			this_cpu_core->cpuc_dtrace_illval = addr;	\
+			return 0;					\
+		}							\
+									\
+		*flags |= CPU_DTRACE_NOFAULT;				\
+		rval = *((volatile uint##bits##_t *)addr);		\
+		*flags &= ~CPU_DTRACE_NOFAULT;				\
+									\
+		return !(*flags & CPU_DTRACE_FAULT) ? rval : 0;		\
+	}
+
+/*
+ * Use the DTRACE_LOADFUNC macro to define functions for each of loading a
+ * uint8_t, a uint16_t, a uint32_t and a uint64_t.
+ */
+DTRACE_LOADFUNC(8)
+DTRACE_LOADFUNC(16)
+DTRACE_LOADFUNC(32)
+DTRACE_LOADFUNC(64)
+
+#define DT_BSWAP_8(x)	((x) & 0xff)
+#define DT_BSWAP_16(x)	((DT_BSWAP_8(x) << 8) | DT_BSWAP_8((x) >> 8))
+#define DT_BSWAP_32(x)	((DT_BSWAP_16(x) << 16) | DT_BSWAP_16((x) >> 16))
+#define DT_BSWAP_64(x)	((DT_BSWAP_32(x) << 32) | DT_BSWAP_32((x) >> 32))
+
+static int dtrace_inscratch(uintptr_t dest, size_t size,
+			    struct dtrace_mstate *mstate)
+{
+	if (dest < mstate->dtms_scratch_base)
+		return 0;
+
+	if (dest + size < dest)
+		return 0;
+
+	if (dest + size > mstate->dtms_scratch_ptr)
+		return 0;
+
+	return 1;
+}
+
+static int dtrace_canstore_statvar(uint64_t addr, size_t sz,
+				   struct dtrace_statvar **svars, int nsvars)
+{
+	int i;
+
+	for (i = 0; i < nsvars; i++) {
+		struct dtrace_statvar	*svar = svars[i];
+
+		if (svar == NULL || svar->dtsv_size == 0)
+			continue;
+
+		if (DTRACE_INRANGE(addr, sz, svar->dtsv_data, svar->dtsv_size))
+			return 1;
+	}
+
+	return 0;
+}
+
+/*
+ * Check to see if the address is within a memory region to which a store may
+ * be issued.  This includes the DTrace scratch areas, and any DTrace variable
+ * region.  The caller of dtrace_canstore() is responsible for performing any
+ * alignment checks that are needed before stores are actually executed.
+ */
+static int dtrace_canstore(uint64_t addr, size_t sz,
+			   struct dtrace_mstate *mstate,
+			   struct dtrace_vstate *vstate)
+{
+	/*
+	 * First, check to see if the address is in scratch space...
+	 */
+	if (DTRACE_INRANGE(addr, sz, mstate->dtms_scratch_base,
+			   mstate->dtms_scratch_size))
+		return 1;
+
+	/*
+	 * Now check to see if it's a dynamic variable.  This check will pick
+	 * up both thread-local variables and any global dynamically-allocated
+	 * variables.
+	 */
+	if (DTRACE_INRANGE(addr, sz, (uintptr_t)vstate->dtvs_dynvars.dtds_base,
+			   vstate->dtvs_dynvars.dtds_size)) {
+		struct dtrace_dstate	*dstate = &vstate->dtvs_dynvars;
+		uintptr_t	base = (uintptr_t)dstate->dtds_base +
+				       (dstate->dtds_hashsize *
+					sizeof(struct dtrace_dynhash));
+		uintptr_t	chunkoffs;
+		uint64_t	num;
+
+		/*
+		 * Before we assume that we can store here, we need to make
+		 * sure that it isn't in our metadata -- storing to our
+		 * dynamic variable metadata would corrupt our state.  For
+		 * the range to not include any dynamic variable metadata,
+		 * it must:
+		 *
+		 *      (1) Start above the hash table that is at the base of
+		 *      the dynamic variable space
+		 *
+		 *      (2) Have a starting chunk offset that is beyond the
+		 *      dtrace_dynvar_t that is at the base of every chunk
+		 *
+		 *      (3) Not span a chunk boundary
+		 */
+		if (addr < base)
+			return 0;
+
+		num = addr - base;
+		chunkoffs = do_div(num, dstate->dtds_chunksize);
+
+		if (chunkoffs < sizeof(struct dtrace_dynvar))
+			return 0;
+
+		if (chunkoffs + sz > dstate->dtds_chunksize)
+			return 0;
+
+		return 1;
+	}
+
+	/*
+	 * Finally, check the static local and global variables.  These checks
+	 * take the longest, so we perform them last.
+	 */
+	if (dtrace_canstore_statvar(addr, sz, vstate->dtvs_locals,
+				    vstate->dtvs_nlocals))
+		return 1;
+
+	if (dtrace_canstore_statvar(addr, sz, vstate->dtvs_globals,
+				    vstate->dtvs_nglobals))
+		return 1;
+
+	return 0;
+}
+
+/*
+ * Convenience routine to check to see if the address is within a memory
+ * region in which a load may be issued given the user's privilege level;
+ * if not, it sets the appropriate error flags and loads 'addr' into the
+ * illegal value slot.
+ *
+ * DTrace subroutines (DIF_SUBR_*) should use this helper to implement
+ * appropriate memory access protection.
+ */
+int
+dtrace_canload(uintptr_t addr, size_t sz, struct dtrace_mstate *mstate,
+	       struct dtrace_vstate *vstate)
+{
+	volatile uintptr_t	*illval = &this_cpu_core->cpuc_dtrace_illval;
+
+	/*
+	 * If we hold the privilege to read from kernel memory, then
+	 * everything is readable.
+	 */
+	if ((mstate->dtms_access & DTRACE_ACCESS_KERNEL) != 0)
+		return 1;
+
+	/*
+	 * You can obviously read that which you can store.
+	 */
+	if (dtrace_canstore(addr, sz, mstate, vstate))
+		return 1;
+
+	/*
+	 * We're allowed to read from our own string table.
+	 */
+	if (DTRACE_INRANGE(addr, sz, (uintptr_t)mstate->dtms_difo->dtdo_strtab,
+			   mstate->dtms_difo->dtdo_strlen))
+		return 1;
+
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_KPRIV);
+	*illval = addr;
+
+	return 0;
+}
+
+/*
+ * Convenience routine to check to see if a given string is within a memory
+ * region in which a load may be issued given the user's privilege level;
+ * this exists so that we don't need to issue unnecessary dtrace_strlen()
+ * calls in the event that the user has all privileges.
+ */
+static int
+dtrace_strcanload(uint64_t addr, size_t sz, struct dtrace_mstate *mstate,
+		  struct dtrace_vstate *vstate)
+{
+	size_t	strsz;
+
+	/*
+	 * If we hold the privilege to read from kernel memory, then
+	 * everything is readable.
+	 */
+	if ((mstate->dtms_access & DTRACE_ACCESS_KERNEL) != 0)
+		return 1;
+
+	strsz = 1 + dtrace_strlen((char *)(uintptr_t)addr, sz);
+	if (dtrace_canload(addr, strsz, mstate, vstate))
+		return 1;
+
+	return 0;
+}
+
+/*
+ * Convenience routine to check to see if a given variable is within a memory
+ * region in which a load may be issued given the user's privilege level.
+ */
+int dtrace_vcanload(void *src, struct dtrace_diftype *diftype,
+		    struct dtrace_mstate *mstate,
+		    struct dtrace_vstate *vstate)
+{
+	size_t	sz;
+
+	ASSERT(diftype->dtdt_flags & DIF_TF_BYREF);
+
+	/*
+	 * If we hold the privilege to read from kernel memory, then
+	 * everything is readable.
+	 */
+	if ((mstate->dtms_access & DTRACE_ACCESS_KERNEL) != 0)
+		return 1;
+
+	if (diftype->dtdt_kind == DIF_TYPE_STRING)
+		sz = dtrace_strlen(
+			src,
+			vstate->dtvs_state->dts_options[DTRACEOPT_STRSIZE]
+		     ) + 1;
+	else
+		sz = diftype->dtdt_size;
+
+	return dtrace_canload((uintptr_t)src, sz, mstate, vstate);
+}
+
+/*
+ * Copy src to dst using safe memory accesses.  The src is assumed to be unsafe
+ * memory specified by the DIF program.  The dst is assumed to be safe memory
+ * that we can store to directly because it is managed by DTrace.  As with
+ * standard bcopy, overlapping copies are handled properly.
+ */
+static void dtrace_bcopy(const void *src, void *dst, size_t len)
+{
+	if (len != 0) {
+		uint8_t		*s1 = dst;
+		const uint8_t	*s2 = src;
+
+		if (s1 <= s2) {
+			do {
+				*s1++ = dtrace_load8((uintptr_t)s2++);
+			} while (--len != 0);
+		} else {
+			s2 += len;
+			s1 += len;
+
+			do {
+				*--s1 = dtrace_load8((uintptr_t)--s2);
+			} while (--len != 0);
+		}
+	}
+}
+
+/*
+ * Copy src to dst using safe memory accesses, up to either the specified
+ * length, or the point that a nul byte is encountered.  The src is assumed to
+ * be unsafe memory specified by the DIF program.  The dst is assumed to be
+ * safe memory that we can store to directly because it is managed by DTrace.
+ * Unlike dtrace_bcopy(), overlapping regions are not handled.
+ */
+static void dtrace_strcpy(const void *src, void *dst, size_t len)
+{
+	if (len != 0) {
+		uint8_t		*s1 = dst, c;
+		const uint8_t	*s2 = src;
+
+		do {
+			*s1++ = c = dtrace_load8((uintptr_t)s2++);
+		} while (--len != 0 && c != '\0');
+	}
+}
+/*
+ * Copy src to dst, deriving the size and type from the specified (BYREF)
+ * variable type.  The src is assumed to be unsafe memory specified by the DIF
+ * program.  The dst is assumed to be DTrace variable memory that is of the
+ * specified type; we assume that we can store to directly.
+ */
+static void dtrace_vcopy(void *src, void *dst, struct dtrace_diftype *diftype)
+{
+	ASSERT(diftype->dtdt_flags & DIF_TF_BYREF);
+
+	if (diftype->dtdt_kind == DIF_TYPE_STRING)
+		dtrace_strcpy(src, dst, diftype->dtdt_size);
+	else
+		dtrace_bcopy(src, dst, diftype->dtdt_size);
+}
+
+/*
+ * Compare s1 to s2 using safe memory accesses.  The s1 data is assumed to be
+ * unsafe memory specified by the DIF program.  The s2 data is assumed to be
+ * safe memory that we can access directly because it is managed by DTrace.
+ */
+static int dtrace_bcmp(const void *s1, const void *s2, size_t len)
+{
+	volatile uint16_t	*flags;
+
+	flags = (volatile uint16_t *)&this_cpu_core->cpuc_dtrace_flags;
+
+	if (s1 == s2)
+		return 0;
+
+	if (s1 == NULL || s2 == NULL)
+		return 1;
+
+	if (s1 != s2 && len != 0) {
+		const uint8_t	*ps1 = s1;
+		const uint8_t	*ps2 = s2;
+
+		do {
+			if (dtrace_load8((uintptr_t)ps1++) != *ps2++)
+				return 1;
+		} while (--len != 0 && !(*flags & CPU_DTRACE_FAULT));
+	}
+
+	return 0;
+}
+
+/*
+ * Zero the specified region using a simple byte-by-byte loop.  Note that this
+ * is for safe DTrace-managed memory only.
+ */
+void dtrace_bzero(void *dst, size_t len)
+{
+	uchar_t	*cp;
+
+	for (cp = dst; len != 0; len--)
+		*cp++ = 0;
+}
+
+#define DTRACE_DYNHASH_FREE	0
+#define DTRACE_DYNHASH_SINK	1
+#define DTRACE_DYNHASH_VALID	2
+
+/*
+ * Depending on the value of the op parameter, this function looks-up,
+ * allocates or deallocates an arbitrarily-keyed dynamic variable.  If an
+ * allocation is requested, this function will return a pointer to a
+ * dtrace_dynvar_t corresponding to the allocated variable -- or NULL if no
+ * variable can be allocated.  If NULL is returned, the appropriate counter
+ * will be incremented.
+ */
+static struct dtrace_dynvar *dtrace_dynvar(struct dtrace_dstate *dstate,
+                                           uint_t nkeys,
+                                           struct dtrace_key *key,
+                                           size_t dsize,
+                                           enum dtrace_dynvar_op op,
+                                           struct dtrace_mstate *mstate,
+                                           struct dtrace_vstate *vstate)
+{
+	uint64_t			hashval = DTRACE_DYNHASH_VALID;
+	struct dtrace_dynhash		*hash = dstate->dtds_hash;
+	struct dtrace_dynvar		*free, *new_free, *next, *dvar, *start,
+					*prev = NULL;
+	processorid_t			me = smp_processor_id(), cpu = me;
+	struct dtrace_dstate_percpu	*dcpu = &dstate->dtds_percpu[me];
+	size_t				bucket, ksize;
+	size_t				chunksize = dstate->dtds_chunksize;
+	uintptr_t			kdata, lock;
+	enum dtrace_dstate_state	nstate;
+	uint_t				i;
+
+	ASSERT(nkeys != 0);
+
+	/*
+	 * Hash the key.  As with aggregations, we use Jenkins' "One-at-a-time"
+	 * algorithm.  For the by-value portions, we perform the algorithm in
+	 * 16-bit chunks (as opposed to 8-bit chunks).  This speeds things up a
+	 * bit, and seems to have only a minute effect on distribution.  For
+	 * the by-reference data, we perform "One-at-a-time" iterating (safely)
+	 * over each referenced byte.  It's painful to do this, but it's much
+	 * better than pathological hash distribution.  The efficacy of the
+	 * hashing algorithm (and a comparison with other algorithms) may be
+	 * found by running the ::dtrace_dynstat MDB dcmd.
+	 */
+	for (i = 0; i < nkeys; i++) {
+		if (key[i].dttk_size == 0) {
+			uint64_t	val = key[i].dttk_value;
+
+			hashval += (val >> 48) & 0xffff;
+			hashval += (hashval << 10);
+			hashval ^= (hashval >> 6);
+
+			hashval += (val >> 32) & 0xffff;
+			hashval += (hashval << 10);
+			hashval ^= (hashval >> 6);
+
+			hashval += (val >> 16) & 0xffff;
+			hashval += (hashval << 10);
+			hashval ^= (hashval >> 6);
+
+			hashval += val & 0xffff;
+			hashval += (hashval << 10);
+			hashval ^= (hashval >> 6);
+		} else {
+			/*
+			 * This is incredibly painful, but it beats the hell
+			 * out of the alternative.
+			 */
+			uint64_t	j, size = key[i].dttk_size;
+			uintptr_t	base = (uintptr_t)key[i].dttk_value;
+
+			if (!dtrace_canload(base, size, mstate, vstate))
+				break;
+
+			for (j = 0; j < size; j++) {
+				hashval += dtrace_load8(base + j);
+				hashval += (hashval << 10);
+				hashval ^= (hashval >> 6);
+			}
+		}
+	}
+
+	if (DTRACE_CPUFLAG_ISSET(CPU_DTRACE_FAULT))
+		return NULL;
+
+	hashval += (hashval << 3);
+	hashval ^= (hashval >> 11);
+	hashval += (hashval << 15);
+
+	/*
+	 * There is a remote chance (ideally, 1 in 2^31) that our hashval
+	 * comes out to be one of our two sentinel hash values.  If this
+	 * actually happens, we set the hashval to be a value known to be a
+	 * non-sentinel value.
+	 */
+	if (hashval == DTRACE_DYNHASH_FREE || hashval == DTRACE_DYNHASH_SINK)
+		hashval = DTRACE_DYNHASH_VALID;
+
+	/*
+	 * Yes, it's painful to do a divide here.  If the cycle count becomes
+	 * important here, tricks can be pulled to reduce it.  (However, it's
+	 * critical that hash collisions be kept to an absolute minimum;
+	 * they're much more painful than a divide.)  It's better to have a
+	 * solution that generates few collisions and still keeps things
+	 * relatively simple.
+	 *
+	 * Linux cannot do a straight 64-bit divide without gcc requiring
+	 * linking in code that the kernel doesn't link, so we need to use an
+	 * alternative.
+	 *
+	 *	bucket = hashval % dstate->dtds_hashsize;
+	 */
+	{
+		uint64_t	num;
+
+		num = hashval;
+		bucket = do_div(num, dstate->dtds_hashsize);
+	}
+
+	if (op == DTRACE_DYNVAR_DEALLOC) {
+		volatile uintptr_t	*lockp = &hash[bucket].dtdh_lock;
+
+		for (;;) {
+			while ((lock = *lockp) & 1)
+				continue;
+
+			if (cmpxchg(lockp, lock, (lock + 1)) == lock)
+				break;
+		}
+
+		dtrace_membar_producer();
+	}
+
+top:
+	prev = NULL;
+	lock = hash[bucket].dtdh_lock;
+
+	dtrace_membar_consumer();
+
+	start = hash[bucket].dtdh_chain;
+	ASSERT(start != NULL && (start->dtdv_hashval == DTRACE_DYNHASH_SINK ||
+	       start->dtdv_hashval != DTRACE_DYNHASH_FREE ||
+	       op != DTRACE_DYNVAR_DEALLOC));
+
+	for (dvar = start; dvar != NULL; dvar = dvar->dtdv_next) {
+		struct dtrace_tuple	*dtuple = &dvar->dtdv_tuple;
+		struct dtrace_key	*dkey = &dtuple->dtt_key[0];
+
+		if (dvar->dtdv_hashval != hashval) {
+			if (dvar->dtdv_hashval == DTRACE_DYNHASH_SINK) {
+				/*
+				 * We've reached the sink, and therefore the
+				 * end of the hash chain; we can kick out of
+				 * the loop knowing that we have seen a valid
+				 * snapshot of state.
+				 */
+				ASSERT(dvar->dtdv_next == NULL);
+				ASSERT(dvar == &dtrace_dynhash_sink);
+				break;
+			}
+
+			if (dvar->dtdv_hashval == DTRACE_DYNHASH_FREE) {
+				/*
+				 * We've gone off the rails:  somewhere along
+				 * the line, one of the members of this hash
+				 * chain was deleted.  Note that we could also
+				 * detect this by simply letting this loop run
+				 * to completion, as we would eventually hit
+				 * the end of the dirty list.  However, we
+				 * want to avoid running the length of the
+				 * dirty list unnecessarily (it might be quite
+				 * long), so we catch this as early as
+				 * possible by detecting the hash marker.  In
+				 * this case, we simply set dvar to NULL and
+				 * break; the conditional after the loop will
+				 * send us back to top.
+				 */
+				dvar = NULL;
+				break;
+			}
+
+			goto next;
+		}
+
+		if (dtuple->dtt_nkeys != nkeys)
+			goto next;
+
+		for (i = 0; i < nkeys; i++, dkey++) {
+			if (dkey->dttk_size != key[i].dttk_size)
+				goto next;	/* size or type mismatch */
+
+			if (dkey->dttk_size != 0) {
+				if (dtrace_bcmp(
+					  (void *)(uintptr_t)key[i].dttk_value,
+					  (void *)(uintptr_t)dkey->dttk_value,
+					  dkey->dttk_size))
+					goto next;
+			} else {
+				if (dkey->dttk_value != key[i].dttk_value)
+					goto next;
+			}
+		}
+
+		if (op != DTRACE_DYNVAR_DEALLOC)
+			return dvar;
+
+		ASSERT(dvar->dtdv_next == NULL ||
+		dvar->dtdv_next->dtdv_hashval != DTRACE_DYNHASH_FREE);
+
+		if (prev != NULL) {
+			ASSERT(hash[bucket].dtdh_chain != dvar);
+			ASSERT(start != dvar);
+			ASSERT(prev->dtdv_next == dvar);
+			prev->dtdv_next = dvar->dtdv_next;
+		} else {
+			if (cmpxchg(&hash[bucket].dtdh_chain, start,
+				    dvar->dtdv_next) != start) {
+				/*
+				 * We have failed to atomically swing the
+				 * hash table head pointer, presumably because
+				 * of a conflicting allocation on another CPU.
+				 * We need to reread the hash chain and try
+				 * again.
+				 */
+				goto top;
+			}
+		}
+
+		dtrace_membar_producer();
+
+		/*
+		 * Now set the hash value to indicate that it's free.
+		 */
+		ASSERT(hash[bucket].dtdh_chain != dvar);
+		dvar->dtdv_hashval = DTRACE_DYNHASH_FREE;
+
+		dtrace_membar_producer();
+
+		/*
+		 * Set the next pointer to point at the dirty list, and
+		 * atomically swing the dirty pointer to the newly freed dvar.
+		 */
+		do {
+			next = dcpu->dtdsc_dirty;
+			dvar->dtdv_next = next;
+		} while (cmpxchg(&dcpu->dtdsc_dirty, next, dvar) != next);
+
+		/*
+		 * Finally, unlock this hash bucket.
+		 */
+		ASSERT(hash[bucket].dtdh_lock == lock);
+		ASSERT(lock & 1);
+		hash[bucket].dtdh_lock++;
+
+		return NULL;
+next:
+		prev = dvar;
+		continue;
+	}
+
+	if (dvar == NULL) {
+		/*
+		 * If dvar is NULL, it is because we went off the rails:
+		 * one of the elements that we traversed in the hash chain
+		 * was deleted while we were traversing it.  In this case,
+		 * we assert that we aren't doing a dealloc (deallocs lock
+		 * the hash bucket to prevent themselves from racing with
+		 * one another), and retry the hash chain traversal.
+		 */
+		ASSERT(op != DTRACE_DYNVAR_DEALLOC);
+		goto top;
+	}
+
+	if (op != DTRACE_DYNVAR_ALLOC) {
+		/*
+		 * If we are not to allocate a new variable, we want to
+		 * return NULL now.  Before we return, check that the value
+		 * of the lock word hasn't changed.  If it has, we may have
+		 * seen an inconsistent snapshot.
+		 */
+		if (op == DTRACE_DYNVAR_NOALLOC) {
+			if (hash[bucket].dtdh_lock != lock)
+				goto top;
+		} else {
+			ASSERT(op == DTRACE_DYNVAR_DEALLOC);
+			ASSERT(hash[bucket].dtdh_lock == lock);
+			ASSERT(lock & 1);
+			hash[bucket].dtdh_lock++;
+		}
+
+		return NULL;
+	}
+
+	/*
+	 * We need to allocate a new dynamic variable.  The size we need is the
+	 * size of dtrace_dynvar plus the size of nkeys dtrace_key_t's plus the
+	 * size of any auxiliary key data (rounded up to 8-byte alignment) plus
+	 * the size of any referred-to data (dsize).  We then round the final
+	 * size up to the chunksize for allocation.
+	 */
+	for (ksize = 0, i = 0; i < nkeys; i++)
+		ksize += P2ROUNDUP(key[i].dttk_size, sizeof(uint64_t));
+
+	/*
+	 * This should be pretty much impossible, but could happen if, say,
+	 * strange DIF specified the tuple.  Ideally, this should be an
+	 * assertion and not an error condition -- but that requires that the
+	 * chunksize calculation in dtrace_difo_chunksize() be absolutely
+	 * bullet-proof.  (That is, it must not be able to be fooled by
+	 * malicious DIF.)  Given the lack of backwards branches in DIF,
+	 * solving this would presumably not amount to solving the Halting
+	 * Problem -- but it still seems awfully hard.
+	 */
+	if (sizeof(struct dtrace_dynvar) +
+	    sizeof(struct dtrace_key) * (nkeys - 1) +
+	    ksize + dsize > chunksize) {
+		dcpu->dtdsc_drops++;
+		return NULL;
+	}
+
+	nstate = DTRACE_DSTATE_EMPTY;
+
+	do {
+retry:
+		free = dcpu->dtdsc_free;
+
+		if (free == NULL) {
+			struct dtrace_dynvar *clean = dcpu->dtdsc_clean;
+			void *rval;
+
+			if (clean == NULL) {
+				/*
+				 * We're out of dynamic variable space on
+				 * this CPU.  Unless we have tried all CPUs,
+				 * we'll try to allocate from a different
+				 * CPU.
+				 */
+				switch (dstate->dtds_state) {
+				case DTRACE_DSTATE_CLEAN: {
+					enum dtrace_dstate_state	*sp =
+						(enum dtrace_dstate_state *)
+							&dstate->dtds_state;
+
+					if (++cpu >= NR_CPUS)
+						cpu = 0;
+
+					if (dcpu->dtdsc_dirty != NULL &&
+					    nstate == DTRACE_DSTATE_EMPTY)
+						nstate = DTRACE_DSTATE_DIRTY;
+
+					if (dcpu->dtdsc_rinsing != NULL)
+						nstate = DTRACE_DSTATE_RINSING;
+
+					dcpu = &dstate->dtds_percpu[cpu];
+
+					if (cpu != me)
+						goto retry;
+
+					cmpxchg(sp, DTRACE_DSTATE_CLEAN,
+						nstate);
+
+					/*
+					 * To increment the correct bean
+					 * counter, take another lap.
+					 */
+					goto retry;
+				}
+
+				case DTRACE_DSTATE_DIRTY:
+					dcpu->dtdsc_dirty_drops++;
+					break;
+
+				case DTRACE_DSTATE_RINSING:
+					dcpu->dtdsc_rinsing_drops++;
+					break;
+
+				case DTRACE_DSTATE_EMPTY:
+					dcpu->dtdsc_drops++;
+					break;
+				}
+
+				DTRACE_CPUFLAG_SET(CPU_DTRACE_DROP);
+				return NULL;
+			}
+
+			/*
+			 * The clean list appears to be non-empty.  We want to
+			 * move the clean list to the free list; we start by
+			 * moving the clean pointer aside.
+			 */
+			if (cmpxchg(&dcpu->dtdsc_clean, clean, NULL) != clean)
+				/*
+				 * We are in one of two situations:
+				 *
+				 *  (a) The clean list was switched to the
+				 *      free list by another CPU.
+				 *
+				 *  (b) The clean list was added to by the
+				 *      cleansing cyclic.
+				 *
+				 * In either of these situations, we can
+				 * just reattempt the free list allocation.
+				 */
+				goto retry;
+
+			ASSERT(clean->dtdv_hashval == DTRACE_DYNHASH_FREE);
+
+			/*
+			 * Now we'll move the clean list to the free list.
+			 * It's impossible for this to fail:  the only way
+			 * the free list can be updated is through this
+			 * code path, and only one CPU can own the clean list.
+			 * Thus, it would only be possible for this to fail if
+			 * this code were racing with dtrace_dynvar_clean().
+			 * (That is, if dtrace_dynvar_clean() updated the clean
+			 * list, and we ended up racing to update the free
+			 * list.)  This race is prevented by the dtrace_sync()
+			 * in dtrace_dynvar_clean() -- which flushes the
+			 * owners of the clean lists out before resetting
+			 * the clean lists.
+			 */
+			rval = cmpxchg(&dcpu->dtdsc_free, NULL, clean);
+			ASSERT(rval == NULL);
+
+			goto retry;
+		}
+
+		dvar = free;
+		new_free = dvar->dtdv_next;
+	} while (cmpxchg(&dcpu->dtdsc_free, free, new_free) != free);
+
+	/*
+	 * We have now allocated a new chunk.  We copy the tuple keys into the
+	 * tuple array and copy any referenced key data into the data space
+	 * following the tuple array.  As we do this, we relocate dttk_value
+	 * in the final tuple to point to the key data address in the chunk.
+	 */
+	kdata = (uintptr_t)&dvar->dtdv_tuple.dtt_key[nkeys];
+	dvar->dtdv_data = (void *)(kdata + ksize);
+	dvar->dtdv_tuple.dtt_nkeys = nkeys;
+
+	for (i = 0; i < nkeys; i++) {
+		struct dtrace_key	*dkey = &dvar->dtdv_tuple.dtt_key[i];
+		size_t			kesize = key[i].dttk_size;
+
+		if (kesize != 0) {
+			dtrace_bcopy(
+				(const void *)(uintptr_t)key[i].dttk_value,
+				(void *)kdata, kesize);
+			dkey->dttk_value = kdata;
+			kdata += P2ROUNDUP(kesize, sizeof(uint64_t));
+		} else
+			dkey->dttk_value = key[i].dttk_value;
+
+		dkey->dttk_size = kesize;
+	}
+
+	ASSERT(dvar->dtdv_hashval == DTRACE_DYNHASH_FREE);
+	dvar->dtdv_hashval = hashval;
+	dvar->dtdv_next = start;
+
+	if (cmpxchg(&hash[bucket].dtdh_chain, start, dvar) == start)
+		return dvar;
+
+	/*
+	 * The cas has failed.  Either another CPU is adding an element to
+	 * this hash chain, or another CPU is deleting an element from this
+	 * hash chain.  The simplest way to deal with both of these cases
+	 * (though not necessarily the most efficient) is to free our
+	 * allocated block and tail-call ourselves.  Note that the free is
+	 * to the dirty list and _not_ to the free list.  This is to prevent
+	 * races with allocators, above.
+	 */
+	dvar->dtdv_hashval = DTRACE_DYNHASH_FREE;
+
+	dtrace_membar_producer();
+
+	do {
+		free = dcpu->dtdsc_dirty;
+		dvar->dtdv_next = free;
+	} while (cmpxchg(&dcpu->dtdsc_dirty, free, dvar) != free);
+
+	return dtrace_dynvar(dstate, nkeys, key, dsize, op, mstate, vstate);
+}
+
+/*
+ * Return a string.  In the event that the user lacks the privilege to access
+ * arbitrary kernel memory, we copy the string out to scratch memory so that we
+ * don't fail access checking.
+ *
+ * dtrace_dif_variable() uses this routine as a helper for various
+ * builtin values such as 'execname' and 'probefunc.'
+ */
+static uintptr_t dtrace_dif_varstr(uintptr_t addr, struct dtrace_state *state,
+				   struct dtrace_mstate *mstate)
+{
+	uint64_t	size = state->dts_options[DTRACEOPT_STRSIZE];
+	uintptr_t	ret;
+	size_t		strsz;
+
+	/*
+	 * The easy case: this probe is allowed to read all of memory, so
+	 * we can just return this as a vanilla pointer.
+	 */
+	if ((mstate->dtms_access & DTRACE_ACCESS_KERNEL) != 0)
+		return addr;
+
+	/*
+	 * This is the tougher case: we copy the string in question from
+	 * kernel memory into scratch memory and return it that way: this
+	 * ensures that we won't trip up when access checking tests the
+	 * BYREF return value.
+	 */
+	strsz = dtrace_strlen((char *)addr, size) + 1;
+
+	if (mstate->dtms_scratch_ptr + strsz >
+	    mstate->dtms_scratch_base + mstate->dtms_scratch_size) {
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+		return (uintptr_t)NULL;
+	}
+
+	dtrace_strcpy((const void *)addr, (void *)mstate->dtms_scratch_ptr,
+		      strsz);
+	ret = mstate->dtms_scratch_ptr;
+	mstate->dtms_scratch_ptr += strsz;
+
+	return ret;
+}
+
+/*
+ * This function implements the DIF emulator's variable lookups.  The emulator
+ * passes a reserved variable identifier and optional built-in array index.
+ *
+ * This function is annotated to be always inlined in dtrace_dif_emulate()
+ * because (1) that is the only place where it is called from, and (2) it has
+ * come to our attention that some GCC versions inline it automatically while
+ * others do not and that messes up the number of frames to skip (aframes).
+ */
+static __always_inline uint64_t dtrace_dif_variable(struct dtrace_mstate *mstate,
+                                                    struct dtrace_state *state,
+                                                    uint64_t v, uint64_t ndx)
+{
+	/*
+	 * If we're accessing one of the uncached arguments, we'll turn this
+	 * into a reference in the args array.
+	 */
+	if (v >= DIF_VAR_ARG0 && v <= DIF_VAR_ARG9) {
+		ndx = v - DIF_VAR_ARG0;
+		v = DIF_VAR_ARGS;
+	}
+
+	switch (v) {
+	case DIF_VAR_ARGS:
+		ASSERT(mstate->dtms_present & DTRACE_MSTATE_ARGS);
+
+		if (ndx >= DTRACE_MSTATE_ARGS_MAX) {
+			int			aframes =
+					mstate->dtms_probe->dtpr_aframes + 1;
+			struct dtrace_provider	*pv;
+			uint64_t		val;
+
+			pv = mstate->dtms_probe->dtpr_provider;
+			if (pv->dtpv_pops.dtps_getargval != NULL)
+				val = pv->dtpv_pops.dtps_getargval(
+					pv->dtpv_arg,
+					mstate->dtms_probe->dtpr_id,
+					mstate->dtms_probe->dtpr_arg,
+					ndx, aframes);
+			else
+				val = dtrace_getarg(ndx, aframes);
+
+			/*
+			 * This is regrettably required to keep the compiler
+			 * from tail-optimizing the call to dtrace_getarg().
+			 * The condition always evaluates to true, but the
+			 * compiler has no way of figuring that out a priori.
+			 * (None of this would be necessary if the compiler
+			 * could be relied upon to _always_ tail-optimize
+			 * the call to dtrace_getarg() -- but it can't.)
+			 */
+			if (mstate->dtms_probe != NULL)
+				return val;
+
+			ASSERT(0);
+		}
+
+		return mstate->dtms_arg[ndx];
+
+	case DIF_VAR_UREGS: {
+		if (!dtrace_priv_proc(state))
+			return 0;
+
+		return dtrace_getreg(current, ndx);
+	}
+
+	case DIF_VAR_CURTHREAD:
+		if (!dtrace_priv_kernel(state))
+			return 0;
+
+		return (uint64_t)(uintptr_t)current;
+
+	case DIF_VAR_TIMESTAMP:
+		if (!(mstate->dtms_present & DTRACE_MSTATE_TIMESTAMP)) {
+			mstate->dtms_timestamp = dtrace_gethrtime();
+			mstate->dtms_present |= DTRACE_MSTATE_TIMESTAMP;
+		}
+
+		return ktime_to_ns(mstate->dtms_timestamp);
+
+	case DIF_VAR_WALLTIMESTAMP:
+		return ktime_to_ns(dtrace_get_walltime());
+
+	case DIF_VAR_VTIMESTAMP:
+		ASSERT(dtrace_vtime_references != 0);
+
+		if (current->dt_task != NULL)
+			return ktime_to_ns(current->dt_task->dt_vtime);
+
+		/*
+		 * This is not ideal but without any data available
+		 * there is no reasonable default value for vtimestamp
+		 * variable.
+		 */
+		return ktime_to_ns(0);
+
+	case DIF_VAR_IPL:
+		if (!dtrace_priv_kernel(state))
+			return 0;
+
+		if (!(mstate->dtms_present & DTRACE_MSTATE_IPL)) {
+			mstate->dtms_ipl = dtrace_getipl();
+			mstate->dtms_present |= DTRACE_MSTATE_IPL;
+		}
+
+		return mstate->dtms_ipl;
+
+	case DIF_VAR_EPID:
+		ASSERT(mstate->dtms_present & DTRACE_MSTATE_EPID);
+		ASSERT(mstate->dtms_present & DTRACE_MSTATE_EPID);
+
+		return mstate->dtms_epid;
+
+	case DIF_VAR_ID:
+		ASSERT(mstate->dtms_present & DTRACE_MSTATE_PROBE);
+		return mstate->dtms_probe->dtpr_id;
+
+	case DIF_VAR_STACKDEPTH:
+		if (!dtrace_priv_kernel(state))
+			return 0;
+		if (!(mstate->dtms_present & DTRACE_MSTATE_STACKDEPTH)) {
+			int	aframes = mstate->dtms_probe->dtpr_aframes + 2;
+
+			mstate->dtms_stackdepth = dtrace_getstackdepth(
+							mstate, aframes);
+			mstate->dtms_present |= DTRACE_MSTATE_STACKDEPTH;
+		}
+
+		return mstate->dtms_stackdepth;
+
+	case DIF_VAR_USTACKDEPTH:
+		if (!dtrace_priv_proc(state))
+			return 0;
+
+		if (!(mstate->dtms_present & DTRACE_MSTATE_USTACKDEPTH)) {
+			/*
+			 * See comment in DIF_VAR_PID.
+			 */
+			if (DTRACE_ANCHORED(mstate->dtms_probe) &&
+			    in_interrupt())
+				mstate->dtms_ustackdepth = 0;
+			else
+				mstate->dtms_ustackdepth =
+					dtrace_getustackdepth();
+
+			mstate->dtms_present |= DTRACE_MSTATE_USTACKDEPTH;
+		}
+
+		return mstate->dtms_ustackdepth;
+
+	case DIF_VAR_CALLER:
+		if (!dtrace_priv_kernel(state))
+			return 0;
+
+		if (!(mstate->dtms_present & DTRACE_MSTATE_CALLER)) {
+			int	aframes = mstate->dtms_probe->dtpr_aframes + 1;
+
+			if (!DTRACE_ANCHORED(mstate->dtms_probe)) {
+				/*
+				 * If this is an unanchored probe, we are
+				 * required to go through the slow path:
+				 * dtrace_caller() only guarantees correct
+				 * results for anchored probes.
+				 */
+				uint64_t	caller[2];
+
+				dtrace_getpcstack(caller, 2, aframes,
+					(uint32_t *)(uintptr_t)
+							mstate->dtms_arg[0]);
+				mstate->dtms_caller = caller[1];
+			} else if ((mstate->dtms_caller =
+					dtrace_caller(aframes, 0)) == -1) {
+				/*
+				 * We have failed to do this the quick way;
+				 * we must resort to the slower approach of
+				 * calling dtrace_getpcstack().
+				 */
+				uint64_t	caller;
+
+				dtrace_getpcstack(&caller, 1, aframes, NULL);
+				mstate->dtms_caller = caller;
+			}
+
+			mstate->dtms_present |= DTRACE_MSTATE_CALLER;
+		}
+
+		return mstate->dtms_caller;
+
+	case DIF_VAR_UCALLER:
+		if (!dtrace_priv_proc(state))
+			return 0;
+
+		if (!(mstate->dtms_present & DTRACE_MSTATE_UCALLER)) {
+			uint64_t	ustack[4];
+
+			/*
+			 * dtrace_getupcstack() fills in the first uint64_t with
+			 * the current PID, and the second uint64_t with the
+			 * current TGID.  The third uint64_t will be the
+			 * program counter at user-level.  The fourth uint64_t
+			 * will contain the caller, which is what we're after.
+			 */
+			ustack[3] = 0;
+			dtrace_getupcstack(ustack, 4);
+
+			mstate->dtms_ucaller = ustack[3];
+			mstate->dtms_present |= DTRACE_MSTATE_UCALLER;
+		}
+
+		return mstate->dtms_ucaller;
+
+	case DIF_VAR_PROBEPROV:
+		ASSERT(mstate->dtms_present & DTRACE_MSTATE_PROBE);
+
+		return dtrace_dif_varstr(
+			(uintptr_t)mstate->dtms_probe->dtpr_provider->dtpv_name,
+			state, mstate);
+
+	case DIF_VAR_PROBEMOD:
+		ASSERT(mstate->dtms_present & DTRACE_MSTATE_PROBE);
+		return dtrace_dif_varstr(
+			(uintptr_t)mstate->dtms_probe->dtpr_mod, state,
+			mstate);
+
+	case DIF_VAR_PROBEFUNC:
+		ASSERT(mstate->dtms_present & DTRACE_MSTATE_PROBE);
+
+		return dtrace_dif_varstr(
+			(uintptr_t)mstate->dtms_probe->dtpr_func, state,
+			mstate);
+
+	case DIF_VAR_PROBENAME:
+		ASSERT(mstate->dtms_present & DTRACE_MSTATE_PROBE);
+
+		return dtrace_dif_varstr(
+			(uintptr_t)mstate->dtms_probe->dtpr_name, state,
+			mstate);
+
+	case DIF_VAR_PID:
+		if (!dtrace_priv_proc(state))
+			return 0;
+
+		/*
+		 * It is always safe to dereference current, it always points
+		 * to a valid task_struct.
+		 */
+		return (uint64_t)current->tgid;
+
+	case DIF_VAR_PPID:
+		if (!dtrace_priv_proc(state))
+			return 0;
+
+		/*
+		 * It is always safe to dereference current, it always points
+		 * to a valid task_struct.
+		 *
+		 * Additionally, it is safe to dereference one's parent, since
+		 * it is never NULL after process birth.
+		 */
+		return (uint64_t)current->real_parent->tgid;
+
+	case DIF_VAR_TID:
+		return (uint64_t)current->pid;
+
+	case DIF_VAR_EXECNAME:
+		if (!dtrace_priv_proc(state))
+			return 0;
+
+		/*
+		 * It is always safe to dereference current, it always points
+		 * to a valid task_struct.
+		 */
+		return dtrace_dif_varstr((uintptr_t)current->comm, state,
+					 mstate);
+
+	case DIF_VAR_ZONENAME:
+		return 0;
+
+	case DIF_VAR_UID:
+		if (!dtrace_priv_proc(state))
+			return 0;
+
+		/*
+		 * It is always safe to dereference current, it always points
+		 * to a valid task_struct.
+		 *
+		 * Additionally, it is safe to dereference one's own process
+		 * credential, since this is never NULL after process birth.
+		 */
+		return (uint64_t)from_kuid(current_user_ns(),
+					   current_real_cred()->uid);
+
+	case DIF_VAR_GID:
+		if (!dtrace_priv_proc(state))
+			return 0;
+
+		/*
+		 * It is always safe to dereference current, it always points
+		 * to a valid task_struct.
+		 *
+		 * Additionally, it is safe to dereference one's own process
+		 * credential, since this is never NULL after process birth.
+		 */
+		return (uint64_t)from_kgid(current_user_ns(),
+					   current_real_cred()->gid);
+
+	case DIF_VAR_ERRNO: {
+		int64_t	arg0;
+
+		ASSERT(mstate->dtms_present & DTRACE_MSTATE_PROBE);
+
+		if (!dtrace_priv_proc(state))
+			return 0;
+
+		/*
+		 * We need to do some magic here to get the correct semantics
+		 * for the 'errno' variable.  It can only have a non-zero value
+		 * when executing a system call, and for Linux, only after the
+		 * actual system call implementation has completed, indicating
+		 * in its return value either an error code (-2048 < errno < 0)
+		 * or a valid result.  So, the only time we can expect a valid
+		 * value in errno is during the processing of any return probe
+		 * in the syscall provider.  In all other cases, it should have
+		 * the value 0.
+		 *
+		 * So, we only look at probes that match: syscall:::return
+		 */
+		if (strncmp(mstate->dtms_probe->dtpr_provider->dtpv_name,
+			    "syscall", 7) != 0)
+			return 0;
+		if (strncmp(mstate->dtms_probe->dtpr_name, "return", 6) != 0)
+			return 0;
+
+		/*
+		 * Error number is present if arg0 lies between 0 and -2048,
+		 * exclusive.
+		 */
+		arg0 = (int64_t)mstate->dtms_arg[ndx];
+		if (arg0 < 0 && arg0 > -2048)
+			return (uint64_t)-arg0;
+
+		return 0;
+	}
+
+	case DIF_VAR_CURCPU:
+		return (uint64_t)(uintptr_t)this_cpu_info;
+
+	default:
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
+		return 0;
+	}
+}
+
+#define DTRACE_V4MAPPED_OFFSET	(sizeof(uint32_t) * 3)
+
+/*
+ * Emulate the execution of DTrace ID subroutines invoked by the call opcode.
+ * Notice that we don't bother validating the proper number of arguments or
+ * their types in the tuple stack.  This isn't needed because all argument
+ * interpretation is safe because of our load safety -- the worst that can
+ * happen is that a bogus program can obtain bogus results.
+ */
+static void dtrace_dif_subr(uint_t subr, uint_t rd, uint64_t *regs,
+			    struct dtrace_key *tupregs, int nargs,
+			    struct dtrace_mstate *mstate,
+			    struct dtrace_state *state)
+{
+	volatile uint16_t	*flags = &this_cpu_core->cpuc_dtrace_flags;
+	volatile uintptr_t	*illval = &this_cpu_core->cpuc_dtrace_illval;
+	struct dtrace_vstate	*vstate = &state->dts_vstate;
+	struct mutex		mtx;
+
+	union {
+		rwlock_t ri;
+		uintptr_t rw;
+	} r;
+
+	dt_dbg_dif("        Subroutine %d\n", subr);
+
+	switch (subr) {
+	case DIF_SUBR_RAND:
+		regs[rd] = ktime_to_ns(dtrace_gethrtime()) * 2416 + 374441;
+		regs[rd] = do_div(regs[rd], 1771875);
+		break;
+
+	case DIF_SUBR_MUTEX_OWNED:
+		if (!dtrace_canload(tupregs[0].dttk_value,
+				    sizeof(struct mutex), mstate, vstate))
+			break;
+
+		dtrace_bcopy((const void *)(uintptr_t)tupregs[0].dttk_value,
+			     &mtx, sizeof(struct mutex));
+		if (*flags & CPU_DTRACE_FAULT)
+			break;
+
+		regs[rd] = mutex_owned(&mtx);
+		break;
+
+	case DIF_SUBR_MUTEX_OWNER:
+		regs[rd] = 0;
+		if (!dtrace_canload(tupregs[0].dttk_value,
+				    sizeof(struct mutex), mstate, vstate))
+			break;
+
+		dtrace_bcopy((const void *)(uintptr_t)tupregs[0].dttk_value,
+			     &mtx, sizeof(struct mutex));
+		if (*flags & CPU_DTRACE_FAULT)
+			break;
+
+#ifdef CONFIG_SMP
+		regs[rd] = (uintptr_t)__mutex_owner(&mtx);
+#else
+		regs[rd] = 0;
+#endif
+		break;
+
+	case DIF_SUBR_MUTEX_TYPE_ADAPTIVE:
+		if (!dtrace_canload(tupregs[0].dttk_value,
+				    sizeof(struct mutex), mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		/*
+		 * On Linux, all mutexes are adaptive.
+		 */
+		regs[rd] = 1;
+		break;
+
+	case DIF_SUBR_MUTEX_TYPE_SPIN:
+		if (!dtrace_canload(tupregs[0].dttk_value,
+				    sizeof(struct mutex), mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		/*
+		 * On Linux, all mutexes are adaptive.
+		 */
+		regs[rd] = 0;
+		break;
+
+	case DIF_SUBR_RW_READ_HELD: {
+		if (!dtrace_canload(tupregs[0].dttk_value, sizeof(rwlock_t),
+		    mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		r.rw = dtrace_loadptr(tupregs[0].dttk_value);
+		regs[rd] = !peek_write_can_lock(&r.ri) &&
+			peek_read_can_lock(&r.ri);
+		break;
+	}
+
+	case DIF_SUBR_RW_WRITE_HELD:
+		if (!dtrace_canload(tupregs[0].dttk_value, sizeof(rwlock_t),
+		    mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		r.rw = dtrace_loadptr(tupregs[0].dttk_value);
+		regs[rd] = !peek_write_can_lock(&r.ri);
+		break;
+
+	case DIF_SUBR_RW_ISWRITER:
+		if (!dtrace_canload(tupregs[0].dttk_value, sizeof(rwlock_t),
+		    mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		r.rw = dtrace_loadptr(tupregs[0].dttk_value);
+		/*
+		 * On Linux there is no way to determine whether someone is
+		 * trying to acquire a write lock.
+		 */
+		regs[rd] = !peek_write_can_lock(&r.ri);
+		break;
+
+	case DIF_SUBR_BCOPY: {
+		/*
+		 * We need to be sure that the destination is in the scratch
+		 * region -- no other region is allowed.
+		 */
+		uintptr_t	src = tupregs[0].dttk_value;
+		uintptr_t	dest = tupregs[1].dttk_value;
+		size_t		size = tupregs[2].dttk_value;
+
+		if (!dtrace_inscratch(dest, size, mstate)) {
+			*flags |= CPU_DTRACE_BADADDR;
+			*illval = regs[rd];
+			break;
+		}
+
+		if (!dtrace_canload(src, size, mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		dtrace_bcopy((void *)src, (void *)dest, size);
+		break;
+	}
+
+	case DIF_SUBR_ALLOCA:
+	case DIF_SUBR_COPYIN: {
+		uintptr_t	dest = P2ROUNDUP(mstate->dtms_scratch_ptr, 8);
+		uint64_t	size;
+		size_t		scratch_size;
+
+		size = tupregs[subr == DIF_SUBR_ALLOCA ? 0 : 1].dttk_value;
+		scratch_size = (dest - mstate->dtms_scratch_ptr) + size;
+
+		/*
+		 * This action doesn't require any credential checks since
+		 * probes will not activate in user contexts to which the
+		 * enabling user does not have permissions.
+		 */
+
+		/*
+		 * Rounding up the user allocation size could have overflowed
+		 * a large, bogus allocation (like -1ULL) to 0.
+		 */
+		if (scratch_size < size ||
+		    !DTRACE_INSCRATCH(mstate, scratch_size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+
+		if (subr == DIF_SUBR_COPYIN) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+			dtrace_copyin(tupregs[0].dttk_value, dest, size, flags);
+			DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+		}
+
+		mstate->dtms_scratch_ptr += scratch_size;
+		regs[rd] = dest;
+		break;
+	}
+
+	case DIF_SUBR_COPYINTO: {
+		uint64_t	size = tupregs[1].dttk_value;
+		uintptr_t	dest = tupregs[2].dttk_value;
+
+		/*
+		 * This action doesn't require any credential checks since
+		 * probes will not activate in user contexts to which the
+		 * enabling user does not have permissions.
+		 */
+		if (!dtrace_inscratch(dest, size, mstate)) {
+			*flags |= CPU_DTRACE_BADADDR;
+			*illval = regs[rd];
+			break;
+		}
+
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+		dtrace_copyin(tupregs[0].dttk_value, dest, size, flags);
+		DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+		break;
+	}
+
+	case DIF_SUBR_COPYINSTR: {
+		uintptr_t	dest = mstate->dtms_scratch_ptr;
+		uint64_t	size = state->dts_options[DTRACEOPT_STRSIZE];
+
+		if (nargs > 1 && tupregs[1].dttk_value < size)
+			size = tupregs[1].dttk_value + 1;
+
+		/*
+		 * This action doesn't require any credential checks since
+		 * probes will not activate in user contexts to which the
+		 * enabling user does not have permissions.
+		 */
+		if (!DTRACE_INSCRATCH(mstate, size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+		dtrace_copyinstr(tupregs[0].dttk_value, dest, size, flags);
+		DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+
+		((char *)dest)[size - 1] = '\0';
+		mstate->dtms_scratch_ptr += size;
+		regs[rd] = dest;
+		break;
+	}
+
+#if 0 /* FIXME */
+	case DIF_SUBR_MSGSIZE:
+	case DIF_SUBR_MSGDSIZE: {
+		uintptr_t	baddr = tupregs[0].dttk_value, daddr;
+		uintptr_t	wptr, rptr;
+		size_t		count = 0;
+		int		cont = 0;
+
+		while (baddr != NULL && !(*flags & CPU_DTRACE_FAULT)) {
+
+			if (!dtrace_canload(baddr, sizeof(mblk_t), mstate,
+			    vstate)) {
+				regs[rd] = 0;
+				break;
+			}
+
+			wptr = dtrace_loadptr(baddr +
+			    offsetof(mblk_t, b_wptr));
+
+			rptr = dtrace_loadptr(baddr +
+			    offsetof(mblk_t, b_rptr));
+
+			if (wptr < rptr) {
+				*flags |= CPU_DTRACE_BADADDR;
+				*illval = tupregs[0].dttk_value;
+				break;
+			}
+
+			daddr = dtrace_loadptr(baddr +
+			    offsetof(mblk_t, b_datap));
+
+			baddr = dtrace_loadptr(baddr +
+			    offsetof(mblk_t, b_cont));
+
+			/*
+			 * We want to prevent against denial-of-service here,
+			 * so we're only going to search the list for
+			 * dtrace_msgdsize_max mblks.
+			 */
+			if (cont++ > dtrace_msgdsize_max) {
+				*flags |= CPU_DTRACE_ILLOP;
+				break;
+			}
+
+			if (subr == DIF_SUBR_MSGDSIZE) {
+				if (dtrace_load8(daddr +
+				    offsetof(dblk_t, db_type)) != M_DATA)
+					continue;
+			}
+
+			count += wptr - rptr;
+		}
+
+		if (!(*flags & CPU_DTRACE_FAULT))
+			regs[rd] = count;
+
+		break;
+	}
+#endif
+
+	case DIF_SUBR_PROGENYOF: {
+		pid_t			pid = tupregs[0].dttk_value;
+		struct task_struct	*p;
+		int			rval = 0;
+
+		for (p = current; p != NULL; p = p->real_parent) {
+			if (p->pid == pid) {
+				rval = 1;
+				break;
+			}
+
+			if (p == p->real_parent)
+				break;
+		}
+
+		regs[rd] = rval;
+		break;
+	}
+
+	case DIF_SUBR_SPECULATION:
+		regs[rd] = dtrace_speculation(state);
+		break;
+
+	case DIF_SUBR_COPYOUT: {
+		uintptr_t	kaddr = tupregs[0].dttk_value;
+		uintptr_t	uaddr = tupregs[1].dttk_value;
+		uint64_t	size = tupregs[2].dttk_value;
+
+		if (!dtrace_destructive_disallow &&
+		    dtrace_priv_proc_control(state) &&
+		    !dtrace_istoxic(kaddr, size) &&
+		    dtrace_canload(kaddr, size, mstate, vstate)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+			dtrace_copyout(kaddr, uaddr, size, flags);
+			DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+		}
+		break;
+	}
+
+	case DIF_SUBR_COPYOUTSTR: {
+		uintptr_t	kaddr = tupregs[0].dttk_value;
+		uintptr_t	uaddr = tupregs[1].dttk_value;
+		uint64_t	size = tupregs[2].dttk_value;
+
+		if (!dtrace_destructive_disallow &&
+		    dtrace_priv_proc_control(state) &&
+		    !dtrace_istoxic(kaddr, size) &&
+		    dtrace_strcanload(kaddr, size, mstate, vstate)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+			dtrace_copyoutstr(kaddr, uaddr, size, flags);
+			DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+		}
+		break;
+	}
+
+	case DIF_SUBR_STRLEN: {
+		size_t		sz;
+		uintptr_t	addr = (uintptr_t)tupregs[0].dttk_value;
+
+		sz = dtrace_strlen((char *)addr,
+				   state->dts_options[DTRACEOPT_STRSIZE]);
+
+		if (!dtrace_canload(addr, sz + 1, mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		regs[rd] = sz;
+
+		break;
+	}
+
+	case DIF_SUBR_STRCHR:
+	case DIF_SUBR_STRRCHR: {
+		/*
+		 * We're going to iterate over the string looking for the
+		 * specified character.  We will iterate until we have reached
+		 * the string length or we have found the character.  If this
+		 * is DIF_SUBR_STRRCHR, we will look for the last occurrence
+		 * of the specified character instead of the first.
+		 */
+		uintptr_t	saddr = tupregs[0].dttk_value;
+		uintptr_t	addr = tupregs[0].dttk_value;
+		uintptr_t	limit = addr +
+					state->dts_options[DTRACEOPT_STRSIZE];
+		char		c, target = (char)tupregs[1].dttk_value;
+
+		for (regs[rd] = 0; addr < limit; addr++) {
+			c = dtrace_load8(addr);
+			if (c == target) {
+				regs[rd] = addr;
+
+				if (subr == DIF_SUBR_STRCHR)
+					break;
+			}
+
+			if (c == '\0')
+				break;
+		}
+
+		if (!dtrace_canload(saddr, addr - saddr, mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		break;
+	}
+
+	case DIF_SUBR_STRSTR:
+	case DIF_SUBR_INDEX:
+	case DIF_SUBR_RINDEX: {
+		/*
+		 * We're going to iterate over the string looking for the
+		 * specified string.  We will iterate until we have reached
+		 * the string length or we have found the string.  (Yes, this
+		 * is done in the most naive way possible -- but considering
+		 * that the string we're searching for is likely to be
+		 * relatively short, the complexity of Rabin-Karp or similar
+		 * hardly seems merited.)
+		 */
+		char		*addr = (char *)(uintptr_t)
+							tupregs[0].dttk_value;
+		char		*substr = (char *)(uintptr_t)
+							tupregs[1].dttk_value;
+		uint64_t	size = state->dts_options[DTRACEOPT_STRSIZE];
+		size_t		len = dtrace_strlen(addr, size);
+		size_t		sublen = dtrace_strlen(substr, size);
+		char		*limit = addr + len, *orig = addr;
+		int		notfound = subr == DIF_SUBR_STRSTR ? 0 : -1;
+		int		inc = 1;
+
+		regs[rd] = notfound;
+
+		if (!dtrace_canload((uintptr_t)addr, len + 1, mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		if (!dtrace_canload((uintptr_t)substr, sublen + 1, mstate,
+				    vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		/*
+		 * strstr() and index()/rindex() have similar semantics if
+		 * both strings are the empty string: strstr() returns a
+		 * pointer to the (empty) string, and index() and rindex()
+		 * both return index 0 (regardless of any position argument).
+		 */
+		if (sublen == 0 && len == 0) {
+			if (subr == DIF_SUBR_STRSTR)
+				regs[rd] = (uintptr_t)addr;
+			else
+				regs[rd] = 0;
+			break;
+		}
+
+		if (subr != DIF_SUBR_STRSTR) {
+			if (subr == DIF_SUBR_RINDEX) {
+				limit = orig - 1;
+				addr += len;
+				inc = -1;
+			}
+
+			/*
+			 * Both index() and rindex() take an optional position
+			 * argument that denotes the starting position.
+			 */
+			if (nargs == 3) {
+				int64_t	pos = (int64_t)tupregs[2].dttk_value;
+
+				/*
+				 * If the position argument to index() is
+				 * negative, Perl implicitly clamps it at
+				 * zero.  This semantic is a little surprising
+				 * given the special meaning of negative
+				 * positions to similar Perl functions like
+				 * substr(), but it appears to reflect a
+				 * notion that index() can start from a
+				 * negative index and increment its way up to
+				 * the string.  Given this notion, Perl's
+				 * rindex() is at least self-consistent in
+				 * that it implicitly clamps positions greater
+				 * than the string length to be the string
+				 * length.  Where Perl completely loses
+				 * coherence, however, is when the specified
+				 * substring is the empty string ("").  In
+				 * this case, even if the position is
+				 * negative, rindex() returns 0 -- and even if
+				 * the position is greater than the length,
+				 * index() returns the string length.  These
+				 * semantics violate the notion that index()
+				 * should never return a value less than the
+				 * specified position and that rindex() should
+				 * never return a value greater than the
+				 * specified position.  (One assumes that
+				 * these semantics are artifacts of Perl's
+				 * implementation and not the results of
+				 * deliberate design -- it beggars belief that
+				 * even Larry Wall could desire such oddness.)
+				 * While in the abstract one would wish for
+				 * consistent position semantics across
+				 * substr(), index() and rindex() -- or at the
+				 * very least self-consistent position
+				 * semantics for index() and rindex() -- we
+				 * instead opt to keep with the extant Perl
+				 * semantics, in all their broken glory.  (Do
+				 * we have more desire to maintain Perl's
+				 * semantics than Perl does?  Probably.)
+				 */
+				if (subr == DIF_SUBR_RINDEX) {
+					if (pos < 0) {
+						if (sublen == 0)
+							regs[rd] = 0;
+						break;
+					}
+
+					if (pos > len)
+						pos = len;
+				} else {
+					if (pos < 0)
+						pos = 0;
+
+					if (pos >= len) {
+						if (sublen == 0)
+							regs[rd] = len;
+						break;
+					}
+				}
+
+				addr = orig + pos;
+			}
+		}
+
+		for (regs[rd] = notfound; addr != limit; addr += inc) {
+			if (dtrace_strncmp(addr, substr, sublen) == 0) {
+				if (subr != DIF_SUBR_STRSTR) {
+					/*
+					 * As D index() and rindex() are
+					 * modeled on Perl (and not on awk),
+					 * we return a zero-based (and not a
+					 * one-based) index.  (For you Perl
+					 * weenies: no, we're not going to add
+					 * $[ -- and shouldn't you be at a con
+					 * or something?)
+					 */
+					regs[rd] = (uintptr_t)(addr - orig);
+					break;
+				}
+
+				ASSERT(subr == DIF_SUBR_STRSTR);
+				regs[rd] = (uintptr_t)addr;
+				break;
+			}
+		}
+
+		break;
+	}
+
+	case DIF_SUBR_STRTOK: {
+		uintptr_t	addr = tupregs[0].dttk_value;
+		uintptr_t	tokaddr = tupregs[1].dttk_value;
+		uint64_t	size = state->dts_options[DTRACEOPT_STRSIZE];
+		uintptr_t	limit, toklimit = tokaddr + size;
+		uint8_t		c = 0, tokmap[32];	/* 256 / 8 */
+		char		*dest = (char *)mstate->dtms_scratch_ptr;
+		int		i;
+
+		/*
+		 * Check both the token buffer and (later) the input buffer,
+		 * since both could be non-scratch addresses.
+		 */
+		if (!dtrace_strcanload(tokaddr, size, mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		if (!DTRACE_INSCRATCH(mstate, size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+
+		if (addr == (uintptr_t)NULL) {
+			/*
+			 * If the address specified is NULL, we use our saved
+			 * strtok pointer from the mstate.  Note that this
+			 * means that the saved strtok pointer is _only_
+			 * valid within multiple enablings of the same probe --
+			 * it behaves like an implicit clause-local variable.
+			 */
+			addr = mstate->dtms_strtok;
+		} else {
+			/*
+			 * If the user-specified address is non-NULL we must
+			 * access check it.  This is the only time we have
+			 * a chance to do so, since this address may reside
+			 * in the string table of this clause-- future calls
+			 * (when we fetch addr from mstate->dtms_strtok)
+			 * would fail this access check.
+			 */
+			if (!dtrace_strcanload(addr, size, mstate, vstate)) {
+				regs[rd] = 0;
+				break;
+			}
+		}
+
+		/*
+		 * First, zero the token map, and then process the token
+		 * string -- setting a bit in the map for every character
+		 * found in the token string.
+		 */
+		for (i = 0; i < sizeof(tokmap); i++)
+			tokmap[i] = 0;
+
+		for (; tokaddr < toklimit; tokaddr++) {
+			c = dtrace_load8(tokaddr);
+			if (c == '\0')
+				break;
+
+			ASSERT((c >> 3) < sizeof(tokmap));
+			tokmap[c >> 3] |= (1 << (c & 0x7));
+		}
+
+		for (limit = addr + size; addr < limit; addr++) {
+			/*
+			 * We're looking for a character that is _not_ contained
+			 * in the token string.
+			 */
+			c = dtrace_load8(addr);
+			if (c == '\0')
+				break;
+
+			if (!(tokmap[c >> 3] & (1 << (c & 0x7))))
+				break;
+		}
+
+		if (c == '\0') {
+			/*
+			 * We reached the end of the string without finding
+			 * any character that was not in the token string.
+			 * We return NULL in this case, and we set the saved
+			 * address to NULL as well.
+			 */
+			regs[rd] = 0;
+			mstate->dtms_strtok = (uintptr_t)NULL;
+			break;
+		}
+
+		/*
+		 * From here on, we're copying into the destination string.
+		 */
+		for (i = 0; addr < limit && i < size - 1; addr++) {
+			c = dtrace_load8(addr);
+			if (c == '\0')
+				break;
+
+			if (tokmap[c >> 3] & (1 << (c & 0x7)))
+				break;
+
+			ASSERT(i < size);
+			dest[i++] = c;
+		}
+
+		ASSERT(i < size);
+		dest[i] = '\0';
+		regs[rd] = (uintptr_t)dest;
+		mstate->dtms_scratch_ptr += size;
+		mstate->dtms_strtok = addr;
+		break;
+	}
+
+	case DIF_SUBR_SUBSTR: {
+		uintptr_t	s = tupregs[0].dttk_value;
+		uint64_t	size = state->dts_options[DTRACEOPT_STRSIZE];
+		char		*d = (char *)mstate->dtms_scratch_ptr;
+		int64_t		index = (int64_t)tupregs[1].dttk_value;
+		int64_t		remaining = (int64_t)tupregs[2].dttk_value;
+		size_t		len = dtrace_strlen((char *)s, size);
+		int64_t		i = 0;
+
+		if (!dtrace_canload(s, len + 1, mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		if (!DTRACE_INSCRATCH(mstate, size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+
+		if (nargs <= 2)
+			remaining = (int64_t)size;
+
+		if (index < 0) {
+			index += len;
+
+			if (index < 0 && index + remaining > 0) {
+				remaining += index;
+				index = 0;
+			}
+		}
+
+		if (index >= len || index < 0)
+			remaining = 0;
+		else if (remaining < 0)
+			remaining += len - index;
+		else if (index + remaining > size)
+			remaining = size - index;
+
+		for (i = 0; i < remaining; i++) {
+			d[i] = dtrace_load8(s + index + i);
+			if (d[i] == '\0')
+				break;
+		}
+
+		d[i] = '\0';
+
+		mstate->dtms_scratch_ptr += size;
+		regs[rd] = (uintptr_t)d;
+		break;
+	}
+
+	case DIF_SUBR_GETMAJOR:
+		regs[rd] = MAJOR(tupregs[0].dttk_value);
+		break;
+
+	case DIF_SUBR_GETMINOR:
+		regs[rd] = MINOR(tupregs[0].dttk_value);
+		break;
+
+#if 0 /* FIXME */
+	case DIF_SUBR_DDI_PATHNAME: {
+		/*
+		 * This one is a galactic mess.  We are going to roughly
+		 * emulate ddi_pathname(), but it's made more complicated
+		 * by the fact that we (a) want to include the minor name and
+		 * (b) must proceed iteratively instead of recursively.
+		 */
+		uintptr_t dest = mstate->dtms_scratch_ptr;
+		uint64_t size = state->dts_options[DTRACEOPT_STRSIZE];
+		char *start = (char *)dest, *end = start + size - 1;
+		uintptr_t daddr = tupregs[0].dttk_value;
+		int64_t minor = (int64_t)tupregs[1].dttk_value;
+		char *s;
+		int i, len, depth = 0;
+
+		/*
+		 * Due to all the pointer jumping we do and context we must
+		 * rely upon, we just mandate that the user must have kernel
+		 * read privileges to use this routine.
+		 */
+		if ((mstate->dtms_access & DTRACE_ACCESS_KERNEL) == 0) {
+			*flags |= CPU_DTRACE_KPRIV;
+			*illval = daddr;
+			regs[rd] = 0;
+		}
+
+		if (!DTRACE_INSCRATCH(mstate, size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+
+		*end = '\0';
+
+		/*
+		 * We want to have a name for the minor.  In order to do this,
+		 * we need to walk the minor list from the devinfo.  We want
+		 * to be sure that we don't infinitely walk a circular list,
+		 * so we check for circularity by sending a scout pointer
+		 * ahead two elements for every element that we iterate over;
+		 * if the list is circular, these will ultimately point to the
+		 * same element.  You may recognize this little trick as the
+		 * answer to a stupid interview question -- one that always
+		 * seems to be asked by those who had to have it laboriously
+		 * explained to them, and who can't even concisely describe
+		 * the conditions under which one would be forced to resort to
+		 * this technique.  Needless to say, those conditions are
+		 * found here -- and probably only here.  Is this the only use
+		 * of this infamous trick in shipping, production code?  If it
+		 * isn't, it probably should be...
+		 */
+		if (minor != -1) {
+			uintptr_t maddr = dtrace_loadptr(daddr +
+			    offsetof(struct dev_info, devi_minor));
+
+			uintptr_t next = offsetof(struct ddi_minor_data, next);
+			uintptr_t name = offsetof(struct ddi_minor_data,
+			    d_minor) + offsetof(struct ddi_minor, name);
+			uintptr_t dev = offsetof(struct ddi_minor_data,
+			    d_minor) + offsetof(struct ddi_minor, dev);
+			uintptr_t scout;
+
+			if (maddr != NULL)
+				scout = dtrace_loadptr(maddr + next);
+
+			while (maddr != NULL && !(*flags & CPU_DTRACE_FAULT)) {
+				uint64_t m;
+#ifdef _LP64
+				m = dtrace_load64(maddr + dev) & MAXMIN64;
+#else
+				m = dtrace_load32(maddr + dev) & MAXMIN;
+#endif
+				if (m != minor) {
+					maddr = dtrace_loadptr(maddr + next);
+
+					if (scout == NULL)
+						continue;
+
+					scout = dtrace_loadptr(scout + next);
+
+					if (scout == NULL)
+						continue;
+
+					scout = dtrace_loadptr(scout + next);
+
+					if (scout == NULL)
+						continue;
+
+					if (scout == maddr) {
+						*flags |= CPU_DTRACE_ILLOP;
+						break;
+					}
+
+					continue;
+				}
+
+				/*
+				 * We have the minor data.  Now we need to
+				 * copy the minor's name into the end of the
+				 * pathname.
+				 */
+				s = (char *)dtrace_loadptr(maddr + name);
+				len = dtrace_strlen(s, size);
+
+				if (*flags & CPU_DTRACE_FAULT)
+					break;
+
+				if (len != 0) {
+					end -= len + 1;
+					if (end < start)
+						break;
+
+					*end = ':';
+				}
+
+				for (i = 1; i <= len; i++)
+					end[i] = dtrace_load8((uintptr_t)s++);
+				break;
+			}
+		}
+
+		while (daddr != NULL && !(*flags & CPU_DTRACE_FAULT)) {
+			ddi_node_state_t devi_state;
+
+			devi_state = dtrace_load32(daddr +
+			    offsetof(struct dev_info, devi_node_state));
+
+			if (*flags & CPU_DTRACE_FAULT)
+				break;
+
+			if (devi_state >= DS_INITIALIZED) {
+				s = (char *)dtrace_loadptr(daddr +
+				    offsetof(struct dev_info, devi_addr));
+				len = dtrace_strlen(s, size);
+
+				if (*flags & CPU_DTRACE_FAULT)
+					break;
+
+				if (len != 0) {
+					end -= len + 1;
+					if (end < start)
+						break;
+
+					*end = '@';
+				}
+
+				for (i = 1; i <= len; i++)
+					end[i] = dtrace_load8((uintptr_t)s++);
+			}
+
+			/*
+			 * Now for the node name...
+			 */
+			s = (char *)dtrace_loadptr(daddr +
+			    offsetof(struct dev_info, devi_node_name));
+
+			daddr = dtrace_loadptr(daddr +
+			    offsetof(struct dev_info, devi_parent));
+
+			/*
+			 * If our parent is NULL (that is, if we're the root
+			 * node), we're going to use the special path
+			 * "devices".
+			 */
+			if (daddr == NULL)
+				s = "devices";
+
+			len = dtrace_strlen(s, size);
+			if (*flags & CPU_DTRACE_FAULT)
+				break;
+
+			end -= len + 1;
+			if (end < start)
+				break;
+
+			for (i = 1; i <= len; i++)
+				end[i] = dtrace_load8((uintptr_t)s++);
+			*end = '/';
+
+			if (depth++ > dtrace_devdepth_max) {
+				*flags |= CPU_DTRACE_ILLOP;
+				break;
+			}
+		}
+
+		if (end < start)
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+
+		if (daddr == NULL) {
+			regs[rd] = (uintptr_t)end;
+			mstate->dtms_scratch_ptr += size;
+		}
+
+		break;
+	}
+#endif
+
+	case DIF_SUBR_STRJOIN: {
+		char		*d = (char *)mstate->dtms_scratch_ptr;
+		uint64_t	size = state->dts_options[DTRACEOPT_STRSIZE];
+		uintptr_t	s1 = tupregs[0].dttk_value;
+		uintptr_t	s2 = tupregs[1].dttk_value;
+		int		i = 0;
+
+		if (!dtrace_strcanload(s1, size, mstate, vstate) ||
+		    !dtrace_strcanload(s2, size, mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		if (!DTRACE_INSCRATCH(mstate, size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+
+		for (;;) {
+			if (i >= size) {
+				DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+				regs[rd] = 0;
+				break;
+			}
+
+			d[i] = dtrace_load8(s1++);
+			if ((d[i++]) == '\0') {
+				i--;
+				break;
+			}
+		}
+
+		for (;;) {
+			if (i >= size) {
+				DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+				regs[rd] = 0;
+				break;
+			}
+
+			d[i] = dtrace_load8(s2++);
+			if ((d[i++]) == '\0')
+				break;
+		}
+
+		if (i < size) {
+			mstate->dtms_scratch_ptr += i;
+			regs[rd] = (uintptr_t)d;
+		}
+
+		break;
+	}
+
+	case DIF_SUBR_LLTOSTR: {
+		int64_t		i = (int64_t)tupregs[0].dttk_value;
+		int64_t		val = i < 0 ? i * -1 : i;
+		uint64_t	size = 22;	/* room for 2^64 in dec */
+		char		*end = (char *)mstate->dtms_scratch_ptr + size
+									- 1;
+
+		if (!DTRACE_INSCRATCH(mstate, size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+
+		/*
+		 * GCC on Linux introduces calls to functions that are not
+		 * linked into the kernel image, so we need to use the do_div()
+		 * function instead.  It modifies the first argument in place
+		 * (replaces it with the quotient), and returns the remainder.
+		 *
+		 * Was:
+		 *	for (*end-- = '\0'; val; val /= 10)
+		 *		*end-- = '0' + (val % 10);
+		 */
+		for (*end-- = '\0'; val; )
+			*end-- = '0' + do_div(val, 10);
+
+		if (i == 0)
+			*end-- = '0';
+
+		if (i < 0)
+			*end-- = '-';
+
+		regs[rd] = (uintptr_t)end + 1;
+		mstate->dtms_scratch_ptr += size;
+		break;
+	}
+
+	case DIF_SUBR_HTONS:
+	case DIF_SUBR_NTOHS:
+#ifdef __BIG_ENDIAN
+		regs[rd] = (uint16_t)tupregs[0].dttk_value;
+#else
+		regs[rd] = DT_BSWAP_16((uint16_t)tupregs[0].dttk_value);
+#endif
+		break;
+
+
+	case DIF_SUBR_HTONL:
+	case DIF_SUBR_NTOHL:
+#ifdef __BIG_ENDIAN
+		regs[rd] = (uint32_t)tupregs[0].dttk_value;
+#else
+		regs[rd] = DT_BSWAP_32((uint32_t)tupregs[0].dttk_value);
+#endif
+		break;
+
+
+	case DIF_SUBR_HTONLL:
+	case DIF_SUBR_NTOHLL:
+#ifdef __BIG_ENDIAN
+		regs[rd] = (uint64_t)tupregs[0].dttk_value;
+#else
+		regs[rd] = DT_BSWAP_64((uint64_t)tupregs[0].dttk_value);
+#endif
+		break;
+
+
+	case DIF_SUBR_DIRNAME:
+	case DIF_SUBR_BASENAME: {
+		char		*dest = (char *)mstate->dtms_scratch_ptr;
+		uint64_t	size = state->dts_options[DTRACEOPT_STRSIZE];
+		uintptr_t	src = tupregs[0].dttk_value;
+		int		i, j, len = dtrace_strlen((char *)src, size);
+		int		lastbase = -1, firstbase = -1, lastdir = -1;
+		int		start, end;
+
+		if (!dtrace_canload(src, len + 1, mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		if (!DTRACE_INSCRATCH(mstate, size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+
+		/*
+		 * The basename and dirname for a zero-length string is
+		 * defined to be "."
+		 */
+		if (len == 0) {
+			len = 1;
+			src = (uintptr_t)".";
+		}
+
+		/*
+		 * Start from the back of the string, moving back toward the
+		 * front until we see a character that isn't a slash.  That
+		 * character is the last character in the basename.
+		 */
+		for (i = len - 1; i >= 0; i--) {
+			if (dtrace_load8(src + i) != '/')
+				break;
+		}
+
+		if (i >= 0)
+			lastbase = i;
+
+		/*
+		 * Starting from the last character in the basename, move
+		 * towards the front until we find a slash.  The character
+		 * that we processed immediately before that is the first
+		 * character in the basename.
+		 */
+		for (; i >= 0; i--) {
+			if (dtrace_load8(src + i) == '/')
+				break;
+		}
+
+		if (i >= 0)
+			firstbase = i + 1;
+
+		/*
+		 * Now keep going until we find a non-slash character.  That
+		 * character is the last character in the dirname.
+		 */
+		for (; i >= 0; i--) {
+			if (dtrace_load8(src + i) != '/')
+				break;
+		}
+
+		if (i >= 0)
+			lastdir = i;
+
+		ASSERT(!(lastbase == -1 && firstbase != -1));
+		ASSERT(!(firstbase == -1 && lastdir != -1));
+
+		if (lastbase == -1) {
+			/*
+			 * We didn't find a non-slash character.  We know that
+			 * the length is non-zero, so the whole string must be
+			 * slashes.  In either the dirname or the basename
+			 * case, we return '/'.
+			 */
+			ASSERT(firstbase == -1);
+			firstbase = lastbase = lastdir = 0;
+		}
+
+		if (firstbase == -1) {
+			/*
+			 * The entire string consists only of a basename
+			 * component.  If we're looking for dirname, we need
+			 * to change our string to be just "."; if we're
+			 * looking for a basename, we'll just set the first
+			 * character of the basename to be 0.
+			 */
+			if (subr == DIF_SUBR_DIRNAME) {
+				ASSERT(lastdir == -1);
+				src = (uintptr_t)".";
+				lastdir = 0;
+			} else {
+				firstbase = 0;
+			}
+		}
+
+		if (subr == DIF_SUBR_DIRNAME) {
+			if (lastdir == -1) {
+				/*
+				 * We know that we have a slash in the name --
+				 * or lastdir would be set to 0, above.  And
+				 * because lastdir is -1, we know that this
+				 * slash must be the first character.  (That
+				 * is, the full string must be of the form
+				 * "/basename".)  In this case, the last
+				 * character of the directory name is 0.
+				 */
+				lastdir = 0;
+			}
+
+			start = 0;
+			end = lastdir;
+		} else {
+			ASSERT(subr == DIF_SUBR_BASENAME);
+			ASSERT(firstbase != -1 && lastbase != -1);
+			start = firstbase;
+			end = lastbase;
+		}
+
+		for (i = start, j = 0; i <= end && j < size - 1; i++, j++)
+			dest[j] = dtrace_load8(src + i);
+
+		dest[j] = '\0';
+		regs[rd] = (uintptr_t)dest;
+		mstate->dtms_scratch_ptr += size;
+		break;
+	}
+
+	case DIF_SUBR_CLEANPATH: {
+		char		*dest = (char *)mstate->dtms_scratch_ptr, c;
+		uint64_t	size = state->dts_options[DTRACEOPT_STRSIZE];
+		uintptr_t	src = tupregs[0].dttk_value;
+		int		i = 0, j = 0;
+
+		if (!dtrace_strcanload(src, size, mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		if (!DTRACE_INSCRATCH(mstate, size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+
+		/*
+		 * Move forward, loading each character.
+		 */
+		do {
+			c = dtrace_load8(src + i++);
+next:
+			if (j + 5 >= size)	/* 5 = strlen("/..c\0") */
+				break;
+
+			if (c != '/') {
+				dest[j++] = c;
+				continue;
+			}
+
+			c = dtrace_load8(src + i++);
+
+			if (c == '/') {
+				/*
+				 * We have two slashes -- we can just advance
+				 * to the next character.
+				 */
+				goto next;
+			}
+
+			if (c != '.') {
+				/*
+				 * This is not "." and it's not ".." -- we can
+				 * just store the "/" and this character and
+				 * drive on.
+				 */
+				dest[j++] = '/';
+				dest[j++] = c;
+				continue;
+			}
+
+			c = dtrace_load8(src + i++);
+
+			if (c == '/') {
+				/*
+				 * This is a "/./" component.  We're not going
+				 * to store anything in the destination buffer;
+				 * we're just going to go to the next component.
+				 */
+				goto next;
+			}
+
+			if (c != '.') {
+				/*
+				 * This is not ".." -- we can just store the
+				 * "/." and this character and continue
+				 * processing.
+				 */
+				dest[j++] = '/';
+				dest[j++] = '.';
+				dest[j++] = c;
+				continue;
+			}
+
+			c = dtrace_load8(src + i++);
+
+			if (c != '/' && c != '\0') {
+				/*
+				 * This is not ".." -- it's "..[mumble]".
+				 * We'll store the "/.." and this character
+				 * and continue processing.
+				 */
+				dest[j++] = '/';
+				dest[j++] = '.';
+				dest[j++] = '.';
+				dest[j++] = c;
+				continue;
+			}
+
+			/*
+			 * This is "/../" or "/..\0".  We need to back up
+			 * our destination pointer until we find a "/".
+			 */
+			i--;
+			while (j != 0 && dest[--j] != '/')
+				continue;
+
+			if (c == '\0')
+				dest[++j] = '/';
+		} while (c != '\0');
+
+		dest[j] = '\0';
+		regs[rd] = (uintptr_t)dest;
+		mstate->dtms_scratch_ptr += size;
+		break;
+	}
+
+	case DIF_SUBR_LINK_NTOP: {
+		struct dtrace_hwtype_alen {
+			int dhwa_hwtype;
+			size_t dhwa_hwalen;
+		} hwinfo[] = {
+			{ ARPHRD_ETHER, ETH_ALEN },
+			{ ARPHRD_INFINIBAND, INFINIBAND_ALEN },
+			{ -1, 0 }
+		};
+/*
+ * Captures the maximum hardware address length among all the supported
+ * hardware types. Please update this macro when adding a new hardware type.
+ */
+#define DTRACE_MAX_HWTYPE_ALEN (ETH_ALEN > INFINIBAND_ALEN ? \
+				ETH_ALEN : INFINIBAND_ALEN)
+		uintptr_t src = tupregs[1].dttk_value;
+		int hwtype = tupregs[0].dttk_value;
+		uint8_t hwaddr[DTRACE_MAX_HWTYPE_ALEN];
+		char *base;
+		size_t size, len;
+		int i;
+
+		for (i = 0; hwinfo[i].dhwa_hwtype != -1; i++) {
+			if (hwtype == hwinfo[i].dhwa_hwtype)
+				break;
+		}
+		if (hwinfo[i].dhwa_hwtype == -1) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
+			regs[rd] = 0;
+			break;
+		}
+		len = hwinfo[i].dhwa_hwalen;
+
+		/*
+		 * Safely load the hardware address.
+		 */
+		if (!dtrace_canload(src, len, mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+		dtrace_bcopy((void *)src, hwaddr, len);
+
+		/*
+		 * Check if a hardware address string will fit in scratch.
+		 * For every byte we need 3 characters (including ':').
+		 */
+		size = len * 3;
+		if (!DTRACE_INSCRATCH(mstate, size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+		base = (char *)mstate->dtms_scratch_ptr;
+
+		/*
+		 * Build the Hardware address string by working through the
+		 * address from the beginning. Given a hardware address
+		 * {0xa0, 0xaa, 0xff, 0xc, 0, 1, 2} of length 6, it will build
+		 * a0:aa:ff:0c:00:01:02.
+		 */
+		for (i = 0; i < len; i++) {
+			if (hwaddr[i] < 16) {
+				*base++ = '0';
+				*base++ = hexdigits[hwaddr[i]];
+			} else {
+				*base++ = hexdigits[hwaddr[i] / 16];
+				*base++ = hexdigits[hwaddr[i] % 16];
+			}
+
+			if (i < len - 1)
+				*base++ = ':';
+		}
+		*base++ = '\0';
+		regs[rd] = mstate->dtms_scratch_ptr;
+		mstate->dtms_scratch_ptr += size;
+#undef DTRACE_MAX_HWTYPE_ALEN
+		break;
+	}
+
+	case DIF_SUBR_INET_NTOA:
+	case DIF_SUBR_INET_NTOA6:
+	case DIF_SUBR_INET_NTOP: {
+		uintptr_t src;
+		size_t	size;
+		int	af, argi, i;
+		char	*base, *end;
+
+		if (subr == DIF_SUBR_INET_NTOP) {
+			af = (int)tupregs[0].dttk_value;
+			argi = 1;
+		} else {
+			af = subr == DIF_SUBR_INET_NTOA ? AF_INET : AF_INET6;
+			argi = 0;
+		}
+
+		src = tupregs[argi].dttk_value;
+		if (af == AF_INET) {
+			ipaddr_t	ip4;
+			ipaddr_t_p	ptr4;
+			uint8_t		*ptr8, val;
+
+			/*
+			 * Safely load the IPv4 address.
+			 */
+			if (!dtrace_canload(src, 4, mstate, vstate)) {
+				regs[rd] = 0;
+				break;
+			}
+			ip4 = dtrace_load32(src);
+
+			/*
+			 * Check an IPv4 string will fit in scratch.
+			 */
+			size = INET_ADDRSTRLEN;
+			if (!DTRACE_INSCRATCH(mstate, size)) {
+				DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+				regs[rd] = 0;
+				break;
+			}
+			base = (char *)mstate->dtms_scratch_ptr;
+			end = (char *)mstate->dtms_scratch_ptr + size - 1;
+
+			/*
+			 * Stringify as a dotted decimal quad.
+			 */
+			*end-- = '\0';
+			ptr4 = &ip4;
+			ptr8 = (uint8_t *)ptr4;
+			for (i = 3; i >= 0; i--) {
+				val = ptr8[i];
+
+				if (val == 0) {
+					*end-- = '0';
+				} else {
+					for (; val; val /= 10)
+						*end-- = '0' + (val % 10);
+				}
+
+				if (i > 0)
+					*end-- = '.';
+			}
+			ASSERT(end + 1 >= base);
+#if IS_ENABLED(CONFIG_IPV6)
+		} else if (af == AF_INET6) {
+			in6_addr_t	ip6;
+			int		firstzero, tryzero, numzero, v6end;
+			uint16_t	val;
+
+			/*
+			 * Stringify using RFC 1884 convention 2 - 16 bit
+			 * hexadecimal values with a zero-run compression.
+			 * Lower case hexadecimal digits are used.
+			 *	eg, fe80::214:4fff:fe0b:76c8.
+			 * The IPv4 embedded form is returned for inet_ntop,
+			 * just the IPv4 string is returned for inet_ntoa6.
+			 */
+
+			/*
+			 * Safely load the IPv6 address.
+			 */
+			if (!dtrace_canload(src, sizeof(in6_addr_t), mstate,
+					    vstate)) {
+				regs[rd] = 0;
+				break;
+			}
+			dtrace_bcopy((void *)src, (void *)(uintptr_t)&ip6,
+				     sizeof(in6_addr_t));
+
+			/*
+			 * Check an IPv6 string will fit in scratch.
+			 */
+			size = INET6_ADDRSTRLEN;
+			if (!DTRACE_INSCRATCH(mstate, size)) {
+				DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+				regs[rd] = 0;
+				break;
+			}
+			base = (char *)mstate->dtms_scratch_ptr;
+			end = (char *)mstate->dtms_scratch_ptr + size - 1;
+			*end-- = '\0';
+
+			/*
+			 * Find the longest run of 16 bit zero values
+			 * for the single allowed zero compression - "::".
+			 */
+			firstzero = -1;
+			tryzero = -1;
+			numzero = 1;
+			for (i = 0; i < sizeof(in6_addr_t); i++) {
+				if (ip6.s6_addr[i] == 0 &&
+				    tryzero == -1 && i % 2 == 0) {
+					tryzero = i;
+					continue;
+				}
+
+				if (tryzero != -1 &&
+				    (ip6.s6_addr[i] != 0 ||
+				    i == sizeof(in6_addr_t) - 1)) {
+
+					if (i - tryzero <= numzero) {
+						tryzero = -1;
+						continue;
+					}
+
+					firstzero = tryzero;
+					numzero = i - i % 2 - tryzero;
+					tryzero = -1;
+
+					if (ip6.s6_addr[i] == 0 &&
+					    i == sizeof(in6_addr_t) - 1)
+						numzero += 2;
+				}
+			}
+			ASSERT(firstzero + numzero <= sizeof(in6_addr_t));
+
+			/*
+			 * Check for an IPv4 embedded address.
+			 */
+			v6end = sizeof(in6_addr_t) - 2;
+			if (ipv6_addr_type(&ip6) &
+			    (IPV6_ADDR_COMPATv4 | IPV6_ADDR_MAPPED)) {
+				for (i = sizeof(in6_addr_t) - 1;
+				    i >= DTRACE_V4MAPPED_OFFSET; i--) {
+					ASSERT(end >= base);
+
+					val = ip6.s6_addr[i];
+
+					if (val == 0) {
+						*end-- = '0';
+					} else {
+						for (; val; val /= 10)
+							*end-- = '0' + val % 10;
+					}
+
+					if (i > DTRACE_V4MAPPED_OFFSET)
+						*end-- = '.';
+				}
+
+				if (subr == DIF_SUBR_INET_NTOA6)
+					goto inetout;
+
+				/*
+				 * Set v6end to skip the IPv4 address that
+				 * we have already stringified.
+				 */
+				v6end = 10;
+			}
+
+			/*
+			 * Build the IPv6 string by working through the
+			 * address in reverse.
+			 */
+			for (i = v6end; i >= 0; i -= 2) {
+				ASSERT(end >= base);
+
+				if (i == firstzero + numzero - 2) {
+					*end-- = ':';
+					*end-- = ':';
+					i -= numzero - 2;
+					continue;
+				}
+
+				if (i < 14 && i != firstzero - 2)
+					*end-- = ':';
+
+				val = (ip6.s6_addr[i] << 8) +
+				    ip6.s6_addr[i + 1];
+
+				if (val == 0) {
+					*end-- = '0';
+				} else {
+					for (; val; val /= 16)
+						*end-- = hexdigits[val % 16];
+				}
+			}
+			ASSERT(end + 1 >= base);
+#endif
+		} else {
+			/*
+			 * The user didn't use AH_INET or AH_INET6.
+			 */
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
+			regs[rd] = 0;
+			break;
+		}
+
+#if IS_ENABLED(CONFIG_IPV6)
+inetout:
+#endif
+		regs[rd] = (uintptr_t)end + 1;
+		mstate->dtms_scratch_ptr += size;
+		break;
+	}
+
+	case DIF_SUBR_D_PATH: {
+		struct path	*path = (struct path *)tupregs[0].dttk_value;
+		char		*dest = (char *)mstate->dtms_scratch_ptr;
+		char		*ptr;
+		uint64_t	size = state->dts_options[DTRACEOPT_STRSIZE];
+		unsigned int	fd;
+		struct files_struct
+				*files = current->files;
+		struct fdtable	*fdt;
+
+		if (!dtrace_canload((uintptr_t)path, sizeof(struct path),
+				    mstate, vstate)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		if (!DTRACE_INSCRATCH(mstate, size)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+			regs[rd] = 0;
+			break;
+		}
+
+		if (spin_is_locked(&files->file_lock) ||
+		    !spin_trylock(&files->file_lock)) {
+			regs[rd] = 0;
+			break;
+		}
+
+		fdt = files->fdt;
+
+		/*
+		 * We (currently) limit the d_path() subroutine to paths that
+		 * relate to open files in the current task.
+		 */
+		for (fd = 0; fd < fdt->max_fds; fd++) {
+			if (fdt->fd[fd] && &fdt->fd[fd]->f_path == path)
+				break;
+		}
+
+		spin_unlock(&files->file_lock);
+
+		if (fd >= fdt->max_fds) {
+			*flags |= CPU_DTRACE_BADADDR;
+			*illval = (uintptr_t)path;
+			regs[rd] = 0;
+			break;
+		}
+
+		ptr = d_path(path, dest, size);
+		if (ptr < 0) {
+			regs[rd] = 0;
+			break;
+		}
+
+		regs[rd] = (uintptr_t)ptr;
+		mstate->dtms_scratch_ptr += size;
+		break;
+	}
+
+	}
+}
+
+/*
+ * Emulate the execution of DTrace IR instructions specified by the given DIF
+ * object.  This function is deliberately void fo assertions as all of the
+ * necessary checks are handled by a call to dtrace_difo_validate().
+ */
+uint64_t dtrace_dif_emulate(struct dtrace_difo *difo,
+			    struct dtrace_mstate *mstate,
+			    struct dtrace_vstate *vstate,
+			    struct dtrace_state *state)
+{
+	const dif_instr_t	*text = difo->dtdo_buf;
+	const uint_t		textlen = difo->dtdo_len;
+	const char		*strtab = difo->dtdo_strtab;
+	const uint64_t		*inttab = difo->dtdo_inttab;
+
+	uint64_t		rval = 0;
+	struct dtrace_statvar	*svar;
+	struct dtrace_dstate	*dstate = &vstate->dtvs_dynvars;
+	struct dtrace_difv	*v;
+	volatile uint16_t	*flags = &this_cpu_core->cpuc_dtrace_flags;
+	volatile uintptr_t	*illval = &this_cpu_core->cpuc_dtrace_illval;
+
+	struct dtrace_key	tupregs[DIF_DTR_NREGS + 2];
+						/* +2 for thread and id */
+	uint64_t		regs[DIF_DIR_NREGS];
+	uint64_t		*tmp;
+
+	uint8_t			cc_n = 0, cc_z = 0, cc_v = 0, cc_c = 0;
+	int64_t			cc_r;
+	uint_t			pc = 0, id, opc = 0;
+	uint8_t			ttop = 0;
+	dif_instr_t		instr;
+	uint_t			r1, r2, rd;
+
+	dt_dbg_dif("    DIF %p emulation (text %p, %d instructions)...\n",
+		   difo, text, textlen);
+
+	/*
+	 * We stash the current DIF object into the machine state: we need it
+	 * for subsequent access checking.
+	 */
+	mstate->dtms_difo = difo;
+
+	regs[DIF_REG_R0] = 0;			/* %r0 is fixed at zero */
+
+	while (pc < textlen && !(*flags & CPU_DTRACE_FAULT)) {
+		opc = pc;
+
+		instr = text[pc++];
+		r1 = DIF_INSTR_R1(instr);
+		r2 = DIF_INSTR_R2(instr);
+		rd = DIF_INSTR_RD(instr);
+
+		dt_dbg_dif("      Executing opcode %02x (%02x, %02x, %02x)\n",
+			   DIF_INSTR_OP(instr), r1, r2, rd);
+
+		switch (DIF_INSTR_OP(instr)) {
+		case DIF_OP_OR:
+			regs[rd] = regs[r1] | regs[r2];
+			break;
+		case DIF_OP_XOR:
+			regs[rd] = regs[r1] ^ regs[r2];
+			break;
+		case DIF_OP_AND:
+			regs[rd] = regs[r1] & regs[r2];
+			break;
+		case DIF_OP_SLL:
+			regs[rd] = regs[r1] << regs[r2];
+			break;
+		case DIF_OP_SRL:
+			regs[rd] = regs[r1] >> regs[r2];
+			break;
+		case DIF_OP_SUB:
+			regs[rd] = regs[r1] - regs[r2];
+			break;
+		case DIF_OP_ADD:
+			regs[rd] = regs[r1] + regs[r2];
+			break;
+		case DIF_OP_MUL:
+			regs[rd] = regs[r1] * regs[r2];
+			break;
+		case DIF_OP_SDIV:
+			if (regs[r2] == 0) {
+				regs[rd] = 0;
+				*flags |= CPU_DTRACE_DIVZERO;
+			} else {
+				int	neg = 0;
+
+				/*
+				 * We cannot simply do a 64-bit division, since
+				 * gcc translates it into a call to a function
+				 * that is not linked into the kernel.
+				 *
+				 * regs[rd] = (int64_t)regs[r1] /
+				 *	      (int64_t)regs[r2];
+				 */
+				if ((int64_t)regs[r1] < 0) {
+					neg = !neg;
+					regs[r1] = -(int64_t)regs[r1];
+				}
+				if ((int64_t)regs[r2] < 0) {
+					neg = !neg;
+					regs[r2] = -(int64_t)regs[r2];
+				}
+				regs[rd] = regs[r1];
+				do_div(regs[rd], regs[r2]);
+
+				if (neg)
+					regs[rd] = -(int64_t)regs[rd];
+			}
+			break;
+
+		case DIF_OP_UDIV:
+			if (regs[r2] == 0) {
+				regs[rd] = 0;
+				*flags |= CPU_DTRACE_DIVZERO;
+			} else {
+				/*
+				 * We cannot simply do a 64-bit division, since
+				 * gcc translates it into a call to a function
+				 * that is not linked into the kernel.
+				 *
+				 * regs[rd] = regs[r1] / regs[r2];
+				 */
+				regs[rd] = regs[r1];
+				do_div(regs[rd], regs[r2]);
+			}
+			break;
+
+		case DIF_OP_SREM:
+			if (regs[r2] == 0) {
+				regs[rd] = 0;
+				*flags |= CPU_DTRACE_DIVZERO;
+			} else {
+				int	neg = 0;
+
+				/*
+				 * We cannot simply do a 64-bit division, since
+				 * gcc translates it into a call to a function
+				 * that is not linked into the kernel.
+				 *
+				 * regs[rd] = (int64_t)regs[r1] %
+				 *	      (int64_t)regs[r2];
+				 */
+				if ((int64_t)regs[r1] < 0) {
+					neg = !neg;
+					regs[r1] = -(int64_t)regs[r1];
+				}
+				if ((int64_t)regs[r2] < 0) {
+					neg = !neg;
+					regs[r2] = -(int64_t)regs[r2];
+				}
+				regs[rd] = regs[r1];
+				regs[rd] = do_div(regs[rd], regs[r2]);
+
+				if (neg)
+					regs[rd] = -(int64_t)regs[rd];
+			}
+			break;
+
+		case DIF_OP_UREM:
+			if (regs[r2] == 0) {
+				regs[rd] = 0;
+				*flags |= CPU_DTRACE_DIVZERO;
+			} else {
+				/*
+				 * We cannot simply do a 64-bit division, since
+				 * gcc translates it into a call to a function
+				 * that is not linked into the kernel.
+				 *
+				 * regs[rd] = regs[r1] % regs[r2];
+				 */
+				regs[rd] = regs[r1];
+				regs[rd] = do_div(regs[rd], regs[r2]);
+			}
+			break;
+
+		case DIF_OP_NOT:
+			regs[rd] = ~regs[r1];
+			break;
+		case DIF_OP_MOV:
+			regs[rd] = regs[r1];
+			break;
+		case DIF_OP_CMP:
+			cc_r = regs[r1] - regs[r2];
+			cc_n = cc_r < 0;
+			cc_z = cc_r == 0;
+			cc_v = 0;
+			cc_c = regs[r1] < regs[r2];
+			break;
+		case DIF_OP_TST:
+			cc_n = cc_v = cc_c = 0;
+			cc_z = regs[r1] == 0;
+			break;
+		case DIF_OP_BA:
+			pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_BE:
+			if (cc_z)
+				pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_BNE:
+			if (cc_z == 0)
+				pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_BG:
+			if ((cc_z | (cc_n ^ cc_v)) == 0)
+				pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_BGU:
+			if ((cc_c | cc_z) == 0)
+				pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_BGE:
+			if ((cc_n ^ cc_v) == 0)
+				pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_BGEU:
+			if (cc_c == 0)
+				pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_BL:
+			if (cc_n ^ cc_v)
+				pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_BLU:
+			if (cc_c)
+				pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_BLE:
+			if (cc_z | (cc_n ^ cc_v))
+				pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_BLEU:
+			if (cc_c | cc_z)
+				pc = DIF_INSTR_LABEL(instr);
+			break;
+		case DIF_OP_RLDSB:
+#ifdef FIXME_OPENSOLARIS_BUG
+			if (!dtrace_canstore(regs[r1], 1, mstate, vstate)) {
+#else
+			if (!dtrace_canload(regs[r1], 1, mstate, vstate)) {
+#endif
+				*flags |= CPU_DTRACE_KPRIV;
+				*illval = regs[r1];
+				break;
+			}
+			/*FALLTHROUGH*/
+		case DIF_OP_LDSB:
+			regs[rd] = (int8_t)dtrace_load8(regs[r1]);
+			break;
+		case DIF_OP_RLDSH:
+			if (!dtrace_canstore(regs[r1], 2, mstate, vstate)) {
+				*flags |= CPU_DTRACE_KPRIV;
+				*illval = regs[r1];
+				break;
+			}
+			/*FALLTHROUGH*/
+		case DIF_OP_LDSH:
+			regs[rd] = (int16_t)dtrace_load16(regs[r1]);
+			break;
+		case DIF_OP_RLDSW:
+			if (!dtrace_canstore(regs[r1], 4, mstate, vstate)) {
+				*flags |= CPU_DTRACE_KPRIV;
+				*illval = regs[r1];
+				break;
+			}
+			/*FALLTHROUGH*/
+		case DIF_OP_LDSW:
+			regs[rd] = (int32_t)dtrace_load32(regs[r1]);
+			break;
+		case DIF_OP_RLDUB:
+			if (!dtrace_canstore(regs[r1], 1, mstate, vstate)) {
+				*flags |= CPU_DTRACE_KPRIV;
+				*illval = regs[r1];
+				break;
+			}
+			/*FALLTHROUGH*/
+		case DIF_OP_LDUB:
+			regs[rd] = dtrace_load8(regs[r1]);
+			break;
+		case DIF_OP_RLDUH:
+			if (!dtrace_canstore(regs[r1], 2, mstate, vstate)) {
+				*flags |= CPU_DTRACE_KPRIV;
+				*illval = regs[r1];
+				break;
+			}
+			/*FALLTHROUGH*/
+		case DIF_OP_LDUH:
+			regs[rd] = dtrace_load16(regs[r1]);
+			break;
+		case DIF_OP_RLDUW:
+			if (!dtrace_canstore(regs[r1], 4, mstate, vstate)) {
+				*flags |= CPU_DTRACE_KPRIV;
+				*illval = regs[r1];
+				break;
+			}
+			/*FALLTHROUGH*/
+		case DIF_OP_LDUW:
+			regs[rd] = dtrace_load32(regs[r1]);
+			break;
+		case DIF_OP_RLDX:
+			if (!dtrace_canstore(regs[r1], 8, mstate, vstate)) {
+				*flags |= CPU_DTRACE_KPRIV;
+				*illval = regs[r1];
+				break;
+			}
+			/*FALLTHROUGH*/
+		case DIF_OP_LDX:
+			regs[rd] = dtrace_load64(regs[r1]);
+			break;
+		case DIF_OP_ULDSB:
+			regs[rd] = (int8_t)dtrace_fuword8(
+						(void *)(uintptr_t)regs[r1]);
+			break;
+		case DIF_OP_ULDSH:
+			regs[rd] = (int16_t)dtrace_fuword16(
+						(void *)(uintptr_t)regs[r1]);
+			break;
+		case DIF_OP_ULDSW:
+			regs[rd] = (int32_t)dtrace_fuword32(
+						(void *)(uintptr_t)regs[r1]);
+			break;
+		case DIF_OP_ULDUB:
+			regs[rd] = dtrace_fuword8((void *)(uintptr_t)regs[r1]);
+			break;
+		case DIF_OP_ULDUH:
+			regs[rd] = dtrace_fuword16(
+						(void *)(uintptr_t)regs[r1]);
+			break;
+		case DIF_OP_ULDUW:
+			regs[rd] = dtrace_fuword32(
+						(void *)(uintptr_t)regs[r1]);
+			break;
+		case DIF_OP_ULDX:
+			regs[rd] = dtrace_fuword64(
+						(void *)(uintptr_t)regs[r1]);
+			break;
+		case DIF_OP_RET:
+			rval = regs[rd];
+			pc = textlen;
+			break;
+		case DIF_OP_NOP:
+			break;
+		case DIF_OP_SETX:
+			regs[rd] = inttab[DIF_INSTR_INTEGER(instr)];
+			break;
+		case DIF_OP_SETS:
+			regs[rd] = (uint64_t)(uintptr_t)
+					(strtab + DIF_INSTR_STRING(instr));
+			break;
+		case DIF_OP_SCMP: {
+			size_t		sz = state->dts_options[
+							DTRACEOPT_STRSIZE];
+			uintptr_t	s1 = regs[r1];
+			uintptr_t	s2 = regs[r2];
+
+			if (s1 != (uintptr_t)NULL &&
+			    !dtrace_strcanload(s1, sz, mstate, vstate))
+				break;
+			if (s2 != (uintptr_t)NULL &&
+			    !dtrace_strcanload(s2, sz, mstate, vstate))
+				break;
+
+			cc_r = dtrace_strncmp((char *)s1, (char *)s2, sz);
+
+			cc_n = cc_r < 0;
+			cc_z = cc_r == 0;
+			cc_v = cc_c = 0;
+			break;
+		}
+		case DIF_OP_LDGA:
+		    regs[rd] = dtrace_dif_variable(mstate, state, r1,
+						   regs[r2]);
+			break;
+		case DIF_OP_LDGS:
+			id = DIF_INSTR_VAR(instr);
+
+			if (id >= DIF_VAR_OTHER_UBASE) {
+				uintptr_t	a;
+
+				id -= DIF_VAR_OTHER_UBASE;
+				svar = vstate->dtvs_globals[id];
+				ASSERT(svar != NULL);
+				v = &svar->dtsv_var;
+
+				if (!(v->dtdv_type.dtdt_flags & DIF_TF_BYREF)) {
+					regs[rd] = svar->dtsv_data;
+					break;
+				}
+
+				a = (uintptr_t)svar->dtsv_data;
+
+				/*
+				 * If the 0th byte is set to UINT8_MAX then
+				 * this is to be treated as a reference to a
+				 * NULL variable.
+				 */
+				if (*(uint8_t *)a == UINT8_MAX)
+					regs[rd] = 0;
+				else
+					regs[rd] = a + sizeof(uint64_t);
+
+				break;
+			}
+
+			regs[rd] = dtrace_dif_variable(mstate, state, id, 0);
+			break;
+
+		case DIF_OP_STGS:
+			id = DIF_INSTR_VAR(instr);
+
+			ASSERT(id >= DIF_VAR_OTHER_UBASE);
+			id -= DIF_VAR_OTHER_UBASE;
+
+			svar = vstate->dtvs_globals[id];
+			ASSERT(svar != NULL);
+			v = &svar->dtsv_var;
+
+			if (v->dtdv_type.dtdt_flags & DIF_TF_BYREF) {
+				uintptr_t	a = (uintptr_t)svar->dtsv_data;
+
+				ASSERT(a != 0);
+				ASSERT(svar->dtsv_size != 0);
+
+				if (regs[rd] == 0) {
+					*(uint8_t *)a = UINT8_MAX;
+					break;
+				} else {
+					*(uint8_t *)a = 0;
+					a += sizeof(uint64_t);
+				}
+
+				if (!dtrace_vcanload(
+					(void *)(uintptr_t)regs[rd],
+					&v->dtdv_type, mstate, vstate))
+					break;
+
+				dtrace_vcopy((void *)(uintptr_t)regs[rd],
+					     (void *)a, &v->dtdv_type);
+				break;
+			}
+
+			svar->dtsv_data = regs[rd];
+			break;
+
+		case DIF_OP_LDTA:
+			/*
+			 * There are no DTrace built-in thread-local arrays at
+			 * present.  This opcode is saved for future work.
+			 */
+			*flags |= CPU_DTRACE_ILLOP;
+			regs[rd] = 0;
+			break;
+
+		case DIF_OP_LDLS:
+			id = DIF_INSTR_VAR(instr);
+
+			if (id < DIF_VAR_OTHER_UBASE) {
+				/*
+				 * For now, this has no meaning.
+				 */
+				regs[rd] = 0;
+				break;
+			}
+
+			id -= DIF_VAR_OTHER_UBASE;
+
+			ASSERT(id < vstate->dtvs_nlocals);
+			ASSERT(vstate->dtvs_locals != NULL);
+
+			svar = vstate->dtvs_locals[id];
+			ASSERT(svar != NULL);
+			v = &svar->dtsv_var;
+
+			if (v->dtdv_type.dtdt_flags & DIF_TF_BYREF) {
+				uintptr_t	a = (uintptr_t)svar->dtsv_data;
+				size_t		sz = v->dtdv_type.dtdt_size;
+
+				sz += sizeof(uint64_t);
+				ASSERT(svar->dtsv_size == NR_CPUS * sz);
+				a += smp_processor_id() * sz;
+
+				if (*(uint8_t *)a == UINT8_MAX) {
+					/*
+					 * If the 0th byte is set to UINT8_MAX
+					 * then this is to be treated as a
+					 * reference to a NULL variable.
+					 */
+					regs[rd] = 0;
+				} else
+					regs[rd] = a + sizeof(uint64_t);
+
+				break;
+			}
+
+			ASSERT(svar->dtsv_size == NR_CPUS * sizeof(uint64_t));
+			tmp = (uint64_t *)(uintptr_t)svar->dtsv_data;
+			regs[rd] = tmp[smp_processor_id()];
+			break;
+
+		case DIF_OP_STLS:
+			id = DIF_INSTR_VAR(instr);
+
+			ASSERT(id >= DIF_VAR_OTHER_UBASE);
+			id -= DIF_VAR_OTHER_UBASE;
+			ASSERT(id < vstate->dtvs_nlocals);
+
+			ASSERT(vstate->dtvs_locals != NULL);
+			svar = vstate->dtvs_locals[id];
+			ASSERT(svar != NULL);
+			v = &svar->dtsv_var;
+
+			if (v->dtdv_type.dtdt_flags & DIF_TF_BYREF) {
+				uintptr_t	a = (uintptr_t)svar->dtsv_data;
+				size_t		sz = v->dtdv_type.dtdt_size;
+
+				sz += sizeof(uint64_t);
+				ASSERT(svar->dtsv_size == NR_CPUS * sz);
+				a += smp_processor_id() * sz;
+
+				if (regs[rd] == 0) {
+					*(uint8_t *)a = UINT8_MAX;
+					break;
+				} else {
+					*(uint8_t *)a = 0;
+					a += sizeof(uint64_t);
+				}
+
+				if (!dtrace_vcanload(
+						(void *)(uintptr_t)regs[rd],
+						&v->dtdv_type, mstate, vstate))
+					break;
+
+				dtrace_vcopy((void *)(uintptr_t)regs[rd],
+					     (void *)a, &v->dtdv_type);
+				break;
+			}
+
+			ASSERT(svar->dtsv_size == NR_CPUS * sizeof(uint64_t));
+			tmp = (uint64_t *)(uintptr_t)svar->dtsv_data;
+			tmp[smp_processor_id()] = regs[rd];
+			break;
+
+		case DIF_OP_LDTS: {
+			struct dtrace_dynvar	*dvar;
+			struct dtrace_key	*key;
+
+			id = DIF_INSTR_VAR(instr);
+			ASSERT(id >= DIF_VAR_OTHER_UBASE);
+			id -= DIF_VAR_OTHER_UBASE;
+			v = &vstate->dtvs_tlocals[id];
+
+			key = &tupregs[DIF_DTR_NREGS];
+			key[0].dttk_value = (uint64_t)id;
+			key[0].dttk_size = 0;
+			DTRACE_TLS_THRKEY(key[1].dttk_value);
+			key[1].dttk_size = 0;
+
+			dvar = dtrace_dynvar(dstate, 2, key, sizeof(uint64_t),
+					     DTRACE_DYNVAR_NOALLOC, mstate,
+					     vstate);
+
+			if (dvar == NULL) {
+				regs[rd] = 0;
+				break;
+			}
+
+			if (v->dtdv_type.dtdt_flags & DIF_TF_BYREF)
+				regs[rd] = (uint64_t)(uintptr_t)dvar->dtdv_data;
+			else
+				regs[rd] = *((uint64_t *)dvar->dtdv_data);
+
+			break;
+		}
+
+		case DIF_OP_STTS: {
+			struct dtrace_dynvar	*dvar;
+			struct dtrace_key	*key;
+
+			id = DIF_INSTR_VAR(instr);
+			ASSERT(id >= DIF_VAR_OTHER_UBASE);
+			id -= DIF_VAR_OTHER_UBASE;
+
+			key = &tupregs[DIF_DTR_NREGS];
+			key[0].dttk_value = (uint64_t)id;
+			key[0].dttk_size = 0;
+			DTRACE_TLS_THRKEY(key[1].dttk_value);
+			key[1].dttk_size = 0;
+			v = &vstate->dtvs_tlocals[id];
+
+			dvar = dtrace_dynvar(dstate, 2, key,
+				v->dtdv_type.dtdt_size > sizeof(uint64_t)
+					?  v->dtdv_type.dtdt_size
+					: sizeof(uint64_t),
+				regs[rd]
+					? DTRACE_DYNVAR_ALLOC
+					: DTRACE_DYNVAR_DEALLOC,
+				mstate, vstate);
+
+			/*
+			 * Given that we're storing to thread-local data,
+			 * we need to flush our predicate cache.
+			 */
+			if (current->dt_task != NULL)
+				current->dt_task->dt_predcache = 0;
+
+			if (dvar == NULL)
+				break;
+
+			if (v->dtdv_type.dtdt_flags & DIF_TF_BYREF) {
+				if (!dtrace_vcanload(
+						(void *)(uintptr_t)regs[rd],
+						&v->dtdv_type, mstate, vstate))
+					break;
+
+				dtrace_vcopy((void *)(uintptr_t)regs[rd],
+					     dvar->dtdv_data, &v->dtdv_type);
+			} else
+				*((uint64_t *)dvar->dtdv_data) = regs[rd];
+
+			break;
+		}
+
+		case DIF_OP_SRA:
+			regs[rd] = (int64_t)regs[r1] >> regs[r2];
+			break;
+
+		case DIF_OP_CALL:
+			dtrace_dif_subr(DIF_INSTR_SUBR(instr), rd, regs,
+					tupregs, ttop, mstate, state);
+			break;
+
+		case DIF_OP_PUSHTR:
+			if (ttop == DIF_DTR_NREGS) {
+				*flags |= CPU_DTRACE_TUPOFLOW;
+				break;
+			}
+
+			if (r1 == DIF_TYPE_STRING)
+				/*
+				 * If this is a string type and the size is 0,
+				 * we'll use the system-wide default string
+				 * size.  Note that we are _not_ looking at
+				 * the value of the DTRACEOPT_STRSIZE option;
+				 * had this been set, we would expect to have
+				 * a non-zero size value in the "pushtr".
+				 */
+				tupregs[ttop].dttk_size =
+					dtrace_strlen(
+						(char *)(uintptr_t)regs[rd],
+						regs[r2]
+						    ? regs[r2]
+						    : dtrace_strsize_default
+					) + 1;
+			else
+				tupregs[ttop].dttk_size = regs[r2];
+
+			tupregs[ttop++].dttk_value = regs[rd];
+			break;
+
+		case DIF_OP_PUSHTV:
+			if (ttop == DIF_DTR_NREGS) {
+				*flags |= CPU_DTRACE_TUPOFLOW;
+				break;
+			}
+
+			tupregs[ttop].dttk_value = regs[rd];
+			tupregs[ttop++].dttk_size = 0;
+			break;
+
+		case DIF_OP_POPTS:
+			if (ttop != 0)
+				ttop--;
+			break;
+
+		case DIF_OP_FLUSHTS:
+			ttop = 0;
+			break;
+
+		case DIF_OP_LDGAA:
+		case DIF_OP_LDTAA: {
+			struct dtrace_dynvar	*dvar;
+			struct dtrace_key	*key = tupregs;
+			uint_t			nkeys = ttop;
+
+			id = DIF_INSTR_VAR(instr);
+			ASSERT(id >= DIF_VAR_OTHER_UBASE);
+			id -= DIF_VAR_OTHER_UBASE;
+
+			key[nkeys].dttk_value = (uint64_t)id;
+			key[nkeys++].dttk_size = 0;
+
+			if (DIF_INSTR_OP(instr) == DIF_OP_LDTAA) {
+				DTRACE_TLS_THRKEY(key[nkeys].dttk_value);
+				key[nkeys++].dttk_size = 0;
+				v = &vstate->dtvs_tlocals[id];
+			} else
+				v = &vstate->dtvs_globals[id]->dtsv_var;
+
+			dvar = dtrace_dynvar(dstate, nkeys, key,
+			v->dtdv_type.dtdt_size > sizeof(uint64_t) ?
+			v->dtdv_type.dtdt_size : sizeof(uint64_t),
+			DTRACE_DYNVAR_NOALLOC, mstate, vstate);
+
+			if (dvar == NULL) {
+				regs[rd] = 0;
+				break;
+			}
+
+			if (v->dtdv_type.dtdt_flags & DIF_TF_BYREF)
+				regs[rd] = (uint64_t)(uintptr_t)dvar->dtdv_data;
+			else
+				regs[rd] = *((uint64_t *)dvar->dtdv_data);
+
+			break;
+		}
+
+		case DIF_OP_STGAA:
+		case DIF_OP_STTAA: {
+			struct dtrace_dynvar	*dvar;
+			struct dtrace_key	*key = tupregs;
+			uint_t			nkeys = ttop;
+
+			id = DIF_INSTR_VAR(instr);
+			ASSERT(id >= DIF_VAR_OTHER_UBASE);
+			id -= DIF_VAR_OTHER_UBASE;
+
+			key[nkeys].dttk_value = (uint64_t)id;
+			key[nkeys++].dttk_size = 0;
+
+			if (DIF_INSTR_OP(instr) == DIF_OP_STTAA) {
+				DTRACE_TLS_THRKEY(key[nkeys].dttk_value);
+				key[nkeys++].dttk_size = 0;
+				v = &vstate->dtvs_tlocals[id];
+			} else
+				v = &vstate->dtvs_globals[id]->dtsv_var;
+
+			dvar = dtrace_dynvar(dstate, nkeys, key,
+				v->dtdv_type.dtdt_size > sizeof(uint64_t)
+					?  v->dtdv_type.dtdt_size
+					: sizeof(uint64_t),
+				regs[rd] ? DTRACE_DYNVAR_ALLOC
+					 : DTRACE_DYNVAR_DEALLOC,
+				mstate, vstate);
+
+			if (dvar == NULL)
+				break;
+
+			if (v->dtdv_type.dtdt_flags & DIF_TF_BYREF) {
+				if (!dtrace_vcanload(
+						(void *)(uintptr_t)regs[rd],
+						&v->dtdv_type, mstate, vstate))
+					break;
+
+				dtrace_vcopy((void *)(uintptr_t)regs[rd],
+					     dvar->dtdv_data, &v->dtdv_type);
+			} else
+				*((uint64_t *)dvar->dtdv_data) = regs[rd];
+
+			break;
+		}
+
+		case DIF_OP_ALLOCS: {
+			uintptr_t	ptr =
+					P2ROUNDUP(mstate->dtms_scratch_ptr, 8);
+			size_t		size = ptr - mstate->dtms_scratch_ptr +
+					       regs[r1];
+
+			/*
+			 * Rounding up the user allocation size could have
+			 * overflowed large, bogus allocations (like -1ULL) to
+			 * 0.
+			 */
+			if (size < regs[r1] ||
+			    !DTRACE_INSCRATCH(mstate, size)) {
+				DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+				regs[rd] = 0;
+				break;
+			}
+
+			dtrace_bzero((void *) mstate->dtms_scratch_ptr, size);
+			mstate->dtms_scratch_ptr += size;
+			regs[rd] = ptr;
+			break;
+		}
+
+		case DIF_OP_COPYS:
+			if (!dtrace_canstore(regs[rd], regs[r2], mstate,
+					     vstate)) {
+				*flags |= CPU_DTRACE_BADADDR;
+				*illval = regs[rd];
+				break;
+			}
+
+			if (!dtrace_canload(regs[r1], regs[r2], mstate, vstate))
+				break;
+
+			dtrace_bcopy((void *)(uintptr_t)regs[r1],
+				     (void *)(uintptr_t)regs[rd],
+				     (size_t)regs[r2]);
+			break;
+
+		case DIF_OP_STB:
+			if (!dtrace_canstore(regs[rd], 1, mstate, vstate)) {
+				*flags |= CPU_DTRACE_BADADDR;
+				*illval = regs[rd];
+				break;
+			}
+
+			*((uint8_t *)(uintptr_t)regs[rd]) = (uint8_t)regs[r1];
+			break;
+
+		case DIF_OP_STH:
+			if (!dtrace_canstore(regs[rd], 2, mstate, vstate)) {
+				*flags |= CPU_DTRACE_BADADDR;
+				*illval = regs[rd];
+				break;
+			}
+
+			if (regs[rd] & 1) {
+				*flags |= CPU_DTRACE_BADALIGN;
+				*illval = regs[rd];
+				break;
+			}
+
+			*((uint16_t *)(uintptr_t)regs[rd]) = (uint16_t)regs[r1];
+			break;
+
+		case DIF_OP_STW:
+			if (!dtrace_canstore(regs[rd], 4, mstate, vstate)) {
+				*flags |= CPU_DTRACE_BADADDR;
+				*illval = regs[rd];
+				break;
+			}
+
+			if (regs[rd] & 3) {
+				*flags |= CPU_DTRACE_BADALIGN;
+				*illval = regs[rd];
+				break;
+			}
+
+			*((uint32_t *)(uintptr_t)regs[rd]) = (uint32_t)regs[r1];
+			break;
+
+		case DIF_OP_STX:
+			if (!dtrace_canstore(regs[rd], 8, mstate, vstate)) {
+				*flags |= CPU_DTRACE_BADADDR;
+				*illval = regs[rd];
+				break;
+			}
+
+			if (regs[rd] & 7) {
+				*flags |= CPU_DTRACE_BADALIGN;
+				*illval = regs[rd];
+				break;
+			}
+
+			*((uint64_t *)(uintptr_t)regs[rd]) = regs[r1];
+			break;
+		}
+	}
+
+
+	if (!(*flags & CPU_DTRACE_FAULT)) {
+		dt_dbg_dif("    DIF %p completed, rval = %llx (flags %x)\n",
+			   difo, rval, *flags);
+		return rval;
+	}
+
+	dt_dbg_dif("    DIF %p emulation failed (flags %x)\n",  difo, *flags);
+
+	mstate->dtms_fltoffs = opc * sizeof(dif_instr_t);
+	mstate->dtms_present |= DTRACE_MSTATE_FLTOFFS;
+
+	return 0;
+}
diff --git a/dtrace/dtrace_dof.c b/dtrace/dtrace_dof.c
new file mode 100644
index 000000000000..85ff9b21a205
--- /dev/null
+++ b/dtrace/dtrace_dof.c
@@ -0,0 +1,2504 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_dof.c
+ * DESCRIPTION:	DTrace - DOF implementation
+ *
+ * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dtrace_task_impl.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/vmalloc.h>
+#include <linux/uaccess.h>
+
+#include "dtrace.h"
+
+size_t			dtrace_difo_maxsize = 256 * 1024;
+dtrace_optval_t		dtrace_dof_maxsize = 256 * 1024;
+size_t			dtrace_actions_max = 16 * 1024;
+dtrace_optval_t		dtrace_helper_actions_max = 32;
+dtrace_optval_t		dtrace_helper_providers_max = 32;
+
+static int		dtrace_helpers;
+
+static uint32_t		dtrace_helptrace_next;
+static uint32_t		dtrace_helptrace_nlocals;
+
+#ifdef CONFIG_DT_DEBUG
+int			dtrace_helptrace_enabled = 1;
+#else
+int			dtrace_helptrace_enabled = 0;
+#endif
+int			dtrace_helptrace_bufsize = 512 * 1024;
+char			*dtrace_helptrace_buffer;
+
+void dtrace_dof_error(struct dof_hdr *dof, const char *str)
+{
+	if (dtrace_err_verbose)
+		pr_warn("failed to process DOF: %s", str);
+	else
+		dt_dbg_dof("Failed to process DOF: %s\n", str);
+
+#ifdef DTRACE_ERRDEBUG
+	dtrace_errdebug(str);
+#endif
+}
+
+/*
+ * Create DOF out of a currently enabled state.  Right now, we only create
+ * DOF containing the run-time options -- but this could be expanded to create
+ * complete DOF representing the enabled state.
+ */
+struct dof_hdr *dtrace_dof_create(struct dtrace_state *state)
+{
+	struct dof_hdr		*dof;
+	struct dof_sec		*sec;
+	struct dof_optdesc	*opt;
+
+	int i, len = sizeof(struct dof_hdr) +
+		roundup(sizeof(struct dof_sec),
+			sizeof(uint64_t)) +
+		sizeof(struct dof_optdesc) * DTRACEOPT_MAX;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	dof = vmalloc(len);
+	if (dof == NULL)
+		return NULL;
+
+	dof->dofh_ident[DOF_ID_MAG0] = DOF_MAG_MAG0;
+	dof->dofh_ident[DOF_ID_MAG1] = DOF_MAG_MAG1;
+	dof->dofh_ident[DOF_ID_MAG2] = DOF_MAG_MAG2;
+	dof->dofh_ident[DOF_ID_MAG3] = DOF_MAG_MAG3;
+
+	dof->dofh_ident[DOF_ID_MODEL] = DOF_MODEL_NATIVE;
+	dof->dofh_ident[DOF_ID_ENCODING] = DOF_ENCODE_NATIVE;
+	dof->dofh_ident[DOF_ID_VERSION] = DOF_VERSION;
+	dof->dofh_ident[DOF_ID_DIFVERS] = DIF_VERSION;
+	dof->dofh_ident[DOF_ID_DIFIREG] = DIF_DIR_NREGS;
+	dof->dofh_ident[DOF_ID_DIFTREG] = DIF_DTR_NREGS;
+
+	dof->dofh_flags = 0;
+	dof->dofh_hdrsize = sizeof(struct dof_hdr);
+	dof->dofh_secsize = sizeof(struct dof_sec);
+	dof->dofh_secnum = 1;   /* only DOF_SECT_OPTDESC */
+	dof->dofh_secoff = sizeof(struct dof_hdr);
+	dof->dofh_loadsz = len;
+	dof->dofh_filesz = len;
+	dof->dofh_pad = 0;
+
+	/*
+	 * Fill in the option section header...
+	 */
+	sec = (struct dof_sec *)((uintptr_t)dof + sizeof(struct dof_hdr));
+	sec->dofs_type = DOF_SECT_OPTDESC;
+	sec->dofs_align = sizeof(uint64_t);
+	sec->dofs_flags = DOF_SECF_LOAD;
+	sec->dofs_entsize = sizeof(struct dof_optdesc);
+
+	opt = (struct dof_optdesc *)((uintptr_t)sec +
+				     roundup(sizeof(struct dof_sec),
+					     sizeof(uint64_t)));
+
+	sec->dofs_offset = (uintptr_t)opt - (uintptr_t)dof;
+	sec->dofs_size = sizeof(struct dof_optdesc) * DTRACEOPT_MAX;
+
+	for (i = 0; i < DTRACEOPT_MAX; i++) {
+		opt[i].dofo_option = i;
+		opt[i].dofo_strtab = DOF_SECIDX_NONE;
+		opt[i].dofo_value = state->dts_options[i];
+	}
+
+	return dof;
+}
+
+struct dof_hdr *dtrace_dof_copyin(void __user *argp, int *errp)
+{
+	struct dof_hdr	hdr, *dof;
+
+	ASSERT(!MUTEX_HELD(&dtrace_lock));
+
+	/*
+	 * First, we're going to copyin() the sizeof(dof_hdr_t).
+	 */
+	if (copy_from_user(&hdr, argp, sizeof(hdr)) != 0) {
+		dtrace_dof_error(NULL, "failed to copyin DOF header");
+		*errp = -EFAULT;
+		return NULL;
+	}
+
+	/*
+	 * Now we'll allocate the entire DOF and copy it in -- provided
+	 * that the length isn't outrageous.
+	 */
+	if (hdr.dofh_loadsz >= dtrace_dof_maxsize) {
+		dtrace_dof_error(&hdr, "load size exceeds maximum");
+		*errp = -E2BIG;
+		return NULL;
+	}
+
+	if (hdr.dofh_loadsz < sizeof(hdr)) {
+		dtrace_dof_error(&hdr, "invalid load size");
+		*errp = -EINVAL;
+		return NULL;
+	}
+
+	dof = vmalloc(hdr.dofh_loadsz);
+	if (dof == NULL) {
+		*errp = -ENOMEM;
+		return NULL;
+	}
+
+	if (copy_from_user(dof, argp, hdr.dofh_loadsz) != 0 ||
+		dof->dofh_loadsz != hdr.dofh_loadsz) {
+		vfree(dof);
+		*errp = -EFAULT;
+		return NULL;
+	}
+
+	return dof;
+}
+
+struct dof_hdr *dtrace_dof_property(const char *name)
+{
+	uchar_t		*buf;
+	uint64_t	loadsz;
+	unsigned int	len, i;
+	struct dof_hdr	*dof;
+
+	/*
+	 * Unfortunately, array of values in .conf files are always (and
+	 * only) interpreted to be integer arrays.  We must read our DOF
+	 * as an integer array, and then squeeze it into a byte array.
+	 */
+#ifdef FIXME
+	if (ddi_prop_lookup_int_array(DDI_DEV_T_ANY, dtrace_devi, 0,
+				      (char *)name, (int **)&buf, &len) !=
+	    DDI_PROP_SUCCESS)
+		return NULL;
+#else
+	return NULL;
+#endif
+
+	for (i = 0; i < len; i++)
+		buf[i] = (uchar_t)(((int *)buf)[i]);
+
+	if (len < sizeof(struct dof_hdr)) {
+#ifdef FIXME
+		ddi_prop_free(buf);
+#endif
+		dtrace_dof_error(NULL, "truncated header");
+		return NULL;
+	}
+
+	loadsz = ((struct dof_hdr *)buf)->dofh_loadsz;
+	if (len < loadsz) {
+#ifdef FIXME
+		ddi_prop_free(buf);
+#endif
+		dtrace_dof_error(NULL, "truncated DOF");
+		return NULL;
+	}
+
+	if (loadsz >= dtrace_dof_maxsize) {
+#ifdef FIXME
+		ddi_prop_free(buf);
+#endif
+		dtrace_dof_error(NULL, "oversized DOF");
+		return NULL;
+	}
+
+	dof = vmalloc(loadsz);
+	if (dof == NULL) {
+		dtrace_dof_error(NULL, "out-of-memory");
+		return NULL;
+	}
+	memcpy(dof, buf, loadsz);
+#ifdef FIXME
+	ddi_prop_free(buf);
+#endif
+
+	return dof;
+}
+
+void dtrace_dof_destroy(struct dof_hdr *dof)
+{
+	vfree(dof);
+}
+
+/*
+ * Return the dof_sec_t pointer corresponding to a given section index.  If the
+ * index is not valid, dtrace_dof_error() is called and NULL is returned.  If
+ * a type other than DOF_SECT_NONE is specified, the header is checked against
+ * this type and NULL is returned if the types do not match.
+ */
+static struct dof_sec *dtrace_dof_sect(struct dof_hdr *dof, uint32_t doftype,
+                                       dof_secidx_t i)
+{
+	struct dof_sec *sec;
+
+	sec = (struct dof_sec *)(uintptr_t) ((uintptr_t)dof +
+					     dof->dofh_secoff +
+					     i * dof->dofh_secsize);
+
+	if (i >= dof->dofh_secnum) {
+		dtrace_dof_error(dof, "referenced section index is invalid");
+		return NULL;
+	}
+
+	if (!(sec->dofs_flags & DOF_SECF_LOAD)) {
+		dtrace_dof_error(dof, "referenced section is not loadable");
+		return NULL;
+	}
+
+	if (doftype != DOF_SECT_NONE && doftype != sec->dofs_type) {
+		dtrace_dof_error(dof, "referenced section is the wrong type");
+		return NULL;
+	}
+
+	return sec;
+}
+
+static struct dtrace_probedesc *dtrace_dof_probedesc(struct dof_hdr *dof,
+                                                     struct dof_sec *sec,
+                                                     struct dtrace_probedesc *desc)
+{
+	struct dof_probedesc	*probe;
+	struct dof_sec		*strtab;
+	uintptr_t		daddr = (uintptr_t)dof;
+	uintptr_t		str;
+	size_t			size;
+
+	if (sec->dofs_type != DOF_SECT_PROBEDESC) {
+		dtrace_dof_error(dof, "invalid probe section");
+		return NULL;
+	}
+
+	if (sec->dofs_align != sizeof(dof_secidx_t)) {
+		dtrace_dof_error(dof, "bad alignment in probe description");
+		return NULL;
+	}
+
+	if (sec->dofs_offset + sizeof(struct dof_probedesc) >
+	    dof->dofh_loadsz) {
+		dtrace_dof_error(dof, "truncated probe description");
+		return NULL;
+	}
+
+	probe = (struct dof_probedesc *)(uintptr_t)(daddr + sec->dofs_offset);
+	strtab = dtrace_dof_sect(dof, DOF_SECT_STRTAB, probe->dofp_strtab);
+
+	if (strtab == NULL)
+		return NULL;
+
+	str = daddr + strtab->dofs_offset;
+	size = strtab->dofs_size;
+
+	if (probe->dofp_provider >= strtab->dofs_size) {
+		dtrace_dof_error(dof, "corrupt probe provider");
+		return NULL;
+	}
+
+	strncpy(desc->dtpd_provider, (char *)(str + probe->dofp_provider),
+		min((size_t)DTRACE_PROVNAMELEN - 1,
+		    size - probe->dofp_provider));
+
+	if (probe->dofp_mod >= strtab->dofs_size) {
+		dtrace_dof_error(dof, "corrupt probe module");
+		return NULL;
+	}
+
+	strncpy(desc->dtpd_mod, (char *)(str + probe->dofp_mod),
+		min((size_t)DTRACE_MODNAMELEN - 1, size - probe->dofp_mod));
+
+	if (probe->dofp_func >= strtab->dofs_size) {
+		dtrace_dof_error(dof, "corrupt probe function");
+		return NULL;
+	}
+
+	strncpy(desc->dtpd_func, (char *)(str + probe->dofp_func),
+		min((size_t)DTRACE_FUNCNAMELEN - 1, size - probe->dofp_func));
+
+	if (probe->dofp_name >= strtab->dofs_size) {
+		dtrace_dof_error(dof, "corrupt probe name");
+		return NULL;
+	}
+
+	strncpy(desc->dtpd_name, (char *)(str + probe->dofp_name),
+		min((size_t)DTRACE_NAMELEN - 1, size - probe->dofp_name));
+
+	dt_dbg_dof("      ECB Probe %s:%s:%s:%s\n",
+		   desc->dtpd_provider, desc->dtpd_mod, desc->dtpd_func,
+		   desc->dtpd_name);
+
+	return desc;
+}
+
+static struct dtrace_difo *dtrace_dof_difo(struct dof_hdr *dof,
+                                           struct dof_sec *sec,
+                                           struct dtrace_vstate *vstate,
+                                           const struct cred *cr)
+{
+	struct dtrace_difo	*dp;
+	size_t			ttl = 0;
+	struct dof_difohdr	*dofd;
+	uintptr_t		daddr = (uintptr_t)dof;
+	size_t			max = dtrace_difo_maxsize;
+	int			i, l, n;
+
+	static const struct {
+		int section;
+		int bufoffs;
+		int lenoffs;
+		int entsize;
+		int align;
+		const char *msg;
+	} difo[] = {
+		{
+			DOF_SECT_DIF,
+			offsetof(struct dtrace_difo, dtdo_buf),
+			offsetof(struct dtrace_difo, dtdo_len),
+			sizeof(dif_instr_t),
+			sizeof(dif_instr_t),
+			"multiple DIF sections"
+		},
+		{
+			DOF_SECT_INTTAB,
+			offsetof(struct dtrace_difo, dtdo_inttab),
+			offsetof(struct dtrace_difo, dtdo_intlen),
+			sizeof(uint64_t),
+			sizeof(uint64_t),
+			"multiple integer tables"
+		},
+		{
+			DOF_SECT_STRTAB,
+			offsetof(struct dtrace_difo, dtdo_strtab),
+			offsetof(struct dtrace_difo, dtdo_strlen),
+			0,
+			sizeof(char),
+			"multiple string tables"
+		},
+		{
+			DOF_SECT_VARTAB,
+			offsetof(struct dtrace_difo, dtdo_vartab),
+			offsetof(struct dtrace_difo, dtdo_varlen),
+			sizeof(struct dtrace_difv),
+			sizeof(uint_t),
+			"multiple variable tables"
+		},
+		{
+			DOF_SECT_NONE,
+			0,
+			0,
+			0,
+			0,
+			NULL
+		}
+	};
+
+	if (sec->dofs_type != DOF_SECT_DIFOHDR) {
+		dtrace_dof_error(dof, "invalid DIFO header section");
+		return NULL;
+	}
+
+	if (sec->dofs_align != sizeof(dof_secidx_t)) {
+		dtrace_dof_error(dof, "bad alignment in DIFO header");
+		return NULL;
+	}
+
+	if (sec->dofs_size < sizeof(struct dof_difohdr) ||
+	    sec->dofs_size % sizeof(dof_secidx_t)) {
+		dtrace_dof_error(dof, "bad size in DIFO header");
+		return NULL;
+	}
+
+	dofd = (struct dof_difohdr *)(uintptr_t)(daddr + sec->dofs_offset);
+	n = (sec->dofs_size - sizeof(*dofd)) / sizeof(dof_secidx_t) + 1;
+
+	dp = kzalloc(sizeof(struct dtrace_difo), GFP_KERNEL);
+	if (dp == NULL) {
+		dtrace_dof_error(dof, "out-of-memory");
+		return NULL;
+	}
+	dp->dtdo_rtype = dofd->dofd_rtype;
+
+	for (l = 0; l < n; l++) {
+		struct dof_sec	*subsec;
+		void		**bufp;
+		uint32_t	*lenp;
+
+		subsec = dtrace_dof_sect(dof, DOF_SECT_NONE,
+					 dofd->dofd_links[l]);
+		if (subsec == NULL)
+			goto err; /* invalid section link */
+
+		if (ttl + subsec->dofs_size > max) {
+			dtrace_dof_error(dof, "exceeds maximum size");
+			goto err;
+		}
+
+		ttl += subsec->dofs_size;
+
+		for (i = 0; difo[i].section != DOF_SECT_NONE; i++) {
+			if (subsec->dofs_type != difo[i].section)
+				continue;
+
+			if (!(subsec->dofs_flags & DOF_SECF_LOAD)) {
+				dtrace_dof_error(dof, "section not loaded");
+				goto err;
+			}
+
+			if (subsec->dofs_align != difo[i].align) {
+				dtrace_dof_error(dof, "bad alignment");
+				goto err;
+			}
+
+			bufp = (void **)((uintptr_t)dp + difo[i].bufoffs);
+			lenp = (uint32_t *)((uintptr_t)dp + difo[i].lenoffs);
+
+			if (*bufp != NULL) {
+				dtrace_dof_error(dof, difo[i].msg);
+				goto err;
+			}
+
+			if (difo[i].entsize != subsec->dofs_entsize) {
+				dtrace_dof_error(dof, "entry size mismatch");
+				goto err;
+			}
+
+			if (subsec->dofs_entsize != 0) {
+				uint64_t	n = subsec->dofs_size;
+
+				if (do_div(n, subsec->dofs_entsize) != 0) {
+					dtrace_dof_error(dof,
+							 "corrupt entry size");
+					goto err;
+				}
+			}
+
+			*lenp = subsec->dofs_size;
+			*bufp = vmalloc(subsec->dofs_size);
+			if (*bufp == NULL) {
+				dtrace_dof_error(dof, "out-of-memory");
+				goto err;
+			}
+			memcpy(*bufp,
+			       (char *)(uintptr_t)(daddr + subsec->dofs_offset),
+			       subsec->dofs_size);
+
+			if (subsec->dofs_entsize != 0)
+				*lenp /= subsec->dofs_entsize;
+
+			break;
+		}
+
+		/*
+		 * If we encounter a loadable DIFO sub-section that is not
+		 * known to us, assume this is a broken program and fail.
+		 */
+		if (difo[i].section == DOF_SECT_NONE &&
+		    (subsec->dofs_flags & DOF_SECF_LOAD)) {
+			dtrace_dof_error(dof, "unrecognized DIFO subsection");
+			goto err;
+		}
+	}
+
+	if (dp->dtdo_buf == NULL) {
+		/*
+		 * We can't have a DIF object without DIF text.
+		 */
+		dtrace_dof_error(dof, "missing DIF text");
+		goto err;
+	}
+
+	/*
+	 * Before we validate the DIF object, run through the variable table
+	 * looking for the strings -- if any of their size are under, we'll set
+	 * their size to be the system-wide default string size.  Note that
+	 * this should _not_ happen if the "strsize" option has been set --
+	 * in this case, the compiler should have set the size to reflect the
+	 * setting of the option.
+	 */
+	for (i = 0; i < dp->dtdo_varlen; i++) {
+		struct dtrace_difv	*v = &dp->dtdo_vartab[i];
+		struct dtrace_diftype	*t = &v->dtdv_type;
+
+		if (v->dtdv_id < DIF_VAR_OTHER_UBASE)
+			continue;
+
+		if (t->dtdt_kind == DIF_TYPE_STRING && t->dtdt_size == 0)
+			t->dtdt_size = dtrace_strsize_default;
+	}
+
+	if (dtrace_difo_validate(dp, vstate, DIF_DIR_NREGS, cr) != 0)
+		goto err;
+
+	dtrace_difo_init(dp, vstate);
+	return dp;
+
+err:
+	if (dp->dtdo_buf != NULL)
+		vfree(dp->dtdo_buf);
+	if (dp->dtdo_inttab != NULL)
+		vfree(dp->dtdo_inttab);
+	if (dp->dtdo_strtab != NULL)
+		vfree(dp->dtdo_strtab);
+	if (dp->dtdo_vartab != NULL)
+		vfree(dp->dtdo_vartab);
+
+	kfree(dp);
+
+	return NULL;
+}
+
+static struct dtrace_predicate *dtrace_dof_predicate(struct dof_hdr *dof,
+                                                     struct dof_sec *sec,
+                                                     struct dtrace_vstate *vstate,
+                                                     const struct cred *cr)
+{
+	struct dtrace_difo *dp;
+
+	if ((dp = dtrace_dof_difo(dof, sec, vstate, cr)) == NULL)
+		return NULL;
+
+	return dtrace_predicate_create(dp);
+}
+
+static struct dtrace_actdesc *dtrace_dof_actdesc(struct dof_hdr *dof,
+                                                 struct dof_sec *sec,
+                                                 struct dtrace_vstate *vstate,
+                                                 const struct cred *cr)
+{
+	struct dtrace_actdesc	*act, *first = NULL, *last = NULL, *next;
+	struct dof_actdesc	*desc;
+	struct dof_sec		*difosec;
+	size_t			offs;
+	uintptr_t		daddr = (uintptr_t)dof;
+	uint64_t		arg;
+	dtrace_actkind_t	kind;
+
+	if (sec->dofs_type != DOF_SECT_ACTDESC) {
+		dtrace_dof_error(dof, "invalid action section");
+		return NULL;
+	}
+
+	if (sec->dofs_offset + sizeof(struct dof_actdesc) > dof->dofh_loadsz) {
+		dtrace_dof_error(dof, "truncated action description");
+		return NULL;
+	}
+
+	if (sec->dofs_align != sizeof(uint64_t)) {
+		dtrace_dof_error(dof, "bad alignment in action description");
+		return NULL;
+	}
+
+	if (sec->dofs_size < sec->dofs_entsize) {
+		dtrace_dof_error(dof, "section entry size exceeds total size");
+		return NULL;
+	}
+
+	if (sec->dofs_entsize != sizeof(struct dof_actdesc)) {
+		dtrace_dof_error(dof, "bad entry size in action description");
+		return NULL;
+	}
+
+	/*
+	 * Was: sec->dofs_size / sec->dofs_entsize > dtrace_actions_max
+	 * but it is safer to simply avoid the division (it requires use of
+	 * a macro in Linux to cover 64-bit division in a 32-bit kernel.
+	 */
+	if (sec->dofs_size > sec->dofs_entsize * dtrace_actions_max) {
+		dtrace_dof_error(dof, "actions exceed dtrace_actions_max");
+		return NULL;
+	}
+
+	for (offs = 0; offs < sec->dofs_size; offs += sec->dofs_entsize) {
+		desc = (struct dof_actdesc *)(daddr +
+					 (uintptr_t)sec->dofs_offset + offs);
+		kind = (dtrace_actkind_t)desc->dofa_kind;
+
+		if (DTRACEACT_ISPRINTFLIKE(kind) &&
+		    (kind != DTRACEACT_PRINTA ||
+		     desc->dofa_strtab != DOF_SECIDX_NONE)) {
+			struct dof_sec	*strtab;
+			char		*str, *fmt;
+			uint64_t	i;
+
+			/*
+			 * The printf()-like actions must have a format string.
+			 */
+			strtab = dtrace_dof_sect(dof, DOF_SECT_STRTAB,
+						 desc->dofa_strtab);
+			if (strtab == NULL)
+				goto err;
+
+			str = (char *)((uintptr_t)dof +
+				       (uintptr_t)strtab->dofs_offset);
+
+			for (i = desc->dofa_arg; i < strtab->dofs_size; i++) {
+				if (str[i] == '\0')
+					break;
+			}
+
+			if (i >= strtab->dofs_size) {
+				dtrace_dof_error(dof, "bogus format string");
+				goto err;
+			}
+
+			if (i == desc->dofa_arg) {
+				dtrace_dof_error(dof, "empty format string");
+				goto err;
+			}
+
+			i -= desc->dofa_arg;
+			fmt = vmalloc(i + 1);
+			if (fmt == NULL) {
+				dtrace_dof_error(dof, "out-of-memory");
+				goto err;
+			}
+			memcpy(fmt, &str[desc->dofa_arg], i + 1);
+			arg = (uint64_t)(uintptr_t)fmt;
+		} else {
+			if (kind == DTRACEACT_PRINTA) {
+				ASSERT(desc->dofa_strtab == DOF_SECIDX_NONE);
+				arg = 0;
+			} else
+				arg = desc->dofa_arg;
+		}
+
+		act = dtrace_actdesc_create(kind, desc->dofa_ntuple,
+					    desc->dofa_uarg, arg);
+		if (act == NULL)
+			goto err;
+
+		if (last != NULL)
+			last->dtad_next = act;
+		else
+			first = act;
+
+		last = act;
+
+		if (desc->dofa_difo == DOF_SECIDX_NONE)
+			continue;
+
+		difosec = dtrace_dof_sect(dof, DOF_SECT_DIFOHDR,
+					  desc->dofa_difo);
+		if (difosec == NULL)
+			goto err;
+
+		act->dtad_difo = dtrace_dof_difo(dof, difosec, vstate, cr);
+
+		if (act->dtad_difo == NULL)
+			goto err;
+	}
+
+	ASSERT(first != NULL);
+	return first;
+
+err:
+	for (act = first; act != NULL; act = next) {
+		next = act->dtad_next;
+		dtrace_actdesc_release(act, vstate);
+	}
+
+	return NULL;
+}
+
+static struct dtrace_ecbdesc *dtrace_dof_ecbdesc(struct dof_hdr *dof,
+                                                 struct dof_sec *sec,
+                                                 struct dtrace_vstate *vstate,
+                                                 const struct cred *cr)
+{
+	struct dtrace_ecbdesc	*ep;
+	struct dof_ecbdesc	*ecb;
+	struct dtrace_probedesc	*desc;
+	struct dtrace_predicate	*pred = NULL;
+
+	if (sec->dofs_size < sizeof(struct dof_ecbdesc)) {
+		dtrace_dof_error(dof, "truncated ECB description");
+		return NULL;
+	}
+
+	if (sec->dofs_align != sizeof(uint64_t)) {
+		dtrace_dof_error(dof, "bad alignment in ECB description");
+		return NULL;
+	}
+
+	ecb = (struct dof_ecbdesc *)
+	  ((uintptr_t)dof + (uintptr_t)sec->dofs_offset);
+	sec = dtrace_dof_sect(dof, DOF_SECT_PROBEDESC, ecb->dofe_probes);
+
+	if (sec == NULL)
+		return NULL;
+
+	ep = kzalloc(sizeof(struct dtrace_ecbdesc), GFP_KERNEL);
+	if (ep == NULL)
+		return NULL;
+	ep->dted_uarg = ecb->dofe_uarg;
+	desc = &ep->dted_probe;
+
+	if (dtrace_dof_probedesc(dof, sec, desc) == NULL)
+		goto err;
+
+	if (ecb->dofe_pred != DOF_SECIDX_NONE) {
+		sec = dtrace_dof_sect(dof, DOF_SECT_DIFOHDR, ecb->dofe_pred);
+		if (sec == NULL)
+			goto err;
+
+		pred = dtrace_dof_predicate(dof, sec, vstate, cr);
+		if (pred == NULL)
+			goto err;
+
+		ep->dted_pred.dtpdd_predicate = pred;
+	}
+
+	if (ecb->dofe_actions != DOF_SECIDX_NONE) {
+		sec = dtrace_dof_sect(dof, DOF_SECT_ACTDESC, ecb->dofe_actions);
+		if (sec == NULL)
+			goto err;
+
+		ep->dted_action = dtrace_dof_actdesc(dof, sec, vstate, cr);
+
+		if (ep->dted_action == NULL)
+			goto err;
+	}
+
+	return ep;
+
+err:
+	if (pred != NULL)
+		dtrace_predicate_release(pred, vstate);
+	kfree(ep);
+	return NULL;
+}
+
+/*
+ * Apply the relocations from the specified 'sec' (a DOF_SECT_URELHDR) to the
+ * specified DOF.  At present, this amounts to simply adding 'ubase' to the
+ * site of any user SETX relocations to account for load object base address.
+ * In the future, if we need other relocations, this function can be extended.
+ */
+static int dtrace_dof_relocate(struct dof_hdr *dof, struct dof_sec *sec,
+			       uint64_t ubase)
+{
+	uintptr_t		daddr = (uintptr_t)dof;
+	struct dof_relohdr	*dofr;
+	struct dof_sec		*ss, *rs, *ts;
+	struct dof_relodesc	*r;
+	uint_t			i, n;
+
+	dofr = (struct dof_relohdr *)(uintptr_t) (daddr + sec->dofs_offset);
+
+	if (sec->dofs_size < sizeof(struct dof_relohdr) ||
+	    sec->dofs_align != sizeof(dof_secidx_t)) {
+		dtrace_dof_error(dof, "invalid relocation header");
+		return -1;
+	}
+
+	ss = dtrace_dof_sect(dof, DOF_SECT_STRTAB, dofr->dofr_strtab);
+	rs = dtrace_dof_sect(dof, DOF_SECT_RELTAB, dofr->dofr_relsec);
+	ts = dtrace_dof_sect(dof, DOF_SECT_NONE, dofr->dofr_tgtsec);
+
+	if (ss == NULL || rs == NULL || ts == NULL)
+		return -1; /* dtrace_dof_error() has been called already */
+
+	if (rs->dofs_entsize < sizeof(struct dof_relodesc) ||
+	    rs->dofs_align != sizeof(uint64_t)) {
+		dtrace_dof_error(dof, "invalid relocation section");
+		return -1;
+	}
+
+	r = (struct dof_relodesc *)(uintptr_t)(daddr + rs->dofs_offset);
+	/*
+	 * Was: n = rs->dofs_size / rs->dofs_entsize;
+	 * but on Linux we need to use a macro for the division to handle the
+	 * possible case of 64-bit division on a 32-bit kernel.
+	 */
+	n = rs->dofs_size;
+	do_div(n, rs->dofs_entsize);
+
+	for (i = 0; i < n; i++) {
+		uintptr_t taddr = daddr + ts->dofs_offset + r->dofr_offset;
+
+		switch (r->dofr_type) {
+		case DOF_RELO_NONE:
+			break;
+		case DOF_RELO_SETX:
+			if (r->dofr_offset >= ts->dofs_size ||
+			    r->dofr_offset + sizeof(uint64_t) >
+				ts->dofs_size) {
+				dtrace_dof_error(dof, "bad relocation offset");
+				return -1;
+			}
+
+			if (!IS_ALIGNED(taddr, sizeof(uint64_t))) {
+				dtrace_dof_error(dof, "misaligned setx relo");
+				return -1;
+			}
+
+			/*
+			 * This is a bit ugly but it is necessary for arm64,
+			 * where the linking of shared libraries retains the
+			 * relocation records for the .SUNW_dof section.  In
+			 * that case, the runtime loader already performed the
+			 * relocation, so we do not have to do anything here.
+			 *
+			 * We check for this situation by comparing the target
+			 * address against the base address (ubase).  If it is
+			 * larger, we assume the relocation already took place.
+			 */
+			if (*(uint64_t *)taddr > ubase)
+				dt_dbg_dof("      Relocation by runtime " \
+					   "loader: 0x%llx (base 0x%llx)\n",
+					   *(uint64_t *)taddr, ubase);
+			else {
+				dt_dbg_dof("      Relocate 0x%llx + 0x%llx " \
+					   "= 0x%llx\n",
+					   *(uint64_t *)taddr, ubase,
+					   *(uint64_t *)taddr + ubase);
+
+				*(uint64_t *)taddr += ubase;
+			}
+
+			break;
+		default:
+			dtrace_dof_error(dof, "invalid relocation type");
+			return -1;
+		}
+
+		r = (struct dof_relodesc *)((uintptr_t)r + rs->dofs_entsize);
+	}
+
+	return 0;
+}
+
+/*
+ * The dof_hdr_t passed to dtrace_dof_slurp() should be a partially validated
+ * header:  it should be at the front of a memory region that is at least
+ * sizeof(dof_hdr_t) in size -- and then at least dof_hdr.dofh_loadsz in
+ * size.  It need not be validated in any other way.
+ */
+int dtrace_dof_slurp(struct dof_hdr *dof, struct dtrace_vstate *vstate,
+		     const struct cred *cr, struct dtrace_enabling **enabp,
+		     uint64_t ubase, int noprobes)
+{
+	uint64_t		len = dof->dofh_loadsz, seclen;
+	uintptr_t		daddr = (uintptr_t)dof;
+	struct dtrace_ecbdesc	*ep;
+	struct dtrace_enabling	*enab;
+	uint_t			i;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(dof->dofh_loadsz >= sizeof(struct dof_hdr));
+
+	dt_dbg_dof("  DOF 0x%p Slurping...\n", dof);
+
+	dt_dbg_dof("    DOF 0x%p Validating...\n", dof);
+
+	/*
+	 * Check the DOF header identification bytes.  In addition to checking
+	 * valid settings, we also verify that unused bits/bytes are zeroed so
+	 * we can use them later without fear of regressing existing binaries.
+	 */
+	if (memcmp(&dof->dofh_ident[DOF_ID_MAG0], DOF_MAG_STRING,
+		   DOF_MAG_STRLEN) != 0) {
+		dtrace_dof_error(dof, "DOF magic string mismatch");
+		return -1;
+	}
+
+	if (dof->dofh_ident[DOF_ID_MODEL] != DOF_MODEL_ILP32 &&
+	    dof->dofh_ident[DOF_ID_MODEL] != DOF_MODEL_LP64) {
+		dtrace_dof_error(dof, "DOF has invalid data model");
+		return -1;
+	}
+
+	if (dof->dofh_ident[DOF_ID_ENCODING] != DOF_ENCODE_NATIVE) {
+		dtrace_dof_error(dof, "DOF encoding mismatch");
+		return -1;
+	}
+
+	if (dof->dofh_ident[DOF_ID_VERSION] != DOF_VERSION_1 &&
+	    dof->dofh_ident[DOF_ID_VERSION] != DOF_VERSION_2) {
+		dtrace_dof_error(dof, "DOF version mismatch");
+		return -1;
+	}
+
+	if (dof->dofh_ident[DOF_ID_DIFVERS] != DIF_VERSION_2) {
+		dtrace_dof_error(dof, "DOF uses unsupported instruction set");
+		return -1;
+	}
+
+	if (dof->dofh_ident[DOF_ID_DIFIREG] > DIF_DIR_NREGS) {
+		dtrace_dof_error(dof, "DOF uses too many integer registers");
+		return -1;
+	}
+
+	if (dof->dofh_ident[DOF_ID_DIFTREG] > DIF_DTR_NREGS) {
+		dtrace_dof_error(dof, "DOF uses too many tuple registers");
+		return -1;
+	}
+
+	for (i = DOF_ID_PAD; i < DOF_ID_SIZE; i++) {
+		if (dof->dofh_ident[i] != 0) {
+			dtrace_dof_error(dof, "DOF has invalid ident byte set");
+			return -1;
+		}
+	}
+
+	if (dof->dofh_flags & ~DOF_FL_VALID) {
+		dtrace_dof_error(dof, "DOF has invalid flag bits set");
+		return -1;
+	}
+
+	if (dof->dofh_secsize == 0) {
+		dtrace_dof_error(dof, "zero section header size");
+		return -1;
+	}
+
+	/*
+	 * Check that the section headers don't exceed the amount of DOF
+	 * data.  Note that we cast the section size and number of sections
+	 * to uint64_t's to prevent possible overflow in the multiplication.
+	 */
+	seclen = (uint64_t)dof->dofh_secnum * (uint64_t)dof->dofh_secsize;
+
+	if (dof->dofh_secoff > len || seclen > len ||
+	    dof->dofh_secoff + seclen > len) {
+		dtrace_dof_error(dof, "truncated section headers");
+		return -1;
+	}
+
+	if (!IS_ALIGNED(dof->dofh_secoff, sizeof(uint64_t))) {
+		dtrace_dof_error(dof, "misaligned section headers");
+		return -1;
+	}
+
+	if (!IS_ALIGNED(dof->dofh_secsize, sizeof(uint64_t))) {
+		dtrace_dof_error(dof, "misaligned section size");
+		return -1;
+	}
+
+	/*
+	 * Take an initial pass through the section headers to be sure that
+	 * the headers don't have stray offsets.  If the 'noprobes' flag is
+	 * set, do not permit sections relating to providers, probes, or args.
+	 */
+	dt_dbg_dof("    DOF 0x%p Checking section offsets...\n", dof);
+
+	for (i = 0; i < dof->dofh_secnum; i++) {
+		struct dof_sec *sec;
+
+		sec = (struct dof_sec *)(daddr + (uintptr_t)dof->dofh_secoff +
+					 i * dof->dofh_secsize);
+
+		if (noprobes) {
+			switch (sec->dofs_type) {
+			case DOF_SECT_PROVIDER:
+			case DOF_SECT_PROBES:
+			case DOF_SECT_PRARGS:
+			case DOF_SECT_PROFFS:
+				dtrace_dof_error(
+					dof, "illegal sections for enabling");
+				return -1;
+			}
+		}
+
+		if (DOF_SEC_ISLOADABLE(sec->dofs_type) &&
+		    !(sec->dofs_flags & DOF_SECF_LOAD)) {
+			dtrace_dof_error(
+				dof, "loadable section with load flag unset");
+			return -1;
+		}
+
+		/*
+		 * Just ignore non-loadable sections.
+		 */
+		if (!(sec->dofs_flags & DOF_SECF_LOAD))
+			continue;
+
+		if (sec->dofs_align & (sec->dofs_align - 1)) {
+			dtrace_dof_error(dof, "bad section alignment");
+			return -1;
+		}
+
+		if (sec->dofs_offset & (sec->dofs_align - 1)) {
+			dtrace_dof_error(dof, "misaligned section");
+			return -1;
+		}
+
+		if (sec->dofs_offset > len || sec->dofs_size > len ||
+		    sec->dofs_offset + sec->dofs_size > len) {
+			dtrace_dof_error(dof, "corrupt section header");
+			return -1;
+		}
+
+		if (sec->dofs_type == DOF_SECT_STRTAB && *((char *)daddr +
+		    sec->dofs_offset + sec->dofs_size - 1) != '\0') {
+			dtrace_dof_error(dof, "non-terminating string table");
+			return -1;
+		}
+	}
+
+	/*
+	 * Take a second pass through the sections and locate and perform any
+	 * relocations that are present.  We do this after the first pass to
+	 * be sure that all sections have had their headers validated.
+	 */
+	dt_dbg_dof("    DOF 0x%p Performing relocations...\n", dof);
+
+	for (i = 0; i < dof->dofh_secnum; i++) {
+		struct dof_sec *sec;
+
+		sec = (struct dof_sec *)(daddr + (uintptr_t)dof->dofh_secoff +
+					 i * dof->dofh_secsize);
+
+		/*
+		 * Skip sections that are not loadable.
+		 */
+		if (!(sec->dofs_flags & DOF_SECF_LOAD))
+			continue;
+
+		switch (sec->dofs_type) {
+		case DOF_SECT_URELHDR:
+			if (dtrace_dof_relocate(dof, sec, ubase) != 0)
+				return -1;
+			break;
+		}
+	}
+
+	dt_dbg_dof("    DOF 0x%p Processing enablings...\n", dof);
+
+	enab = *enabp;
+	if (enab == NULL)
+		enab = *enabp = dtrace_enabling_create(vstate);
+
+	if (enab == NULL) {
+		dt_dbg_dof("  DOF 0x%p Done slurping - no enablings\n", dof);
+		return -1;
+	}
+
+	for (i = 0; i < dof->dofh_secnum; i++) {
+		struct dof_sec *sec;
+
+		sec = (struct dof_sec *)(daddr + (uintptr_t)dof->dofh_secoff +
+					 i * dof->dofh_secsize);
+
+		if (sec->dofs_type != DOF_SECT_ECBDESC)
+			continue;
+
+		ep = dtrace_dof_ecbdesc(dof, sec, vstate, cr);
+		if (ep == NULL) {
+			dt_dbg_dof("  DOF 0x%p Done slurping - ECB problem\n",
+				   dof);
+			dtrace_enabling_destroy(enab);
+			*enabp = NULL;
+			return -1;
+		}
+
+		dtrace_enabling_add(enab, ep);
+	}
+
+	dt_dbg_dof("    DOF 0x%p Enablings processed\n", dof);
+	dt_dbg_dof("  DOF 0x%p Done slurping\n", dof);
+
+	return 0;
+}
+
+/*
+ * Process DOF for any options.  This should be called after the DOF has been
+ * processed by dtrace_dof_slurp().
+ */
+int dtrace_dof_options(struct dof_hdr *dof, struct dtrace_state *state)
+{
+	int		i, rval;
+	uint32_t	entsize;
+	size_t 		offs;
+	struct dof_optdesc *desc;
+
+	for (i = 0; i < dof->dofh_secnum; i++) {
+		struct dof_sec *sec;
+
+		sec = (struct dof_sec *)((uintptr_t)dof +
+					 (uintptr_t)dof->dofh_secoff +
+					 i * dof->dofh_secsize);
+
+		if (sec->dofs_type != DOF_SECT_OPTDESC)
+			continue;
+
+		if (sec->dofs_align != sizeof(uint64_t)) {
+			dtrace_dof_error(
+				dof, "bad alignment in option description");
+			return -EINVAL;
+		}
+
+		entsize = sec->dofs_entsize;
+		if (entsize == 0) {
+			dtrace_dof_error(dof, "zeroed option entry size");
+			return -EINVAL;
+		}
+
+		if (entsize < sizeof(struct dof_optdesc)) {
+			dtrace_dof_error(dof, "bad option entry size");
+			return -EINVAL;
+		}
+
+		for (offs = 0; offs < sec->dofs_size; offs += entsize) {
+			desc = (struct dof_optdesc *)((uintptr_t)dof +
+						 (uintptr_t)sec->dofs_offset +
+						 offs);
+
+			if (desc->dofo_strtab != DOF_SECIDX_NONE) {
+				dtrace_dof_error(
+					dof, "non-zero option string");
+				return -EINVAL;
+			}
+
+			if (desc->dofo_value == DTRACEOPT_UNSET) {
+				dtrace_dof_error(dof, "unset option");
+				return -EINVAL;
+			}
+
+			rval = dtrace_state_option(state, desc->dofo_option,
+						   desc->dofo_value);
+			if (rval != 0) {
+				dtrace_dof_error(dof, "rejected option");
+				return rval;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static struct dtrace_helpers *dtrace_helpers_create(struct task_struct *curr)
+{
+	struct dtrace_helpers	*dth;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	if (curr->dt_task == NULL)
+		return NULL;
+
+	ASSERT(curr->dt_task->dt_helpers == NULL);
+
+	dth = kzalloc(sizeof(struct dtrace_helpers), GFP_KERNEL);
+	if (dth == NULL)
+		return NULL;
+
+	dth->dthps_actions = vzalloc(sizeof(struct dtrace_helper_action *) *
+				     DTRACE_NHELPER_ACTIONS);
+	if (dth->dthps_actions == NULL) {
+		kfree(dth);
+		return NULL;
+	}
+
+	curr->dt_task->dt_helpers = dth;
+	dtrace_helpers++;
+
+	dt_dbg_dof("  Helpers allocated for task 0x%p (%d system-wide)\n",
+		   curr, dtrace_helpers);
+
+	return dth;
+}
+
+static int dtrace_helper_validate(struct dtrace_helper_action *helper)
+{
+	int			err = 0, i;
+	struct dtrace_difo	*dp;
+
+	dp = helper->dtha_predicate;
+	if (dp != NULL)
+		err += dtrace_difo_validate_helper(dp);
+
+	for (i = 0; i < helper->dtha_nactions; i++)
+		err += dtrace_difo_validate_helper(helper->dtha_actions[i]);
+
+	return (err == 0);
+}
+
+static int dtrace_helper_provider_validate(struct dof_hdr *dof,
+					   struct dof_sec *sec)
+{
+	uintptr_t		daddr = (uintptr_t)dof;
+	struct dof_sec		*str_sec, *prb_sec, *arg_sec, *off_sec,
+				*enoff_sec;
+	struct dof_provider	*prov;
+	struct dof_probe	*prb;
+	uint8_t			*arg;
+	char			*strtab, *typestr;
+	dof_stridx_t		typeidx;
+	size_t			typesz;
+	uint_t			nprobes, j, k;
+
+	ASSERT(sec->dofs_type == DOF_SECT_PROVIDER);
+
+	if (sec->dofs_offset & (sizeof(uint_t) - 1)) {
+		dtrace_dof_error(dof, "misaligned section offset");
+		return -1;
+	}
+
+	/*
+	 * The section needs to be large enough to contain the DOF provider
+	 * structure appropriate for the given version.
+	 */
+	if (sec->dofs_size <
+	    ((dof->dofh_ident[DOF_ID_VERSION] == DOF_VERSION_1)
+			? offsetof(struct dof_provider, dofpv_prenoffs)
+			: sizeof(struct dof_provider))) {
+		dtrace_dof_error(dof, "provider section too small");
+		return -1;
+	}
+
+	prov = (struct dof_provider *)(uintptr_t)(daddr + sec->dofs_offset);
+	str_sec = dtrace_dof_sect(dof, DOF_SECT_STRTAB, prov->dofpv_strtab);
+	prb_sec = dtrace_dof_sect(dof, DOF_SECT_PROBES, prov->dofpv_probes);
+	arg_sec = dtrace_dof_sect(dof, DOF_SECT_PRARGS, prov->dofpv_prargs);
+	off_sec = dtrace_dof_sect(dof, DOF_SECT_PROFFS, prov->dofpv_proffs);
+
+	if (str_sec == NULL || prb_sec == NULL ||
+	    arg_sec == NULL || off_sec == NULL)
+		return -1;
+
+	enoff_sec = NULL;
+
+	if (dof->dofh_ident[DOF_ID_VERSION] != DOF_VERSION_1 &&
+	    prov->dofpv_prenoffs != DOF_SECT_NONE) {
+		enoff_sec = dtrace_dof_sect(dof, DOF_SECT_PRENOFFS,
+					    prov->dofpv_prenoffs);
+
+		if (enoff_sec == NULL)
+			return -1;
+	}
+
+	strtab = (char *)(uintptr_t)(daddr + str_sec->dofs_offset);
+
+	if (prov->dofpv_name >= str_sec->dofs_size ||
+	    strlen(strtab + prov->dofpv_name) >= DTRACE_PROVNAMELEN) {
+		dtrace_dof_error(dof, "invalid provider name");
+		return -1;
+	}
+
+	if (prb_sec->dofs_entsize == 0 ||
+	    prb_sec->dofs_entsize > prb_sec->dofs_size) {
+		dtrace_dof_error(dof, "invalid entry size");
+		return -1;
+	}
+
+	if (prb_sec->dofs_entsize & (sizeof(uintptr_t) - 1)) {
+		dtrace_dof_error(dof, "misaligned entry size");
+		return -1;
+	}
+
+	if (off_sec->dofs_entsize != sizeof(uint32_t)) {
+		dtrace_dof_error(dof, "invalid entry size");
+		return -1;
+	}
+
+	if (off_sec->dofs_offset & (sizeof(uint32_t) - 1)) {
+		dtrace_dof_error(dof, "misaligned section offset");
+		return -1;
+	}
+
+	if (arg_sec->dofs_entsize != sizeof(uint8_t)) {
+		dtrace_dof_error(dof, "invalid entry size");
+		return -1;
+	}
+
+	arg = (uint8_t *)(uintptr_t)(daddr + arg_sec->dofs_offset);
+	nprobes = prb_sec->dofs_size / prb_sec->dofs_entsize;
+
+	dt_dbg_dof("    DOF 0x%p %s::: with %d probes\n",
+		   dof, strtab + prov->dofpv_name, nprobes);
+
+	/*
+	 * Take a pass through the probes to check for errors.
+	 */
+	for (j = 0; j < nprobes; j++) {
+		prb = (struct dof_probe *)(uintptr_t)
+			(daddr + prb_sec->dofs_offset +
+			 j * prb_sec->dofs_entsize);
+
+		if (prb->dofpr_func >= str_sec->dofs_size) {
+			dtrace_dof_error(dof, "invalid function name");
+			return -1;
+		}
+
+		if (strlen(strtab + prb->dofpr_func) >= DTRACE_FUNCNAMELEN) {
+			dtrace_dof_error(dof, "function name too long");
+			return -1;
+		}
+
+		if (prb->dofpr_name >= str_sec->dofs_size ||
+		    strlen(strtab + prb->dofpr_name) >= DTRACE_NAMELEN) {
+			dtrace_dof_error(dof, "invalid probe name");
+			return -1;
+		}
+
+		/*
+		 * The offset count must not wrap the index, and the offsets
+		 * must also not overflow the section's data.
+		 */
+		if (prb->dofpr_offidx + prb->dofpr_noffs < prb->dofpr_offidx ||
+		    (prb->dofpr_offidx + prb->dofpr_noffs) *
+		    off_sec->dofs_entsize > off_sec->dofs_size) {
+			dtrace_dof_error(dof, "invalid probe offset");
+			return -1;
+		}
+
+		if (dof->dofh_ident[DOF_ID_VERSION] != DOF_VERSION_1) {
+			/*
+			 * If there's no is-enabled offset section, make sure
+			 * there aren't any is-enabled offsets. Otherwise
+			 * perform the same checks as for probe offsets
+			 * (immediately above).
+			 */
+			if (enoff_sec == NULL) {
+				if (prb->dofpr_enoffidx != 0 ||
+				    prb->dofpr_nenoffs != 0) {
+					dtrace_dof_error(dof,
+							 "is-enabled offsets "
+							 "with null section");
+					return -1;
+				}
+			} else if (prb->dofpr_enoffidx + prb->dofpr_nenoffs <
+				   prb->dofpr_enoffidx ||
+				   (prb->dofpr_enoffidx + prb->dofpr_nenoffs) *
+				   enoff_sec->dofs_entsize >
+				   enoff_sec->dofs_size) {
+				dtrace_dof_error(dof, "invalid is-enabled "
+						      "offset");
+				return -1;
+			}
+
+			if (prb->dofpr_noffs + prb->dofpr_nenoffs == 0) {
+				dtrace_dof_error(dof, "zero probe and "
+						      "is-enabled offsets");
+				return -1;
+			}
+		} else if (prb->dofpr_noffs == 0) {
+			dtrace_dof_error(dof, "zero probe offsets");
+			return -1;
+		}
+
+		if (prb->dofpr_argidx + prb->dofpr_xargc < prb->dofpr_argidx ||
+		    (prb->dofpr_argidx + prb->dofpr_xargc) *
+		    arg_sec->dofs_entsize > arg_sec->dofs_size) {
+			dtrace_dof_error(dof, "invalid args");
+			return -1;
+		}
+
+		typeidx = prb->dofpr_nargv;
+		typestr = strtab + prb->dofpr_nargv;
+		for (k = 0; k < prb->dofpr_nargc; k++) {
+			if (typeidx >= str_sec->dofs_size) {
+				dtrace_dof_error(dof, "bad native argument "
+						      "type");
+				return -1;
+			}
+
+			typesz = strlen(typestr) + 1;
+			if (typesz > DTRACE_ARGTYPELEN) {
+				dtrace_dof_error(dof, "native argument type "
+						      "too long");
+				return -1;
+			}
+
+			typeidx += typesz;
+			typestr += typesz;
+		}
+
+		typeidx = prb->dofpr_xargv;
+		typestr = strtab + prb->dofpr_xargv;
+		for (k = 0; k < prb->dofpr_xargc; k++) {
+			if (arg[prb->dofpr_argidx + k] > prb->dofpr_nargc) {
+				dtrace_dof_error(dof, "bad native argument "
+						      "index");
+				return -1;
+			}
+
+			if (typeidx >= str_sec->dofs_size) {
+				dtrace_dof_error(dof, "bad translated "
+						      "argument type");
+				return -1;
+			}
+
+			typesz = strlen(typestr) + 1;
+			if (typesz > DTRACE_ARGTYPELEN) {
+				dtrace_dof_error(dof, "translated argument "
+						      "type too long");
+				return -1;
+			}
+
+			typeidx += typesz;
+			typestr += typesz;
+		}
+
+		dt_dbg_dof("      Probe %d %s:%s:%s:%s with %d offsets, "
+			   "%d is-enabled offsets\n", j,
+			   strtab + prov->dofpv_name, "",
+			   strtab + prb->dofpr_func, strtab + prb->dofpr_name,
+			   prb->dofpr_noffs, prb->dofpr_nenoffs);
+	}
+
+	return 0;
+}
+
+static void dtrace_helper_action_destroy(struct dtrace_helper_action *helper,
+					 struct dtrace_vstate *vstate)
+{
+	int	i;
+
+	if (helper->dtha_predicate != NULL)
+		dtrace_difo_release(helper->dtha_predicate, vstate);
+
+	for (i = 0; i < helper->dtha_nactions; i++) {
+		ASSERT(helper->dtha_actions[i] != NULL);
+		dtrace_difo_release(helper->dtha_actions[i], vstate);
+	}
+
+	vfree(helper->dtha_actions);
+	kfree(helper);
+}
+
+static int dtrace_helper_action_add(int which, struct dtrace_ecbdesc *ep)
+{
+	struct dtrace_helpers		*dth;
+	struct dtrace_helper_action	*helper, *last;
+	struct dtrace_actdesc		*act;
+	struct dtrace_vstate		*vstate;
+	struct dtrace_predicate		*pred;
+	int				count = 0, nactions = 0, i;
+
+	if (which < 0 || which >= DTRACE_NHELPER_ACTIONS)
+		return -EINVAL;
+
+	if (current->dt_task == NULL)
+		return -ENOMEM;
+
+	dth = current->dt_task->dt_helpers;
+	last = dth->dthps_actions[which];
+	vstate = &dth->dthps_vstate;
+
+	for (count = 0; last != NULL; last = last->dtha_next) {
+		count++;
+		if (last->dtha_next == NULL)
+			break;
+	}
+
+	/*
+	 * If we already have dtrace_helper_actions_max helper actions for this
+	 * helper action type, we'll refuse to add a new one.
+	 */
+	if (count >= dtrace_helper_actions_max)
+		return -ENOSPC;
+
+	helper = kzalloc(sizeof(struct dtrace_helper_action), GFP_KERNEL);
+	if (helper == NULL)
+		return -ENOMEM;
+
+	helper->dtha_generation = dth->dthps_generation;
+
+	pred = ep->dted_pred.dtpdd_predicate;
+	if (pred != NULL) {
+		ASSERT(pred->dtp_difo != NULL);
+		dtrace_difo_hold(pred->dtp_difo);
+		helper->dtha_predicate = pred->dtp_difo;
+	}
+
+	for (act = ep->dted_action; act != NULL; act = act->dtad_next) {
+		if (act->dtad_kind != DTRACEACT_DIFEXPR)
+			goto err;
+
+		if (act->dtad_difo == NULL)
+			goto err;
+
+		nactions++;
+	}
+
+	helper->dtha_actions = vzalloc(sizeof(struct dtrace_difo *) *
+				       (helper->dtha_nactions = nactions));
+	if (helper->dtha_actions == NULL)
+		goto err;
+
+	for (act = ep->dted_action, i = 0; act != NULL; act = act->dtad_next) {
+		dtrace_difo_hold(act->dtad_difo);
+		helper->dtha_actions[i++] = act->dtad_difo;
+	}
+
+	if (!dtrace_helper_validate(helper))
+		goto err;
+
+	if (last == NULL)
+		dth->dthps_actions[which] = helper;
+	else
+		last->dtha_next = helper;
+
+	if (vstate->dtvs_nlocals > dtrace_helptrace_nlocals) {
+		dtrace_helptrace_nlocals = vstate->dtvs_nlocals;
+		dtrace_helptrace_next = 0;
+	}
+
+	return 0;
+
+err:
+	dtrace_helper_action_destroy(helper, vstate);
+	if (helper->dtha_actions != NULL)
+		vfree(helper->dtha_actions);
+	else
+		return -ENOMEM;
+
+	return -EINVAL;
+}
+
+static int dtrace_helper_provider_add(struct dof_helper *dofhp, int gen)
+{
+	struct dtrace_helpers		*dth;
+	struct dtrace_helper_provider	*hprov, **tmp_provs;
+	uint_t				tmp_maxprovs, i;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	if (current->dt_task == NULL)
+		return -ENOMEM;
+
+	dth = current->dt_task->dt_helpers;
+	ASSERT(dth != NULL);
+
+	/*
+	 * If we already have dtrace_helper_providers_max helper providers,
+	 * we're refuse to add a new one.
+	 */
+	if (dth->dthps_nprovs >= dtrace_helper_providers_max)
+		return -ENOSPC;
+
+	/*
+	 * Check to make sure this isn't a duplicate.
+	 */
+	for (i = 0; i < dth->dthps_nprovs; i++) {
+		if (dofhp->dofhp_addr ==
+		    dth->dthps_provs[i]->dthp_prov.dofhp_addr)
+			return -EALREADY;
+	}
+
+	hprov = kzalloc(sizeof(struct dtrace_helper_provider), GFP_KERNEL);
+	if (hprov == NULL)
+		return -ENOMEM;
+	hprov->dthp_prov = *dofhp;
+	hprov->dthp_ref = 1;
+	hprov->dthp_generation = gen;
+
+	/*
+	 * Allocate a bigger table for helper providers if it's already full.
+	 */
+	if (dth->dthps_maxprovs == dth->dthps_nprovs) {
+		tmp_maxprovs = dth->dthps_maxprovs;
+		tmp_provs = dth->dthps_provs;
+
+		if (dth->dthps_maxprovs == 0)
+			dth->dthps_maxprovs = 2;
+		else
+			dth->dthps_maxprovs *= 2;
+
+		if (dth->dthps_maxprovs > dtrace_helper_providers_max)
+			dth->dthps_maxprovs = dtrace_helper_providers_max;
+
+		ASSERT(tmp_maxprovs < dth->dthps_maxprovs);
+
+		dth->dthps_provs =
+		  vzalloc(dth->dthps_maxprovs *
+			  sizeof(struct dtrace_helper_provider *));
+
+		if (dth->dthps_provs == NULL) {
+			kfree(hprov);
+			return -ENOMEM;
+		}
+
+		if (tmp_provs != NULL) {
+			memcpy(dth->dthps_provs, tmp_provs,
+			       tmp_maxprovs *
+			       sizeof(struct dtrace_helper_provider *));
+			vfree(tmp_provs);
+		}
+	}
+
+	dth->dthps_provs[dth->dthps_nprovs] = hprov;
+	dth->dthps_nprovs++;
+
+	return 0;
+}
+
+static void dtrace_helper_provider_destroy(struct dtrace_helper_provider *hprov)
+{
+	mutex_lock(&dtrace_lock);
+
+	if (--hprov->dthp_ref == 0) {
+		struct dof_hdr	*dof;
+
+		mutex_unlock(&dtrace_lock);
+
+		dof = (struct dof_hdr *)(uintptr_t)hprov->dthp_prov.dofhp_dof;
+		dtrace_dof_destroy(dof);
+		kfree(hprov);
+	} else
+		mutex_unlock(&dtrace_lock);
+}
+
+static void dtrace_dofattr2attr(struct dtrace_attribute *attr,
+				const dof_attr_t dofattr)
+{
+	attr->dtat_name = DOF_ATTR_NAME(dofattr);
+	attr->dtat_data = DOF_ATTR_DATA(dofattr);
+	attr->dtat_class = DOF_ATTR_CLASS(dofattr);
+}
+
+static void dtrace_dofprov2hprov(struct dtrace_helper_provdesc *hprov,
+				 const struct dof_provider *dofprov,
+				 char *strtab)
+{
+	hprov->dthpv_provname = strtab + dofprov->dofpv_name;
+	dtrace_dofattr2attr(&hprov->dthpv_pattr.dtpa_provider,
+			    dofprov->dofpv_provattr);
+	dtrace_dofattr2attr(&hprov->dthpv_pattr.dtpa_mod,
+			    dofprov->dofpv_modattr);
+	dtrace_dofattr2attr(&hprov->dthpv_pattr.dtpa_func,
+			    dofprov->dofpv_funcattr);
+	dtrace_dofattr2attr(&hprov->dthpv_pattr.dtpa_name,
+			    dofprov->dofpv_nameattr);
+	dtrace_dofattr2attr(&hprov->dthpv_pattr.dtpa_args,
+			    dofprov->dofpv_argsattr);
+}
+
+static void dtrace_helper_provider_remove_one(struct dof_helper *dhp,
+					      struct dof_sec *sec, pid_t pid)
+{
+	uintptr_t			daddr = (uintptr_t)dhp->dofhp_dof;
+	struct dof_hdr			*dof = (struct dof_hdr *)daddr;
+	struct dof_sec			*str_sec;
+	struct dof_provider		*prov;
+	char				*strtab;
+	struct dtrace_helper_provdesc	dhpv;
+	struct dtrace_meta		*meta = dtrace_meta_pid;
+	struct dtrace_mops		*mops = &meta->dtm_mops;
+
+	prov = (struct dof_provider *)(uintptr_t)(daddr + sec->dofs_offset);
+	str_sec = (struct dof_sec *)(uintptr_t)(daddr + dof->dofh_secoff +
+						prov->dofpv_strtab *
+						dof->dofh_secsize);
+
+	strtab = (char *)(uintptr_t)(daddr + str_sec->dofs_offset);
+
+	/*
+	 * Create the provider.
+	 */
+	dtrace_dofprov2hprov(&dhpv, prov, strtab);
+
+	dt_dbg_dof("    Removing provider %s for PID %d\n",
+		   dhpv.dthpv_provname, pid);
+
+	mops->dtms_remove_pid(meta->dtm_arg, &dhpv, pid);
+
+	meta->dtm_count--;
+}
+
+static void dtrace_helper_provider_remove(struct dof_helper *dhp, pid_t pid)
+{
+	uintptr_t	daddr = (uintptr_t)dhp->dofhp_dof;
+	struct dof_hdr	*dof = (struct dof_hdr *)daddr;
+	int		i;
+
+	ASSERT(MUTEX_HELD(&dtrace_meta_lock));
+
+	for (i = 0; i < dof->dofh_secnum; i++) {
+		struct dof_sec *sec;
+
+		sec = (struct dof_sec *)(uintptr_t) (daddr + dof->dofh_secoff +
+						     i * dof->dofh_secsize);
+
+		if (sec->dofs_type != DOF_SECT_PROVIDER)
+			continue;
+
+		dtrace_helper_provider_remove_one(dhp, sec, pid);
+	}
+}
+
+static void dtrace_helper_provide_one(struct dof_helper *dhp,
+				      struct dof_sec *sec,
+				      pid_t pid)
+{
+	uintptr_t	daddr = (uintptr_t)dhp->dofhp_dof;
+	uint32_t	*off, *enoff;
+	uint8_t		*arg;
+	char		*strtab;
+	uint_t		i, nprobes;
+	void		*parg;
+
+	struct dof_hdr			*dof = (struct dof_hdr *)daddr;
+	struct dof_sec			*str_sec, *prb_sec, *arg_sec, *off_sec,
+					*enoff_sec;
+	struct dof_provider		*prov;
+	struct dof_probe		*probe;
+	struct dtrace_helper_provdesc	dhpv;
+	struct dtrace_helper_probedesc	dhpb;
+	struct dtrace_meta		*meta = dtrace_meta_pid;
+	struct dtrace_mops		*mops = &meta->dtm_mops;
+
+	prov = (struct dof_provider *)(uintptr_t)(daddr + sec->dofs_offset);
+	str_sec = (struct dof_sec *)(uintptr_t)(daddr + dof->dofh_secoff +
+						prov->dofpv_strtab *
+						dof->dofh_secsize);
+	prb_sec = (struct dof_sec *)(uintptr_t)(daddr + dof->dofh_secoff +
+						prov->dofpv_probes *
+						dof->dofh_secsize);
+	arg_sec = (struct dof_sec *)(uintptr_t)(daddr + dof->dofh_secoff +
+						prov->dofpv_prargs *
+						dof->dofh_secsize);
+	off_sec = (struct dof_sec *)(uintptr_t)(daddr + dof->dofh_secoff +
+						prov->dofpv_proffs *
+						dof->dofh_secsize);
+
+	strtab = (char *)(uintptr_t)(daddr + str_sec->dofs_offset);
+	off = (uint32_t *)(uintptr_t)(daddr + off_sec->dofs_offset);
+	arg = (uint8_t *)(uintptr_t)(daddr + arg_sec->dofs_offset);
+	enoff = NULL;
+
+	/*
+	 * See dtrace_helper_provider_validate().
+	 */
+	if (dof->dofh_ident[DOF_ID_VERSION] != DOF_VERSION_1 &&
+	    prov->dofpv_prenoffs != DOF_SECT_NONE) {
+		enoff_sec = (struct dof_sec *)(uintptr_t)
+		  (daddr + dof->dofh_secoff +
+		   prov->dofpv_prenoffs * dof->dofh_secsize);
+		enoff = (uint32_t *)(uintptr_t)
+		  (daddr + enoff_sec->dofs_offset);
+	}
+
+	nprobes = prb_sec->dofs_size / prb_sec->dofs_entsize;
+
+	/*
+	 * Create the provider.
+	 */
+	dtrace_dofprov2hprov(&dhpv, prov, strtab);
+
+	dt_dbg_dof("    Creating provider %s for PID %d\n",
+		   strtab + prov->dofpv_name, pid);
+
+	/*
+	 * This used to just 'return;' when parg is NULL, but that causes the
+	 * cleanup code (dtrace_helper_provider_remove[_one]) to make a call
+	 * to dtms_remove_pid() for a provider that never got created.
+	 *
+	 * If we fail to provide this provider, mark it as something to ignore,
+	 * so we don't try to process it during cleanup.
+	 */
+	parg = mops->dtms_provide_pid(meta->dtm_arg, &dhpv, pid);
+	if (parg == NULL) {
+		sec->dofs_type = DOF_SECT_NONE;
+		return;
+	}
+
+	meta->dtm_count++;
+
+	/*
+	 * Create the probes.
+	 */
+	for (i = 0; i < nprobes; i++) {
+		probe = (struct dof_probe *)(uintptr_t)(daddr +
+						   prb_sec->dofs_offset +
+						   i * prb_sec->dofs_entsize);
+
+		dhpb.dthpb_mod = dhp->dofhp_mod;
+		dhpb.dthpb_func = strtab + probe->dofpr_func;
+		dhpb.dthpb_name = strtab + probe->dofpr_name;
+		dhpb.dthpb_base = probe->dofpr_addr;
+		dhpb.dthpb_offs = off + probe->dofpr_offidx;
+		dhpb.dthpb_noffs = probe->dofpr_noffs;
+
+		if (enoff != NULL) {
+			dhpb.dthpb_enoffs = enoff + probe->dofpr_enoffidx;
+			dhpb.dthpb_nenoffs = probe->dofpr_nenoffs;
+		} else {
+			dhpb.dthpb_enoffs = NULL;
+			dhpb.dthpb_nenoffs = 0;
+		}
+
+		dhpb.dthpb_args = arg + probe->dofpr_argidx;
+		dhpb.dthpb_nargc = probe->dofpr_nargc;
+		dhpb.dthpb_xargc = probe->dofpr_xargc;
+		dhpb.dthpb_ntypes = strtab + probe->dofpr_nargv;
+		dhpb.dthpb_xtypes = strtab + probe->dofpr_xargv;
+
+		dt_dbg_dof("      Creating probe %s:%s:%s:%s\n",
+			   strtab + prov->dofpv_name, "", dhpb.dthpb_func,
+			   dhpb.dthpb_name);
+
+		mops->dtms_create_probe(meta->dtm_arg, parg, &dhpb);
+	}
+}
+
+void dtrace_helper_provide(struct dof_helper *dhp, pid_t pid)
+{
+	uintptr_t	daddr = (uintptr_t)dhp->dofhp_dof;
+	struct dof_hdr	*dof = (struct dof_hdr *)daddr;
+	int		i;
+
+	ASSERT(MUTEX_HELD(&dtrace_meta_lock));
+
+	for (i = 0; i < dof->dofh_secnum; i++) {
+		struct dof_sec *sec;
+
+		sec = (struct dof_sec *)(uintptr_t) (daddr + dof->dofh_secoff +
+						     i * dof->dofh_secsize);
+
+		if (sec->dofs_type != DOF_SECT_PROVIDER)
+			continue;
+
+		dtrace_helper_provide_one(dhp, sec, pid);
+	}
+
+	/*
+	 * We may have just created probes, so we must now rematch against any
+	 * retained enablings.  Note that this call will acquire both cpu_lock
+	 * and dtrace_lock; the fact that we are holding dtrace_meta_lock now
+	 * is what defines the ordering with respect to these three locks.
+	 */
+	dt_dbg_dof("    Re-matching against any retained enablings\n");
+	dtrace_enabling_matchall();
+}
+
+static void dtrace_helper_provider_register(struct task_struct *tsk,
+					    struct dtrace_helpers *dth,
+					    struct dof_helper *dofhp)
+{
+	ASSERT(!MUTEX_HELD(&dtrace_lock));
+
+	mutex_lock(&dtrace_meta_lock);
+	mutex_lock(&dtrace_lock);
+
+	if (!dtrace_attached() || dtrace_meta_pid == NULL) {
+		dt_dbg_dof("    No meta provider registered -- deferred\n");
+
+		/*
+		 * If the dtrace module is loaded but not attached, or if there
+		 * isn't a meta provider registered to deal with these provider
+		 * descriptions, we need to postpone creating the actual
+		 * providers until later.
+		 */
+		if (dth->dthps_next == NULL && dth->dthps_prev == NULL &&
+		    dtrace_deferred_pid != dth) {
+			dth->dthps_deferred = 1;
+			dth->dthps_pid = tsk->pid;
+			dth->dthps_next = dtrace_deferred_pid;
+			dth->dthps_prev = NULL;
+			if (dtrace_deferred_pid != NULL)
+				dtrace_deferred_pid->dthps_prev = dth;
+			dtrace_deferred_pid = dth;
+		}
+
+		mutex_unlock(&dtrace_lock);
+	} else if (dofhp != NULL) {
+		/*
+		 * If the dtrace module is loaded and we have a particular
+		 * helper provider description, pass that off to the meta
+		 * provider.
+		 */
+		mutex_unlock(&dtrace_lock);
+
+		dtrace_helper_provide(dofhp, tsk->pid);
+	} else {
+		/*
+		 * Otherwise, just pass all the helper provider descriptions
+		 * off to the meta provider.
+		 */
+		int	i;
+
+		mutex_unlock(&dtrace_lock);
+
+		for (i = 0; i < dth->dthps_nprovs; i++) {
+			dtrace_helper_provide(&dth->dthps_provs[i]->dthp_prov,
+					      tsk->pid);
+		}
+	}
+
+	mutex_unlock(&dtrace_meta_lock);
+}
+
+int dtrace_helper_slurp(struct dof_hdr *dof, struct dof_helper *dhp)
+{
+	struct dtrace_helpers	*dth;
+	struct dtrace_vstate	*vstate;
+	struct dtrace_enabling	*enab = NULL;
+	int			i, gen, rv;
+	int			nhelpers = 0, nprovs = 0, destroy = 1;
+	uintptr_t		daddr = (uintptr_t)dof;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	if (current->dt_task == NULL)
+		return -1;
+
+	dth = current->dt_task->dt_helpers;
+	if (dth == NULL)
+		dth = dtrace_helpers_create(current);
+
+	if (dth == NULL) {
+		dtrace_dof_destroy(dof);
+		return -1;
+	}
+
+	dt_dbg_dof("DOF 0x%p from helper {'%s', %p, %p}...\n",
+		   dof, dhp ? dhp->dofhp_mod : "<none>",
+			dhp ? (void *)(dhp->dofhp_addr) : NULL,
+			dhp ? (void *)(dhp->dofhp_dof) : NULL);
+
+	vstate = &dth->dthps_vstate;
+
+	rv = dtrace_dof_slurp(dof, vstate, NULL, &enab,
+			      dhp != NULL ? dhp->dofhp_addr : 0, FALSE);
+	if (rv != 0) {
+		dtrace_dof_destroy(dof);
+		return rv;
+	}
+
+	/*
+	 * Look for helper providers and validate their descriptions.
+	 */
+	if (dhp != NULL) {
+		dt_dbg_dof("  DOF 0x%p Validating providers...\n", dof);
+
+		for (i = 0; i < dof->dofh_secnum; i++) {
+			struct dof_sec *sec;
+
+			sec = (struct dof_sec *)(uintptr_t)
+				(daddr + dof->dofh_secoff +
+				 i * dof->dofh_secsize);
+
+			if (sec->dofs_type != DOF_SECT_PROVIDER)
+				continue;
+
+			if (dtrace_helper_provider_validate(dof, sec) != 0) {
+				dtrace_enabling_destroy(enab);
+				dtrace_dof_destroy(dof);
+				return -1;
+			}
+
+			nprovs++;
+		}
+	}
+
+	/*
+	 * Now we need to walk through the ECB descriptions in the enabling.
+	 */
+	for (i = 0; i < enab->dten_ndesc; i++) {
+		struct dtrace_ecbdesc	*ep = enab->dten_desc[i];
+		struct dtrace_probedesc	*desc = &ep->dted_probe;
+
+		dt_dbg_dof("  ECB Desc %s:%s:%s:%s\n",
+			   desc->dtpd_provider, desc->dtpd_mod,
+			   desc->dtpd_func, desc->dtpd_name);
+		if (strcmp(desc->dtpd_provider, "dtrace") != 0)
+			continue;
+
+		if (strcmp(desc->dtpd_mod, "helper") != 0)
+			continue;
+
+		if (strcmp(desc->dtpd_func, "ustack") != 0)
+			continue;
+
+		rv = dtrace_helper_action_add(DTRACE_HELPER_ACTION_USTACK, ep);
+		if (rv != 0) {
+			/*
+			 * Adding this helper action failed -- we are now going
+			 * to rip out the entire generation and return failure.
+			 */
+			dtrace_helper_destroygen(dth->dthps_generation);
+			dtrace_enabling_destroy(enab);
+			dtrace_dof_destroy(dof);
+			return -1;
+		}
+
+		nhelpers++;
+	}
+
+	if (nhelpers < enab->dten_ndesc)
+		dtrace_dof_error(dof, "unmatched helpers");
+
+	gen = dth->dthps_generation++;
+	dtrace_enabling_destroy(enab);
+
+	if (dhp != NULL && nprovs > 0) {
+		dt_dbg_dof("  DOF 0x%p Adding and registering providers\n",
+			   dof);
+
+		dhp->dofhp_dof = (uint64_t)(uintptr_t)dof;
+		if (dtrace_helper_provider_add(dhp, gen) == 0) {
+			mutex_unlock(&dtrace_lock);
+			dtrace_helper_provider_register(current, dth, dhp);
+			mutex_lock(&dtrace_lock);
+
+			destroy = 0;
+		}
+	}
+
+	if (destroy)
+		dtrace_dof_destroy(dof);
+
+	return gen;
+}
+
+void dtrace_helpers_destroy(struct task_struct *tsk)
+{
+	struct dtrace_helpers	*help;
+	struct dtrace_vstate	*vstate;
+	int			i;
+
+	if (tsk->dt_task == NULL)
+		return;
+
+	mutex_lock(&dtrace_lock);
+
+	ASSERT(tsk->dt_task->dt_helpers != NULL);
+	ASSERT(dtrace_helpers > 0);
+
+	dt_dbg_dof("Helper cleanup: PID %d\n", tsk->pid);
+
+	help = tsk->dt_task->dt_helpers;
+	vstate = &help->dthps_vstate;
+
+	/*
+	 * We're now going to lose the help from this process.
+	 */
+	tsk->dt_task->dt_helpers = NULL;
+	dtrace_sync();
+
+	/*
+	 * Destroy the helper actions.
+	 */
+	for (i = 0; i < DTRACE_NHELPER_ACTIONS; i++) {
+		struct dtrace_helper_action *h, *next;
+
+		for (h = help->dthps_actions[i]; h != NULL; h = next) {
+			next = h->dtha_next;
+			dtrace_helper_action_destroy(h, vstate);
+			h = next;
+		}
+	}
+
+	mutex_unlock(&dtrace_lock);
+
+	/*
+	 * Destroy the helper providers.
+	 */
+	if (help->dthps_maxprovs > 0) {
+		mutex_lock(&dtrace_meta_lock);
+		if (dtrace_meta_pid != NULL) {
+			ASSERT(dtrace_deferred_pid == NULL);
+
+			for (i = 0; i < help->dthps_nprovs; i++) {
+				dtrace_helper_provider_remove(
+					&help->dthps_provs[i]->dthp_prov,
+					tsk->pid);
+			}
+		} else {
+			mutex_lock(&dtrace_lock);
+			ASSERT(help->dthps_deferred == 0 ||
+			       help->dthps_next != NULL ||
+			       help->dthps_prev != NULL ||
+			       help == dtrace_deferred_pid);
+
+			/*
+			 * Remove the helper from the deferred list.
+			 */
+			if (help->dthps_next != NULL)
+				help->dthps_next->dthps_prev = help->dthps_prev;
+			if (help->dthps_prev != NULL)
+				help->dthps_prev->dthps_next = help->dthps_next;
+			if (dtrace_deferred_pid == help) {
+				dtrace_deferred_pid = help->dthps_next;
+				ASSERT(help->dthps_prev == NULL);
+			}
+
+			mutex_unlock(&dtrace_lock);
+		}
+
+		mutex_unlock(&dtrace_meta_lock);
+
+		for (i = 0; i < help->dthps_nprovs; i++)
+			dtrace_helper_provider_destroy(help->dthps_provs[i]);
+
+		vfree(help->dthps_provs);
+	}
+
+	mutex_lock(&dtrace_lock);
+
+	dtrace_vstate_fini(&help->dthps_vstate);
+	vfree(help->dthps_actions);
+	kfree(help);
+
+	--dtrace_helpers;
+	mutex_unlock(&dtrace_lock);
+}
+
+void dtrace_helpers_duplicate(struct task_struct *from, struct task_struct *to)
+{
+	struct dtrace_task		*dfrom = from->dt_task;
+	struct dtrace_task		*dto = to->dt_task;
+	struct dtrace_helpers		*help, *newhelp;
+	struct dtrace_helper_action	*helper, *new, *last;
+	struct dtrace_difo		*dp;
+	struct dtrace_vstate		*vstate;
+
+	int i, j, sz, hasprovs = 0;
+
+	if (dfrom == NULL || dto == NULL)
+		return;
+
+	mutex_lock(&dtrace_lock);
+
+	ASSERT(dfrom->dt_helpers != NULL);
+	ASSERT(dtrace_helpers > 0);
+
+	help = dfrom->dt_helpers;
+	newhelp = dtrace_helpers_create(to);
+
+	ASSERT(dto->dt_helpers != NULL);
+
+	newhelp->dthps_generation = help->dthps_generation;
+	vstate = &newhelp->dthps_vstate;
+
+	/*
+	 * Duplicate the helper actions.
+	 */
+	for (i = 0; i < DTRACE_NHELPER_ACTIONS; i++) {
+		helper = help->dthps_actions[i];
+		if (helper == NULL)
+			continue;
+
+		for (last = NULL; helper != NULL; helper = helper->dtha_next) {
+			new = kzalloc(sizeof(struct dtrace_helper_action),
+				      GFP_KERNEL);
+			new->dtha_generation = helper->dtha_generation;
+
+			dp = helper->dtha_predicate;
+			if (dp != NULL) {
+				dp = dtrace_difo_duplicate(dp, vstate);
+				new->dtha_predicate = dp;
+			}
+
+			new->dtha_nactions = helper->dtha_nactions;
+			sz = sizeof(struct dtrace_difo *) * new->dtha_nactions;
+			new->dtha_actions = vmalloc(sz);
+
+			for (j = 0; j < new->dtha_nactions; j++) {
+				struct dtrace_difo *dp;
+
+				dp = helper->dtha_actions[j];
+				ASSERT(dp != NULL);
+
+				dp = dtrace_difo_duplicate(dp, vstate);
+				new->dtha_actions[j] = dp;
+			}
+
+			if (last != NULL)
+				last->dtha_next = new;
+			else
+				newhelp->dthps_actions[i] = new;
+
+			last = new;
+		}
+	}
+
+	/*
+	 * Duplicate the helper providers and register them with the
+	 * DTrace framework.
+	 */
+	if (help->dthps_nprovs > 0) {
+		newhelp->dthps_nprovs = help->dthps_nprovs;
+		newhelp->dthps_maxprovs = help->dthps_nprovs;
+		newhelp->dthps_provs = vmalloc(
+			newhelp->dthps_nprovs *
+			sizeof(struct dtrace_helper_provider *));
+
+		for (i = 0; i < newhelp->dthps_nprovs; i++) {
+			newhelp->dthps_provs[i] = help->dthps_provs[i];
+			newhelp->dthps_provs[i]->dthp_ref++;
+		}
+
+		hasprovs = 1;
+	}
+
+	mutex_unlock(&dtrace_lock);
+
+	if (hasprovs)
+		dtrace_helper_provider_register(to, newhelp, NULL);
+}
+
+int dtrace_helper_destroygen(int gen)
+{
+	struct task_struct	*p = current;
+	struct dtrace_helpers	*dth;
+	struct dtrace_vstate	*vstate;
+	int			i;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	if (current->dt_task == NULL)
+		return -ENOMEM;
+
+	dth = current->dt_task->dt_helpers;
+
+	if (dth == NULL || gen > dth->dthps_generation)
+		return -EINVAL;
+
+	vstate = &dth->dthps_vstate;
+
+	for (i = 0; i < DTRACE_NHELPER_ACTIONS; i++) {
+		struct dtrace_helper_action *last = NULL, *h, *next;
+
+		for (h = dth->dthps_actions[i]; h != NULL; h = next) {
+			next = h->dtha_next;
+
+			dt_dbg_dof("  Comparing action (agen %d vs rgen %d)\n",
+				   h->dtha_generation, gen);
+
+			if (h->dtha_generation == gen) {
+				if (last != NULL)
+					last->dtha_next = next;
+				else
+					dth->dthps_actions[i] = next;
+
+				dtrace_helper_action_destroy(h, vstate);
+			} else
+				last = h;
+		}
+	}
+
+	/*
+	 * Iterate until we've cleared out all helper providers with the given
+	 * generation number.
+	 */
+	for (;;) {
+		struct dtrace_helper_provider	*prov = NULL;
+
+		/*
+		 * Look for a helper provider with the right generation.  We
+		 * have to start back at the beginning of the list each time
+		 * because we drop dtrace_lock.  It's unlikely that we'll make
+		 * more than two passes.
+		 */
+		for (i = 0; i < dth->dthps_nprovs; i++) {
+			prov = dth->dthps_provs[i];
+
+			if (prov->dthp_generation == gen)
+				break;
+		}
+
+		/*
+		 * If there were no matches, we are done.
+		 */
+		if (i == dth->dthps_nprovs)
+			break;
+
+		dt_dbg_dof("  Found provider with gen %d\n", gen);
+
+		/*
+		 * Move the last helper provider into this slot.
+		 */
+		dth->dthps_nprovs--;
+		dth->dthps_provs[i] = dth->dthps_provs[dth->dthps_nprovs];
+		dth->dthps_provs[dth->dthps_nprovs] = NULL;
+
+		mutex_unlock(&dtrace_lock);
+
+		/*
+		 * If we have a meta provider, remove this helper provider.
+		 */
+		mutex_lock(&dtrace_meta_lock);
+
+		if (dtrace_meta_pid != NULL) {
+			ASSERT(dtrace_deferred_pid == NULL);
+
+			dtrace_helper_provider_remove(&prov->dthp_prov,
+						      p->pid);
+		}
+
+		mutex_unlock(&dtrace_meta_lock);
+
+		dtrace_helper_provider_destroy(prov);
+
+		mutex_lock(&dtrace_lock);
+	}
+
+	return 0;
+}
+
+static void dtrace_helper_trace(struct dtrace_helper_action *helper,
+				struct dtrace_mstate *mstate,
+				struct dtrace_vstate *vstate, int where)
+{
+	uint32_t		size, next, nnext, i;
+	struct dtrace_helptrace	*ent;
+	uint16_t		flags = this_cpu_core->cpuc_dtrace_flags;
+
+	if (!dtrace_helptrace_enabled)
+		return;
+
+	ASSERT(vstate->dtvs_nlocals <= dtrace_helptrace_nlocals);
+
+	/*
+	 * What would a tracing framework be without its own tracing
+	 * framework?  (Well, a hell of a lot simpler, for starters...)
+	 */
+	size = sizeof(struct dtrace_helptrace) + dtrace_helptrace_nlocals *
+	       sizeof(uint64_t) - sizeof(uint64_t);
+
+	/*
+	 * Iterate until we can allocate a slot in the trace buffer.
+	 */
+	do {
+		next = dtrace_helptrace_next;
+
+		if (next + size < dtrace_helptrace_bufsize)
+			nnext = next + size;
+		else
+			nnext = size;
+	} while (cmpxchg(&dtrace_helptrace_next, next, nnext) != next);
+
+	/*
+	 * We have our slot; fill it in.
+	 */
+	if (nnext == size)
+		next = 0;
+
+	ent = (struct dtrace_helptrace *)&dtrace_helptrace_buffer[next];
+	ent->dtht_helper = helper;
+	ent->dtht_where = where;
+	ent->dtht_nlocals = vstate->dtvs_nlocals;
+
+	ent->dtht_fltoffs = (mstate->dtms_present & DTRACE_MSTATE_FLTOFFS)
+				?  mstate->dtms_fltoffs
+				: -1;
+	ent->dtht_fault = DTRACE_FLAGS2FLT(flags);
+	ent->dtht_illval = this_cpu_core->cpuc_dtrace_illval;
+
+	for (i = 0; i < vstate->dtvs_nlocals; i++) {
+		struct dtrace_statvar	*svar;
+
+		svar = vstate->dtvs_locals[i];
+		if (svar == NULL)
+			continue;
+
+		ASSERT(svar->dtsv_size >= NR_CPUS * sizeof(uint64_t));
+		ent->dtht_locals[i] =
+			((uint64_t *)(uintptr_t)svar->dtsv_data)[
+							smp_processor_id()];
+	}
+}
+
+uint64_t dtrace_helper(int which, struct dtrace_mstate *mstate,
+		       struct dtrace_state *state, uint64_t arg0,
+		       uint64_t arg1)
+{
+	uint16_t		*flags = &this_cpu_core->cpuc_dtrace_flags;
+	uint64_t		sarg0 = mstate->dtms_arg[0];
+	uint64_t		sarg1 = mstate->dtms_arg[1];
+	uint64_t		rval = 0;
+	struct dtrace_helpers	*helpers;
+	struct dtrace_helper_action *helper;
+	struct dtrace_vstate	*vstate;
+	struct dtrace_difo	*pred;
+	int			i, trace = dtrace_helptrace_enabled;
+
+	ASSERT(which >= 0 && which < DTRACE_NHELPER_ACTIONS);
+
+	if (current->dt_task == NULL)
+		return 0;
+
+	helpers = current->dt_task->dt_helpers;
+	if (helpers == NULL)
+		return 0;
+
+	helper = helpers->dthps_actions[which];
+	if (helper == NULL)
+		return 0;
+
+	vstate = &helpers->dthps_vstate;
+	mstate->dtms_arg[0] = arg0;
+	mstate->dtms_arg[1] = arg1;
+
+	/*
+	 * Now iterate over each helper.  If its predicate evaluates to 'true',
+	 * we'll call the corresponding actions.  Note that the below calls
+	 * to dtrace_dif_emulate() may set faults in machine state.  This is
+	 * okay:  our caller (the outer dtrace_dif_emulate()) will simply plow
+	 * the stored DIF offset with its own (which is the desired behavior).
+	 * Also, note the calls to dtrace_dif_emulate() may allocate scratch
+	 * from machine state; this is okay, too.
+	 */
+	for (; helper != NULL; helper = helper->dtha_next) {
+		pred = helper->dtha_predicate;
+		if (pred != NULL) {
+			if (trace)
+				dtrace_helper_trace(helper, mstate, vstate, 0);
+
+			if (!dtrace_dif_emulate(pred, mstate, vstate, state))
+				goto next;
+
+			if (*flags & CPU_DTRACE_FAULT)
+				goto err;
+		}
+
+		for (i = 0; i < helper->dtha_nactions; i++) {
+			if (trace)
+				dtrace_helper_trace(helper, mstate, vstate,
+						    i + 1);
+
+			rval = dtrace_dif_emulate(helper->dtha_actions[i],
+						  mstate, vstate, state);
+
+			if (*flags & CPU_DTRACE_FAULT)
+				goto err;
+		}
+
+next:
+		if (trace)
+			dtrace_helper_trace(helper, mstate, vstate,
+					    DTRACE_HELPTRACE_NEXT);
+	}
+
+	if (trace)
+		dtrace_helper_trace(helper, mstate, vstate,
+				    DTRACE_HELPTRACE_DONE);
+
+	/*
+	 * Restore the arg0 that we saved upon entry.
+	 */
+	mstate->dtms_arg[0] = sarg0;
+	mstate->dtms_arg[1] = sarg1;
+
+	return rval;
+
+err:
+	if (trace)
+		dtrace_helper_trace(helper, mstate, vstate,
+				    DTRACE_HELPTRACE_ERR);
+
+	/*
+	 * Restore the arg0 that we saved upon entry.
+	 */
+	mstate->dtms_arg[0] = sarg0;
+	mstate->dtms_arg[1] = sarg1;
+
+	return 0;
+}
diff --git a/dtrace/dtrace_ecb.c b/dtrace/dtrace_ecb.c
new file mode 100644
index 000000000000..cc04d1a14661
--- /dev/null
+++ b/dtrace/dtrace_ecb.c
@@ -0,0 +1,936 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_ecb.c
+ * DESCRIPTION:	DTrace - ECB implementation
+ *
+ * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#include "dtrace.h"
+
+struct dtrace_ecb	*dtrace_ecb_create_cache;
+
+static struct dtrace_action *
+dtrace_ecb_aggregation_create(struct dtrace_ecb *ecb,
+                              struct dtrace_actdesc *desc)
+{
+	struct dtrace_aggregation *agg;
+	size_t			size = sizeof(uint64_t);
+	int			ntuple = desc->dtad_ntuple;
+	struct dtrace_action	*act;
+	struct dtrace_recdesc	*frec;
+	dtrace_aggid_t		aggid;
+	struct dtrace_state	*state = ecb->dte_state;
+
+	agg = kzalloc(sizeof(struct dtrace_aggregation), GFP_KERNEL);
+	if (agg == NULL)
+		return NULL;
+
+	agg->dtag_ecb = ecb;
+
+	ASSERT(DTRACEACT_ISAGG(desc->dtad_kind));
+
+	switch (desc->dtad_kind) {
+	case DTRACEAGG_MIN:
+		agg->dtag_initial = INT64_MAX;
+		agg->dtag_aggregate = dtrace_aggregate_min;
+		break;
+
+	case DTRACEAGG_MAX:
+		agg->dtag_initial = INT64_MIN;
+		agg->dtag_aggregate = dtrace_aggregate_max;
+		break;
+
+	case DTRACEAGG_COUNT:
+		agg->dtag_aggregate = dtrace_aggregate_count;
+		break;
+
+	case DTRACEAGG_QUANTIZE:
+		agg->dtag_aggregate = dtrace_aggregate_quantize;
+		size = (((sizeof(uint64_t) * NBBY) - 1) * 2 + 1) *
+		       sizeof(uint64_t);
+		break;
+
+	case DTRACEAGG_LQUANTIZE: {
+		uint16_t	step = DTRACE_LQUANTIZE_STEP(desc->dtad_arg);
+		uint16_t	levels =
+				DTRACE_LQUANTIZE_LEVELS(desc->dtad_arg);
+
+		agg->dtag_initial = desc->dtad_arg;
+		agg->dtag_aggregate = dtrace_aggregate_lquantize;
+
+		if (step == 0 || levels == 0)
+			goto err;
+
+		size = levels * sizeof(uint64_t) + 3 * sizeof(uint64_t);
+		break;
+	}
+
+	case DTRACEAGG_LLQUANTIZE: {
+		uint16_t factor = DTRACE_LLQUANTIZE_FACTOR(desc->dtad_arg);
+		uint16_t lmag = DTRACE_LLQUANTIZE_LMAG(desc->dtad_arg);
+		uint16_t hmag = DTRACE_LLQUANTIZE_HMAG(desc->dtad_arg);
+		uint16_t steps = DTRACE_LLQUANTIZE_STEPS(desc->dtad_arg);
+		uint64_t buf64s;
+
+		agg->dtag_initial = desc->dtad_arg;
+		agg->dtag_aggregate = dtrace_aggregate_llquantize;
+
+		/*
+		 * 64 is the largest hmag can practically be (for the smallest
+		 * possible value of factor, 2).  libdtrace has already checked
+		 * for overflow, so if hmag > 64, we have corrupted DOF.
+		 */
+		if (factor < 2 || steps == 0 || hmag > 64)
+			goto err;
+
+		/*
+		 * The size of the buffer for an llquantize() is given by:
+		 *   (hmag-lmag+1) logarithmic ranges
+		 *   x
+		 *   (steps - steps/factor) bins per range
+		 *   x
+		 *   2 signs
+		 *   +
+		 *   two overflow bins
+		 *   +
+		 *   one underflow bin
+		 *   +
+		 *   beginning word to encode factor,lmag,hmag,steps
+		 */
+		buf64s = ((hmag-lmag+1)*(steps-steps/factor)*2+4);
+		size = buf64s * sizeof(uint64_t);
+		break;
+	}
+
+	case DTRACEAGG_AVG:
+		agg->dtag_aggregate = dtrace_aggregate_avg;
+		size = sizeof(uint64_t) * 2;
+		break;
+
+	case DTRACEAGG_STDDEV:
+		agg->dtag_aggregate = dtrace_aggregate_stddev;
+		size = sizeof(uint64_t) * 4;
+		break;
+
+	case DTRACEAGG_SUM:
+		agg->dtag_aggregate = dtrace_aggregate_sum;
+		break;
+
+	default:
+		goto err;
+	}
+
+	agg->dtag_action.dta_rec.dtrd_size = size;
+
+	if (ntuple == 0)
+		goto err;
+
+	for (act = ecb->dte_action_last; act != NULL; act = act->dta_prev) {
+		if (DTRACEACT_ISAGG(act->dta_kind))
+			break;
+
+		if (--ntuple == 0) {
+			agg->dtag_first = act;
+			goto success;
+		}
+	}
+
+	ASSERT(ntuple != 0);
+err:
+	kfree(agg);
+	return NULL;
+
+success:
+	ASSERT(ecb->dte_action_last != NULL);
+	act = ecb->dte_action_last;
+
+	if (act->dta_kind == DTRACEACT_DIFEXPR) {
+		ASSERT(act->dta_difo != NULL);
+
+		if (act->dta_difo->dtdo_rtype.dtdt_size == 0)
+			agg->dtag_hasarg = 1;
+	}
+
+	/*
+	 * Get an ID for the aggregation (add it to the idr).
+	 */
+	idr_preload(GFP_KERNEL);
+	aggid = idr_alloc_cyclic(&state->dts_agg_idr, agg, 0, 0, GFP_NOWAIT);
+	idr_preload_end();
+	if (aggid < 0) {
+		/* FIXME: need to handle this */
+	}
+
+	state->dts_naggs++;
+	agg->dtag_id = aggid;
+
+	frec = &agg->dtag_first->dta_rec;
+	if (frec->dtrd_alignment < sizeof(dtrace_aggid_t))
+		frec->dtrd_alignment = sizeof(dtrace_aggid_t);
+
+	for (act = agg->dtag_first; act != NULL; act = act->dta_next) {
+		ASSERT(!act->dta_intuple);
+
+		act->dta_intuple = 1;
+	}
+
+	return &agg->dtag_action;
+}
+
+void dtrace_ecb_aggregation_destroy(struct dtrace_ecb *ecb,
+				    struct dtrace_action *act)
+{
+	struct dtrace_aggregation	*agg = (struct dtrace_aggregation *)act;
+	struct dtrace_state		*state = ecb->dte_state;
+
+	ASSERT(DTRACEACT_ISAGG(act->dta_kind));
+
+	idr_remove(&state->dts_agg_idr, agg->dtag_id);
+	state->dts_naggs--;
+
+	kfree(agg);
+}
+
+static int dtrace_ecb_action_add(struct dtrace_ecb *ecb,
+				 struct dtrace_actdesc *desc)
+{
+	struct dtrace_action	*action, *last;
+	struct dtrace_difo	*dp = desc->dtad_difo;
+	uint32_t		size = 0, align = sizeof(uint8_t), mask;
+	uint16_t		format = 0;
+	struct dtrace_recdesc	*rec;
+	struct dtrace_state	*state = ecb->dte_state;
+	dtrace_optval_t		*opt = state->dts_options, nframes, strsize;
+	uint64_t		arg = desc->dtad_arg;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(ecb->dte_action == NULL || ecb->dte_action->dta_refcnt == 1);
+
+	if (DTRACEACT_ISAGG(desc->dtad_kind)) {
+		struct dtrace_action *act;
+
+		for (act = ecb->dte_action; act != NULL; act = act->dta_next) {
+			if (act->dta_kind == DTRACEACT_COMMIT)
+				return -EINVAL;
+
+			if (act->dta_kind == DTRACEACT_SPECULATE)
+				return -EINVAL;
+		}
+
+		action = dtrace_ecb_aggregation_create(ecb, desc);
+		if (action == NULL)
+			return -EINVAL;
+	} else {
+		if (DTRACEACT_ISDESTRUCTIVE(desc->dtad_kind) ||
+		    (desc->dtad_kind == DTRACEACT_DIFEXPR &&
+		     dp != NULL && dp->dtdo_destructive))
+			state->dts_destructive = 1;
+
+		switch (desc->dtad_kind) {
+		case DTRACEACT_PRINTF:
+		case DTRACEACT_PRINTA:
+		case DTRACEACT_SYSTEM:
+		case DTRACEACT_FREOPEN:
+			if ((void *)(uintptr_t)arg == NULL) {
+				ASSERT(desc->dtad_kind == DTRACEACT_PRINTA);
+
+				format = 0;
+			} else {
+				ASSERT((void *)(uintptr_t)arg != NULL);
+#ifdef FIXME
+				ASSERT(arg > KERNELBASE);
+#endif
+
+				format = dtrace_format_add(
+						state, (char *)(uintptr_t)arg);
+			}
+			/* fallthru */
+
+		case DTRACEACT_TRACEMEM:
+		case DTRACEACT_LIBACT:
+		case DTRACEACT_DIFEXPR:
+			if (dp == NULL)
+				return -EINVAL;
+
+			size = dp->dtdo_rtype.dtdt_size;
+			if (size != 0)
+				break;
+
+			if (dp->dtdo_rtype.dtdt_kind == DIF_TYPE_STRING) {
+				if (!(dp->dtdo_rtype.dtdt_flags & DIF_TF_BYREF))
+					return -EINVAL;
+
+				size = opt[DTRACEOPT_STRSIZE];
+			}
+
+			break;
+
+		case DTRACEACT_STACK:
+			nframes = arg;
+			if (nframes == 0) {
+				nframes = opt[DTRACEOPT_STACKFRAMES];
+
+				ASSERT(nframes > 0);
+
+				arg = nframes;
+			}
+
+			size = nframes * sizeof(uint64_t);
+			break;
+
+		case DTRACEACT_JSTACK:
+			strsize = DTRACE_USTACK_STRSIZE(arg);
+			if (strsize == 0)
+				strsize = opt[DTRACEOPT_JSTACKSTRSIZE];
+
+			nframes = DTRACE_USTACK_NFRAMES(arg);
+			if (nframes == 0)
+				nframes = opt[DTRACEOPT_JSTACKFRAMES];
+
+			arg = DTRACE_USTACK_ARG(nframes, strsize);
+			/* fallthru */
+
+		case DTRACEACT_USTACK:
+			if (desc->dtad_kind != DTRACEACT_JSTACK &&
+			    (nframes = DTRACE_USTACK_NFRAMES(arg)) == 0) {
+				strsize = DTRACE_USTACK_STRSIZE(arg);
+				nframes = opt[DTRACEOPT_USTACKFRAMES];
+
+				ASSERT(nframes > 0);
+
+				arg = DTRACE_USTACK_ARG(nframes, strsize);
+			}
+
+			size = (nframes + 2) * sizeof(uint64_t);
+			size += DTRACE_USTACK_STRSIZE(arg);
+			size = P2ROUNDUP(size, (uint32_t)(sizeof(uintptr_t)));
+
+			break;
+
+		case DTRACEACT_SYM:
+		case DTRACEACT_MOD:
+			if (dp == NULL || ((size = dp->dtdo_rtype.dtdt_size) !=
+					   sizeof(uint64_t)) ||
+			    (dp->dtdo_rtype.dtdt_flags & DIF_TF_BYREF))
+				return -EINVAL;
+
+			break;
+
+		case DTRACEACT_USYM:
+		case DTRACEACT_UMOD:
+		case DTRACEACT_UADDR:
+			if (dp == NULL ||
+			    (dp->dtdo_rtype.dtdt_size != sizeof(uint64_t)) ||
+			    (dp->dtdo_rtype.dtdt_flags & DIF_TF_BYREF))
+				return -EINVAL;
+
+			size = 3 * sizeof(uint64_t);
+
+			break;
+
+		case DTRACEACT_STOP:
+		case DTRACEACT_BREAKPOINT:
+		case DTRACEACT_PANIC:
+			break;
+
+		case DTRACEACT_CHILL:
+		case DTRACEACT_DISCARD:
+		case DTRACEACT_RAISE:
+			if (dp == NULL)
+				return -EINVAL;
+
+			break;
+
+		case DTRACEACT_EXIT:
+			if (dp == NULL || (size = dp->dtdo_rtype.dtdt_size) !=
+					   sizeof(int) ||
+			    (dp->dtdo_rtype.dtdt_flags & DIF_TF_BYREF))
+				return -EINVAL;
+
+			break;
+
+		case DTRACEACT_SPECULATE:
+			if (ecb->dte_size > sizeof(dtrace_epid_t))
+				return -EINVAL;
+
+			if (dp == NULL)
+				return -EINVAL;
+
+			state->dts_speculates = 1;
+
+			break;
+
+		case DTRACEACT_COMMIT: {
+			struct dtrace_action *act = ecb->dte_action;
+
+			for (; act != NULL; act = act->dta_next) {
+				if (act->dta_kind == DTRACEACT_COMMIT)
+					return -EINVAL;
+			}
+
+			if (dp == NULL)
+				return -EINVAL;
+
+			break;
+		}
+
+		case DTRACEACT_PCAP:
+			size = dp->dtdo_rtype.dtdt_size;
+			break;
+
+		default:
+			return -EINVAL;
+		}
+
+		if (size != 0 || desc->dtad_kind == DTRACEACT_SPECULATE) {
+			struct dtrace_action *act = ecb->dte_action;
+
+			for (; act != NULL; act = act->dta_next) {
+				if (act->dta_kind == DTRACEACT_COMMIT)
+					return -EINVAL;
+			}
+		}
+
+		action = kzalloc(sizeof(struct dtrace_action), GFP_KERNEL);
+		if (action == NULL)
+			return -ENOMEM;
+
+		action->dta_rec.dtrd_size = size;
+	}
+
+	action->dta_refcnt = 1;
+	rec = &action->dta_rec;
+	size = rec->dtrd_size;
+
+	for (mask = sizeof(uint64_t) - 1; size != 0 && mask > 0; mask >>= 1) {
+		if (!(size & mask)) {
+			align = mask + 1;
+
+			break;
+		}
+	}
+
+	action->dta_kind = desc->dtad_kind;
+
+	action->dta_difo = dp;
+	if (action->dta_difo != NULL)
+		dtrace_difo_hold(dp);
+
+	rec->dtrd_action = action->dta_kind;
+	rec->dtrd_arg = arg;
+	rec->dtrd_uarg = desc->dtad_uarg;
+	rec->dtrd_alignment = (uint16_t)align;
+	rec->dtrd_format = format;
+
+	last = ecb->dte_action_last;
+	if (last != NULL) {
+		ASSERT(ecb->dte_action != NULL);
+
+		action->dta_prev = last;
+		last->dta_next = action;
+	} else {
+		ASSERT(ecb->dte_action == NULL);
+
+		ecb->dte_action = action;
+	}
+
+	ecb->dte_action_last = action;
+
+	return 0;
+}
+
+static void dtrace_ecb_action_remove(struct dtrace_ecb *ecb)
+{
+	struct dtrace_action	*act = ecb->dte_action, *next;
+	struct dtrace_vstate	*vstate = &ecb->dte_state->dts_vstate;
+	struct dtrace_difo	*dp;
+	uint16_t		format;
+
+	if (act != NULL && act->dta_refcnt > 1) {
+		ASSERT(act->dta_next == NULL || act->dta_next->dta_refcnt == 1);
+
+		act->dta_refcnt--;
+	} else {
+		for (; act != NULL; act = next) {
+			next = act->dta_next;
+			ASSERT(next != NULL || act == ecb->dte_action_last);
+			ASSERT(act->dta_refcnt == 1);
+
+			format = act->dta_rec.dtrd_format;
+			if (format != 0)
+				dtrace_format_remove(ecb->dte_state, format);
+
+			dp = act->dta_difo;
+			if (dp != NULL)
+				dtrace_difo_release(dp, vstate);
+
+			if (DTRACEACT_ISAGG(act->dta_kind))
+				dtrace_ecb_aggregation_destroy(ecb, act);
+			else
+				kfree(act);
+		}
+	}
+
+	ecb->dte_action = NULL;
+	ecb->dte_action_last = NULL;
+	ecb->dte_size = sizeof(dtrace_epid_t);
+}
+
+/*
+ * Disable the ECB by removing it from its probe.
+ */
+void dtrace_ecb_disable(struct dtrace_ecb *ecb)
+{
+	struct dtrace_ecb	*pecb, *prev = NULL;
+	struct dtrace_probe	*probe = ecb->dte_probe;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	if (probe == NULL)
+		return;
+
+	for (pecb = probe->dtpr_ecb; pecb != NULL; pecb = pecb->dte_next) {
+		if (pecb == ecb)
+			break;
+
+		prev = pecb;
+	}
+
+	ASSERT(pecb != NULL);
+
+	if (prev == NULL)
+		probe->dtpr_ecb = ecb->dte_next;
+	else
+		prev->dte_next = ecb->dte_next;
+
+	if (ecb == probe->dtpr_ecb_last) {
+		ASSERT(ecb->dte_next == NULL);
+		probe->dtpr_ecb_last = prev;
+	}
+
+	/*
+	 * The ECB has been disconnected from the probe; now sync to assure
+	 * that all CPUs have seen the change before returning.
+	 */
+	dtrace_sync();
+
+	if (probe->dtpr_ecb == NULL) {
+		/*
+		 * That was the last ECB on the probe; clear the predicate
+		 * cache ID for the probe, disable it and sync one more time
+		 * to assure that we'll never hit it again.
+		 */
+		struct dtrace_provider	*prov = probe->dtpr_provider;
+
+		ASSERT(ecb->dte_next == NULL);
+		ASSERT(probe->dtpr_ecb_last == NULL);
+
+		probe->dtpr_predcache = DTRACE_CACHEIDNONE;
+		prov->dtpv_pops.dtps_disable(prov->dtpv_arg,
+					     probe->dtpr_id, probe->dtpr_arg);
+
+		dtrace_sync();
+	} else {
+		/*
+		 * There is at least one ECB remaining on the probe.  If there
+		 * is _exactly_ one, set the probe's predicate cache ID to be
+		 * the predicate cache ID of the remaining ECB.
+		 */
+		ASSERT(probe->dtpr_ecb_last != NULL);
+		ASSERT(probe->dtpr_predcache == DTRACE_CACHEIDNONE);
+
+		if (probe->dtpr_ecb == probe->dtpr_ecb_last) {
+			struct dtrace_predicate	*p =
+						probe->dtpr_ecb->dte_predicate;
+
+			ASSERT(probe->dtpr_ecb->dte_next == NULL);
+
+			if (p != NULL)
+				probe->dtpr_predcache = p->dtp_cacheid;
+		}
+
+		ecb->dte_next = NULL;
+	}
+}
+
+static struct dtrace_ecb *dtrace_ecb_add(struct dtrace_state *state,
+                                         struct dtrace_probe *probe)
+{
+	struct dtrace_ecb	*ecb;
+	dtrace_epid_t		epid;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	ecb = kzalloc(sizeof(struct dtrace_ecb), GFP_KERNEL);
+	if (ecb == NULL)
+		return NULL;
+
+	ecb->dte_predicate = NULL;
+	ecb->dte_probe = probe;
+	ecb->dte_size = ecb->dte_needed = sizeof(dtrace_epid_t);
+	ecb->dte_alignment = sizeof(dtrace_epid_t);
+
+	epid = state->dts_epid++;
+
+	if (epid - 1 >= state->dts_necbs) {
+		struct dtrace_ecb	**oecbs = state->dts_ecbs, **ecbs;
+		int			necbs = state->dts_necbs << 1;
+
+		ASSERT(epid == state->dts_necbs + 1);
+
+		if (necbs == 0) {
+			ASSERT(oecbs == NULL);
+
+			necbs = 1;
+		}
+
+		ecbs = vzalloc(necbs * sizeof(*ecbs));
+		if (ecbs == NULL) {
+			kfree(ecb);
+			return NULL;
+		}
+
+		if (oecbs != NULL)
+			memcpy(ecbs, oecbs, state->dts_necbs * sizeof(*ecbs));
+
+		dtrace_membar_producer();
+
+		state->dts_ecbs = ecbs;
+
+		if (oecbs != NULL) {
+			if (state->dts_activity != DTRACE_ACTIVITY_INACTIVE)
+				dtrace_sync();
+
+			vfree(oecbs);
+		}
+
+		dtrace_membar_producer();
+
+		state->dts_necbs = necbs;
+	}
+
+	ecb->dte_state = state;
+
+	ASSERT(state->dts_ecbs[epid - 1] == NULL);
+
+	dtrace_membar_producer();
+
+	state->dts_ecbs[(ecb->dte_epid = epid) - 1] = ecb;
+
+	return ecb;
+}
+
+static struct dtrace_ecb * dtrace_ecb_create(struct dtrace_state *state,
+                                             struct dtrace_probe *probe,
+                                             struct dtrace_enabling *enab)
+{
+	struct dtrace_ecb	*ecb;
+	struct dtrace_predicate	*pred;
+	struct dtrace_actdesc	*act;
+	struct dtrace_provider	*prov;
+	struct dtrace_ecbdesc	*desc = enab->dten_current;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(state != NULL);
+
+	ecb = dtrace_ecb_add(state, probe);
+	if (ecb == NULL)
+		return NULL;
+
+	ecb->dte_uarg = desc->dted_uarg;
+
+	pred = desc->dted_pred.dtpdd_predicate;
+	if (pred != NULL) {
+		dtrace_predicate_hold(pred);
+		ecb->dte_predicate = pred;
+	}
+
+	if (probe != NULL) {
+		prov = probe->dtpr_provider;
+
+		if (!(state->dts_cred.dcr_visible & DTRACE_CRV_ALLPROC) &&
+		    (prov->dtpv_priv.dtpp_flags & DTRACE_PRIV_USER))
+			ecb->dte_cond |= DTRACE_COND_OWNER;
+
+		if (!(state->dts_cred.dcr_visible & DTRACE_CRV_KERNEL) &&
+		    (prov->dtpv_priv.dtpp_flags & DTRACE_PRIV_KERNEL))
+			ecb->dte_cond |= DTRACE_COND_USERMODE;
+	}
+
+	if (dtrace_ecb_create_cache != NULL) {
+		struct dtrace_ecb	*cached = dtrace_ecb_create_cache;
+		struct dtrace_action	*act = cached->dte_action;
+
+		if (act != NULL) {
+			ASSERT(act->dta_refcnt > 0);
+
+			act->dta_refcnt++;
+			ecb->dte_action = act;
+			ecb->dte_action_last = cached->dte_action_last;
+			ecb->dte_needed = cached->dte_needed;
+			ecb->dte_size = cached->dte_size;
+			ecb->dte_alignment = cached->dte_alignment;
+		}
+
+		return ecb;
+	}
+
+	for (act = desc->dted_action; act != NULL; act = act->dtad_next) {
+		enab->dten_error = dtrace_ecb_action_add(ecb, act);
+		if (enab->dten_error != 0) {
+			dtrace_ecb_destroy(ecb);
+			return NULL;
+		}
+	}
+
+	dtrace_ecb_resize(ecb);
+
+	return (dtrace_ecb_create_cache = ecb);
+}
+
+int dtrace_ecb_create_enable(struct dtrace_probe *probe, void *arg)
+{
+	struct dtrace_ecb	*ecb;
+	struct dtrace_enabling	*enab = arg;
+	struct dtrace_state	*state = enab->dten_vstate->dtvs_state;
+
+	ASSERT(state != NULL);
+
+	if (probe != NULL && probe->dtpr_gen < enab->dten_probegen)
+		return DTRACE_MATCH_NEXT;
+
+	ecb = dtrace_ecb_create(state, probe, enab);
+	if (ecb == NULL)
+		return DTRACE_MATCH_DONE;
+
+	if (dtrace_ecb_enable(ecb) < 0)
+		return DTRACE_MATCH_FAIL;
+
+	return DTRACE_MATCH_NEXT;
+}
+
+void dtrace_ecb_destroy(struct dtrace_ecb *ecb)
+{
+	struct dtrace_state	*state = ecb->dte_state;
+	struct dtrace_vstate	*vstate = &state->dts_vstate;
+	struct dtrace_predicate	*pred;
+	dtrace_epid_t		epid = ecb->dte_epid;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(ecb->dte_next == NULL);
+	ASSERT(ecb->dte_probe == NULL || ecb->dte_probe->dtpr_ecb != ecb);
+
+	pred = ecb->dte_predicate;
+	if (pred != NULL)
+		dtrace_predicate_release(pred, vstate);
+
+	dtrace_ecb_action_remove(ecb);
+
+	ASSERT(state->dts_ecbs[epid - 1] == ecb);
+	state->dts_ecbs[epid - 1] = NULL;
+
+	kfree(ecb);
+}
+
+void dtrace_ecb_resize(struct dtrace_ecb *ecb)
+{
+	struct dtrace_action	*act;
+	uint32_t		maxalign = sizeof(dtrace_epid_t);
+	uint32_t		align = sizeof(uint8_t), offs, diff;
+	int			wastuple = 0;
+	uint32_t		aggbase = UINT32_MAX;
+	struct dtrace_state	*state = ecb->dte_state;
+
+	/*
+	 * If we record anything, we always record the epid.  (And we always
+	 * record it first.)
+	 */
+	offs = sizeof(dtrace_epid_t);
+	ecb->dte_size = ecb->dte_needed = sizeof(dtrace_epid_t);
+
+	for (act = ecb->dte_action; act != NULL; act = act->dta_next) {
+		struct dtrace_recdesc	*rec = &act->dta_rec;
+
+		align = rec->dtrd_alignment;
+		if (align > maxalign)
+			maxalign = align;
+
+		if (!wastuple && act->dta_intuple) {
+			/*
+			 * This is the first record in a tuple.  Align the
+			 * offset to be at offset 4 in an 8-byte aligned
+			 * block.
+			 */
+			diff = offs + sizeof(dtrace_aggid_t);
+
+			diff &= sizeof(uint64_t) - 1;
+			if (diff)
+				offs += sizeof(uint64_t) - diff;
+
+			aggbase = offs - sizeof(dtrace_aggid_t);
+			ASSERT(!(aggbase & (sizeof(uint64_t) - 1)));
+		}
+
+		if (rec->dtrd_size != 0) {
+			diff = offs & (align - 1);
+			if (diff)
+				/*
+				 * The current offset is not properly
+				 * aligned; align it.
+				 */
+				offs += align - diff;
+		}
+
+		rec->dtrd_offset = offs;
+
+		if (offs + rec->dtrd_size > ecb->dte_needed) {
+			ecb->dte_needed = offs + rec->dtrd_size;
+
+			if (ecb->dte_needed > state->dts_needed)
+				state->dts_needed = ecb->dte_needed;
+		}
+
+		if (DTRACEACT_ISAGG(act->dta_kind)) {
+			struct dtrace_aggregation	*agg;
+			struct dtrace_action		*first, *prev;
+
+			agg = (struct dtrace_aggregation *)act;
+			first = agg->dtag_first;
+
+			ASSERT(rec->dtrd_size != 0 && first != NULL);
+			ASSERT(wastuple);
+			ASSERT(aggbase != UINT32_MAX);
+
+			agg->dtag_base = aggbase;
+
+			while ((prev = first->dta_prev) != NULL &&
+			       DTRACEACT_ISAGG(prev->dta_kind)) {
+				agg = (struct dtrace_aggregation *)prev;
+				first = agg->dtag_first;
+			}
+
+			if (prev != NULL) {
+				offs = prev->dta_rec.dtrd_offset +
+				prev->dta_rec.dtrd_size;
+			} else
+				offs = sizeof(dtrace_epid_t);
+
+			wastuple = 0;
+		} else {
+			if (!act->dta_intuple)
+				ecb->dte_size = offs + rec->dtrd_size;
+
+			offs += rec->dtrd_size;
+		}
+
+		wastuple = act->dta_intuple;
+	}
+
+	act = ecb->dte_action;
+	if (act != NULL &&
+	    !(act->dta_kind == DTRACEACT_SPECULATE && act->dta_next == NULL) &&
+	    ecb->dte_size == sizeof(dtrace_epid_t)) {
+		/*
+		 * If the size is still sizeof(dtrace_epid_t), then all
+		 * actions store no data; set the size to 0.
+		 */
+		ecb->dte_alignment = maxalign;
+		ecb->dte_size = 0;
+
+		/*
+		 * If the needed space is still sizeof(dtrace_epid_t), then
+		 * all actions need no additional space; set the needed
+		 * size to 0.
+		 */
+		if (ecb->dte_needed == sizeof(dtrace_epid_t))
+			ecb->dte_needed = 0;
+
+		return;
+	}
+
+	/*
+	 * Set our alignment, and make sure that the dte_size and dte_needed
+	 * are aligned to the size of an EPID.
+	 */
+	ecb->dte_alignment = maxalign;
+	ecb->dte_size = (ecb->dte_size + (sizeof(dtrace_epid_t) - 1)) &
+			~(sizeof(dtrace_epid_t) - 1);
+	ecb->dte_needed = (ecb->dte_needed + (sizeof(dtrace_epid_t) - 1)) &
+			  ~(sizeof(dtrace_epid_t) - 1);
+	ASSERT(ecb->dte_size <= ecb->dte_needed);
+}
+
+int dtrace_ecb_enable(struct dtrace_ecb *ecb)
+{
+	struct dtrace_probe	*probe = ecb->dte_probe;
+
+	ASSERT(MUTEX_HELD(&cpu_lock));
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(ecb->dte_next == NULL);
+
+	if (probe == NULL)
+		return 0;
+
+	if (probe->dtpr_ecb == NULL) {
+		struct dtrace_provider	*prov = probe->dtpr_provider;
+
+		probe->dtpr_ecb = probe->dtpr_ecb_last = ecb;
+
+
+		if (ecb->dte_predicate != NULL)
+			probe->dtpr_predcache = ecb->dte_predicate->dtp_cacheid;
+
+		return prov->dtpv_pops.dtps_enable(prov->dtpv_arg,
+						   probe->dtpr_id,
+						   probe->dtpr_arg);
+	} else {
+		ASSERT(probe->dtpr_ecb_last != NULL);
+
+		probe->dtpr_ecb_last->dte_next = ecb;
+		probe->dtpr_ecb_last = ecb;
+		probe->dtpr_predcache = 0;
+
+		dtrace_sync();
+
+		return 0;
+	}
+}
+
+struct dtrace_ecb *dtrace_epid2ecb(struct dtrace_state *state,
+                                   dtrace_epid_t id)
+{
+	struct dtrace_ecb *ecb;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	if (id == 0 || id > state->dts_necbs)
+		return NULL;
+
+	ASSERT(state->dts_necbs > 0 && state->dts_ecbs != NULL);
+	ecb = state->dts_ecbs[id - 1];
+	ASSERT(ecb == NULL || ecb->dte_epid == id);
+
+	return ecb;
+}
+
+struct dtrace_aggregation *dtrace_aggid2agg(struct dtrace_state *state,
+                                            dtrace_aggid_t id)
+{
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	return idr_find(&state->dts_agg_idr, id);
+}
diff --git a/dtrace/dtrace_enable.c b/dtrace/dtrace_enable.c
new file mode 100644
index 000000000000..72f30149cb9c
--- /dev/null
+++ b/dtrace/dtrace_enable.c
@@ -0,0 +1,449 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_enable.c
+ * DESCRIPTION:	DTrace - probe enabling implementation
+ *
+ * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#include "dtrace.h"
+
+size_t			dtrace_retain_max = 1024;
+struct dtrace_enabling	*dtrace_retained;
+dtrace_genid_t		dtrace_retained_gen;
+
+struct dtrace_enabling *dtrace_enabling_create(struct dtrace_vstate *vstate)
+{
+	struct dtrace_enabling	*enab;
+
+	enab = kzalloc(sizeof(struct dtrace_enabling), GFP_KERNEL);
+	if (enab == NULL)
+		return NULL;
+
+	enab->dten_vstate = vstate;
+
+	return enab;
+}
+
+void dtrace_enabling_add(struct dtrace_enabling *enab,
+			 struct dtrace_ecbdesc *ecb)
+{
+	struct dtrace_ecbdesc	**ndesc;
+	size_t			osize, nsize;
+
+	/*
+	 * We can't add to enablings after we've enabled them, or after we've
+	 * retained them.
+	 */
+	ASSERT(enab->dten_probegen == 0);
+	ASSERT(enab->dten_next == NULL && enab->dten_prev == NULL);
+
+	if (enab->dten_ndesc < enab->dten_maxdesc) {
+		enab->dten_desc[enab->dten_ndesc++] = ecb;
+		return;
+	}
+
+	osize = enab->dten_maxdesc * sizeof(struct dtrace_enabling *);
+
+	if (enab->dten_maxdesc == 0)
+		enab->dten_maxdesc = 1;
+	else
+		enab->dten_maxdesc <<= 1;
+
+	ASSERT(enab->dten_ndesc < enab->dten_maxdesc);
+
+	nsize = enab->dten_maxdesc * sizeof(struct dtrace_enabling *);
+	ndesc = vzalloc(nsize);
+	memcpy(ndesc, enab->dten_desc, osize);
+	vfree(enab->dten_desc);
+
+	enab->dten_desc = ndesc;
+	enab->dten_desc[enab->dten_ndesc++] = ecb;
+}
+
+static void dtrace_enabling_addlike(struct dtrace_enabling *enab,
+				    struct dtrace_ecbdesc *ecb,
+				    struct dtrace_probedesc *pd)
+{
+	struct dtrace_ecbdesc	*new;
+	struct dtrace_predicate	*pred;
+	struct dtrace_actdesc	*act;
+
+	/*
+	 * We're going to create a new ECB description that matches the
+	 * specified ECB in every way, but has the specified probe description.
+	 */
+	new = kzalloc(sizeof(struct dtrace_ecbdesc), GFP_KERNEL);
+
+	pred = ecb->dted_pred.dtpdd_predicate;
+	if (pred != NULL)
+		dtrace_predicate_hold(pred);
+
+	for (act = ecb->dted_action; act != NULL; act = act->dtad_next)
+		dtrace_actdesc_hold(act);
+
+	new->dted_action = ecb->dted_action;
+	new->dted_pred = ecb->dted_pred;
+	new->dted_probe = *pd;
+	new->dted_uarg = ecb->dted_uarg;
+
+	dtrace_enabling_add(enab, new);
+}
+
+void dtrace_enabling_dump(struct dtrace_enabling *enab)
+{
+	int	i;
+
+	for (i = 0; i < enab->dten_ndesc; i++) {
+		struct dtrace_probedesc	*desc =
+					&enab->dten_desc[i]->dted_probe;
+
+		pr_info("enabling probe %d (%s:%s:%s:%s)",
+			i, desc->dtpd_provider, desc->dtpd_mod,
+			desc->dtpd_func, desc->dtpd_name);
+	}
+}
+
+void dtrace_enabling_destroy(struct dtrace_enabling *enab)
+{
+	int			i;
+	struct dtrace_ecbdesc	*ep;
+	struct dtrace_vstate	*vstate = enab->dten_vstate;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	for (i = 0; i < enab->dten_ndesc; i++) {
+		struct dtrace_actdesc	*act, *next;
+		struct dtrace_predicate	*pred;
+
+		ep = enab->dten_desc[i];
+
+		pred = ep->dted_pred.dtpdd_predicate;
+		if (pred != NULL)
+			dtrace_predicate_release(pred, vstate);
+
+		for (act = ep->dted_action; act != NULL; act = next) {
+			next = act->dtad_next;
+			dtrace_actdesc_release(act, vstate);
+		}
+
+		kfree(ep);
+	}
+
+	vfree(enab->dten_desc);
+
+	/*
+	 * If this was a retained enabling, decrement the dts_nretained count
+	 * and remove it from the dtrace_retained list.
+	 */
+	if (enab->dten_prev != NULL || enab->dten_next != NULL ||
+	    dtrace_retained == enab) {
+		ASSERT(enab->dten_vstate->dtvs_state != NULL);
+		ASSERT(enab->dten_vstate->dtvs_state->dts_nretained > 0);
+		enab->dten_vstate->dtvs_state->dts_nretained--;
+		dtrace_retained_gen++;
+	}
+
+	if (enab->dten_prev == NULL) {
+		if (dtrace_retained == enab) {
+			dtrace_retained = enab->dten_next;
+
+			if (dtrace_retained != NULL)
+				dtrace_retained->dten_prev = NULL;
+		}
+	} else {
+		ASSERT(enab != dtrace_retained);
+		ASSERT(dtrace_retained != NULL);
+		enab->dten_prev->dten_next = enab->dten_next;
+	}
+
+	if (enab->dten_next != NULL) {
+		ASSERT(dtrace_retained != NULL);
+		enab->dten_next->dten_prev = enab->dten_prev;
+	}
+
+	kfree(enab);
+}
+
+int dtrace_enabling_retain(struct dtrace_enabling *enab)
+{
+	struct dtrace_state	*state;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(enab->dten_next == NULL && enab->dten_prev == NULL);
+	ASSERT(enab->dten_vstate != NULL);
+
+	state = enab->dten_vstate->dtvs_state;
+	ASSERT(state != NULL);
+
+	/*
+	 * We only allow each state to retain dtrace_retain_max enablings.
+	 */
+	if (state->dts_nretained >= dtrace_retain_max)
+		return -ENOSPC;
+
+	state->dts_nretained++;
+	dtrace_retained_gen++;
+
+	if (dtrace_retained == NULL) {
+		dtrace_retained = enab;
+		return 0;
+	}
+
+	enab->dten_next = dtrace_retained;
+	dtrace_retained->dten_prev = enab;
+	dtrace_retained = enab;
+
+	return 0;
+}
+
+int dtrace_enabling_replicate(struct dtrace_state *state,
+			      struct dtrace_probedesc *match,
+			      struct dtrace_probedesc *create)
+{
+	struct dtrace_enabling	*new, *enab;
+	int			found = 0, err = -ENOENT;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(strlen(match->dtpd_provider) < DTRACE_PROVNAMELEN);
+	ASSERT(strlen(match->dtpd_mod) < DTRACE_MODNAMELEN);
+	ASSERT(strlen(match->dtpd_func) < DTRACE_FUNCNAMELEN);
+	ASSERT(strlen(match->dtpd_name) < DTRACE_NAMELEN);
+
+	new = dtrace_enabling_create(&state->dts_vstate);
+	if (new == NULL)
+		return -ENOMEM;
+
+	/*
+	 * Iterate over all retained enablings, looking for enablings that
+	 * match the specified state.
+	 */
+	for (enab = dtrace_retained; enab != NULL; enab = enab->dten_next) {
+		int	i;
+
+		/*
+		 * dtvs_state can only be NULL for helper enablings -- and
+		 * helper enablings can't be retained.
+		 */
+		ASSERT(enab->dten_vstate->dtvs_state != NULL);
+
+		if (enab->dten_vstate->dtvs_state != state)
+			continue;
+
+		/*
+		 * Now iterate over each probe description; we're looking for
+		 * an exact match to the specified probe description.
+		 */
+		for (i = 0; i < enab->dten_ndesc; i++) {
+			struct dtrace_ecbdesc	*ep = enab->dten_desc[i];
+			struct dtrace_probedesc	*pd = &ep->dted_probe;
+
+			if (strcmp(pd->dtpd_provider, match->dtpd_provider))
+				continue;
+
+			if (strcmp(pd->dtpd_mod, match->dtpd_mod))
+				continue;
+
+			if (strcmp(pd->dtpd_func, match->dtpd_func))
+				continue;
+
+			if (strcmp(pd->dtpd_name, match->dtpd_name))
+				continue;
+
+			/*
+			 * We have a winning probe!  Add it to our growing
+			 * enabling.
+			 */
+			found = 1;
+			dtrace_enabling_addlike(new, ep, create);
+		}
+	}
+
+	if (!found || (err = dtrace_enabling_retain(new)) != 0) {
+		dtrace_enabling_destroy(new);
+		return err;
+	}
+
+	return 0;
+}
+
+void dtrace_enabling_retract(struct dtrace_state *state)
+{
+	struct dtrace_enabling	*enab, *next;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	/*
+	 * Iterate over all retained enablings, destroy the enablings retained
+	 * for the specified state.
+	 */
+	for (enab = dtrace_retained; enab != NULL; enab = next) {
+		next = enab->dten_next;
+
+		/*
+		 * dtvs_state can only be NULL for helper enablings, and helper
+		 * enablings can't be retained.
+		 */
+		ASSERT(enab->dten_vstate->dtvs_state != NULL);
+
+		if (enab->dten_vstate->dtvs_state == state) {
+			ASSERT(state->dts_nretained > 0);
+			dtrace_enabling_destroy(enab);
+		}
+	}
+
+	ASSERT(state->dts_nretained == 0);
+}
+
+int dtrace_enabling_match(struct dtrace_enabling *enab, int *nmatched)
+{
+	int	i;
+	int	total_matched = 0, matched = 0;
+
+	for (i = 0; i < enab->dten_ndesc; i++) {
+		struct dtrace_ecbdesc	*ep = enab->dten_desc[i];
+
+		enab->dten_current = ep;
+		enab->dten_error = 0;
+
+		dt_dbg_enable("  Matching enabling %p[%d] for %s:%s:%s:%s\n",
+			      enab, i, ep->dted_probe.dtpd_provider,
+			      ep->dted_probe.dtpd_mod,
+			      ep->dted_probe.dtpd_func,
+			      ep->dted_probe.dtpd_name);
+
+		matched = dtrace_probe_enable(&ep->dted_probe, enab);
+		if (matched < 0) {
+			dt_dbg_enable("  Matching enabling %p[%d] failed: "
+				      "busy\n", enab, i);
+			return -EBUSY;
+		}
+
+		dt_dbg_enable("  Matching enabling %p[%d] found %d matches.\n",
+			      enab, i, matched);
+
+		total_matched += matched;
+
+		if (enab->dten_error != 0) {
+			if (nmatched == NULL)
+				pr_warn("%s error on %p: %d\n", __func__,
+					(void *)ep, enab->dten_error);
+
+			return enab->dten_error;
+		}
+	}
+
+	enab->dten_probegen = dtrace_probegen;
+	if (nmatched != NULL)
+		*nmatched = total_matched;
+
+	return 0;
+}
+
+void dtrace_enabling_matchall(void)
+{
+	struct dtrace_enabling	*enab;
+
+	mutex_lock(&cpu_lock);
+	mutex_lock(&dtrace_lock);
+
+	for (enab = dtrace_retained; enab != NULL; enab = enab->dten_next)
+		(void) dtrace_enabling_match(enab, NULL);
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&cpu_lock);
+}
+
+/*
+ * If an enabling is to be enabled without having matched probes (that is, if
+ * dtrace_state_go() is to be called on the underlying dtrace_state_t), the
+ * enabling must be _primed_ by creating an ECB for every ECB description.
+ * This must be done to assure that we know the number of speculations, the
+ * number of aggregations, the minimum buffer size needed, etc. before we
+ * transition out of DTRACE_ACTIVITY_INACTIVE.  To do this without actually
+ * enabling any probes, we create ECBs for every ECB description, but with a
+ * NULL probe -- which is exactly what this function does.
+ */
+void dtrace_enabling_prime(struct dtrace_state *state)
+{
+	struct dtrace_enabling	*enab;
+	int			i;
+
+	for (enab = dtrace_retained; enab != NULL; enab = enab->dten_next) {
+		ASSERT(enab->dten_vstate->dtvs_state != NULL);
+
+		if (enab->dten_vstate->dtvs_state != state)
+			continue;
+
+		/*
+		 * We don't want to prime an enabling more than once, lest
+		 * we allow a malicious user to induce resource exhaustion.
+		 * (The ECBs that result from priming an enabling aren't
+		 * leaked -- but they also aren't deallocated until the
+		 * consumer state is destroyed.)
+		 */
+		if (enab->dten_primed)
+			continue;
+
+		for (i = 0; i < enab->dten_ndesc; i++) {
+			enab->dten_current = enab->dten_desc[i];
+			dtrace_probe_enable(NULL, enab);
+		}
+
+		enab->dten_primed = 1;
+	}
+}
+
+void dtrace_enabling_provide(struct dtrace_provider *prv)
+{
+	int		all = 0;
+	dtrace_genid_t	gen;
+
+	if (prv == NULL) {
+		all = 1;
+		prv = dtrace_provider;
+	}
+
+	do {
+		struct dtrace_enabling	*enab;
+		void			*parg = prv->dtpv_arg;
+
+retry:
+		gen = dtrace_retained_gen;
+		for (enab = dtrace_retained; enab != NULL;
+		     enab = enab->dten_next) {
+			int	i;
+
+			for (i = 0; i < enab->dten_ndesc; i++) {
+				struct dtrace_probedesc	desc;
+
+				desc = enab->dten_desc[i]->dted_probe;
+				mutex_unlock(&dtrace_lock);
+				prv->dtpv_pops.dtps_provide(parg, &desc);
+				mutex_lock(&dtrace_lock);
+
+				if (gen != dtrace_retained_gen)
+					goto retry;
+			}
+		}
+	} while (all && (prv = prv->dtpv_next) != NULL);
+
+	mutex_unlock(&dtrace_lock);
+	dtrace_probe_provide(NULL, all ? NULL : prv);
+	mutex_lock(&dtrace_lock);
+}
diff --git a/dtrace/dtrace_fmt.c b/dtrace/dtrace_fmt.c
new file mode 100644
index 000000000000..78fcc8e6efb8
--- /dev/null
+++ b/dtrace/dtrace_fmt.c
@@ -0,0 +1,104 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_fmt.c
+ * DESCRIPTION:	DTrace - format string implementation
+ *
+ * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#include "dtrace.h"
+
+uint16_t dtrace_format_add(struct dtrace_state *state, char *str)
+{
+	char		*fmt, **new;
+	uint16_t	ndx;
+
+	fmt = dtrace_strdup(str);
+	if (fmt == NULL)
+		return 0;
+
+	for (ndx = 0; ndx < state->dts_nformats; ndx++) {
+		if (state->dts_formats[ndx] == NULL) {
+			state->dts_formats[ndx] = fmt;
+
+			return ndx + 1;
+		}
+	}
+
+	if (state->dts_nformats == UINT16_MAX) {
+		kfree(fmt);
+
+		return 0;
+	}
+
+	ndx = state->dts_nformats;
+	new = vmalloc((ndx + 1) * sizeof(char *));
+	if (new == NULL) {
+		kfree(fmt);
+		return 0;
+	}
+
+	state->dts_nformats++;
+
+	if (state->dts_formats != NULL) {
+		ASSERT(ndx != 0);
+		memcpy(new, state->dts_formats, ndx * sizeof(char *));
+		vfree(state->dts_formats);
+	}
+
+	state->dts_formats = new;
+	state->dts_formats[ndx] = fmt;
+
+	return ndx + 1;
+}
+
+void dtrace_format_remove(struct dtrace_state *state, uint16_t format)
+{
+	char	*fmt;
+
+	ASSERT(state->dts_formats != NULL);
+	ASSERT(format <= state->dts_nformats);
+	ASSERT(state->dts_formats[format - 1] != NULL);
+
+	fmt = state->dts_formats[format - 1];
+	kfree(fmt);
+	state->dts_formats[format - 1] = NULL;
+}
+
+void dtrace_format_destroy(struct dtrace_state *state)
+{
+	int	i;
+
+	if (state->dts_nformats == 0) {
+		ASSERT(state->dts_formats == NULL);
+		return;
+	}
+
+	ASSERT(state->dts_formats != NULL);
+
+	for (i = 0; i < state->dts_nformats; i++) {
+		char	*fmt = state->dts_formats[i];
+
+		if (fmt == NULL)
+			continue;
+
+		kfree(fmt);
+	}
+
+	vfree(state->dts_formats);
+	state->dts_nformats = 0;
+	state->dts_formats = NULL;
+}
diff --git a/dtrace/dtrace_hash.c b/dtrace/dtrace_hash.c
new file mode 100644
index 000000000000..0773c60e7897
--- /dev/null
+++ b/dtrace/dtrace_hash.c
@@ -0,0 +1,266 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_hash.c
+ * DESCRIPTION:	DTrace - hash table implementation
+ *
+ * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+
+#include "dtrace.h"
+
+#define DTRACE_HASHSTR(hash, probe)	\
+	dtrace_hash_str(*((char **)((uintptr_t)(probe) + (hash)->dth_stroffs)))
+#define DTRACE_HASHEQ(hash, lhs, rhs)	\
+	(strcmp(*((char **)((uintptr_t)(lhs) + (hash)->dth_stroffs)), \
+		*((char **)((uintptr_t)(rhs) + (hash)->dth_stroffs))) == 0)
+
+static uint_t dtrace_hash_str(char *p)
+{
+	uint_t	g;
+	uint_t	hval = 0;
+
+	while (*p) {
+		hval = (hval << 4) + *p++;
+		g = hval & 0xf0000000;
+		if (g != 0)
+			hval ^= g >> 24;
+
+		hval &= ~g;
+	}
+
+	return hval;
+}
+
+struct dtrace_hash *dtrace_hash_create(uintptr_t stroffs, uintptr_t nextoffs,
+                                       uintptr_t prevoffs)
+{
+	struct dtrace_hash *hash;
+
+	hash = kzalloc(sizeof(struct dtrace_hash), GFP_KERNEL);
+	if (hash == NULL)
+		return NULL;
+
+	hash->dth_stroffs = stroffs;
+	hash->dth_nextoffs = nextoffs;
+	hash->dth_prevoffs = prevoffs;
+
+	hash->dth_size = 1;
+	hash->dth_mask = hash->dth_size - 1;
+
+	hash->dth_tab = vzalloc(hash->dth_size *
+				sizeof(struct dtrace_hashbucket *));
+
+	if (hash->dth_tab == NULL) {
+		kfree(hash);
+		return NULL;
+	}
+
+	return hash;
+}
+
+void dtrace_hash_destroy(struct dtrace_hash *hash)
+{
+#ifdef DEBUG
+	int	i;
+
+	for (i = 0; i < hash->dth_size; i++)
+		ASSERT(hash->dth_tab[i] == NULL);
+#endif
+
+	if (hash == NULL)
+		return;
+
+	vfree(hash->dth_tab);
+	kfree(hash);
+}
+
+static int dtrace_hash_resize(struct dtrace_hash *hash)
+{
+	int			size = hash->dth_size, i, ndx;
+	int			new_size = hash->dth_size << 1;
+	int			new_mask = new_size - 1;
+	struct dtrace_hashbucket **new_tab, *bucket, *next;
+
+	ASSERT((new_size & new_mask) == 0);
+
+	new_tab = vzalloc(new_size * sizeof(void *));
+	if (new_tab == NULL)
+		return -ENOMEM;
+
+	for (i = 0; i < size; i++) {
+		for (bucket = hash->dth_tab[i]; bucket != NULL;
+		     bucket = next) {
+			struct dtrace_probe *probe = bucket->dthb_chain;
+
+			ASSERT(probe != NULL);
+			ndx = DTRACE_HASHSTR(hash, probe) & new_mask;
+
+			next = bucket->dthb_next;
+			bucket->dthb_next = new_tab[ndx];
+			new_tab[ndx] = bucket;
+		}
+	}
+
+	vfree(hash->dth_tab);
+	hash->dth_tab = new_tab;
+	hash->dth_size = new_size;
+	hash->dth_mask = new_mask;
+
+	return 0;
+}
+
+int dtrace_hash_add(struct dtrace_hash *hash, struct dtrace_probe *new)
+{
+	int 			hashval = DTRACE_HASHSTR(hash, new);
+	int			ndx = hashval & hash->dth_mask;
+	struct dtrace_hashbucket *bucket = hash->dth_tab[ndx];
+	struct dtrace_probe	**nextp, **prevp;
+
+	for (; bucket != NULL; bucket = bucket->dthb_next) {
+		if (DTRACE_HASHEQ(hash, bucket->dthb_chain, new))
+			goto add;
+	}
+
+	if ((hash->dth_nbuckets >> 1) > hash->dth_size) {
+		int	err = 0;
+
+		err = dtrace_hash_resize(hash);
+		if (err != 0)
+			return err;
+
+		dtrace_hash_add(hash, new);
+		return 0;
+	}
+
+	bucket = kzalloc(sizeof(struct dtrace_hashbucket), GFP_KERNEL);
+	if (bucket == NULL)
+		return -ENOMEM;
+
+	bucket->dthb_next = hash->dth_tab[ndx];
+	hash->dth_tab[ndx] = bucket;
+	hash->dth_nbuckets++;
+
+add:
+	nextp = DTRACE_HASHNEXT(hash, new);
+
+	ASSERT(*nextp == NULL && *(DTRACE_HASHPREV(hash, new)) == NULL);
+
+	*nextp = bucket->dthb_chain;
+
+	if (bucket->dthb_chain != NULL) {
+		prevp = DTRACE_HASHPREV(hash, bucket->dthb_chain);
+
+		ASSERT(*prevp == NULL);
+
+		*prevp = new;
+	}
+
+	bucket->dthb_chain = new;
+	bucket->dthb_len++;
+
+	return 0;
+}
+
+struct dtrace_probe *dtrace_hash_lookup(struct dtrace_hash *hash,
+                                        struct dtrace_probe *template)
+{
+	int hashval = DTRACE_HASHSTR(hash, template);
+	int ndx = hashval & hash->dth_mask;
+
+	struct dtrace_hashbucket *bucket = hash->dth_tab[ndx];
+
+	for (; bucket != NULL; bucket = bucket->dthb_next) {
+		if (DTRACE_HASHEQ(hash, bucket->dthb_chain, template))
+			return bucket->dthb_chain;
+	}
+
+	return NULL;
+}
+
+/*
+ * FIXME:
+ * It would be more accurate to calculate a lookup cost based on the number
+ * of buckets in the hash table slot, the length of the chain, and the length
+ * of the string being looked up.
+ * The hash tables can also be optimized by storing the hashval in each element
+ * rather than always performing string comparisons.
+ */
+int dtrace_hash_collisions(struct dtrace_hash *hash,
+			   struct dtrace_probe *template)
+{
+	int hashval = DTRACE_HASHSTR(hash, template);
+	int ndx = hashval & hash->dth_mask;
+
+	struct dtrace_hashbucket *bucket = hash->dth_tab[ndx];
+
+	for (; bucket != NULL; bucket = bucket->dthb_next) {
+		if (DTRACE_HASHEQ(hash, bucket->dthb_chain, template))
+			return bucket->dthb_len;
+	}
+
+	return 0;
+}
+
+void dtrace_hash_remove(struct dtrace_hash *hash, struct dtrace_probe *probe)
+{
+	int ndx = DTRACE_HASHSTR(hash, probe) & hash->dth_mask;
+
+	struct dtrace_hashbucket *bucket = hash->dth_tab[ndx];
+	struct dtrace_probe	**prevp = DTRACE_HASHPREV(hash, probe);
+	struct dtrace_probe	**nextp = DTRACE_HASHNEXT(hash, probe);
+
+	for (; bucket != NULL; bucket = bucket->dthb_next) {
+		if (DTRACE_HASHEQ(hash, bucket->dthb_chain, probe))
+			break;
+	}
+
+	ASSERT(bucket != NULL);
+
+	if (*prevp == NULL) {
+		if (*nextp == NULL) {
+			/*
+			 * This is the last probe in the bucket; we can remove
+			 * the bucket.
+			 */
+			struct dtrace_hashbucket *b = hash->dth_tab[ndx];
+
+			ASSERT(bucket->dthb_chain == probe);
+			ASSERT(b != NULL);
+
+			if (b == bucket)
+				hash->dth_tab[ndx] = bucket->dthb_next;
+			else {
+				while (b->dthb_next != bucket)
+					b = b->dthb_next;
+
+				b->dthb_next = bucket->dthb_next;
+			}
+
+			ASSERT(hash->dth_nbuckets > 0);
+
+			hash->dth_nbuckets--;
+			kfree(bucket);
+
+			return;
+		}
+
+		bucket->dthb_chain = *nextp;
+	} else
+		*(DTRACE_HASHNEXT(hash, *prevp)) = *nextp;
+
+	if (*nextp != NULL)
+		*(DTRACE_HASHPREV(hash, *nextp)) = *prevp;
+}
diff --git a/dtrace/dtrace_isa.c b/dtrace/dtrace_isa.c
new file mode 100644
index 000000000000..f84ce1cd52cc
--- /dev/null
+++ b/dtrace/dtrace_isa.c
@@ -0,0 +1,361 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_isa.c
+ * DESCRIPTION:	DTrace - architecture specific code
+ *
+ * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dtrace_cpu.h>
+#include <linux/dtrace_task_impl.h>
+#include <linux/hardirq.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/uaccess.h>
+#include <linux/cpumask.h>
+#include <asm/cacheflush.h>
+#include <asm/ptrace.h>
+#include <asm/stacktrace.h>
+
+#include "dtrace.h"
+
+DEFINE_MUTEX(cpu_lock);
+EXPORT_SYMBOL(cpu_lock);
+
+int dtrace_getipl(void)
+{
+	return in_interrupt();
+}
+
+void dtrace_xcall(processorid_t cpu, dtrace_xcall_t func, void *arg)
+{
+	if (cpu == DTRACE_CPUALL)
+		smp_call_function(func, arg, 1);
+	else
+		smp_call_function_single(cpu, func, arg, 1);
+}
+
+void dtrace_toxic_ranges(void (*func)(uintptr_t, uintptr_t))
+{
+	/* FIXME */
+}
+
+/*
+ * Note:  not called from probe context.  This function is called
+ * asynchronously (and at a regular interval) from outside of probe context
+ * by the DTrace framework to sync shared data which DTrace probe context
+ * may access without locks.
+ *
+ * Whenever the framework updates data which can be accessed from probe context,
+ * the framework then calls dtrace_sync().  dtrace_sync() guarantees all probes
+ * are using the new data before returning.
+ *
+ * See the comment in dtrace_impl.h which describes this algorithm.
+ * The cpuc_in_probe_ctxt flag is an increasing 16-bit count.  It is odd when
+ * in DTrace probe context and even when not in DTrace probe context.
+ * The upper 15 bits are a counter which are incremented when exiting DTrace
+ * probe context.  These upper 15 bits are used to detect "sample aliasing":
+ * i.e. the target CPU is not in DTrace probe context between samples but
+ * continually enters probe context just before being sampled.
+ *
+ * dtrace_sync() loops over NCPUs.  CPUs which are not in DTrace probe context
+ * (cpuc_in_probe_ctxt is even) are removed from the list.  This is repeated
+ * until there are no CPUs left in the sync list.
+ *
+ * In the rare cases where dtrace_sync() loops over all NCPUs more than
+ * dtrace_sync_sample_count times, dtrace_sync() then spins on one CPU's
+ * cpuc_in_probe_ctxt count until the count increments.  This is intended to
+ * avoid sample aliasing.
+ */
+void dtrace_sync(void)
+{
+	/*
+	 * sync_cpus is a bitmap of CPUs that need to be synced with.
+	 */
+	cpumask_t	sync_cpus;
+	uint64_t	sample_count = 0;
+	int		cpuid, sample_cpuid = 0;
+	int		outstanding;
+
+	/*
+	 * Create bitmap of CPUs that need to be synced with.
+	 */
+	cpumask_copy(&sync_cpus, cpu_online_mask);
+	outstanding = 0;
+	for_each_cpu(cpuid, &sync_cpus) {
+		++outstanding;
+
+		/*
+		 * Set a flag to let the CPU know we are syncing with it.
+		 */
+		DTRACE_SYNC_START(cpuid);
+	}
+
+	/*
+	 * The preceding stores by DTRACE_SYNC_START() must complete before
+	 * subsequent loads or stores.  No membar is needed because the
+	 * atomic-add operation in DTRACE_SYNC_START is a memory barrier on
+	 * SPARC and X86.
+	 */
+
+	while (outstanding > 0) {
+		/*
+		 * Loop over the map of CPUs that need to be synced with.
+		 */
+		for_each_cpu(cpuid, &sync_cpus) {
+			if (!DTRACE_SYNC_IN_CRITICAL(cpuid)) {
+
+				/* Clear the CPU's sync request flag */
+				DTRACE_SYNC_END(cpuid);
+
+				/*
+				 * remove cpuid from list of CPUs that
+				 * still need to be synced with.
+				 */
+				DTRACE_SYNC_DONE(cpuid, &sync_cpus);
+				--outstanding;
+			} else {
+				/*
+				 * Remember one of the outstanding CPUs to spin
+				 * on once we reach the sampling limit.
+				 */
+				sample_cpuid = cpuid;
+			}
+		}
+
+		/*
+		 * dtrace_probe may be running in sibling threads in this core.
+		 */
+		if (outstanding > 0) {
+			dtrace_safe_smt_pause();
+
+			/*
+			 * After sample_count loops, spin on one CPU's count
+			 * instead of just checking for odd/even.
+			 */
+			if (++sample_count > dtrace_sync_sample_count) {
+				uint64_t count =
+				    DTRACE_SYNC_CRITICAL_COUNT(sample_cpuid);
+
+				/*
+				 * Spin until critical section count increments.
+				 */
+				if (DTRACE_SYNC_IN_CRITICAL(sample_cpuid)) {
+					while (count ==
+					    DTRACE_SYNC_CRITICAL_COUNT(
+					    sample_cpuid)) {
+
+						dtrace_safe_smt_pause();
+					}
+				}
+
+				DTRACE_SYNC_END(sample_cpuid);
+				DTRACE_SYNC_DONE(sample_cpuid, &sync_cpus);
+				--outstanding;
+			}
+		}
+	}
+
+/*
+ * All preceding loads by DTRACE_SYNC_IN_CRITICAL() and
+ * DTRACE_SYNC_CRITICAL_COUNT() must complete before subsequent loads
+ * or stores.  No membar is needed because the atomic-add operation in
+ * DTRACE_SYNC_END() is a memory barrier on SPARC and X86.
+ */
+}
+
+/*
+ * Handle a few special cases where we store information in kernel memory that
+ * in other systems is typically found in userspace.
+ */
+static int dtrace_fake_copyin(intptr_t addr, size_t size)
+{
+	struct dtrace_psinfo	*psinfo;
+	uintptr_t		argv;
+	unsigned long		argc;
+	uintptr_t		envp;
+	unsigned long		envc;
+
+	if (current->dt_task == NULL)
+		return 0;
+
+	psinfo = current->dt_task->dt_psinfo;
+	if (psinfo == NULL)
+		return 0;
+
+	argv = (uintptr_t)psinfo->dtps_argv;
+	argc = psinfo->dtps_argc;
+	envp = (uintptr_t)psinfo->dtps_envp;
+	envc = psinfo->dtps_envc;
+
+	/*
+	 * Ensure addr is within the argv array (or the envp array):
+	 *	addr in [argv..argv + argc * sizeof(psinfo->argv[0])[
+	 * Ensure that addr + size is within the same array
+	 *	addr + size in [argv..argv * sizeof(psinfo->argv[0])]
+	 *
+	 * To guard against overflows on (addr + size) we rewrite this basic
+	 * equation:
+	 *	addr + size <= argv + argc * sizeof(psinfo->argv[0])
+	 * into:
+	 *	addr - argv <= argc * sizeof(psinfo->argv[0]) - size
+	 */
+	return (addr >= argv &&
+		addr - argv < argc * sizeof(psinfo->dtps_argv[0]) &&
+		addr - argv <= argc * sizeof(psinfo->dtps_argv[0]) - size) ||
+		(addr >= envp &&
+		 addr - envp < envc * sizeof(psinfo->dtps_envp[0]) &&
+		 addr - envp <= envc * sizeof(psinfo->dtps_envp[0]) - size);
+}
+
+void dtrace_copyin(uintptr_t uaddr, uintptr_t kaddr, size_t size,
+		   volatile uint16_t *flags)
+{
+	if (dtrace_fake_copyin(uaddr, size)) {
+		memcpy((char *)kaddr, (char *)uaddr, size);
+		return;
+	}
+
+	dtrace_copyin_arch(uaddr, kaddr, size, flags);
+}
+
+void dtrace_copyinstr(uintptr_t uaddr, uintptr_t kaddr, size_t size,
+		      volatile uint16_t *flags)
+{
+	if (dtrace_fake_copyin(uaddr, size)) {
+		strncpy((char *)kaddr, (char *)uaddr,
+			 min(size, (size_t)PR_PSARGS_SZ));
+		return;
+	}
+
+	dtrace_copyinstr_arch(uaddr, kaddr, size, flags);
+}
+
+/*
+ * FIXME: aframes + 3 should really be aframes + 1, dtrace_stacktrace() in the
+ *	  kernel should do its own aframes + 2
+ */
+void dtrace_getpcstack(uint64_t *pcstack, int pcstack_limit, int aframes,
+		       uint32_t *intrpc)
+{
+	struct stacktrace_state	st = {
+					pcstack,
+					NULL,
+					pcstack_limit,
+					aframes + 3,
+					STACKTRACE_KERNEL
+				     };
+
+	dtrace_stacktrace(&st);
+
+	while (st.depth < st.limit)
+		pcstack[st.depth++] = 0;
+}
+EXPORT_SYMBOL(dtrace_getpcstack);
+
+/*
+ * Get user stack entries up to the pcstack_limit; return the number of entries
+ * acquired.  If pcstack is NULL, return the number of entries potentially
+ * acquirable.
+ */
+unsigned long dtrace_getufpstack(uint64_t *pcstack, uint64_t *fpstack,
+				 int pcstack_limit)
+{
+	struct task_struct	*p = current;
+	struct stacktrace_state	st;
+	unsigned long		depth;
+
+	if (pcstack) {
+		if (unlikely(pcstack_limit < 2)) {
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
+			return 0;
+		}
+		*pcstack++ = (uint64_t)p->pid;
+		*pcstack++ = (uint64_t)p->tgid;
+		pcstack_limit -= 2;
+	}
+
+	st.pcs = pcstack;
+	st.fps = fpstack;
+	st.limit = pcstack_limit;
+	st.depth = 0;
+	st.flags = STACKTRACE_USER;
+
+	dtrace_stacktrace(&st);
+
+	depth = st.depth;
+	if (pcstack) {
+		while (st.depth < st.limit) {
+			pcstack[st.depth++] = 0;
+			if (fpstack)
+				fpstack[st.depth++] = 0;
+		}
+	}
+
+	return depth;
+}
+
+void dtrace_getupcstack(uint64_t *pcstack, int pcstack_limit)
+{
+	dtrace_getufpstack(pcstack, NULL, pcstack_limit);
+}
+
+/*
+ * FIXME: aframes + 3 should really be aframes + 1, dtrace_stacktrace() in the
+ *	  kernel should do its own aframes + 2
+ */
+int dtrace_getstackdepth(struct dtrace_mstate *mstate, int aframes)
+{
+	uintptr_t		old = mstate->dtms_scratch_ptr;
+	struct stacktrace_state	st = {
+					NULL,
+					NULL,
+					0,
+					aframes + 3,
+					STACKTRACE_KERNEL
+				     };
+
+	st.pcs = (uint64_t *)ALIGN(old, 8);
+	if ((uintptr_t)st.pcs >
+	    mstate->dtms_scratch_base + mstate->dtms_scratch_size) {
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+		return 0;
+	}
+
+	/*
+	 * Calculate how many (64-bit) PCs we can fit in the remaining scratch
+	 * memory.
+	 */
+	st.limit = (mstate->dtms_scratch_base + mstate->dtms_scratch_size -
+		    (uintptr_t)st.pcs) >> 3;
+
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+	dtrace_stacktrace(&st);
+	DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+
+	mstate->dtms_scratch_ptr = old;
+
+	return st.depth;
+}
+
+int dtrace_getustackdepth(void)
+{
+	return dtrace_getufpstack(NULL, NULL, INT_MAX);
+}
+
+void dtrace_probe_error(struct dtrace_state *state, dtrace_epid_t epid,
+			int act, int fltoffs, int flags, uintptr_t addr)
+{
+	dtrace_probe(dtrace_probeid_error, (uintptr_t)state, epid, act,
+		     fltoffs, flags, addr, 0);
+}
diff --git a/dtrace/dtrace_match.c b/dtrace/dtrace_match.c
new file mode 100644
index 000000000000..a63e3f8be1cd
--- /dev/null
+++ b/dtrace/dtrace_match.c
@@ -0,0 +1,364 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_match.c
+ * DESCRIPTION:	DTrace - probe match implementation
+ *
+ * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "dtrace.h"
+
+struct dtrace_hash	*dtrace_bymod;
+struct dtrace_hash	*dtrace_byfunc;
+struct dtrace_hash	*dtrace_byname;
+
+int dtrace_match_priv(const struct dtrace_probe *prp, uint32_t priv,
+		      kuid_t uid)
+{
+	if (priv != DTRACE_PRIV_ALL) {
+		uint32_t	ppriv =
+				prp->dtpr_provider->dtpv_priv.dtpp_flags;
+		uint32_t	match = priv & ppriv;
+
+		if ((priv & (DTRACE_PRIV_PROC | DTRACE_PRIV_USER |
+		    DTRACE_PRIV_KERNEL)) == 0)
+			return 0;
+
+		if (match == 0 && ppriv != 0)
+			return 0;
+
+		if (((ppriv & ~match) & DTRACE_PRIV_OWNER) != 0 &&
+		    !uid_eq(uid, make_kuid(init_user_namespace,
+			       prp->dtpr_provider->dtpv_priv.dtpp_uid)))
+			return 0;
+	}
+
+	return 1;
+}
+
+int dtrace_match_probe(const struct dtrace_probe *prp,
+		       const struct dtrace_probekey *pkp,
+		       uint32_t priv, kuid_t uid)
+{
+	struct dtrace_provider	*pvp = prp->dtpr_provider;
+	int			rv;
+
+	if (pvp->dtpv_defunct)
+		return 0;
+
+	rv = pkp->dtpk_pmatch(pvp->dtpv_name, pkp->dtpk_prov, 0);
+	if (rv <= 0)
+		return rv;
+
+	rv = pkp->dtpk_mmatch(prp->dtpr_mod, pkp->dtpk_mod, 0);
+	if (rv <= 0)
+		return rv;
+
+	rv = pkp->dtpk_fmatch(prp->dtpr_func, pkp->dtpk_func, 0);
+	if (rv <= 0)
+		return rv;
+
+	rv = pkp->dtpk_nmatch(prp->dtpr_name, pkp->dtpk_name, 0);
+	if (rv <= 0)
+		return rv;
+
+	if (dtrace_match_priv(prp, priv, uid) == 0)
+		return 0;
+
+	return rv;
+}
+
+int dtrace_match_glob(const char *s, const char *p, int depth)
+{
+	const char	*olds;
+	char		s1, c;
+	int		gs;
+
+	if (depth > DTRACE_PROBEKEY_MAXDEPTH)
+		return -1;
+
+	if (s == NULL)
+		s = "";
+
+top:
+	olds = s;
+	s1 = *s++;
+
+	if (p == NULL)
+		return 0;
+
+	c = *p++;
+	if (c == '\0')
+		return s1 == '\0';
+
+	switch (c) {
+	case '[':
+		{
+			int	ok = 0, notflag = 0;
+			char	lc = '\0';
+
+			if (s1 == '\0')
+				return 0;
+
+			if (*p == '!') {
+				notflag = 1;
+				p++;
+			}
+
+			c = *p++;
+			if (c == '\0')
+				return 0;
+
+			do {
+				if (c == '-' && lc != '\0' && *p != ']') {
+					c = *p++;
+					if (c == '\0')
+						return 0;
+					if (c == '\\') {
+						c = *p++;
+						if (c == '\0')
+							return 0;
+					}
+					if (notflag) {
+						if (s1 < lc || s1 > c)
+							ok++;
+						else
+							return 0;
+					} else if (lc <= s1 && s1 <= c)
+						ok++;
+				} else if (c == '\\') {
+					c = *p++;
+					if (c == '\0')
+						return 0;
+				}
+				lc = c;
+
+				if (notflag) {
+					if (s1 != c)
+						ok++;
+					else
+						return 0;
+				} else if (s1 == c)
+					ok++;
+
+				c = *p++;
+				if (c == '\0')
+					return 0;
+			} while (c != ']');
+
+			if (ok)
+				goto top;
+
+			return 0;
+		}
+
+	case '\\':
+		c = *p++;
+		if (c == '\0')
+			return 0;
+		/* fallthru */
+	default:
+		if (c != s1)
+			return 0;
+		/* fallthru */
+
+	case '?':
+		if (s1 != '\0')
+			goto top;
+
+		return 0;
+
+	case '*':
+		while (*p == '*')
+			p++;
+
+		if (*p == '\0')
+			return 1;
+
+		for (s = olds; *s != '\0'; s++) {
+			gs = dtrace_match_glob(s, p, depth + 1);
+			if (gs != 0)
+				return gs;
+		}
+
+		return 0;
+	}
+}
+
+int dtrace_match_string(const char *s, const char *p, int depth)
+{
+	return s != NULL && strcmp(s, p) == 0;
+}
+
+int dtrace_match_nul(const char *s, const char *p, int depth)
+{
+	return 1;
+}
+
+int dtrace_match_nonzero(const char *s, const char *p, int depth)
+{
+	return s != NULL && s[0] != '\0';
+}
+
+struct probe_match {
+	const struct dtrace_probekey *pkp;
+	uint32_t		priv;
+	kuid_t			uid;
+	int			(*matched)(struct dtrace_probe *, void *);
+	void			*arg;
+	int			nmatched;
+};
+
+static int dtrace_match_one(int id, void *p, void *data)
+{
+	struct probe_match	*pbm	= (struct probe_match *)data;
+	struct dtrace_probe	*probe	= (struct dtrace_probe *)p;
+	int			rc;
+
+	if (dtrace_match_probe(probe, pbm->pkp, pbm->priv, pbm->uid) <= 0)
+		return 0;
+
+	pbm->nmatched++;
+
+	rc = (pbm->matched)(probe, pbm->arg);
+	if (rc != DTRACE_MATCH_NEXT) {
+		if (rc == DTRACE_MATCH_FAIL)
+			return DTRACE_MATCH_FAIL;
+	}
+
+	return 0;
+}
+
+int dtrace_match(const struct dtrace_probekey *pkp, uint32_t priv, kuid_t uid,
+		 int (*matched)(struct dtrace_probe *, void *), void *arg)
+{
+	struct dtrace_probe	template, *probe;
+	struct dtrace_hash	*hash = NULL;
+	int			len, rc, best = INT_MAX, nmatched = 0;
+
+	if (pkp->dtpk_id != DTRACE_IDNONE) {
+		probe = dtrace_probe_lookup_id(pkp->dtpk_id);
+		if (probe != NULL &&
+		    dtrace_match_probe(probe, pkp, priv, uid) > 0) {
+			if ((*matched)(probe, arg) == DTRACE_MATCH_FAIL)
+				return DTRACE_MATCH_FAIL;
+
+			nmatched++;
+		}
+
+		return nmatched;
+	}
+
+	template.dtpr_mod = (char *)pkp->dtpk_mod;
+	template.dtpr_func = (char *)pkp->dtpk_func;
+	template.dtpr_name = (char *)pkp->dtpk_name;
+
+	if (pkp->dtpk_mmatch == &dtrace_match_string) {
+		len = dtrace_hash_collisions(dtrace_bymod, &template);
+		if (len < best) {
+			best = len;
+			hash = dtrace_bymod;
+		}
+	}
+
+	if (pkp->dtpk_fmatch == &dtrace_match_string) {
+		len = dtrace_hash_collisions(dtrace_byfunc, &template);
+		if (len < best) {
+			best = len;
+			hash = dtrace_byfunc;
+		}
+	}
+
+	if (pkp->dtpk_nmatch == &dtrace_match_string) {
+		len = dtrace_hash_collisions(dtrace_byname, &template);
+		if (len < best) {
+			best = len;
+			hash = dtrace_byname;
+		}
+	}
+
+	if (hash == NULL) {
+		struct probe_match	pbm;
+
+		pbm.pkp = pkp;
+		pbm.priv = priv;
+		pbm.uid = uid;
+		pbm.matched = matched;
+		pbm.arg = arg;
+		pbm.nmatched = 0;
+
+		rc = dtrace_probe_for_each(dtrace_match_one, &pbm);
+		if (rc == DTRACE_MATCH_FAIL)
+			return DTRACE_MATCH_FAIL;
+
+		return pbm.nmatched;
+	}
+
+	for (probe = dtrace_hash_lookup(hash, &template); probe != NULL;
+	     probe = *(DTRACE_HASHNEXT(hash, probe))) {
+		if (dtrace_match_probe(probe, pkp, priv, uid) <= 0)
+			continue;
+
+		nmatched++;
+
+		rc = (*matched)(probe, arg);
+		if (rc != DTRACE_MATCH_NEXT) {
+			if (rc == DTRACE_MATCH_FAIL)
+				return DTRACE_MATCH_FAIL;
+
+			break;
+		}
+	}
+
+	return nmatched;
+}
+
+static dtrace_probekey_f *dtrace_probekey_func(const char *p)
+{
+	char	c;
+
+	if (p == NULL || *p == '\0')
+		return &dtrace_match_nul;
+
+	while ((c = *p++) != '\0') {
+		if (c == '[' || c == '?' || c == '*' || c == '\\')
+			return &dtrace_match_glob;
+	}
+
+	return &dtrace_match_string;
+}
+
+void dtrace_probekey(const struct dtrace_probedesc *pdp,
+		     struct dtrace_probekey *pkp)
+{
+	pkp->dtpk_prov = pdp->dtpd_provider;
+	pkp->dtpk_pmatch = dtrace_probekey_func(pdp->dtpd_provider);
+
+	pkp->dtpk_mod = pdp->dtpd_mod;
+	pkp->dtpk_mmatch = dtrace_probekey_func(pdp->dtpd_mod);
+
+	pkp->dtpk_func = pdp->dtpd_func;
+	pkp->dtpk_fmatch = dtrace_probekey_func(pdp->dtpd_func);
+
+	pkp->dtpk_name = pdp->dtpd_name;
+	pkp->dtpk_nmatch = dtrace_probekey_func(pdp->dtpd_name);
+
+	pkp->dtpk_id = pdp->dtpd_id;
+
+	if (pkp->dtpk_id == DTRACE_IDNONE &&
+	    pkp->dtpk_pmatch == &dtrace_match_nul &&
+	    pkp->dtpk_mmatch == &dtrace_match_nul &&
+	    pkp->dtpk_fmatch == &dtrace_match_nul &&
+	    pkp->dtpk_nmatch == &dtrace_match_nul)
+		pkp->dtpk_fmatch = &dtrace_match_nonzero;
+}
diff --git a/dtrace/dtrace_mod.c b/dtrace/dtrace_mod.c
new file mode 100644
index 000000000000..4da08c3cd816
--- /dev/null
+++ b/dtrace/dtrace_mod.c
@@ -0,0 +1,45 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_mod.c
+ * DESCRIPTION:	DTrace - framework kernel module
+ *
+ * Copyright (c) 2010, 2011, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+
+#include "dtrace_dev.h"
+
+MODULE_AUTHOR("Kris Van Hees (kris.van.hees@oracle.com)");
+MODULE_DESCRIPTION("Dynamic Tracing");
+MODULE_VERSION("v0.1");
+MODULE_LICENSE("GPL");
+
+/*
+ * Initialize the module.
+ */
+static int __init dtrace_init(void)
+{
+	return dtrace_dev_init();
+}
+
+/*
+ * Perform cleanup before the module is removed.
+ */
+static void __exit dtrace_exit(void)
+{
+	dtrace_dev_exit();
+}
+
+module_init(dtrace_init);
+module_exit(dtrace_exit);
diff --git a/dtrace/dtrace_predicate.c b/dtrace/dtrace_predicate.c
new file mode 100644
index 000000000000..004a1c542c76
--- /dev/null
+++ b/dtrace/dtrace_predicate.c
@@ -0,0 +1,80 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_predicate.c
+ * DESCRIPTION:	DTrace - predicate cache implementation
+ *
+ * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/slab.h>
+
+#include "dtrace.h"
+
+static dtrace_cacheid_t	dtrace_predcache_id = DTRACE_CACHEIDNONE + 1;
+
+struct dtrace_predicate *dtrace_predicate_create(struct dtrace_difo *dp)
+{
+	struct dtrace_predicate	*pred;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(dp->dtdo_refcnt != 0);
+
+	pred = kzalloc(sizeof(struct dtrace_predicate), GFP_KERNEL);
+	if (pred == NULL)
+		return NULL;
+
+	pred->dtp_difo = dp;
+	pred->dtp_refcnt = 1;
+
+	if (!dtrace_difo_cacheable(dp))
+		return pred;
+
+	/*
+	 * This is only theoretically possible -- we have had 2^32 cacheable
+	 * predicates on this machine.  We cannot allow any more predicates to
+	 * become cacheable:  as unlikely as it is, there may be a thread
+	 * caching a (now stale) predicate cache ID. (N.B.: the temptation is
+	 * being successfully resisted to have this cmn_err() "Holy shit -- we
+	 * executed this code!")
+	 */
+	if (dtrace_predcache_id == DTRACE_CACHEIDNONE)
+		return pred;
+
+	pred->dtp_cacheid = dtrace_predcache_id++;
+
+	return pred;
+}
+
+void dtrace_predicate_hold(struct dtrace_predicate *pred)
+{
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(pred->dtp_difo != NULL && pred->dtp_difo->dtdo_refcnt != 0);
+	ASSERT(pred->dtp_refcnt > 0);
+
+	pred->dtp_refcnt++;
+}
+
+void dtrace_predicate_release(struct dtrace_predicate *pred,
+			      struct dtrace_vstate *vstate)
+{
+	struct dtrace_difo *dp = pred->dtp_difo;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(dp != NULL && dp->dtdo_refcnt != 0);
+	ASSERT(pred->dtp_refcnt > 0);
+
+	if (--pred->dtp_refcnt == 0) {
+		dtrace_difo_release(dp, vstate);
+		kfree(pred);
+	}
+}
diff --git a/dtrace/dtrace_priv.c b/dtrace/dtrace_priv.c
new file mode 100644
index 000000000000..f50133de572d
--- /dev/null
+++ b/dtrace/dtrace_priv.c
@@ -0,0 +1,120 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_priv.c
+ * DESCRIPTION:	DTrace - privilege support implementation
+ *
+ * Copyright (c) 2010, 2015, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dtrace_cpu.h>
+
+#include "dtrace.h"
+
+/*
+ * This privilege check should be used by actions and subroutines to
+ * verify that the user credentials of the process that enabled the
+ * invoking ECB match the target credentials
+ */
+int dtrace_priv_proc_common_user(struct dtrace_state *state)
+{
+	const struct cred *cr, *s_cr = state->dts_cred.dcr_cred;
+
+	/*
+	 * We should always have a non-NULL state cred here, since if cred
+	 * is null (anonymous tracing), we fast-path bypass this routine.
+	 */
+	ASSERT(s_cr != NULL);
+
+	cr = current_cred();
+	if (cr != NULL &&
+	    uid_eq(s_cr->euid, cr->euid) &&
+	    uid_eq(s_cr->euid, cr->uid) &&
+	    uid_eq(s_cr->euid, cr->suid) &&
+	    gid_eq(s_cr->egid, cr->egid) &&
+	    gid_eq(s_cr->egid, cr->gid) &&
+	    gid_eq(s_cr->egid, cr->sgid))
+		return 1;
+
+	return 0;
+}
+
+/*
+ * This privilege check should be used by actions and subroutines to
+ * verify that the process has not setuid or changed credentials.
+ */
+int dtrace_priv_proc_common_nocd(void)
+{
+#ifdef FIXME
+	proc_t	*proc;
+
+	proc = ttoproc(curthread);
+	if (proc != NULL && !(proc->p_flag & SNOCD))
+		return 1;
+#endif
+
+	return 0;
+}
+
+int dtrace_priv_proc_destructive(struct dtrace_state *state)
+{
+	int	action = state->dts_cred.dcr_action;
+
+	if (((action & DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER) == 0) &&
+	    dtrace_priv_proc_common_user(state) == 0)
+		goto bad;
+
+	if (((action & DTRACE_CRA_PROC_DESTRUCTIVE_CREDCHG) == 0) &&
+	    dtrace_priv_proc_common_nocd() == 0)
+		goto bad;
+
+	return 1;
+
+bad:
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_UPRIV);
+
+	return 0;
+}
+
+int dtrace_priv_proc_control(struct dtrace_state *state)
+{
+	if (state->dts_cred.dcr_action & DTRACE_CRA_PROC_CONTROL)
+		return 1;
+
+	if (dtrace_priv_proc_common_user(state) &&
+	    dtrace_priv_proc_common_nocd())
+		return 1;
+
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_UPRIV);
+
+	return 0;
+}
+
+int dtrace_priv_proc(struct dtrace_state *state)
+{
+	if (state->dts_cred.dcr_action & DTRACE_CRA_PROC)
+		return 1;
+
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_UPRIV);
+
+	return 0;
+}
+
+int dtrace_priv_kernel(struct dtrace_state *state)
+{
+	if (state->dts_cred.dcr_action & DTRACE_CRA_KERNEL)
+		return 1;
+
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_KPRIV);
+
+	return 0;
+}
diff --git a/dtrace/dtrace_probe.c b/dtrace/dtrace_probe.c
new file mode 100644
index 000000000000..8e2e04cb9c13
--- /dev/null
+++ b/dtrace/dtrace_probe.c
@@ -0,0 +1,1542 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_probe.c
+ * DESCRIPTION:	DTrace - probe implementation
+ *
+ * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dtrace_cpu.h>
+#include <linux/dtrace_task_impl.h>
+#include <linux/hardirq.h>
+#include <linux/highmem.h>
+#include <linux/idr.h>
+#include <linux/module.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <asm/pgtable.h>
+#include <asm/cmpxchg.h>
+#include <linux/sched/signal.h>
+
+#include "dtrace.h"
+
+ktime_t				dtrace_chill_interval =
+					KTIME_INIT(1, 0);
+ktime_t				dtrace_chill_max =
+					KTIME_INIT(0,
+						   500 * (NANOSEC / MILLISEC));
+
+dtrace_genid_t			dtrace_probegen;
+struct kmem_cache		*dtrace_probe_cachep;
+
+static struct idr		dtrace_probe_idr;
+
+static struct task_struct	*dtrace_panicked;
+
+/*
+ * Free probe structure (including partially filled in ones).
+ */
+void dtrace_probe_free(struct dtrace_probe *probe)
+{
+	if (probe == NULL)
+		return;
+
+	dtrace_probe_remove_id(probe->dtpr_id);
+
+	kfree(probe->dtpr_mod);
+	kfree(probe->dtpr_func);
+	kfree(probe->dtpr_name);
+
+	kmem_cache_free(dtrace_probe_cachep, probe);
+}
+
+/*
+ * Create a new probe.
+ */
+dtrace_id_t dtrace_probe_create(dtrace_provider_id_t prov, const char *mod,
+				const char *func, const char *name,
+				int aframes, void *arg)
+{
+	struct dtrace_probe	*probe;
+	struct dtrace_provider	*provider = (struct dtrace_provider *)prov;
+	dtrace_id_t		id;
+
+	probe = kmem_cache_alloc(dtrace_probe_cachep, GFP_KERNEL);
+	if (probe == NULL)
+		goto err_probe;
+
+	/*
+	 * The idr_preload() should be called without holding locks as it may
+	 * block.  At the same time it is required to protect DTrace structures.
+	 * We can't drop it before idr_preload() and acquire after it because
+	 * we can't sleep in atomic context (until we reach idr_preload_end()).
+	 *
+	 * It is better to delay DTrace framework than traced host so the lock
+	 * is being held for the duration of idr allocation.
+	 *
+	 * When the provider is the DTrace core itself, dtrace_lock will be
+	 * held when we enter this function.
+	 */
+	if (provider == dtrace_provider)
+		ASSERT(MUTEX_HELD(&dtrace_lock));
+	else
+		mutex_lock(&dtrace_lock);
+
+	idr_preload(GFP_KERNEL);
+	id = idr_alloc_cyclic(&dtrace_probe_idr, probe, 0, 0, GFP_NOWAIT);
+	idr_preload_end();
+	if (id < 0)
+		goto err_probe;
+
+	probe->dtpr_id = id;
+	probe->dtpr_ecb = NULL;
+	probe->dtpr_ecb_last = NULL;
+	probe->dtpr_arg = arg;
+	probe->dtpr_predcache = DTRACE_CACHEIDNONE;
+	probe->dtpr_aframes = aframes;
+	probe->dtpr_provider = provider;
+
+	probe->dtpr_mod = dtrace_strdup(mod);
+	if (probe->dtpr_mod == NULL)
+		goto err_probe;
+
+	probe->dtpr_func = dtrace_strdup(func);
+	if (probe->dtpr_func == NULL)
+		goto err_probe;
+
+	probe->dtpr_name = dtrace_strdup(name);
+	if (probe->dtpr_name == NULL)
+		goto err_probe;
+
+	probe->dtpr_nextmod = probe->dtpr_prevmod = NULL;
+	probe->dtpr_nextfunc = probe->dtpr_prevfunc = NULL;
+	probe->dtpr_nextname = probe->dtpr_prevname = NULL;
+	probe->dtpr_gen = dtrace_probegen++;
+
+	if (dtrace_hash_add(dtrace_bymod, probe) != 0)
+		goto err_probe;
+
+	if (dtrace_hash_add(dtrace_byfunc, probe) != 0)
+		goto err_hash_byfunc;
+
+	if (dtrace_hash_add(dtrace_byname, probe) != 0)
+		goto err_hash_byname;
+
+	if (provider != dtrace_provider)
+		mutex_unlock(&dtrace_lock);
+
+	return id;
+
+err_hash_byname:
+	dtrace_hash_remove(dtrace_byfunc, probe);
+err_hash_byfunc:
+	dtrace_hash_remove(dtrace_bymod, probe);
+err_probe:
+	dtrace_probe_free(probe);
+	if (provider != dtrace_provider)
+		mutex_unlock(&dtrace_lock);
+	return DTRACE_IDNONE;
+}
+EXPORT_SYMBOL(dtrace_probe_create);
+
+int dtrace_probe_enable(const struct dtrace_probedesc *desc,
+			struct dtrace_enabling *enab)
+{
+	struct dtrace_probekey	pkey;
+	uint32_t		priv;
+	kuid_t			uid;
+
+	dtrace_ecb_create_cache = NULL;
+
+	if (desc == NULL) {
+		(void) dtrace_ecb_create_enable(NULL, enab);
+
+		return 0;
+	}
+
+	dtrace_probekey(desc, &pkey);
+	dtrace_cred2priv(enab->dten_vstate->dtvs_state->dts_cred.dcr_cred,
+			 &priv, &uid);
+
+	return dtrace_match(&pkey, priv, uid, dtrace_ecb_create_enable, enab);
+}
+
+/*
+ * Return the probe argument associated with the specified probe.
+ */
+void *dtrace_probe_arg(dtrace_provider_id_t id, dtrace_id_t pid)
+{
+	struct dtrace_probe	*probe;
+	void			*rval = NULL;
+
+	mutex_lock(&dtrace_lock);
+
+	probe = dtrace_probe_lookup_id(pid);
+	if (probe != NULL &&
+	    probe->dtpr_provider == (struct dtrace_provider *)id)
+		rval = probe->dtpr_arg;
+
+	mutex_unlock(&dtrace_lock);
+
+	return rval;
+}
+EXPORT_SYMBOL(dtrace_probe_arg);
+
+/*
+ * Copy a probe into a probe description.
+ */
+void dtrace_probe_description(const struct dtrace_probe *prp,
+			      struct dtrace_probedesc *pdp)
+{
+	memset(pdp, 0, sizeof(struct dtrace_probedesc));
+	pdp->dtpd_id = prp->dtpr_id;
+
+	strncpy(pdp->dtpd_provider, prp->dtpr_provider->dtpv_name,
+		DTRACE_PROVNAMELEN - 1);
+
+	strncpy(pdp->dtpd_mod, prp->dtpr_mod, DTRACE_MODNAMELEN - 1);
+	strncpy(pdp->dtpd_func, prp->dtpr_func, DTRACE_FUNCNAMELEN - 1);
+	strncpy(pdp->dtpd_name, prp->dtpr_name, DTRACE_NAMELEN - 1);
+}
+
+void dtrace_probe_provide(struct dtrace_probedesc *desc,
+			  struct dtrace_provider *prv)
+{
+	int		all = 0;
+
+	if (prv == NULL) {
+		all = 1;
+		prv = dtrace_provider;
+	}
+
+	do {
+		prv->dtpv_pops.dtps_provide(prv->dtpv_arg, desc);
+		dtrace_for_each_module(prv->dtpv_pops.dtps_provide_module,
+				       prv->dtpv_arg);
+	} while (all && (prv = prv->dtpv_next) != NULL);
+}
+
+/*
+ * Atomically increment a specified error counter from probe context.
+ */
+static void dtrace_error(uint32_t *counter)
+{
+	/*
+	 * Most counters stored to in probe context are per-CPU counters.
+	 * However, there are some error conditions that are sufficiently
+	 * arcane that they don't merit per-CPU storage.  If these counters
+	 * are incremented concurrently on different CPUs, scalability will be
+	 * adversely affected -- but we don't expect them to be white-hot in a
+	 * correctly constructed enabling...
+	 */
+	uint32_t	oval, nval;
+
+	do {
+		oval = *counter;
+
+		nval = oval + 1;
+		if (nval == 0) {
+			/*
+			 * If the counter would wrap, set it to 1 -- assuring
+			 * that the counter is never zero when we have seen
+			 * errors.  (The counter must be 32-bits because we
+			 * aren't guaranteed a 64-bit compare&swap operation.)
+			 * To save this code both the infamy of being fingered
+			 * by a priggish news story and the indignity of being
+			 * the target of a neo-puritan witch trial, we're
+			 * carefully avoiding any colorful description of the
+			 * likelihood of this condition -- but suffice it to
+			 * say that it is only slightly more likely than the
+			 * overflow of predicate cache IDs, as discussed in
+			 * dtrace_predicate_create().
+			 */
+			nval = 1;
+		}
+	} while (cmpxchg(counter, oval, nval) != oval);
+}
+
+static int dtrace_priv_kernel_destructive(struct dtrace_state *state)
+{
+	if (state->dts_cred.dcr_action & DTRACE_CRA_KERNEL_DESTRUCTIVE)
+		return 1;
+
+	DTRACE_CPUFLAG_SET(CPU_DTRACE_KPRIV);
+
+	return 0;
+}
+
+static void dtrace_action_breakpoint(struct dtrace_ecb *ecb)
+{
+	struct dtrace_probe	*probe = ecb->dte_probe;
+	struct dtrace_provider	*prov = probe->dtpr_provider;
+	char			c[DTRACE_FULLNAMELEN + 80], *str;
+	char			*msg = "dtrace: breakpoint action at probe ";
+	char			*ecbmsg = " (ecb ";
+	uintptr_t		mask = (0xf << (sizeof(uintptr_t) * NBBY / 4));
+	uintptr_t		val = (uintptr_t)ecb;
+	int			shift = (sizeof(uintptr_t) * NBBY) - 4, i = 0;
+
+	if (dtrace_destructive_disallow)
+		return;
+
+	/*
+	 * It's impossible to be taking action on the NULL probe.
+	 */
+	ASSERT(probe != NULL);
+
+	/*
+	 * This is a poor man's (destitute man's?) sprintf():  we want to
+	 * print the provider name, module name, function name and name of
+	 * the probe, along with the hex address of the ECB with the breakpoint
+	 * action -- all of which we must place in the character buffer by
+	 * hand.
+	 */
+	while (*msg != '\0')
+		c[i++] = *msg++;
+
+	for (str = prov->dtpv_name; *str != '\0'; str++)
+		c[i++] = *str;
+	c[i++] = ':';
+
+	for (str = probe->dtpr_mod; *str != '\0'; str++)
+		c[i++] = *str;
+	c[i++] = ':';
+
+	for (str = probe->dtpr_func; *str != '\0'; str++)
+		c[i++] = *str;
+	c[i++] = ':';
+
+	for (str = probe->dtpr_name; *str != '\0'; str++)
+		c[i++] = *str;
+
+	while (*ecbmsg != '\0')
+		c[i++] = *ecbmsg++;
+
+	while (shift >= 0) {
+		mask = (uintptr_t)0xf << shift;
+
+		if (val >= ((uintptr_t)1 << shift))
+			c[i++] = "0123456789abcdef"[(val & mask) >> shift];
+
+		shift -= 4;
+	}
+
+	c[i++] = ')';
+	c[i] = '\0';
+
+//	debug_enter(c); /* FIXME */
+}
+
+static void dtrace_action_panic(struct dtrace_ecb *ecb)
+{
+	struct dtrace_probe *probe = ecb->dte_probe;
+
+	/*
+	 * It's impossible to be taking action on the NULL probe.
+	 */
+	ASSERT(probe != NULL);
+
+	if (dtrace_destructive_disallow)
+		return;
+
+	if (dtrace_panicked != NULL)
+		return;
+
+	if (cmpxchg(&dtrace_panicked, NULL, current) != NULL)
+		return;
+
+	/*
+	 * We won the right to panic.  (We want to be sure that only one
+	 * thread calls panic() from dtrace_probe(), and that panic() is
+	 * called exactly once.)
+	 */
+	dtrace_panic(KERN_EMERG
+		     "dtrace: panic action at probe %s:%s:%s:%s (ecb %p)",
+		     probe->dtpr_provider->dtpv_name, probe->dtpr_mod,
+		     probe->dtpr_func, probe->dtpr_name, (void *)ecb);
+}
+
+static void dtrace_action_raise(uint64_t sig)
+{
+	if (current->dt_task == NULL)
+		return;
+
+	if (dtrace_destructive_disallow)
+		return;
+
+	if (sig >= _NSIG) {
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
+		return;
+	}
+
+	/*
+	 * raise() has a queue depth of 1 -- we ignore all subsequent
+	 * invocations of the raise() action.
+	 */
+	if (current->dt_task->dt_sig == 0)
+		current->dt_task->dt_sig = (uint8_t)sig;
+}
+
+static void dtrace_action_stop(void)
+{
+	if (current->dt_task == NULL)
+		return;
+
+	if (dtrace_destructive_disallow)
+		return;
+
+	if (!current->dt_task->dt_stop) {
+		current->dt_task->dt_stop = 1;
+//		current->sig_check = 1; /* FIXME */
+//		aston(current);		/* FIXME */
+	}
+}
+
+static void dtrace_action_chill(struct dtrace_mstate *mstate, ktime_t val)
+{
+	ktime_t			now;
+	volatile uint16_t	*flags;
+	struct cpu_core		*cpu = this_cpu_core;
+
+	if (dtrace_destructive_disallow)
+		return;
+
+	flags = (volatile uint16_t *)&cpu->cpuc_dtrace_flags;
+
+	now = dtrace_gethrtime();
+
+	if (ktime_gt(ktime_sub(now, cpu->cpu_dtrace_chillmark),
+		     dtrace_chill_interval)) {
+		/*
+		 * We need to advance the mark to current time.
+		 */
+		cpu->cpu_dtrace_chillmark = now;
+		cpu->cpu_dtrace_chilled = ktime_set(0, 0);
+	}
+
+	/*
+	 * Now check to see if the requested chill time would take us over
+	 * the maximum amount of time allowed in the chill interval.  (Or
+	 * worse, if the calculation itself induces overflow.)
+	 */
+	if (ktime_gt(ktime_add(cpu->cpu_dtrace_chilled, val),
+		     dtrace_chill_max) ||
+	    ktime_lt(ktime_add(cpu->cpu_dtrace_chilled, val),
+		     cpu->cpu_dtrace_chilled)) {
+		*flags |= CPU_DTRACE_ILLOP;
+		return;
+	}
+
+	while (ktime_lt(ktime_sub(dtrace_gethrtime(), now), val))
+		continue;
+
+	/*
+	 * Normally, we assure that the value of the variable "timestamp" does
+	 * not change within an ECB.  The presence of chill() represents an
+	 * exception from this rule, however.
+	 */
+	mstate->dtms_present &= ~DTRACE_MSTATE_TIMESTAMP;
+	cpu->cpu_dtrace_chilled = ktime_add(cpu->cpu_dtrace_chilled, val);
+}
+
+static void dtrace_action_ustack(struct dtrace_mstate *mstate,
+				 struct dtrace_state *state, uint64_t *buf,
+				 uint64_t arg)
+{
+	int		nframes = DTRACE_USTACK_NFRAMES(arg);
+	int		strsize = DTRACE_USTACK_STRSIZE(arg);
+	uint64_t	*pcs = &buf[2], *fps;
+	char		*str = (char *)&pcs[nframes];
+	int		size, offs = 0, i, j;
+	uintptr_t	old = mstate->dtms_scratch_ptr, saved;
+	uint16_t	*flags = &this_cpu_core->cpuc_dtrace_flags;
+	char		*sym;
+
+	/*
+	 * Should be taking a faster path if string space has not been
+	 * allocated.
+	 */
+	ASSERT(strsize != 0);
+
+	/*
+	 * We will first allocate some temporary space for the frame pointers.
+	 */
+	fps = (uint64_t *)P2ROUNDUP(mstate->dtms_scratch_ptr, 8);
+	size = (uintptr_t)fps - mstate->dtms_scratch_ptr +
+	       (nframes * sizeof(uint64_t));
+
+	if (!DTRACE_INSCRATCH(mstate, size)) {
+		/*
+		 * Not enough room for our frame pointers -- need to indicate
+		 * that we ran out of scratch space.
+		 */
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_NOSCRATCH);
+		return;
+	}
+
+	mstate->dtms_scratch_ptr += size;
+	saved = mstate->dtms_scratch_ptr;
+
+	/*
+	 * Now get a stack with both program counters and frame pointers.
+	 */
+	dtrace_getufpstack(buf, fps, nframes + 2);
+
+	/*
+	 * If that faulted, we're cooked.
+	 */
+	if (*flags & CPU_DTRACE_FAULT)
+		goto out;
+
+	/*
+	 * Now we want to walk up the stack, calling the USTACK helper.  For
+	 * each iteration, we restore the scratch pointer.
+	 */
+	for (i = 0; i < nframes; i++) {
+		mstate->dtms_scratch_ptr = saved;
+
+		if (offs >= strsize)
+			break;
+
+		sym = (char *)(uintptr_t)dtrace_helper(
+						DTRACE_HELPER_ACTION_USTACK,
+						mstate, state, pcs[i], fps[i]);
+
+		/*
+		 * If we faulted while running the helper, we're going to
+		 * clear the fault and null out the corresponding string.
+		 */
+		if (*flags & CPU_DTRACE_FAULT) {
+			*flags &= ~CPU_DTRACE_FAULT;
+			str[offs++] = '\0';
+			continue;
+		}
+
+		if (sym == NULL) {
+			str[offs++] = '\0';
+			continue;
+		}
+
+		DTRACE_CPUFLAG_SET(CPU_DTRACE_NOFAULT);
+
+		/*
+		 * Now copy in the string that the helper returned to us.
+		 */
+		for (j = 0; offs + j < strsize; j++) {
+			str[offs + j] = sym[j];
+			if (str[offs + j] == '\0')
+				break;
+		}
+
+		DTRACE_CPUFLAG_CLEAR(CPU_DTRACE_NOFAULT);
+
+		offs += j + 1;
+	}
+
+	/*
+	 * If we didn't have room for all of the strings, we don't abort
+	 * processing -- this needn't be a fatal error -- but we still want
+	 * to increment a counter (dts_stkstroverflows) to allow this condition
+	 * to be warned about.  (If this is from a jstack() action, it is
+	 * easily tuned via jstackstrsize.)
+	 */
+	if (offs >= strsize)
+		dtrace_error(&state->dts_stkstroverflows);
+
+	while (offs < strsize)
+		str[offs++] = '\0';
+
+out:
+	mstate->dtms_scratch_ptr = old;
+}
+
+/*
+ * This macro is used by dtrace_probe_pcap() below.  See linux/skbuff.h for the
+ * original.  Only change is we pass in an already dereferenced page.p as
+ * the fragment f.
+ */
+#define dtrace_skb_frag_foreach_page(f, f_off, f_len, p, p_off, p_len, copied) \
+	for (p = f + ((f_off) >> PAGE_SHIFT),				\
+	     p_off = (f_off) & (PAGE_SIZE - 1),				\
+	     p_len = skb_frag_must_loop(p) ?				\
+	     min_t(u32, f_len, PAGE_SIZE - p_off) : f_len,		\
+	     copied = 0;						\
+	     copied < f_len;						\
+	     copied += p_len, p++, p_off = 0,				\
+	     p_len = min_t(u32, f_len - copied, PAGE_SIZE))		\
+
+
+/*
+ * Capture skb data in linear and non-linear portions.  Returns 0 on success,
+ * -1 if an error is encountered.
+ */
+static __always_inline int dtrace_probe_pcap(uint64_t val, size_t *valoffs,
+					     size_t size, caddr_t tomax,
+					     ktime_t now,
+					     struct dtrace_mstate *mstate,
+					     struct dtrace_vstate *vstate,
+					     volatile uint16_t *flags)
+
+{
+	uintptr_t start = *valoffs, end = *valoffs + size;
+	uintptr_t skb_head, skb_data, skb_tail, shinfo;
+	uint32_t skb_end, tail, skb_len = 0;
+	uintptr_t baddr = val;
+	uint8_t nr_frags, f;
+	uint32_t data_len;
+
+	DTRACE_STORE(uint64_t, tomax, start, ktime_to_ns(now));
+
+	*valoffs += (2 * sizeof(uint64_t));
+
+	/*
+	 * Skip capture of NULL skbs.
+	 */
+	if ((void *)baddr == NULL)
+		goto pcap_done;
+
+	if (!dtrace_canload(baddr, sizeof(struct sk_buff), mstate, vstate))
+		return -1;
+
+	skb_data = dtrace_loadptr(baddr + offsetof(struct sk_buff, data));
+	skb_head = dtrace_loadptr(baddr + offsetof(struct sk_buff, head));
+	skb_len = dtrace_load32(baddr + offsetof(struct sk_buff, len));
+	tail = dtrace_load32(baddr + offsetof(struct sk_buff, tail));
+	skb_tail = skb_head + tail;
+
+	if (skb_tail < skb_data) {
+		*flags |= CPU_DTRACE_BADADDR;
+		return -1;
+	}
+	while (*valoffs < end && skb_data < skb_tail) {
+		DTRACE_STORE(uint8_t, tomax, (*valoffs)++,
+			     dtrace_load8(skb_data++));
+	}
+
+	data_len = dtrace_load32(baddr + offsetof(struct sk_buff, data_len));
+
+	/*
+	 * If skb is linear, no need to explore fragments.
+	 */
+	if (data_len == 0)
+		goto pcap_done;
+
+	skb_end = dtrace_load32(baddr + offsetof(struct sk_buff, end));
+	shinfo = skb_head + skb_end;
+
+	if (!dtrace_canload(shinfo, sizeof(struct skb_shared_info),
+			    mstate, vstate))
+		return -1;
+
+	nr_frags = dtrace_load8(shinfo + offsetof(struct skb_shared_info,
+				nr_frags));
+
+	/*
+	 * See skb_frag_foreach_page() macro usage elsewhere to understand the
+	 * manipulations here; the reason we need this complexity is to support
+	 * compound pages.
+	 */
+	for (f = 0; f < nr_frags; f++) {
+		uint32_t poff, plen, copied, flen;
+		struct page *p, *frag;
+		uintptr_t foff, v;
+		void *vaddr;
+
+		flen = dtrace_load32(shinfo + offsetof(struct skb_shared_info,
+				     frags[f].bv_len));
+		foff = dtrace_load32(shinfo + offsetof(struct skb_shared_info,
+				     frags[f].bv_offset));
+		frag = (struct page *)dtrace_loadptr(shinfo + offsetof(
+						     struct skb_shared_info,
+						     frags[f].bv_page));
+
+		dtrace_skb_frag_foreach_page(frag, foff, flen,
+					     p, poff, plen, copied) {
+			if (data_len == 0)
+				break;
+
+			vaddr = kmap_atomic(p);
+			v = (uintptr_t)vaddr + poff;
+			if (!dtrace_canload(v, plen, mstate, vstate)) {
+				kunmap_atomic(vaddr);
+				return -1;
+			}
+			while (*valoffs < end && data_len-- > 0) {
+				DTRACE_STORE(uint8_t, tomax, (*valoffs)++,
+					     dtrace_load8(v++));
+			}
+			kunmap_atomic(vaddr);
+		}
+	}
+
+pcap_done:
+	/*
+	 * Note that we store the skb len here rather than the portion of it we
+	 * capture; we can determine the latter when collecting data by using
+	 * the "pcapsize" option.  Packet capture headers specify a packet size
+	 * and a capture size, so we want to be able to provide both.  Since
+	 * the capture size can be determined from the packet length when
+	 * consuming records, we don't need to store it.
+	 */
+	DTRACE_STORE(uint64_t, tomax, start + sizeof(uint64_t),
+		     (uint64_t)skb_len);
+
+	return 0;
+}
+void dtrace_probe(dtrace_id_t id, uintptr_t arg0, uintptr_t arg1,
+		  uintptr_t arg2, uintptr_t arg3, uintptr_t arg4,
+		  uintptr_t arg5, uintptr_t arg6)
+{
+	processorid_t		cpuid;
+	dtrace_icookie_t	cookie;
+	struct dtrace_probe	*probe;
+	struct dtrace_mstate	mstate;
+	struct dtrace_ecb	*ecb;
+	struct dtrace_action	*act;
+	intptr_t		offs;
+	size_t			size;
+	int			onintr;
+	int			vtime;
+	volatile uint16_t	*flags;
+	ktime_t			now;
+	uint32_t		re_entry;
+	struct dtrace_task	*dtsk = current->dt_task;
+	dtrace_id_t		old_id;
+
+#ifdef FIXME
+	/*
+	 * Kick out immediately if this CPU is still being born (in which case
+	 * curthread will be set to -1) or the current thread can't allow
+	 * probes in its current context.
+	 */
+	if (((uintptr_t)curthread & 1) || (curthread->t_flag & T_DONTDTRACE))
+		return;
+#endif
+
+	DTRACE_SYNC_ENTER_CRITICAL(cookie, re_entry);
+
+	/*
+	 * Probe context is not re-entrant, unless we're getting called to
+	 * process an ERROR probe.
+	 */
+	flags = (volatile uint16_t *)&this_cpu_core->cpuc_dtrace_flags;
+	cpuid = smp_processor_id();
+	if (re_entry && id != dtrace_probeid_error) {
+		dt_dbg_probe("Attempt to fire probe from within a probe " \
+			     "(ID %d, oID %d, CPU %d)\n", id,
+			     (int)this_cpu_core->cpuc_current_probe, cpuid);
+		DTRACE_SYNC_EXIT_CRITICAL(cookie, re_entry);
+		return;
+	}
+
+	probe = dtrace_probe_lookup_id(id);
+	onintr = in_interrupt();
+
+	if (!onintr && probe->dtpr_predcache != DTRACE_CACHEIDNONE &&
+	    dtsk != NULL && probe->dtpr_predcache == dtsk->dt_predcache) {
+		DTRACE_SYNC_EXIT_CRITICAL(cookie, re_entry);
+		return;
+	}
+
+	if (oops_in_progress) {
+		DTRACE_SYNC_EXIT_CRITICAL(cookie, re_entry);
+		return;
+	}
+
+	old_id = this_cpu_core->cpuc_current_probe;
+	this_cpu_core->cpuc_current_probe = id;
+
+	now = dtrace_gethrtime();
+	vtime = (dtrace_vtime_references > 0);
+
+	if (vtime && dtsk != NULL && ktime_nz(dtsk->dt_start))
+		dtsk->dt_vtime = ktime_add(dtsk->dt_vtime,
+					   ktime_sub(now, dtsk->dt_start));
+
+	mstate.dtms_difo = NULL;
+	mstate.dtms_probe = probe;
+	mstate.dtms_strtok = (uintptr_t)NULL;
+	mstate.dtms_arg[0] = arg0;
+	mstate.dtms_arg[1] = arg1;
+	mstate.dtms_arg[2] = arg2;
+	mstate.dtms_arg[3] = arg3;
+	mstate.dtms_arg[4] = arg4;
+	mstate.dtms_arg[5] = arg5;
+	mstate.dtms_arg[6] = arg6;
+
+	for (ecb = probe->dtpr_ecb; ecb != NULL; ecb = ecb->dte_next) {
+		struct dtrace_predicate	*pred = ecb->dte_predicate;
+		struct dtrace_state	*state = ecb->dte_state;
+		struct dtrace_buffer	*buf = &state->dts_buffer[cpuid];
+		struct dtrace_buffer	*aggbuf = &state->dts_aggbuffer[cpuid];
+		struct dtrace_vstate	*vstate = &state->dts_vstate;
+		struct dtrace_provider	*prov = probe->dtpr_provider;
+		int			committed = 0;
+		caddr_t			tomax;
+
+		/*
+		 * A little subtlety with the following (seemingly innocuous)
+		 * declaration of the automatic 'val':  by looking at the
+		 * code, you might think that it could be declared in the
+		 * action processing loop, below.  (That is, it's only used in
+		 * the action processing loop.)  However, it must be declared
+		 * out of that scope because in the case of DIF expression
+		 * arguments to aggregating actions, one iteration of the
+		 * action loop will use the last iteration's value.
+		 */
+		uint64_t val = 0;
+
+		mstate.dtms_present = DTRACE_MSTATE_ARGS | DTRACE_MSTATE_PROBE;
+		*flags &= ~CPU_DTRACE_ERROR;
+
+		if (prov == dtrace_provider) {
+			/*
+			 * If dtrace itself is the provider of this probe,
+			 * we're only going to continue processing the ECB if
+			 * arg0 (the dtrace_state_t) is equal to the ECB's
+			 * creating state.  (This prevents disjoint consumers
+			 * from seeing one another's metaprobes.)
+			 */
+			if (arg0 != (uint64_t)(uintptr_t)state)
+				continue;
+		}
+
+		if (state->dts_activity != DTRACE_ACTIVITY_ACTIVE) {
+			/*
+			 * We're not currently active.  If our provider isn't
+			 * the dtrace pseudo provider, we're not interested.
+			 */
+			if (prov != dtrace_provider)
+				continue;
+
+			/*
+			 * Now we must further check if we are in the BEGIN
+			 * probe.  If we are, we will only continue orocessing
+			 * if we're still in WARMUP -- if one BEGIN enabling
+			 * has invoked the exit() action, we don't want to
+			 * evaluate subsequent BEGIN enablings.
+			 */
+			if (probe->dtpr_id == dtrace_probeid_begin &&
+			    state->dts_activity != DTRACE_ACTIVITY_WARMUP) {
+				ASSERT(state->dts_activity ==
+				       DTRACE_ACTIVITY_DRAINING);
+				continue;
+			}
+		}
+
+		dt_dbg_probe("Probe (ID %d EPID %d) on CPU %d...\n",
+			     id, ecb->dte_epid, cpuid);
+		if (ecb->dte_cond) {
+			/*
+			 * If the dte_cond bits indicate that this
+			 * consumer is only allowed to see user-mode firings
+			 * of this probe, call the provider's dtps_usermode()
+			 * entry point to check that the probe was fired
+			 * while in a user context. Skip this ECB if that's
+			 * not the case.
+			 */
+			if ((ecb->dte_cond & DTRACE_COND_USERMODE) &&
+			    prov->dtpv_pops.dtps_usermode(
+				prov->dtpv_arg, probe->dtpr_id, probe->dtpr_arg
+			    ) == 0) {
+				dt_dbg_probe("Probe (ID %d EPID %d) Skipped\n",
+					     id, ecb->dte_epid);
+				continue;
+			}
+
+			/*
+			 * This is more subtle than it looks. We have to be
+			 * absolutely certain that current_cred() isn't going
+			 * to change out from under us so it's only legit to
+			 * examine that structure if we're in constrained
+			 * situations. Currently, the only times we'll use this
+			 * check is if a non-super-user has enabled the
+			 * profile or syscall providers -- providers that
+			 * allow visibility of all processes. For the
+			 * profile case, the check above will ensure that
+			 * we're examining a user context.
+			 */
+			if (ecb->dte_cond & DTRACE_COND_OWNER) {
+				const struct cred *cr;
+				const struct cred *s_cr =
+					ecb->dte_state->dts_cred.dcr_cred;
+
+				ASSERT(s_cr != NULL);
+
+				cr = current_cred();
+				if (cr == NULL ||
+				    !uid_eq(s_cr->euid, cr->euid) ||
+				    !uid_eq(s_cr->euid, cr->uid) ||
+				    !uid_eq(s_cr->euid, cr->suid) ||
+				    !gid_eq(s_cr->egid, cr->egid) ||
+				    !gid_eq(s_cr->egid, cr->gid) ||
+				    !gid_eq(s_cr->egid, cr->sgid)) {
+					dt_dbg_probe("Probe (ID %d EPID %d) "
+						     "Skipped\n",
+						     id, ecb->dte_epid);
+					continue;
+				}
+			}
+		}
+
+		if (ktime_gt(ktime_sub(now, state->dts_alive),
+			     dtrace_deadman_timeout)) {
+			/*
+			 * We seem to be dead.  Unless we (a) have kernel
+			 * destructive permissions (b) have expicitly enabled
+			 * destructive actions and (c) destructive actions have
+			 * not been disabled, we're going to transition into
+			 * the KILLED state, from which no further processing
+			 * on this state will be performed.
+			 */
+			if (!dtrace_priv_kernel_destructive(state) ||
+			    !state->dts_cred.dcr_destructive ||
+			    dtrace_destructive_disallow) {
+				enum dtrace_activity	*activity =
+							&state->dts_activity;
+				enum dtrace_activity	curr;
+
+				do {
+					curr = state->dts_activity;
+				} while (cmpxchg(activity, curr,
+					 DTRACE_ACTIVITY_KILLED) != curr);
+
+				dt_dbg_probe("Probe (ID %d EPID %d) Skipped\n",
+					     id, ecb->dte_epid);
+				continue;
+			}
+		}
+
+		offs = dtrace_buffer_reserve(buf, ecb->dte_needed,
+					     ecb->dte_alignment, state,
+					     &mstate);
+		if (offs < 0) {
+			dt_dbg_probe("Probe (ID %d EPID %d) Skipped\n",
+				     id, ecb->dte_epid);
+			continue;
+		}
+
+		tomax = buf->dtb_tomax;
+		ASSERT(tomax != NULL);
+
+		if (ecb->dte_size != 0) {
+			DTRACE_STORE(uint32_t, tomax, offs, ecb->dte_epid);
+			dt_dbg_buf("    Store: %p[%ld .. %ld] <- %d [EPID] "
+				   "(from %s::%d)\n",
+				   buf, offs, offs + sizeof(uint32_t) - 1,
+				   ecb->dte_epid, __func__, __LINE__);
+		}
+
+		mstate.dtms_epid = ecb->dte_epid;
+		mstate.dtms_present |= DTRACE_MSTATE_EPID;
+
+		if (state->dts_cred.dcr_visible & DTRACE_CRV_KERNEL)
+			mstate.dtms_access = DTRACE_ACCESS_KERNEL;
+		else
+			mstate.dtms_access = 0;
+
+		if (pred != NULL) {
+			struct dtrace_difo	*dp = pred->dtp_difo;
+			int			rval;
+
+			dt_dbg_probe("  Evaluating predicate...\n");
+
+			rval = dtrace_dif_emulate(dp, &mstate, vstate, state);
+
+			if (!(*flags & CPU_DTRACE_ERROR) && !rval) {
+				dtrace_cacheid_t	cid =
+							probe->dtpr_predcache;
+
+				if (cid != DTRACE_CACHEIDNONE && !onintr) {
+					/*
+					 * Update the predicate cache...
+					 */
+					ASSERT(cid == pred->dtp_cacheid);
+					if (dtsk != NULL)
+						dtsk->dt_predcache = cid;
+				}
+
+				dt_dbg_probe("  Predicate not met (%d)\n",
+					     rval);
+				dt_dbg_probe("Probe (ID %d EPID %d) Done\n",
+					     id, ecb->dte_epid);
+				continue;
+			}
+
+			dt_dbg_probe("  Predicate met (%d)\n", rval);
+		}
+
+		for (act = ecb->dte_action;
+		     !(*flags & CPU_DTRACE_ERROR) && act != NULL;
+		     act = act->dta_next) {
+			size_t			valoffs;
+			struct dtrace_difo	*dp;
+			struct dtrace_recdesc	*rec = &act->dta_rec;
+
+			dt_dbg_probe("  Evaluating action %p (kind %d)...\n",
+				    act, act->dta_kind);
+
+			size = rec->dtrd_size;
+			valoffs = offs + rec->dtrd_offset;
+
+			if (DTRACEACT_ISAGG(act->dta_kind)) {
+				uint64_t			v = 0xbad;
+				struct dtrace_aggregation	*agg;
+
+				agg = (struct dtrace_aggregation *)act;
+
+				dp = act->dta_difo;
+				if (dp != NULL)
+					v = dtrace_dif_emulate(dp, &mstate,
+							       vstate, state);
+
+				if (*flags & CPU_DTRACE_ERROR)
+					continue;
+
+				/*
+				 * Note that we always pass the expression
+				 * value from the previous iteration of the
+				 * action loop.  This value will only be used
+				 * if there is an expression argument to the
+				 * aggregating action, denoted by the
+				 * dtag_hasarg field.
+				 */
+				dtrace_aggregate(agg, buf, offs, aggbuf, v,
+						 val);
+				continue;
+			}
+
+			switch (act->dta_kind) {
+			case DTRACEACT_STOP:
+				if (dtrace_priv_proc_destructive(state))
+					dtrace_action_stop();
+				continue;
+
+			case DTRACEACT_BREAKPOINT:
+				if (dtrace_priv_kernel_destructive(state))
+					dtrace_action_breakpoint(ecb);
+				continue;
+
+			case DTRACEACT_PANIC:
+				if (dtrace_priv_kernel_destructive(state))
+					dtrace_action_panic(ecb);
+				continue;
+
+			case DTRACEACT_STACK:
+				if (!dtrace_priv_kernel(state))
+					continue;
+
+				dtrace_getpcstack(
+					(uint64_t *)(tomax + valoffs),
+					size / sizeof(pc_t),
+					probe->dtpr_aframes + 1,
+					DTRACE_ANCHORED(probe)
+						? NULL
+						: (uint32_t *)arg0);
+
+				continue;
+
+			case DTRACEACT_JSTACK:
+			case DTRACEACT_USTACK:
+				if (!dtrace_priv_proc(state))
+					continue;
+
+				/*
+				 * See comment in DIF_VAR_PID.
+				 */
+				if (DTRACE_ANCHORED(mstate.dtms_probe) &&
+				    in_interrupt()) {
+					int	depth = DTRACE_USTACK_NFRAMES(
+							    rec->dtrd_arg) + 2;
+
+					dtrace_bzero((void *)(tomax + valoffs),
+						     DTRACE_USTACK_STRSIZE(
+							rec->dtrd_arg) +
+						     depth * sizeof(uint64_t));
+
+					continue;
+				}
+
+				if (DTRACE_USTACK_STRSIZE(rec->dtrd_arg) != 0 &&
+				    dtsk != NULL && dtsk->dt_helpers != NULL) {
+					/*
+					 * This is the slow path -- we have
+					 * allocated string space, and we're
+					 * getting the stack of a process that
+					 * has helpers.  Call into a separate
+					 * routine to perform this processing.
+					 */
+					dtrace_action_ustack(
+						&mstate, state,
+						(uint64_t *)(tomax + valoffs),
+						rec->dtrd_arg);
+					continue;
+				}
+
+				dtrace_getupcstack(
+					(uint64_t *)(tomax + valoffs),
+					DTRACE_USTACK_NFRAMES(rec->dtrd_arg) +
+					2);
+				continue;
+
+			default:
+				break;
+			}
+
+			dp = act->dta_difo;
+			ASSERT(dp != NULL);
+
+			val = dtrace_dif_emulate(dp, &mstate, vstate, state);
+
+			if (*flags & CPU_DTRACE_ERROR)
+				continue;
+
+			switch (act->dta_kind) {
+			case DTRACEACT_SPECULATE:
+				ASSERT(buf == &state->dts_buffer[cpuid]);
+				buf = dtrace_speculation_buffer(state, cpuid,
+								val);
+
+				if (buf == NULL) {
+					*flags |= CPU_DTRACE_DROP;
+					continue;
+				}
+
+				offs = dtrace_buffer_reserve(buf,
+							     ecb->dte_needed,
+							     ecb->dte_alignment,
+							     state, NULL);
+
+				if (offs < 0) {
+					*flags |= CPU_DTRACE_DROP;
+					continue;
+				}
+
+				tomax = buf->dtb_tomax;
+				ASSERT(tomax != NULL);
+
+				if (ecb->dte_size != 0) {
+					DTRACE_STORE(uint32_t, tomax, offs,
+						     ecb->dte_epid);
+					dt_dbg_buf("    Store: %p[%ld .. %ld] "
+						   "<- %d [EPID] "
+						   "(from %s::%d)\n",
+						   buf, offs,
+						   offs + sizeof(uint32_t) - 1,
+						   ecb->dte_epid,
+						   __FUNCTION__, __LINE__);
+				}
+
+				continue;
+
+			case DTRACEACT_CHILL:
+				if (dtrace_priv_kernel_destructive(state))
+					dtrace_action_chill(&mstate,
+							    ns_to_ktime(val));
+
+				continue;
+
+			case DTRACEACT_RAISE:
+				if (dtrace_priv_proc_destructive(state))
+					dtrace_action_raise(val);
+
+				continue;
+
+			case DTRACEACT_COMMIT:
+				ASSERT(!committed);
+
+				/*
+				 * We need to commit our buffer state.
+				 */
+				if (ecb->dte_size) {
+					buf->dtb_offset = offs + ecb->dte_size;
+					dt_dbg_buf("  Consume: %p[%ld .. "
+						   "%lld]\n",
+						   buf, offs,
+						   buf->dtb_offset - 1);
+				}
+
+				buf = &state->dts_buffer[cpuid];
+				dtrace_speculation_commit(state, cpuid, val);
+				committed = 1;
+				continue;
+
+			case DTRACEACT_DISCARD:
+				dtrace_speculation_discard(state, cpuid, val);
+				continue;
+
+			case DTRACEACT_DIFEXPR:
+			case DTRACEACT_LIBACT:
+			case DTRACEACT_PRINTF:
+			case DTRACEACT_PRINTA:
+			case DTRACEACT_SYSTEM:
+			case DTRACEACT_FREOPEN:
+			case DTRACEACT_TRACEMEM:
+			case DTRACEACT_PCAP:
+				break;
+
+			case DTRACEACT_SYM:
+			case DTRACEACT_MOD:
+				if (!dtrace_priv_kernel(state))
+					continue;
+				break;
+
+			case DTRACEACT_USYM:
+			case DTRACEACT_UMOD:
+			case DTRACEACT_UADDR: {
+				pid_t	pid = current->pid;
+				pid_t	tgid = current->tgid;
+
+				if (!dtrace_priv_proc(state))
+					continue;
+
+				DTRACE_STORE(uint64_t, tomax, valoffs,
+					     (uint64_t)pid);
+				dt_dbg_buf("    Store: %p[%ld .. %ld] <- %lld "
+					   "[PID] (from %s::%d)\n",
+					   buf, valoffs,
+					   valoffs + sizeof(uint64_t) - 1,
+					   (uint64_t)pid,
+					   __FUNCTION__, __LINE__);
+				DTRACE_STORE(uint64_t, tomax,
+					     valoffs + sizeof(uint64_t),
+					     (uint64_t)tgid);
+				dt_dbg_buf("    Store: %p[%ld .. %ld] <- %lld "
+					   "[TGID] (from %s::%d)\n",
+					   buf, valoffs + sizeof(uint64_t),
+					   valoffs + 2 * sizeof(uint64_t) - 1,
+					   (uint64_t)tgid,
+					   __FUNCTION__, __LINE__);
+				DTRACE_STORE(uint64_t, tomax,
+					     valoffs + 2 * sizeof(uint64_t),
+					     val);
+				dt_dbg_buf("    Store: %p[%ld .. %ld] <- %lld "
+					   "(from %s::%d)\n",
+					   buf, valoffs + 2 * sizeof(uint64_t),
+					   valoffs + 3 * sizeof(uint64_t) - 1,
+					   val, __FUNCTION__, __LINE__);
+
+				continue;
+			}
+
+			case DTRACEACT_EXIT: {
+				/*
+				 * For the exit action, we are going to attempt
+				 * to atomically set our activity to be
+				 * draining.  If this fails (either because
+				 * another CPU has beat us to the exit action,
+				 * or because our current activity is something
+				 * other than ACTIVE or WARMUP), we will
+				 * continue.  This assures that the exit action
+				 * can be successfully recorded at most once
+				 * when we're in the ACTIVE state.  If we're
+				 * encountering the exit() action while in
+				 * COOLDOWN, however, we want to honor the new
+				 * status code.  (We know that we're the only
+				 * thread in COOLDOWN, so there is no race.)
+				 */
+				enum dtrace_activity	*activity =
+							&state->dts_activity;
+				enum dtrace_activity	curr =
+							state->dts_activity;
+
+				if (curr == DTRACE_ACTIVITY_COOLDOWN)
+					break;
+
+				if (curr != DTRACE_ACTIVITY_WARMUP)
+					curr = DTRACE_ACTIVITY_ACTIVE;
+
+				if (cmpxchg(activity, curr,
+					    DTRACE_ACTIVITY_DRAINING) != curr) {
+					*flags |= CPU_DTRACE_DROP;
+					continue;
+				}
+
+				break;
+			}
+
+			default:
+				ASSERT(0);
+			}
+
+			if (dp->dtdo_rtype.dtdt_flags & DIF_TF_BYREF) {
+				uintptr_t	end = valoffs + size;
+
+				if (!dtrace_vcanload((void *)(uintptr_t)val,
+						      &dp->dtdo_rtype, &mstate,
+						      vstate))
+					continue;
+
+				if (act->dta_kind == DTRACEACT_PCAP) {
+					if (dtrace_probe_pcap(val, &valoffs,
+							      size, tomax, now,
+							      &mstate, vstate,
+							      flags) == -1)
+						break;
+					continue;
+				}
+
+				/*
+				 * If this is a string, we're going to only
+				 * load until we find the zero byte -- after
+				 * which we'll store zero bytes.
+				 */
+				if (dp->dtdo_rtype.dtdt_kind ==
+				    DIF_TYPE_STRING) {
+					char	c = '\0' + 1;
+					int	intuple = act->dta_intuple;
+					size_t	s;
+
+					for (s = 0; s < size; s++) {
+						if (c != '\0')
+							c = dtrace_load8(val++);
+
+						DTRACE_STORE(uint8_t, tomax,
+							     valoffs++, c);
+						dt_dbg_buf("    Store: %p[%ld]"
+							   " <- %d (from "
+							   "%s::%d)\n",
+							   buf, valoffs, c,
+							   __FUNCTION__,
+							   __LINE__);
+
+						if (c == '\0' && intuple)
+							break;
+					}
+
+					continue;
+				}
+
+				while (valoffs < end) {
+					DTRACE_STORE(uint8_t, tomax, valoffs++,
+						     dtrace_load8(val++));
+					dt_dbg_buf("    Store: %p[%ld] <- ??? "
+						   "(from %s::%d)\n",
+						   buf, valoffs,
+						   __FUNCTION__, __LINE__);
+				}
+
+				continue;
+			}
+
+			switch (size) {
+			case 0:
+				break;
+			case sizeof(uint8_t):
+				DTRACE_STORE(uint8_t, tomax, valoffs, val);
+				dt_dbg_buf("    Store: %p[%ld] <- %d "
+					   "(from %s::%d)\n",
+					   buf, valoffs, (uint8_t)val,
+					   __FUNCTION__, __LINE__);
+				break;
+			case sizeof(uint16_t):
+				DTRACE_STORE(uint16_t, tomax, valoffs, val);
+				dt_dbg_buf("    Store: %p[%ld .. %ld] <- %d "
+					   "(from %s::%d)\n",
+					   buf, valoffs,
+					   valoffs + sizeof(uint16_t) - 1,
+					   (uint16_t)val,
+					   __FUNCTION__, __LINE__);
+				break;
+			case sizeof(uint32_t):
+				DTRACE_STORE(uint32_t, tomax, valoffs, val);
+				dt_dbg_buf("    Store: %p[%ld] <- %d "
+					   "(from %s::%d)\n",
+					   buf, valoffs,
+					   (uint32_t)val,
+					   __FUNCTION__, __LINE__);
+				break;
+			case sizeof(uint64_t):
+				DTRACE_STORE(uint64_t, tomax, valoffs, val);
+				dt_dbg_buf("    Store: %p[%ld] <- %lld "
+					   "(from %s::%d)\n",
+					   buf, valoffs,
+					   val,
+					   __FUNCTION__, __LINE__);
+				break;
+			default:
+				/*
+				 * Any other size should have been returned by
+				 * reference, not by value.
+				 */
+				ASSERT(0);
+				break;
+			}
+		}
+
+		if (*flags & CPU_DTRACE_DROP) {
+			dt_dbg_probe("  -> Dropped\n");
+			continue;
+		}
+
+		if (*flags & CPU_DTRACE_FAULT) {
+			int			ndx;
+			struct dtrace_action	*err;
+
+			dt_dbg_probe("  -> Failed (%x)\n", *flags);
+
+			buf->dtb_errors++;
+
+			if (probe->dtpr_id == dtrace_probeid_error) {
+				/*
+				 * There's nothing we can do -- we had an
+				 * error on the error probe.  We bump an
+				 * error counter to at least indicate that
+				 * this condition happened.
+				 */
+				dtrace_error(&state->dts_dblerrors);
+				continue;
+			}
+
+			if (vtime && dtsk != NULL)
+				/*
+				 * Before recursing on dtrace_probe(), we
+				 * need to explicitly clear out our start
+				 * time to prevent it from being accumulated
+				 * into the dtrace_vtime.
+				 */
+				dtsk->dt_start = ktime_set(0, 0);
+
+			/*
+			 * Iterate over the actions to figure out which action
+			 * we were processing when we experienced the error.
+			 * Note that act points _past_ the faulting action; if
+			 * act is ecb->dte_action, the fault was in the
+			 * predicate, if it's ecb->dte_action->dta_next it's
+			 * in action #1, and so on.
+			 */
+			for (err = ecb->dte_action, ndx = 0;
+			     err != act; err = err->dta_next, ndx++)
+				continue;
+
+			dtrace_probe_error(
+				state, ecb->dte_epid, ndx,
+				(mstate.dtms_present & DTRACE_MSTATE_FLTOFFS)
+					? mstate.dtms_fltoffs
+					: -1,
+				DTRACE_FLAGS2FLT(*flags),
+				this_cpu_core->cpuc_dtrace_illval);
+
+			continue;
+		}
+
+		if (!committed) {
+			buf->dtb_offset = offs + ecb->dte_size;
+			dt_dbg_buf("  Consume: %p[%ld .. %lld]\n",
+				   buf, offs, buf->dtb_offset);
+		}
+
+		dt_dbg_probe("Probe (ID %d EPID %d) Done\n",
+			     id, ecb->dte_epid);
+	}
+
+	if (vtime && dtsk != NULL)
+		dtsk->dt_start = dtrace_gethrtime();
+
+	this_cpu_core->cpuc_current_probe = old_id;
+	DTRACE_SYNC_EXIT_CRITICAL(cookie, re_entry);
+
+	if (dtsk != NULL && dtsk->dt_sig != 0) {
+		int	sig = dtsk->dt_sig;
+
+		dtsk->dt_sig = 0;
+
+		send_sig(sig, current, 0);
+	}
+}
+EXPORT_SYMBOL(dtrace_probe);
+
+int dtrace_probe_init(void)
+{
+	dtrace_id_t	id;
+
+	dtrace_probe_cachep = KMEM_CACHE(dtrace_probe, SLAB_HWCACHE_ALIGN);
+	if (dtrace_probe_cachep == NULL)
+		return -ENOMEM;
+
+	idr_init(&dtrace_probe_idr);
+
+	/*
+	 * We create a ID 0 entry as a sentinel, so we can always depend on it
+	 * being the very first entry.  This is used in functionality that runs
+	 * through the list of probes.
+	 */
+	idr_preload(GFP_KERNEL);
+	id = idr_alloc_cyclic(&dtrace_probe_idr, NULL, 0, 0, GFP_NOWAIT);
+	idr_preload_end();
+
+	return id == 0 ? 0 : -EAGAIN;
+}
+
+void dtrace_probe_exit(void)
+{
+	idr_destroy(&dtrace_probe_idr);
+	kmem_cache_destroy(dtrace_probe_cachep);
+}
+
+void dtrace_probe_remove_id(dtrace_id_t id)
+{
+	idr_remove(&dtrace_probe_idr, id);
+}
+
+struct dtrace_probe *dtrace_probe_lookup_id(dtrace_id_t id)
+{
+	return idr_find(&dtrace_probe_idr, id);
+}
+
+static int dtrace_probe_lookup_match(struct dtrace_probe *probe, void *arg)
+{
+	*((dtrace_id_t *)arg) = probe->dtpr_id;
+
+	return DTRACE_MATCH_DONE;
+}
+
+dtrace_id_t dtrace_probe_lookup(dtrace_provider_id_t prid, const char *mod,
+				const char *func, const char *name)
+{
+	struct dtrace_probekey	pkey;
+	dtrace_id_t		id;
+	int			match;
+
+	pkey.dtpk_prov = ((struct dtrace_provider *)prid)->dtpv_name;
+	pkey.dtpk_pmatch = &dtrace_match_string;
+	pkey.dtpk_mod = mod;
+	pkey.dtpk_mmatch = mod ? &dtrace_match_string : &dtrace_match_nul;
+	pkey.dtpk_func = func;
+	pkey.dtpk_fmatch = func ? &dtrace_match_string : &dtrace_match_nul;
+	pkey.dtpk_name = name;
+	pkey.dtpk_nmatch = name ? &dtrace_match_string : &dtrace_match_nul;
+	pkey.dtpk_id = DTRACE_IDNONE;
+
+	mutex_lock(&dtrace_lock);
+	match = dtrace_match(&pkey, DTRACE_PRIV_ALL,
+			     make_kuid(init_user_namespace, 0),
+			     dtrace_probe_lookup_match, &id);
+	mutex_unlock(&dtrace_lock);
+
+	ASSERT(match == 1 || match == 0);
+
+	return match ? id : 0;
+}
+EXPORT_SYMBOL(dtrace_probe_lookup);
+
+struct dtrace_probe *dtrace_probe_get_next(dtrace_id_t *idp)
+{
+	return idr_get_next(&dtrace_probe_idr, idp);
+}
+
+int dtrace_probe_for_each(int (*fn)(int id, void *p, void *data), void *data)
+{
+	return idr_for_each(&dtrace_probe_idr, fn, data);
+}
diff --git a/dtrace/dtrace_probe_ctx.c b/dtrace/dtrace_probe_ctx.c
new file mode 100644
index 000000000000..f04b5b269222
--- /dev/null
+++ b/dtrace/dtrace_probe_ctx.c
@@ -0,0 +1,659 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_probe_ctx.c
+ * DESCRIPTION:	DTrace - probe context safe functions
+ *
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dtrace_cpu.h>
+
+#include "dtrace.h"
+
+void dtrace_panic(const char *fmt, ...)
+{
+	va_list		alist;
+
+	va_start(alist, fmt);
+	vprintk(fmt, alist);
+	va_end(alist);
+
+	BUG();
+}
+EXPORT_SYMBOL(dtrace_panic);
+
+int dtrace_assfail(const char *a, const char *f, int l)
+{
+	dtrace_panic(KERN_EMERG "assertion failed: %s, file: %s, line: %d",
+		     a, f, l);
+
+	/*
+	 * FIXME: We can do better than this.  The OpenSolaris DTrace source
+	 * states that this cannot be optimized away.
+	 */
+	return a[(uintptr_t)f];
+}
+EXPORT_SYMBOL(dtrace_assfail);
+
+#define DT_MASK_LO	0x00000000FFFFFFFFULL
+
+static void dtrace_add_128(uint64_t *addend1, uint64_t *addend2, uint64_t *sum)
+{
+	uint64_t	result[2];
+
+	result[0] = addend1[0] + addend2[0];
+	result[1] = addend1[1] + addend2[1] +
+		    (result[0] < addend1[0] || result[0] < addend2[0] ? 1 : 0);
+
+	sum[0] = result[0];
+	sum[1] = result[1];
+}
+
+static void dtrace_shift_128(uint64_t *a, int b)
+{
+	uint64_t	mask;
+
+	if (b == 0)
+		return;
+
+	if (b < 0) {
+		b = -b;
+
+		if (b >= 64) {
+			a[0] = a[1] >> (b - 64);
+			a[1] = 0;
+		} else {
+			a[0] >>= b;
+			mask = 1LL << (64 - b);
+			mask -= 1;
+			a[0] |= ((a[1] & mask) << (64 - b));
+			a[1] >>= b;
+		}
+	} else {
+		if (b >= 64) {
+			a[1] = a[0] << (b - 64);
+			a[0] = 0;
+		} else {
+			a[1] <<= b;
+			mask = a[0] >> (64 - b);
+			a[1] |= mask;
+			a[0] <<= b;
+		}
+	}
+}
+
+static void dtrace_multiply_128(uint64_t factor1, uint64_t factor2,
+				uint64_t *product)
+{
+	uint64_t	hi1, hi2, lo1, lo2;
+	uint64_t	tmp[2];
+
+	hi1 = factor1 >> 32;
+	hi2 = factor2 >> 32;
+
+	lo1 = factor1 & DT_MASK_LO;
+	lo2 = factor2 & DT_MASK_LO;
+
+	product[0] = lo1 * lo2;
+	product[1] = hi1 * hi2;
+
+	tmp[0] = hi1 * lo2;
+	tmp[1] = 0;
+	dtrace_shift_128(tmp, 32);
+	dtrace_add_128(product, tmp, product);
+
+	tmp[0] = hi2 * lo1;
+	tmp[1] = 0;
+	dtrace_shift_128(tmp, 32);
+	dtrace_add_128(product, tmp, product);
+}
+
+void dtrace_aggregate_min(uint64_t *oval, uint64_t nval, uint64_t arg)
+{
+	if ((int64_t)nval < (int64_t)*oval)
+		*oval = nval;
+}
+
+void dtrace_aggregate_max(uint64_t *oval, uint64_t nval, uint64_t arg)
+{
+	if ((int64_t)nval > (int64_t)*oval)
+		*oval = nval;
+}
+
+void dtrace_aggregate_quantize(uint64_t *quanta, uint64_t nval, uint64_t incr)
+{
+	int	i, zero = DTRACE_QUANTIZE_ZEROBUCKET;
+	int64_t	val = (int64_t)nval;
+
+	if (val < 0) {
+		for (i = 0; i < zero; i++) {
+			if (val <= DTRACE_QUANTIZE_BUCKETVAL(i)) {
+				quanta[i] += incr;
+
+				return;
+			}
+		}
+	} else {
+		for (i = zero + 1; i < DTRACE_QUANTIZE_NBUCKETS; i++) {
+			if (val < DTRACE_QUANTIZE_BUCKETVAL(i)) {
+				quanta[i - 1] += incr;
+
+				return;
+			}
+		}
+
+		quanta[DTRACE_QUANTIZE_NBUCKETS - 1] += incr;
+
+		return;
+	}
+
+	ASSERT(0);
+}
+
+void dtrace_aggregate_lquantize(uint64_t *lquanta, uint64_t nval,
+				uint64_t incr)
+{
+	uint64_t	arg = *lquanta++;
+	int32_t		base = DTRACE_LQUANTIZE_BASE(arg);
+	uint16_t	step = DTRACE_LQUANTIZE_STEP(arg);
+	uint16_t	levels = DTRACE_LQUANTIZE_LEVELS(arg);
+	int64_t		val = (int64_t)nval, level;
+
+	ASSERT(step != 0);
+	ASSERT(levels != 0);
+
+	if (val < base) {
+		lquanta[0] += incr;
+
+		return;
+	}
+
+	level = (val - base) / step;
+
+	if (level < levels) {
+		lquanta[level + 1] += incr;
+
+		return;
+	}
+
+	lquanta[levels + 1] += incr;
+}
+
+static uint64_t dtrace_pow(uint64_t base, uint64_t exp)
+{
+	uint64_t p, r;
+
+	p = base;
+	r = 1;
+	while (exp > 0) {
+		if (exp & 1)
+			r *= p;
+
+		p *= p;
+		exp >>= 1;
+	}
+
+	return (r);
+}
+
+void dtrace_aggregate_llquantize(uint64_t *llquanta, uint64_t nval,
+				 uint64_t incr)
+{
+	uint64_t arg = *llquanta++;
+	int factor = DTRACE_LLQUANTIZE_FACTOR(arg);
+	int lmag = DTRACE_LLQUANTIZE_LMAG(arg);
+	int hmag = DTRACE_LLQUANTIZE_HMAG(arg);
+	int steps = DTRACE_LLQUANTIZE_STEPS(arg);
+	int i, signbit, steps_factor, mag, underflow_bin;
+	uint64_t val, bucket_max;
+
+	ASSERT(steps != 0);
+	ASSERT(factor > 1);
+
+	if (nval >> (64 - 1)) {
+		signbit = -1;
+		val = 1 + ~nval;
+	} else {
+		signbit = +1;
+		val = nval;
+	}
+
+	/*
+	 * Compute steps/factor.
+	 * Notice that while we say there are "steps" bins per logarithmic
+	 * range, steps/factor of them actually overlap with lower ranges.
+	 * E.g., if factor=10 and steps=20, for mag=2 we have the 20 bins
+	 *     0 50 100 150 200 250 300 350 ... 800 850 900 950
+	 * but the first two actually belong to lower ranges.
+	 */
+	steps_factor = steps/factor;
+
+	/* the underflow bin is in the middle */
+	underflow_bin = 1 + (hmag-lmag+1) * (steps-steps_factor);
+
+	bucket_max = dtrace_pow(factor, lmag);
+
+	/* check for "underflow" (smaller than the smallest bin) */
+	if (val < bucket_max) {
+		llquanta[underflow_bin] += incr;
+		return;
+	}
+
+	/* loop over the logarithmic ranges */
+	i = 0;
+	for (mag = lmag; mag <= hmag; mag++) {
+		bucket_max *= factor;
+		if (val >= bucket_max)
+			continue;
+
+		/*
+		 * We want
+		 *     i = val * steps / bucket_max;
+		 * but val*steps could overflow.  An alternative is
+		 *     i = val / ( bucket_max/steps )
+		 * but bucket_max/steps might not divide evenly.
+		 * (Plus, we end up with an extra divide.)
+		 *
+		 * From Solaris, we inherit constraints on factor and steps
+		 * that mean bucket_max/steps divides evenly when mag>0.
+		 * Meanwhile, if mag==0, val*steps cannot overflow.
+		 * So between our two expressions for i, at least one
+		 * will work and we just have to pick which one to use.
+		 */
+		if (mag == 0)
+			i = val * steps / bucket_max;
+		else
+			i = val / (bucket_max/steps);
+
+		// shift for low indices that can never happen
+		i -= steps_factor;
+		break;
+	}
+	i = underflow_bin+signbit*((steps-steps_factor)*(mag-lmag)+i+1);
+	llquanta[i] += incr;
+}
+
+void dtrace_aggregate_avg(uint64_t *data, uint64_t nval, uint64_t arg)
+{
+	data[0]++;
+	data[1] += nval;
+}
+
+void dtrace_aggregate_stddev(uint64_t *data, uint64_t nval, uint64_t arg)
+{
+	int64_t		snval = (int64_t)nval;
+	uint64_t	tmp[2];
+
+	data[0]++;
+	data[1] += nval;
+
+	if (snval < 0)
+		snval = -snval;
+
+	dtrace_multiply_128((uint64_t)snval, (uint64_t)snval, tmp);
+	dtrace_add_128(data + 2, tmp, data + 2);
+}
+
+void dtrace_aggregate_count(uint64_t *oval, uint64_t nval, uint64_t arg)
+{
+	*oval = *oval + 1;
+}
+
+void dtrace_aggregate_sum(uint64_t *oval, uint64_t nval, uint64_t arg)
+{
+	*oval += nval;
+}
+
+/*
+ * DTrace Aggregation Buffers
+ *
+ * Aggregation buffers use much of the same mechanism as described above
+ * ("DTrace Buffers").  However, because an aggregation is fundamentally a
+ * hash, there exists dynamic metadata associated with an aggregation buffer
+ * that is not associated with other kinds of buffers.  This aggregation
+ * metadata is _only_ relevant for the in-kernel implementation of
+ * aggregations; it is not actually relevant to user-level consumers.  To do
+ * this, we allocate dynamic aggregation data (hash keys and hash buckets)
+ * starting below the _limit_ of the buffer, and we allocate data from the
+ * _base_ of the buffer.  When the aggregation buffer is copied out, _only_ the
+ * data is copied out; the metadata is simply discarded.  Schematically,
+ * aggregation buffers look like:
+ *
+ *      base of data buffer --->  +-------+------+-----------+-------+
+ *                                | aggid | key  | value     | aggid |
+ *                                +-------+------+-----------+-------+
+ *                                | key                              |
+ *                                +-------+-------+-----+------------+
+ *                                | value | aggid | key | value      |
+ *                                +-------+------++-----+------+-----+
+ *                                | aggid | key  | value       |     |
+ *                                +-------+------+-------------+     |
+ *                                |                ||                |
+ *                                |                ||                |
+ *                                |                \/                |
+ *                                :                                  :
+ *                                .                                  .
+ *                                .                                  .
+ *                                .                                  .
+ *                                :                                  :
+ *                                |                /\                |
+ *                                |                ||   +------------+
+ *                                |                ||   |            |
+ *                                +---------------------+            |
+ *                                | hash keys                        |
+ *                                | (dtrace_aggkey structures)       |
+ *                                |                                  |
+ *                                +----------------------------------+
+ *                                | hash buckets                     |
+ *                                | (dtrace_aggbuffer structure)     |
+ *                                |                                  |
+ *     limit of data buffer --->  +----------------------------------+
+ *
+ * As implied above, just as we assure that ECBs always store a constant
+ * amount of data, we assure that a given aggregation -- identified by its
+ * aggregation ID -- always stores data of a constant quantity and type.
+ * As with EPIDs, this allows the aggregation ID to serve as the metadata for a
+ * given record.
+ *
+ * Note that the size of the dtrace_aggkey structure must be sizeof (uintptr_t)
+ * aligned.  (If this the structure changes such that this becomes false, an
+ * assertion will fail in dtrace_aggregate().)
+ */
+#define DTRACE_AGGHASHSIZE_SLEW		17
+
+struct dtrace_aggkey {
+	uint32_t dtak_hashval;			/* hash value */
+	uint32_t dtak_action:4;			/* action -- 4 bits */
+	uint32_t dtak_size:28;			/* size -- 28 bits */
+	caddr_t dtak_data;			/* data pointer */
+	struct dtrace_aggkey *dtak_next;	/* next in hash chain */
+};
+
+struct dtrace_aggbuffer {
+	uintptr_t dtagb_hashsize;		/* number of buckets */
+	uintptr_t dtagb_free;			/* free list of keys */
+	struct dtrace_aggkey **dtagb_hash;		/* hash table */
+};
+
+#define DTRACEACT_ISSTRING(act)						      \
+	((act)->dta_kind == DTRACEACT_DIFEXPR &&			      \
+	 (act)->dta_difo->dtdo_rtype.dtdt_kind == DIF_TYPE_STRING)
+
+/*
+ * Aggregate given the tuple in the principal data buffer, and the aggregating
+ * action denoted by the specified dtrace_aggregation_t.  The aggregation
+ * buffer is specified as the buf parameter.  This routine does not return
+ * failure; if there is no space in the aggregation buffer, the data will be
+ * dropped, and a corresponding counter incremented.
+ */
+void dtrace_aggregate(struct dtrace_aggregation *agg,
+		      struct dtrace_buffer *dbuf,
+		      intptr_t offset, struct dtrace_buffer *buf,
+		      uint64_t expr, uint64_t arg)
+{
+	struct dtrace_recdesc	*rec = &agg->dtag_action.dta_rec;
+	uint32_t		i, ndx, size, fsize;
+	uint32_t		align = sizeof(uint64_t) - 1;
+	struct dtrace_aggbuffer	*agb;
+	struct dtrace_aggkey	*key;
+	uint32_t		hashval = 0, limit, isstr;
+	caddr_t			tomax, data, kdata;
+	dtrace_actkind_t	action;
+	struct dtrace_action	*act;
+	uintptr_t		offs;
+
+	if (buf == NULL)
+		return;
+
+	if (!agg->dtag_hasarg)
+		/*
+		 * Currently, only quantize(), lquantize() and llquantize()
+		 * take additional arguments, and they have the same semantics:
+		 * an increment value that defaults to 1 when not present.  If
+		 * additional aggregating actions take arguments, the setting
+		 * of the default argument value will presumably have to
+		 * become more sophisticated...
+		 */
+		arg = 1;
+
+	action = agg->dtag_action.dta_kind - DTRACEACT_AGGREGATION;
+	size = rec->dtrd_offset - agg->dtag_base;
+	fsize = size + rec->dtrd_size;
+
+	ASSERT(dbuf->dtb_tomax != NULL);
+	data = dbuf->dtb_tomax + offset + agg->dtag_base;
+
+	tomax = buf->dtb_tomax;
+	if (tomax == NULL) {
+		dtrace_buffer_drop(buf);
+		return;
+	}
+
+	/*
+	 * The metastructure is always at the bottom of the buffer.
+	 */
+	agb = (struct dtrace_aggbuffer *)(tomax + buf->dtb_size -
+					     sizeof(struct dtrace_aggbuffer));
+
+	if (buf->dtb_offset == 0) {
+		/*
+		 * We just kludge up approximately 1/8th of the size to be
+		 * buckets.  If this guess ends up being routinely
+		 * off-the-mark, we may need to dynamically readjust this
+		 * based on past performance.
+		 */
+		uintptr_t	hashsize = (buf->dtb_size >> 3) /
+					   sizeof(uintptr_t);
+
+		if ((uintptr_t)agb - hashsize * sizeof(struct dtrace_aggkey *) <
+		    (uintptr_t)tomax || hashsize == 0) {
+			/*
+			 * We've been given a ludicrously small buffer;
+			 * increment our drop count and leave.
+			 */
+			dtrace_buffer_drop(buf);
+			return;
+		}
+
+		/*
+		 * And now, a pathetic attempt to try to get a an odd (or
+		 * perchance, a prime) hash size for better hash distribution.
+		 */
+		if (hashsize > (DTRACE_AGGHASHSIZE_SLEW << 3))
+			hashsize -= DTRACE_AGGHASHSIZE_SLEW;
+
+		agb->dtagb_hashsize = hashsize;
+		agb->dtagb_hash = (struct dtrace_aggkey **)((uintptr_t)agb -
+		agb->dtagb_hashsize * sizeof(struct dtrace_aggkey *));
+		agb->dtagb_free = (uintptr_t)agb->dtagb_hash;
+
+		for (i = 0; i < agb->dtagb_hashsize; i++)
+			agb->dtagb_hash[i] = NULL;
+	}
+
+	ASSERT(agg->dtag_first != NULL);
+	ASSERT(agg->dtag_first->dta_intuple);
+
+	/*
+	 * Calculate the hash value based on the key.  Note that we _don't_
+	 * include the aggid in the hashing (but we will store it as part of
+	 * the key).  The hashing algorithm is Bob Jenkins' "One-at-a-time"
+	 * algorithm: a simple, quick algorithm that has no known funnels, and
+	 * gets good distribution in practice.  The efficacy of the hashing
+	 * algorithm (and a comparison with other algorithms) may be found by
+	 * running the ::dtrace_aggstat MDB dcmd.
+	 */
+	for (act = agg->dtag_first; act->dta_intuple; act = act->dta_next) {
+		i = act->dta_rec.dtrd_offset - agg->dtag_base;
+		limit = i + act->dta_rec.dtrd_size;
+		ASSERT(limit <= size);
+		isstr = DTRACEACT_ISSTRING(act);
+
+		for (; i < limit; i++) {
+			hashval += data[i];
+			hashval += (hashval << 10);
+			hashval ^= (hashval >> 6);
+
+			if (isstr && data[i] == '\0')
+				break;
+		}
+	}
+
+	hashval += (hashval << 3);
+	hashval ^= (hashval >> 11);
+	hashval += (hashval << 15);
+
+	/*
+	 * Yes, the divide here is expensive -- but it's generally the least
+	 * of the performance issues given the amount of data that we iterate
+	 * over to compute hash values, compare data, etc.
+	 */
+	ndx = hashval % agb->dtagb_hashsize;
+
+	for (key = agb->dtagb_hash[ndx]; key != NULL; key = key->dtak_next) {
+		ASSERT((caddr_t)key >= tomax);
+		ASSERT((caddr_t)key < tomax + buf->dtb_size);
+
+		if (hashval != key->dtak_hashval || key->dtak_size != size)
+			continue;
+
+		kdata = key->dtak_data;
+		ASSERT(kdata >= tomax && kdata < tomax + buf->dtb_size);
+
+		for (act = agg->dtag_first; act->dta_intuple;
+		     act = act->dta_next) {
+			i = act->dta_rec.dtrd_offset - agg->dtag_base;
+			limit = i + act->dta_rec.dtrd_size;
+			ASSERT(limit <= size);
+			isstr = DTRACEACT_ISSTRING(act);
+
+			for (; i < limit; i++) {
+				if (kdata[i] != data[i])
+					goto next;
+
+				if (isstr && data[i] == '\0')
+					break;
+			}
+		}
+
+		if (action != key->dtak_action) {
+			/*
+			 * We are aggregating on the same value in the same
+			 * aggregation with two different aggregating actions.
+			 * (This should have been picked up in the compiler,
+			 * so we may be dealing with errant or devious DIF.)
+			 * This is an error condition; we indicate as much,
+			 * and return.
+			 */
+			DTRACE_CPUFLAG_SET(CPU_DTRACE_ILLOP);
+			return;
+		}
+
+		/*
+		 * This is a hit:  we need to apply the aggregator to
+		 * the value at this key.
+		 */
+		dt_dbg_agg("    Aggregate [accum]: Buf %p, offs %d, act %d, "
+			   "%lld (%lld, %lld)\n",
+			   buf, size,
+			   agg->dtag_action.dta_kind - DTRACEACT_AGGREGATION,
+			   *(uint64_t *)(kdata + size), expr, arg);
+		agg->dtag_aggregate((uint64_t *)(kdata + size), expr, arg);
+		return;
+next:
+		continue;
+	}
+
+	/*
+	 * We didn't find it.  We need to allocate some zero-filled space,
+	 * link it into the hash table appropriately, and apply the aggregator
+	 * to the (zero-filled) value.
+	 */
+	offs = buf->dtb_offset;
+	while (offs & (align - 1))
+		offs += sizeof(uint32_t);
+
+	/*
+	 * If we don't have enough room to both allocate a new key _and_
+	 * its associated data, increment the drop count and return.
+	 */
+	if ((uintptr_t)tomax + offs + fsize >
+	    agb->dtagb_free - sizeof(struct dtrace_aggkey)) {
+		dtrace_buffer_drop(buf);
+		return;
+	}
+
+	ASSERT(!(sizeof(struct dtrace_aggkey) & (sizeof(uintptr_t) - 1)));
+	key = (struct dtrace_aggkey *)
+		(agb->dtagb_free - sizeof(struct dtrace_aggkey));
+	agb->dtagb_free -= sizeof(struct dtrace_aggkey);
+
+	key->dtak_data = kdata = tomax + offs;
+	buf->dtb_offset = offs + fsize;
+
+	/*
+	 * Now copy the data across.
+	 */
+	*((dtrace_aggid_t *)kdata) = agg->dtag_id;
+
+	for (i = sizeof(dtrace_aggid_t); i < size; i++)
+		kdata[i] = data[i];
+
+	/*
+	 * Because strings are not zeroed out by default, we need to iterate
+	 * looking for actions that store strings, and we need to explicitly
+	 * pad these strings out with zeroes.
+	 */
+	for (act = agg->dtag_first; act->dta_intuple; act = act->dta_next) {
+		int	nul;
+
+		if (!DTRACEACT_ISSTRING(act))
+			continue;
+
+		i = act->dta_rec.dtrd_offset - agg->dtag_base;
+		limit = i + act->dta_rec.dtrd_size;
+		ASSERT(limit <= size);
+
+		for (nul = 0; i < limit; i++) {
+			if (nul) {
+				kdata[i] = '\0';
+				continue;
+			}
+
+			if (data[i] != '\0')
+				continue;
+
+			nul = 1;
+		}
+	}
+
+	for (i = size; i < fsize; i++)
+		kdata[i] = 0;
+
+	key->dtak_hashval = hashval;
+	key->dtak_size = size;
+	key->dtak_action = action;
+	key->dtak_next = agb->dtagb_hash[ndx];
+	agb->dtagb_hash[ndx] = key;
+
+	/*
+	 * Finally, apply the aggregator.
+	 */
+	*((uint64_t *)(key->dtak_data + size)) = agg->dtag_initial;
+	dt_dbg_agg("    Aggregate [initial]: Buf %p, offs %d, act %d, "
+		   "%lld (%lld, %lld)\n",
+		   buf, size,
+		   agg->dtag_action.dta_kind - DTRACEACT_AGGREGATION,
+		   *(uint64_t *)(key->dtak_data + size), expr, arg);
+	agg->dtag_aggregate((uint64_t *)(key->dtak_data + size), expr, arg);
+}
diff --git a/dtrace/dtrace_ptofapi.c b/dtrace/dtrace_ptofapi.c
new file mode 100644
index 000000000000..c42a8471879c
--- /dev/null
+++ b/dtrace/dtrace_ptofapi.c
@@ -0,0 +1,649 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_ptofapi.c
+ * DESCRIPTION:	DTrace - (meta) provider-to-framework API
+ *
+ * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/idr.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+#include "dtrace.h"
+
+struct dtrace_provider	*dtrace_provider;
+struct dtrace_meta	*dtrace_meta_pid;
+struct dtrace_helpers	*dtrace_deferred_pid;
+
+DEFINE_MUTEX(dtrace_provider_lock);
+DEFINE_MUTEX(dtrace_meta_lock);
+
+/*
+ * Register the calling provider with the DTrace core.  This should generally
+ * be called by providers during module initialization.
+ */
+int dtrace_register(const char *name, const struct dtrace_pattr *pap,
+		    uint32_t priv, const struct cred *cr,
+		    const struct dtrace_pops *pops, void *arg,
+		    dtrace_provider_id_t *idp)
+{
+	struct dtrace_provider	*provider;
+
+	if (name == NULL || pap == NULL || pops == NULL || idp == NULL) {
+		pr_warn("Failed to register provider %s: invalid args\n",
+			name ? name : "<NULL>");
+		return -EINVAL;
+	}
+
+	if (name[0] == '\0' || dtrace_badname(name)) {
+		pr_warn("Failed to register provider %s: invalid name\n",
+			name);
+		return -EINVAL;
+	}
+
+	if ((pops->dtps_provide == NULL && pops->dtps_provide_module == NULL) ||
+	    pops->dtps_enable == NULL || pops->dtps_disable == NULL ||
+	    pops->dtps_destroy == NULL ||
+	    ((pops->dtps_resume == NULL) != (pops->dtps_suspend == NULL))) {
+		pr_warn("Failed to register provider %s: invalid ops\n",
+			name);
+		return -EINVAL;
+	}
+
+	if (dtrace_badattr(&pap->dtpa_provider) ||
+	    dtrace_badattr(&pap->dtpa_mod) ||
+	    dtrace_badattr(&pap->dtpa_func) ||
+	    dtrace_badattr(&pap->dtpa_name) ||
+	    dtrace_badattr(&pap->dtpa_args)) {
+		pr_warn("Failed to register provider %s: invalid attributes\n",
+			name);
+		return -EINVAL;
+	}
+
+	if (priv & ~DTRACE_PRIV_ALL) {
+		pr_warn("Failed to register provider %s: invalid privilege "
+			"attributes\n", name);
+		return -EINVAL;
+	}
+
+	if ((priv & DTRACE_PRIV_KERNEL) &&
+	    (priv & (DTRACE_PRIV_USER | DTRACE_PRIV_OWNER)) &&
+	    pops->dtps_usermode == NULL) {
+		pr_warn("Failed to register provider %s: need "
+			"dtps_usermode() op for given privilege "
+			"attributes\n", name);
+		return -EINVAL;
+	}
+
+	dt_dbg_prov("Registering provider '%s'...\n", name);
+	provider = kzalloc(sizeof(struct dtrace_provider), GFP_KERNEL);
+	if (provider == NULL) {
+		dt_dbg_prov("  Failed to allocate provider struct\n");
+		return -ENOMEM;
+	}
+	provider->dtpv_name = dtrace_strdup(name);
+	if (provider->dtpv_name == NULL) {
+		kfree(provider);
+		dt_dbg_prov("  Failed to allocate provider name\n");
+		return -ENOMEM;
+	}
+	provider->dtpv_attr = *pap;
+	provider->dtpv_priv.dtpp_flags = priv;
+
+	if (cr != NULL) {
+		provider->dtpv_priv.dtpp_uid =
+			from_kuid(init_user_namespace, get_cred(cr)->uid);
+		put_cred(cr);
+	}
+
+	provider->dtpv_pops = *pops;
+
+	if (pops->dtps_provide == NULL) {
+		ASSERT(pops->dtps_provide_module != NULL);
+		provider->dtpv_pops.dtps_provide =
+		    (void (*)(void *, const struct dtrace_probedesc *))
+			dtrace_nullop;
+	}
+
+	if (pops->dtps_provide_module == NULL) {
+		ASSERT(pops->dtps_provide != NULL);
+		provider->dtpv_pops.dtps_provide_module =
+		    (void (*)(void *, struct module *))dtrace_nullop;
+	}
+
+	if (pops->dtps_destroy_module == NULL) {
+		provider->dtpv_pops.dtps_destroy_module =
+		    (void (*)(void *, struct module *))dtrace_nullop;
+	}
+
+	if (pops->dtps_suspend == NULL) {
+		ASSERT(pops->dtps_resume == NULL);
+		provider->dtpv_pops.dtps_suspend =
+		    (void (*)(void *, dtrace_id_t, void *))dtrace_nullop;
+		provider->dtpv_pops.dtps_resume =
+		    (void (*)(void *, dtrace_id_t, void *))dtrace_nullop;
+	}
+
+	provider->dtpv_arg = arg;
+	*idp = (dtrace_provider_id_t)provider;
+
+	if (pops == &dtrace_provider_ops) {
+		ASSERT(MUTEX_HELD(&dtrace_provider_lock));
+		ASSERT(MUTEX_HELD(&dtrace_lock));
+		ASSERT(dtrace_anon.dta_enabling == NULL);
+
+		/*
+		 * The DTrace provider must be at the head of the provider
+		 * chain.
+		 */
+		provider->dtpv_next = dtrace_provider;
+		dtrace_provider = provider;
+
+		dt_dbg_prov("  Done registering %s\n", name);
+
+		return 0;
+	}
+
+	mutex_lock(&module_mutex);
+	mutex_lock(&dtrace_provider_lock);
+	mutex_lock(&dtrace_lock);
+
+	/*
+	 * If there is at least one provider registered, we'll add this new one
+	 * after the first provider.
+	 */
+	if (dtrace_provider != NULL) {
+		provider->dtpv_next = dtrace_provider->dtpv_next;
+		dtrace_provider->dtpv_next = provider;
+	} else
+		dtrace_provider = provider;
+
+	if (dtrace_retained != NULL) {
+		dt_dbg_prov("  Processing retained enablings for %s\n", name);
+		dtrace_enabling_provide(provider);
+
+		/*
+		 * We must now call dtrace_enabling_matchall() which needs to
+		 * acquire cpu_lock and dtrace_lock.  We therefore need to drop
+		 * our locks before calling it.
+		 */
+		mutex_unlock(&dtrace_lock);
+		mutex_unlock(&dtrace_provider_lock);
+		mutex_unlock(&module_mutex);
+		dtrace_enabling_matchall();
+
+		dt_dbg_prov("  Done registering %s\n", name);
+
+		return 0;
+	}
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&dtrace_provider_lock);
+	mutex_unlock(&module_mutex);
+
+	dt_dbg_prov("  Done registering %s\n", name);
+
+	return 0;
+}
+EXPORT_SYMBOL(dtrace_register);
+
+struct unreg_state {
+	struct dtrace_provider	*prov;
+	struct dtrace_probe	*first;
+};
+
+/*
+ * Check whether the given probe is still enabled for the given provider.
+ */
+static int dtrace_unregister_check(int id, void *p, void *data)
+{
+	struct dtrace_probe	*probe = (struct dtrace_probe *)p;
+	struct unreg_state	*st = (struct unreg_state *)data;
+
+	if (probe->dtpr_provider != st->prov)
+		return 0;
+
+	if (probe->dtpr_ecb == NULL)
+		return 0;
+
+	return -EBUSY;
+}
+
+/*
+ * Remove the given probe from the hash tables and the probe IDR, if it is
+ * associated with the given provider.  The probes are chained for further
+ * processing.
+ */
+static int dtrace_unregister_probe(int id, void *p, void *data)
+{
+	struct dtrace_probe	*probe = (struct dtrace_probe *)p;
+	struct unreg_state	*st = (struct unreg_state *)data;
+
+	if (probe->dtpr_provider != st->prov)
+		return 0;
+
+	dtrace_hash_remove(dtrace_bymod, probe);
+	dtrace_hash_remove(dtrace_byfunc, probe);
+	dtrace_hash_remove(dtrace_byname, probe);
+
+	if (st->first == NULL) {
+		st->first = probe;
+		probe->dtpr_nextmod = NULL;
+	} else {
+		probe->dtpr_nextmod = st->first;
+		st->first = probe;
+	}
+
+	return 0;
+}
+
+/*
+ * Remove the given probe from the hash tables and the probe IDR, if it is
+ * associated with the given provider and if it does not have any enablings.
+ * The probes are chained for further processing.
+ */
+static int dtrace_condense_probe(int id, void *p, void *data)
+{
+	struct dtrace_probe	*probe = (struct dtrace_probe *)p;
+	struct unreg_state	*st = (struct unreg_state *)data;
+
+	if (probe->dtpr_provider != st->prov)
+		return 0;
+
+	if (probe->dtpr_ecb == NULL)
+		return 0;
+
+	dtrace_hash_remove(dtrace_bymod, probe);
+	dtrace_hash_remove(dtrace_byfunc, probe);
+	dtrace_hash_remove(dtrace_byname, probe);
+
+	if (st->first == NULL) {
+		st->first = probe;
+		probe->dtpr_nextmod = NULL;
+	} else {
+		probe->dtpr_nextmod = st->first;
+		st->first = probe;
+	}
+
+	return 0;
+}
+
+/*
+ * Unregister the specified provider from the DTrace core.  This should be
+ * called by provider during module cleanup.
+ *
+ * The mutex_lock is already held during this call.
+ */
+int dtrace_unregister(dtrace_provider_id_t id)
+{
+	struct dtrace_provider	*old = (struct dtrace_provider *)id;
+	struct dtrace_provider	*prev = NULL;
+	int			err, self = 0;
+	struct dtrace_probe	*probe;
+	struct unreg_state	st = { old, NULL };
+
+	ASSERT(MUTEX_HELD(&module_mutex));
+
+	dt_dbg_prov("Unregistering provider '%s'...\n", old->dtpv_name);
+
+	if (old->dtpv_pops.dtps_enable ==
+	    (int (*)(void *, dtrace_id_t, void *))dtrace_enable_nullop) {
+		/*
+		 * When the provider is the DTrace core itself, we're called
+		 * with locks already held.
+		 */
+		ASSERT(old == dtrace_provider);
+		ASSERT(MUTEX_HELD(&dtrace_provider_lock));
+		ASSERT(MUTEX_HELD(&dtrace_lock));
+
+		self = 1;
+
+		if (dtrace_provider->dtpv_next != NULL) {
+			/*
+			 * We cannot and should not remove the DTrace provider
+			 * if there is any other provider left.
+			 */
+			dt_dbg_prov("  Failed to unregister %s - not last\n",
+				    old->dtpv_name);
+
+			return -EBUSY;
+		}
+	} else {
+		mutex_lock(&dtrace_provider_lock);
+		mutex_lock(&dtrace_lock);
+	}
+
+	/*
+	 * If /dev/dtrace/dtrace is still held open by a process, or if there
+	 * are anonymous probes that are still enabled, we refuse to deregister
+	 * providers, unless the provider has been invalidated explicitly.
+	 */
+	if (!old->dtpv_defunct &&
+	    (dtrace_opens || (dtrace_anon.dta_state != NULL &&
+	     dtrace_anon.dta_state->dts_necbs > 0))) {
+		if (!self) {
+			mutex_unlock(&dtrace_lock);
+			mutex_unlock(&dtrace_provider_lock);
+		}
+
+		dt_dbg_prov("  Failed to unregister %s - dtrace in use\n",
+			    old->dtpv_name);
+
+		return -EBUSY;
+	}
+
+	/*
+	 * Check whether any of the probes associated with this provider are
+	 * still enabled (having at least one ECB).  If any are found, we
+	 * cannot remove this provider.
+	 */
+	st.prov = old;
+	err = dtrace_probe_for_each(dtrace_unregister_check, &st);
+	if (err < 0) {
+		if (!self) {
+			mutex_unlock(&dtrace_lock);
+			mutex_unlock(&dtrace_provider_lock);
+		}
+
+		dt_dbg_prov("  Failed to unregister %s - provider in use\n",
+			    old->dtpv_name);
+
+		return err;
+	}
+
+	/*
+	 * All the probes associated with this provider are disabled.  We can
+	 * safely remove these probes from the hashtables and the probe array.
+	 * We chain all the probes together for further processing.
+	 */
+	dtrace_probe_for_each(dtrace_unregister_probe, &st);
+
+	/*
+	 * The probes associated with the provider have been removed.  Ensure
+	 * synchronization on probe IDR processing.
+	 */
+	dtrace_sync();
+
+	/*
+	 * Now get rid of the actual probes.
+	 */
+	for (probe = st.first; probe != NULL; probe = st.first) {
+		int	probe_id = probe->dtpr_id;
+
+		st.first = probe->dtpr_nextmod;
+
+		old->dtpv_pops.dtps_destroy(old->dtpv_arg, probe_id,
+					    probe->dtpr_arg);
+
+		kfree(probe->dtpr_mod);
+		kfree(probe->dtpr_func);
+		kfree(probe->dtpr_name);
+		kmem_cache_free(dtrace_probe_cachep, probe);
+
+		dtrace_probe_remove_id(probe_id);
+	}
+
+	prev = dtrace_provider;
+	if (prev == old) {
+		/*
+		 * We are removing the provider at the head of the chain.
+		 */
+		ASSERT(self);
+		ASSERT(old->dtpv_next == NULL);
+
+		dtrace_provider = old->dtpv_next;
+	} else {
+		while (prev != NULL && prev->dtpv_next != old)
+			prev = prev->dtpv_next;
+
+		if (prev == NULL) {
+			pr_err("Attempt to unregister non-existent DTrace "
+			       "provider %p\n", (void *)id);
+			BUG();
+		}
+
+		prev->dtpv_next = old->dtpv_next;
+	}
+
+	if (!self) {
+		mutex_unlock(&dtrace_lock);
+		mutex_unlock(&dtrace_provider_lock);
+	}
+
+	kfree(old->dtpv_name);
+	kfree(old);
+
+	dt_dbg_prov("  Done unregistering\n");
+
+	return 0;
+}
+EXPORT_SYMBOL(dtrace_unregister);
+
+/*
+ * Invalidate the specified provider.  All subsequent probe lookups for the
+ * specified provider will fail, but the probes will not be removed.
+ */
+void dtrace_invalidate(dtrace_provider_id_t id)
+{
+	struct dtrace_provider	*pvp = (struct dtrace_provider *)id;
+
+	ASSERT(pvp->dtpv_pops.dtps_enable !=
+	       (int (*)(void *, dtrace_id_t, void *))dtrace_enable_nullop);
+
+	mutex_lock(&dtrace_provider_lock);
+	mutex_lock(&dtrace_lock);
+
+	pvp->dtpv_defunct = 1;
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&dtrace_provider_lock);
+}
+EXPORT_SYMBOL(dtrace_invalidate);
+
+/*
+ * Indicate whether or not DTrace has attached.
+ */
+int dtrace_attached(void)
+{
+	/*
+	 * dtrace_provider will be non-NULL iff the DTrace driver has
+	 * attached.  (It's non-NULL because DTrace is always itself a
+	 * provider.)
+	 */
+	return dtrace_provider != NULL;
+}
+EXPORT_SYMBOL(dtrace_attached);
+
+/*
+ * Remove all the unenabled probes for the given provider.  This function is
+ * not unlike dtrace_unregister(), except that it doesn't remove the provider
+ * -- just as many of its associated probes as it can.
+ */
+int dtrace_condense(dtrace_provider_id_t id)
+{
+	struct dtrace_provider	*prov = (struct dtrace_provider *)id;
+	struct dtrace_probe	*probe;
+	struct unreg_state	st = { prov, NULL };
+
+	/*
+	 * Make sure this isn't the DTrace provider itself.
+	 */
+	ASSERT(prov->dtpv_pops.dtps_enable !=
+	       (int (*)(void *, dtrace_id_t, void *))dtrace_enable_nullop);
+
+	mutex_lock(&dtrace_provider_lock);
+	mutex_lock(&dtrace_lock);
+
+	/*
+	 * Attempt to destroy the probes associated with this provider.
+	 */
+	dtrace_probe_for_each(dtrace_condense_probe, &st);
+
+	/*
+	 * The probes associated with the provider have been removed.  Ensure
+	 * synchronization on probe IDR processing.
+	 */
+	dtrace_sync();
+
+	/*
+	 * Now get rid of the actual probes.
+	 */
+	for (probe = st.first; probe != NULL; probe = st.first) {
+		int	probe_id = probe->dtpr_id;
+
+		st.first = probe->dtpr_nextmod;
+
+		prov->dtpv_pops.dtps_destroy(prov->dtpv_arg, probe_id,
+					     probe->dtpr_arg);
+
+		kfree(probe->dtpr_mod);
+		kfree(probe->dtpr_func);
+		kfree(probe->dtpr_name);
+		kfree(probe);
+
+		dtrace_probe_remove_id(probe_id);
+	}
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&dtrace_provider_lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(dtrace_condense);
+
+int dtrace_meta_register(const char *name, const struct dtrace_mops *mops,
+			 void *arg, dtrace_meta_provider_id_t *idp)
+{
+	struct dtrace_meta	*meta;
+	struct dtrace_helpers	*help, *next;
+	int			i;
+
+	*idp = DTRACE_METAPROVNONE;
+
+	/*
+	 * We strictly don't need the name, but we hold onto it for
+	 * debuggability. All hail error queues!
+	 */
+	if (name == NULL) {
+		pr_warn("failed to register meta-provider: invalid name\n");
+		return -EINVAL;
+	}
+
+	if (mops == NULL ||
+	    mops->dtms_create_probe == NULL ||
+	    mops->dtms_provide_pid == NULL ||
+	    mops->dtms_remove_pid == NULL) {
+		pr_warn("failed to register meta-register %s: invalid ops\n",
+			name);
+		return -EINVAL;
+	}
+
+	dt_dbg_prov("Registering provider '%s'...\n", name);
+	meta = kzalloc(sizeof(struct dtrace_meta), GFP_KERNEL);
+	if (meta == NULL) {
+		dt_dbg_prov("  Failed to allocate meta provider struct\n");
+		return -ENOMEM;
+	}
+	meta->dtm_mops = *mops;
+	meta->dtm_name = kmalloc(strlen(name) + 1, GFP_KERNEL);
+	if (meta->dtm_name == NULL) {
+		kfree(meta);
+		dt_dbg_prov("  Failed to allocate meta provider name\n");
+		return -ENOMEM;
+	}
+	strcpy(meta->dtm_name, name);
+	meta->dtm_arg = arg;
+
+	mutex_lock(&dtrace_meta_lock);
+	mutex_lock(&dtrace_lock);
+
+	if (dtrace_meta_pid != NULL) {
+		mutex_unlock(&dtrace_lock);
+		mutex_unlock(&dtrace_meta_lock);
+		pr_warn("failed to register meta-register %s: user-land "
+			"meta-provider exists", name);
+		kfree(meta->dtm_name);
+		kfree(meta);
+		return -EINVAL;
+	}
+
+	dtrace_meta_pid = meta;
+	*idp = (dtrace_meta_provider_id_t)meta;
+
+	/*
+	 * If there are providers and probes ready to go, pass them
+	 * off to the new meta provider now.
+	 */
+	help = dtrace_deferred_pid;
+	dtrace_deferred_pid = NULL;
+
+	mutex_unlock(&dtrace_lock);
+
+	while (help != NULL) {
+		for (i = 0; i < help->dthps_nprovs; i++) {
+			dtrace_helper_provide(&help->dthps_provs[i]->dthp_prov,
+					      help->dthps_pid);
+		}
+
+		next = help->dthps_next;
+		help->dthps_next = NULL;
+		help->dthps_prev = NULL;
+		help->dthps_deferred = 0;
+		help = next;
+	}
+
+	mutex_unlock(&dtrace_meta_lock);
+
+	dt_dbg_prov("  Done registering %s\n", name);
+
+	return 0;
+}
+EXPORT_SYMBOL(dtrace_meta_register);
+
+int dtrace_meta_unregister(dtrace_meta_provider_id_t id)
+{
+	struct dtrace_meta **pp, *old = (struct dtrace_meta *)id;
+
+	dt_dbg_prov("Unregistering meta provider '%s'...\n", old->dtm_name);
+	mutex_lock(&dtrace_meta_lock);
+	mutex_lock(&dtrace_lock);
+
+	if (old == dtrace_meta_pid) {
+		pp = &dtrace_meta_pid;
+	} else {
+		pr_err("Attempt to unregister non-existent DTrace meta-"
+		       "provider %p\n", (void *)old);
+		BUG();
+	}
+
+	if (old->dtm_count != 0) {
+		mutex_unlock(&dtrace_lock);
+		mutex_unlock(&dtrace_meta_lock);
+		return -EBUSY;
+	}
+
+	*pp = NULL;
+
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&dtrace_meta_lock);
+
+	kfree(old->dtm_name);
+	kfree(old);
+
+	dt_dbg_prov("  Done unregistering\n");
+
+	return 0;
+}
+EXPORT_SYMBOL(dtrace_meta_unregister);
diff --git a/dtrace/dtrace_spec.c b/dtrace/dtrace_spec.c
new file mode 100644
index 000000000000..4ca9bb7a6427
--- /dev/null
+++ b/dtrace/dtrace_spec.c
@@ -0,0 +1,434 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_spec.c
+ * DESCRIPTION:	DTrace - speculation implementation
+ *
+ * Copyright (c) 2010, 2011, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dtrace_cpu.h>
+#include <linux/smp.h>
+#include <asm/cmpxchg.h>
+
+#include "dtrace.h"
+
+/*
+ * Given consumer state, this routine finds a speculation in the INACTIVE
+ * state and transitions it into the ACTIVE state.  If there is no speculation
+ * in the INACTIVE state, 0 is returned.  In this case, no error counter is
+ * incremented -- it is up to the caller to take appropriate action.
+ */
+int dtrace_speculation(struct dtrace_state *state)
+{
+	int		i = 0;
+	uint32_t	count, *stat = &state->dts_speculations_unavail;
+	enum dtrace_speculation_state curr;
+
+	while (i < state->dts_nspeculations) {
+		struct dtrace_speculation *spec = &state->dts_speculations[i];
+
+		curr = spec->dtsp_state;
+
+		if (curr != DTRACESPEC_INACTIVE) {
+			if (curr == DTRACESPEC_COMMITTINGMANY ||
+			    curr == DTRACESPEC_COMMITTING ||
+			    curr == DTRACESPEC_DISCARDING)
+				stat = &state->dts_speculations_busy;
+
+			i++;
+			continue;
+		}
+
+		if (cmpxchg((uint32_t *)&spec->dtsp_state, curr,
+			    DTRACESPEC_ACTIVE) == curr)
+			return i + 1;
+	}
+
+	/*
+	 * We couldn't find a speculation.  If we found as much as a single
+	 * busy speculation buffer, we'll attribute this failure as "busy"
+	 * instead of "unavail".
+	 */
+	do {
+		count = *stat;
+	} while (cmpxchg(stat, count, count + 1) != count);
+
+	return 0;
+}
+
+/*
+ * This routine commits an active speculation.  If the specified speculation
+ * is not in a valid state to perform a commit(), this routine will silently do
+ * nothing.  The state of the specified speculation is transitioned according
+ * to the state transition diagram outlined in <sys/dtrace_impl.h>
+ */
+void dtrace_speculation_commit(struct dtrace_state *state, processorid_t cpu,
+			       dtrace_specid_t which)
+{
+	struct dtrace_speculation	*spec;
+	struct dtrace_buffer		*src, *dest;
+	uintptr_t			daddr, saddr, dlimit;
+	enum dtrace_speculation_state	curr, new = 0;
+	intptr_t			offs;
+
+	if (which == 0)
+		return;
+
+	if (which > state->dts_nspeculations) {
+		per_cpu_core(cpu)->cpuc_dtrace_flags |= CPU_DTRACE_ILLOP;
+		return;
+	}
+
+	spec = &state->dts_speculations[which - 1];
+	src = &spec->dtsp_buffer[cpu];
+	dest = &state->dts_buffer[cpu];
+
+	do {
+		curr = spec->dtsp_state;
+
+		if (curr == DTRACESPEC_COMMITTINGMANY)
+			break;
+
+		switch (curr) {
+		case DTRACESPEC_INACTIVE:
+		case DTRACESPEC_DISCARDING:
+			return;
+
+		case DTRACESPEC_COMMITTING:
+			/*
+			 * This is only possible if we are (a) commit()'ing
+			 * without having done a prior speculate() on this CPU
+			 * and (b) racing with another commit() on a different
+			 * CPU.  There's nothing to do -- we just assert that
+			 * our offset is 0.
+			 */
+			ASSERT(src->dtb_offset == 0);
+			return;
+
+		case DTRACESPEC_ACTIVE:
+			new = DTRACESPEC_COMMITTING;
+			break;
+
+		case DTRACESPEC_ACTIVEONE:
+			/*
+			 * This speculation is active on one CPU.  If our
+			 * buffer offset is non-zero, we know that the one CPU
+			 * must be us.  Otherwise, we are committing on a
+			 * different CPU from the speculate(), and we must
+			 * rely on being asynchronously cleaned.
+			 */
+			if (src->dtb_offset != 0) {
+				new = DTRACESPEC_COMMITTING;
+				break;
+			}
+			/*FALLTHROUGH*/
+
+		case DTRACESPEC_ACTIVEMANY:
+			new = DTRACESPEC_COMMITTINGMANY;
+			break;
+
+		default:
+			ASSERT(0);
+		}
+	} while (cmpxchg((uint32_t *)&spec->dtsp_state, curr, new) !=
+		 curr);
+
+	/*
+	 * We have set the state to indicate that we are committing this
+	 * speculation.  Now reserve the necessary space in the destination
+	 * buffer.
+	 */
+	offs = dtrace_buffer_reserve(dest, src->dtb_offset, sizeof(uint64_t),
+				     state, NULL);
+	if (offs < 0) {
+		dtrace_buffer_drop(dest);
+		goto out;
+	}
+
+	/*
+	 * We have the space; copy the buffer across.  (Note that this is a
+	 * highly subobtimal bcopy(); in the unlikely event that this becomes
+	 * a serious performance issue, a high-performance DTrace-specific
+	 * bcopy() should obviously be invented.)
+	 */
+	daddr = (uintptr_t)dest->dtb_tomax + offs;
+	dlimit = daddr + src->dtb_offset;
+	saddr = (uintptr_t)src->dtb_tomax;
+
+	/*
+	 * First, the aligned portion.
+	 */
+	while (dlimit - daddr >= sizeof(uint64_t)) {
+		*((uint64_t *)daddr) = *((uint64_t *)saddr);
+		*((uint64_t *)daddr) = *((uint64_t *)saddr);
+
+		daddr += sizeof(uint64_t);
+		saddr += sizeof(uint64_t);
+	}
+
+	/*
+	 * Now any left-over bit...
+	 */
+	while (dlimit - daddr)
+		*((uint8_t *)daddr++) = *((uint8_t *)saddr++);
+
+	/*
+	 * Finally, commit the reserved space in the destination buffer.
+	 */
+	dest->dtb_offset = offs + src->dtb_offset;
+
+out:
+	/*
+	 * If we're lucky enough to be the only active CPU on this speculation
+	 * buffer, we can just set the state back to DTRACESPEC_INACTIVE.
+	 */
+	if (curr == DTRACESPEC_ACTIVE ||
+	    (curr == DTRACESPEC_ACTIVEONE && new == DTRACESPEC_COMMITTING)) {
+		/*
+		 * Will cause unused warning if DEBUG is not defined.
+		 */
+		uint32_t	rval =
+				cmpxchg((uint32_t *)&spec->dtsp_state,
+					DTRACESPEC_COMMITTING,
+					DTRACESPEC_INACTIVE);
+
+		ASSERT(rval == DTRACESPEC_COMMITTING);
+		rval = 0; /* Avoid warning about unused variable if !DEBUG */
+	}
+
+	src->dtb_offset = 0;
+	src->dtb_xamot_drops += src->dtb_drops;
+	src->dtb_drops = 0;
+}
+
+/*
+ * This routine discards an active speculation.  If the specified speculation
+ * is not in a valid state to perform a discard(), this routine will silently
+ * do nothing.  The state of the specified speculation is transitioned
+ * according to the state transition diagram outlined in <sys/dtrace_impl.h>
+ */
+void dtrace_speculation_discard(struct dtrace_state *state, processorid_t cpu,
+				dtrace_specid_t which)
+{
+	struct dtrace_speculation	*spec;
+	enum dtrace_speculation_state	curr, new = 0;
+	struct dtrace_buffer		*buf;
+
+	if (which == 0)
+		return;
+
+	if (which > state->dts_nspeculations) {
+		per_cpu_core(cpu)->cpuc_dtrace_flags |= CPU_DTRACE_ILLOP;
+		return;
+	}
+
+	spec = &state->dts_speculations[which - 1];
+	buf = &spec->dtsp_buffer[cpu];
+
+	do {
+		curr = spec->dtsp_state;
+
+		switch (curr) {
+		case DTRACESPEC_INACTIVE:
+		case DTRACESPEC_COMMITTINGMANY:
+		case DTRACESPEC_COMMITTING:
+		case DTRACESPEC_DISCARDING:
+			return;
+
+		case DTRACESPEC_ACTIVE:
+		case DTRACESPEC_ACTIVEMANY:
+			new = DTRACESPEC_DISCARDING;
+			break;
+
+		case DTRACESPEC_ACTIVEONE:
+			if (buf->dtb_offset != 0)
+				new = DTRACESPEC_INACTIVE;
+			else
+				new = DTRACESPEC_DISCARDING;
+
+			break;
+
+		default:
+			ASSERT(0);
+		}
+	} while (cmpxchg((uint32_t *)&spec->dtsp_state, curr, new) != curr);
+
+	buf->dtb_offset = 0;
+	buf->dtb_drops = 0;
+}
+
+/*
+ * Note:  not called from probe context.  This function is called
+ * asynchronously from cross call context to clean any speculations that are
+ * in the COMMITTINGMANY or DISCARDING states.  These speculations may not be
+ * transitioned back to the INACTIVE state until all CPUs have cleaned the
+ * speculation.
+ */
+void dtrace_speculation_clean_here(struct dtrace_state *state)
+{
+	dtrace_icookie_t	cookie;
+	processorid_t		cpu = smp_processor_id();
+	struct dtrace_buffer	*dest = &state->dts_buffer[cpu];
+	dtrace_specid_t		i;
+	uint32_t		re_entry;
+
+	DTRACE_SYNC_ENTER_CRITICAL(cookie, re_entry);
+
+	if (dest->dtb_tomax == NULL) {
+		DTRACE_SYNC_EXIT_CRITICAL(cookie, re_entry);
+		return;
+	}
+
+	for (i = 0; i < state->dts_nspeculations; i++) {
+		struct dtrace_speculation *spec = &state->dts_speculations[i];
+		struct dtrace_buffer      *src = &spec->dtsp_buffer[cpu];
+
+		if (src->dtb_tomax == NULL)
+			continue;
+
+		if (spec->dtsp_state == DTRACESPEC_DISCARDING) {
+			src->dtb_offset = 0;
+			continue;
+		}
+
+		if (spec->dtsp_state != DTRACESPEC_COMMITTINGMANY)
+			continue;
+
+		if (src->dtb_offset == 0)
+			continue;
+
+		dtrace_speculation_commit(state, cpu, i + 1);
+	}
+
+	DTRACE_SYNC_EXIT_CRITICAL(cookie, re_entry);
+}
+
+void dtrace_speculation_clean(struct dtrace_state *state)
+{
+	int		work = 0, rv;
+	dtrace_specid_t	i;
+
+	for (i = 0; i < state->dts_nspeculations; i++) {
+		struct dtrace_speculation *spec = &state->dts_speculations[i];
+
+		ASSERT(!spec->dtsp_cleaning);
+
+		if (spec->dtsp_state != DTRACESPEC_DISCARDING &&
+		    spec->dtsp_state != DTRACESPEC_COMMITTINGMANY)
+			continue;
+
+		work++;
+		spec->dtsp_cleaning = 1;
+	}
+
+	if (!work)
+		return;
+
+	dtrace_xcall(DTRACE_CPUALL,
+		     (dtrace_xcall_t)dtrace_speculation_clean_here, state);
+
+	/*
+	 * We now know that all CPUs have committed or discarded their
+	 * speculation buffers, as appropriate.  We can now set the state
+	 * to inactive.
+	 */
+	for (i = 0; i < state->dts_nspeculations; i++) {
+		struct dtrace_speculation	*spec =
+						&state->dts_speculations[i];
+		enum dtrace_speculation_state	curr, new;
+
+		if (!spec->dtsp_cleaning)
+			continue;
+
+		curr = spec->dtsp_state;
+		ASSERT(curr == DTRACESPEC_DISCARDING ||
+		       curr == DTRACESPEC_COMMITTINGMANY);
+
+		new = DTRACESPEC_INACTIVE;
+
+		rv = cmpxchg((uint32_t *)&spec->dtsp_state, curr, new);
+		ASSERT(rv == curr);
+		spec->dtsp_cleaning = 0;
+	}
+}
+
+/*
+ * Called as part of a speculate() to get the speculative buffer associated
+ * with a given speculation.  Returns NULL if the specified speculation is not
+ * in an ACTIVE state.  If the speculation is in the ACTIVEONE state -- and
+ * the active CPU is not the specified CPU -- the speculation will be
+ * atomically transitioned into the ACTIVEMANY state.
+ */
+struct dtrace_buffer *dtrace_speculation_buffer(struct dtrace_state *state,
+                                                processorid_t cpu,
+                                                dtrace_specid_t which)
+{
+	struct dtrace_speculation	*spec;
+	enum dtrace_speculation_state	curr, new = 0;
+	struct dtrace_buffer		*buf;
+
+	if (which == 0)
+		return NULL;
+
+	if (which > state->dts_nspeculations) {
+		per_cpu_core(cpu)->cpuc_dtrace_flags |= CPU_DTRACE_ILLOP;
+		return NULL;
+	}
+
+	spec = &state->dts_speculations[which - 1];
+	buf = &spec->dtsp_buffer[cpu];
+
+	do {
+		curr = spec->dtsp_state;
+
+		switch (curr) {
+		case DTRACESPEC_INACTIVE:
+		case DTRACESPEC_COMMITTINGMANY:
+		case DTRACESPEC_DISCARDING:
+			return NULL;
+
+		case DTRACESPEC_COMMITTING:
+			ASSERT(buf->dtb_offset == 0);
+			return NULL;
+
+		case DTRACESPEC_ACTIVEONE:
+			/*
+			 * This speculation is currently active on one CPU.
+			 * Check the offset in the buffer; if it's non-zero,
+			 * that CPU must be us (and we leave the state alone).
+			 * If it's zero, assume that we're starting on a new
+			 * CPU -- and change the state to indicate that the
+			 * speculation is active on more than one CPU.
+			 */
+			if (buf->dtb_offset != 0)
+				return buf;
+
+			new = DTRACESPEC_ACTIVEMANY;
+			break;
+
+		case DTRACESPEC_ACTIVEMANY:
+			return buf;
+
+		case DTRACESPEC_ACTIVE:
+			new = DTRACESPEC_ACTIVEONE;
+			break;
+
+		default:
+			ASSERT(0);
+		}
+	} while (cmpxchg((uint32_t *)&spec->dtsp_state, curr, new) != curr);
+
+	ASSERT(new == DTRACESPEC_ACTIVEONE || new == DTRACESPEC_ACTIVEMANY);
+
+	return buf;
+}
diff --git a/dtrace/dtrace_state.c b/dtrace/dtrace_state.c
new file mode 100644
index 000000000000..7fb696e8f1a9
--- /dev/null
+++ b/dtrace/dtrace_state.c
@@ -0,0 +1,1108 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_state.c
+ * DESCRIPTION:	DTrace - consumer state implementation
+ *
+ * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/cyclic.h>
+#include <linux/fs.h>
+#include <linux/idr.h>
+#include <linux/slab.h>
+#include <linux/smp.h>
+#include <linux/vmalloc.h>
+#include <asm/cmpxchg.h>
+
+#include "dtrace.h"
+
+int			dtrace_destructive_disallow = 0;
+dtrace_optval_t		dtrace_nspec_default = 1;
+dtrace_optval_t		dtrace_specsize_default = 32 * 1024;
+dtrace_optval_t		dtrace_dstate_defsize = 1 * 1024 * 1024;
+size_t			dtrace_strsize_default = 256;
+dtrace_optval_t		dtrace_stackframes_default = 20;
+dtrace_optval_t		dtrace_ustackframes_default = 100;
+dtrace_optval_t		dtrace_cleanrate_default = 9900990;
+dtrace_optval_t		dtrace_cleanrate_min = 20000;
+dtrace_optval_t		dtrace_cleanrate_max = (uint64_t)60 * NANOSEC;
+dtrace_optval_t		dtrace_aggrate_default = NANOSEC;
+dtrace_optval_t		dtrace_switchrate_default = NANOSEC;
+dtrace_optval_t		dtrace_statusrate_default = NANOSEC;
+dtrace_optval_t		dtrace_statusrate_max = (uint64_t)10 * NANOSEC;
+dtrace_optval_t		dtrace_jstackframes_default = 50;
+dtrace_optval_t		dtrace_jstackstrsize_default = 512;
+ktime_t			dtrace_deadman_interval = KTIME_INIT(1, 0);
+ktime_t			dtrace_deadman_timeout = KTIME_INIT(10, 0);
+ktime_t			dtrace_deadman_user = KTIME_INIT(30, 0);
+
+			/* Sampling before counting */
+uint64_t		dtrace_sync_sample_count = 100;
+
+dtrace_id_t		dtrace_probeid_begin;
+dtrace_id_t		dtrace_probeid_end;
+dtrace_id_t		dtrace_probeid_error;
+
+struct dtrace_dynvar	dtrace_dynhash_sink;
+
+#define DTRACE_DYNHASH_FREE		0
+#define DTRACE_DYNHASH_SINK		1
+#define DTRACE_DYNHASH_VALID		2
+
+#define DTRACE_DYNVAR_CHUNKSIZE		256
+
+static void dtrace_dynvar_clean(struct dtrace_dstate *dstate)
+{
+	struct dtrace_dynvar		*dirty;
+	struct dtrace_dstate_percpu	*dcpu;
+	int				i, work = 0;
+
+	for (i = 0; i < NR_CPUS; i++) {
+		dcpu = &dstate->dtds_percpu[i];
+
+		ASSERT(dcpu->dtdsc_rinsing == NULL);
+
+		/*
+		 * If the dirty list is NULL, there is no dirty work to do.
+		 */
+		if (dcpu->dtdsc_dirty == NULL)
+			continue;
+
+		/*
+		 * If the clean list is non-NULL, then we're not going to do
+		 * any work for this CPU -- it means that there has not been
+		 * a dtrace_dynvar() allocation on this CPU (or from this CPU)
+		 * since the last time we cleaned house.
+		 */
+		if (dcpu->dtdsc_clean != NULL)
+			continue;
+
+		work = 1;
+
+		/*
+		 * Atomically move the dirty list aside.
+		 */
+		do {
+			dirty = dcpu->dtdsc_dirty;
+
+			/*
+			 * Before we zap the dirty list, set the rinsing list.
+			 * (This allows for a potential assertion in
+			 * dtrace_dynvar():  if a free dynamic variable appears
+			 * on a hash chain, either the dirty list or the
+			 * rinsing list for some CPU must be non-NULL.)
+			 */
+			dcpu->dtdsc_rinsing = dirty;
+			dtrace_membar_producer();
+		} while (cmpxchg(&dcpu->dtdsc_dirty, dirty, NULL) != dirty);
+	}
+
+	/*
+	 * No work to do; return.
+	 */
+	if (!work)
+		return;
+
+	dtrace_sync();
+
+	for (i = 0; i < NR_CPUS; i++) {
+		dcpu = &dstate->dtds_percpu[i];
+
+		if (dcpu->dtdsc_rinsing == NULL)
+			continue;
+
+		/*
+		 * We are now guaranteed that no hash chain contains a pointer
+		 * into this dirty list; we can make it clean.
+		 */
+		ASSERT(dcpu->dtdsc_clean == NULL);
+		dcpu->dtdsc_clean = dcpu->dtdsc_rinsing;
+		dcpu->dtdsc_rinsing = NULL;
+	}
+
+	/*
+	 * Before we actually set the state to be DTRACE_DSTATE_CLEAN, make
+	 * sure that all CPUs have seen all of the dtdsc_clean pointers.
+	 * This prevents a race whereby a CPU incorrectly decides that
+	 * the state should be something other than DTRACE_DSTATE_CLEAN
+	 * after dtrace_dynvar_clean() has completed.
+	 */
+	dtrace_sync();
+
+	dstate->dtds_state = DTRACE_DSTATE_CLEAN;
+}
+
+int dtrace_dstate_init(struct dtrace_dstate *dstate, size_t size)
+{
+	size_t		hashsize, maxper, min,
+			chunksize = dstate->dtds_chunksize;
+	void		*base, *percpu;
+	uintptr_t	limit;
+	struct dtrace_dynvar *dvar, *next, *start;
+	int		i;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(dstate->dtds_base == NULL && dstate->dtds_percpu == NULL);
+
+	memset(dstate, 0, sizeof(struct dtrace_dstate));
+
+	dstate->dtds_chunksize = chunksize;
+	if (dstate->dtds_chunksize == 0)
+		dstate->dtds_chunksize = DTRACE_DYNVAR_CHUNKSIZE;
+
+	min = dstate->dtds_chunksize + sizeof(struct dtrace_dynhash);
+	if (size < min)
+		size = min;
+
+	base = dtrace_vzalloc_try(size);
+	if (base == NULL)
+		return -ENOMEM;
+	percpu = kmem_cache_alloc(dtrace_state_cachep, GFP_KERNEL);
+	if (percpu == NULL) {
+		vfree(base);
+		return -ENOMEM;
+	}
+
+	dstate->dtds_size = size;
+	dstate->dtds_base = base;
+	dstate->dtds_percpu = percpu;
+	memset(dstate->dtds_percpu, 0,
+	       NR_CPUS * sizeof(struct dtrace_dstate_percpu));
+
+	hashsize = size /
+		(dstate->dtds_chunksize + sizeof(struct dtrace_dynhash));
+
+	if (hashsize != 1 && (hashsize & 1))
+		hashsize--;
+
+	dstate->dtds_hashsize = hashsize;
+	dstate->dtds_hash = dstate->dtds_base;
+
+	/*
+	 * Set all of our hash buckets to point to the single sink, and (if
+	 * it hasn't already been set), set the sink's hash value to be the
+	 * sink sentinel value.  The sink is needed for dynamic variable
+	 * lookups to know that they have iterated over an entire, valid hash
+	 * chain.
+	 */
+	for (i = 0; i < hashsize; i++)
+		dstate->dtds_hash[i].dtdh_chain = &dtrace_dynhash_sink;
+
+	if (dtrace_dynhash_sink.dtdv_hashval != DTRACE_DYNHASH_SINK)
+		dtrace_dynhash_sink.dtdv_hashval = DTRACE_DYNHASH_SINK;
+
+	/*
+	 * Determine number of active CPUs.  Divide free list evenly among
+	 * active CPUs.
+	 */
+	start = (struct dtrace_dynvar *)((uintptr_t)base +
+				    hashsize * sizeof(struct dtrace_dynhash));
+	limit = (uintptr_t)base + size;
+
+	maxper = (limit - (uintptr_t)start) / NR_CPUS;
+	maxper = (maxper / dstate->dtds_chunksize) * dstate->dtds_chunksize;
+
+	for (i = 0; i < NR_CPUS; i++) {
+		dstate->dtds_percpu[i].dtdsc_free = dvar = start;
+
+		/*
+		 * If we don't even have enough chunks to make it once through
+		 * NCPUs, we're just going to allocate everything to the first
+		 * CPU.  And if we're on the last CPU, we're going to allocate
+		 * whatever is left over.  In either case, we set the limit to
+		 * be the limit of the dynamic variable space.
+		 */
+		if (maxper == 0 || i == NR_CPUS - 1) {
+			limit = (uintptr_t)base + size;
+			start = NULL;
+		} else {
+			limit = (uintptr_t)start + maxper;
+			start = (struct dtrace_dynvar *)limit;
+		}
+
+		ASSERT(limit <= (uintptr_t)base + size);
+
+		for (;;) {
+			next = (struct dtrace_dynvar *)((uintptr_t)dvar +
+						   dstate->dtds_chunksize);
+
+			if ((uintptr_t)next + dstate->dtds_chunksize >= limit)
+				break;
+
+			dvar->dtdv_next = next;
+			dvar = next;
+		}
+
+		if (maxper == 0)
+			break;
+	}
+
+	return 0;
+}
+
+void dtrace_dstate_fini(struct dtrace_dstate *dstate)
+{
+	ASSERT(MUTEX_HELD(&cpu_lock));
+
+	if (dstate->dtds_base == NULL)
+		return;
+
+	vfree(dstate->dtds_base);
+	kmem_cache_free(dtrace_state_cachep, dstate->dtds_percpu);
+}
+
+void dtrace_vstate_fini(struct dtrace_vstate *vstate)
+{
+	/*
+	 * If only there was a logical XOR operator...
+	 */
+	ASSERT((vstate->dtvs_nglobals == 0) ^ (vstate->dtvs_globals != NULL));
+
+	if (vstate->dtvs_nglobals > 0)
+		vfree(vstate->dtvs_globals);
+
+	if (vstate->dtvs_ntlocals > 0)
+		vfree(vstate->dtvs_tlocals);
+
+	ASSERT((vstate->dtvs_nlocals == 0) ^ (vstate->dtvs_locals != NULL));
+
+	if (vstate->dtvs_nlocals > 0)
+		vfree(vstate->dtvs_locals);
+}
+
+static void dtrace_state_clean(struct dtrace_state *state)
+{
+	dtrace_optval_t		*opt = state->dts_options;
+
+	if (state->dts_activity != DTRACE_ACTIVITY_ACTIVE &&
+	    state->dts_activity != DTRACE_ACTIVITY_DRAINING)
+		return;
+
+	dtrace_dynvar_clean(&state->dts_vstate.dtvs_dynvars);
+	dtrace_speculation_clean(state);
+
+	cyclic_reprogram(state->dts_cleaner, ns_to_ktime(
+						opt[DTRACEOPT_CLEANRATE]));
+}
+
+static void dtrace_state_deadman(struct dtrace_state *state)
+{
+	ktime_t			now;
+
+	dtrace_sync();
+
+	now = dtrace_gethrtime();
+	if (state != dtrace_anon.dta_state &&
+	    ktime_ge(ktime_sub(now, state->dts_laststatus),
+		     dtrace_deadman_user))
+		return;
+
+	/*
+	 * We must be sure that dts_alive never appears to be less than the
+	 * value upon entry to dtrace_state_deadman(), and because we lack a
+	 * dtrace_cas64(), we cannot store to it atomically.  We thus instead
+	 * store KTIME_MAX to it, followed by a memory barrier, followed by
+	 * the new value.  This assures that dts_alive never appears to be
+	 * less than its true value, regardless of the order in which the
+	 * stores to the underlying storage are issued.
+	 */
+	state->dts_alive = ktime_set(KTIME_SEC_MAX, 0);
+	dtrace_membar_producer();
+	state->dts_alive = now;
+}
+
+struct dtrace_state *dtrace_state_create(struct file *file)
+{
+	struct dtrace_state *state;
+	dtrace_optval_t	    *opt;
+	int                 bufsize = NR_CPUS * sizeof(struct dtrace_buffer), i;
+#ifdef FIXME
+	const struct cred   *cr = file->f_cred;
+#endif
+	dtrace_aggid_t aggid;
+
+	ASSERT(MUTEX_HELD(&cpu_lock));
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	state = kzalloc(sizeof(struct dtrace_state), GFP_KERNEL);
+	if (state == NULL)
+		return NULL;
+
+	state->dts_epid = DTRACE_EPIDNONE + 1;
+	state->dts_buffer = vzalloc(bufsize);
+	if (state->dts_buffer == NULL) {
+		kfree(state);
+		return NULL;
+	}
+
+	state->dts_aggbuffer = vzalloc(bufsize);
+	if (state->dts_aggbuffer == NULL) {
+		vfree(state->dts_buffer);
+		kfree(state);
+		return NULL;
+	}
+
+	idr_init(&state->dts_agg_idr);
+	state->dts_naggs = 0;
+	state->dts_cleaner = 0;
+	state->dts_deadman = 0;
+	state->dts_vstate.dtvs_state = state;
+
+	/*
+	 * Create a first entry in the aggregation IDR, so that ID 0 is used as
+	 * that gets used as meaning 'none'.
+	 */
+	idr_preload(GFP_KERNEL);
+	aggid = idr_alloc_cyclic(&state->dts_agg_idr, NULL, 0, 0, GFP_NOWAIT);
+	idr_preload_end();
+
+	ASSERT(aggid == 0);
+
+	for (i = 0; i < DTRACEOPT_MAX; i++)
+		state->dts_options[i] = DTRACEOPT_UNSET;
+
+	/*
+	 * Set the default options.
+	 */
+	opt = state->dts_options;
+	opt[DTRACEOPT_BUFPOLICY] = DTRACEOPT_BUFPOLICY_SWITCH;
+	opt[DTRACEOPT_BUFRESIZE] = DTRACEOPT_BUFRESIZE_AUTO;
+	opt[DTRACEOPT_NSPEC] = dtrace_nspec_default;
+	opt[DTRACEOPT_SPECSIZE] = dtrace_specsize_default;
+	opt[DTRACEOPT_CPU] = (dtrace_optval_t)DTRACE_CPUALL;
+	opt[DTRACEOPT_STRSIZE] = dtrace_strsize_default;
+	opt[DTRACEOPT_STACKFRAMES] = dtrace_stackframes_default;
+	opt[DTRACEOPT_USTACKFRAMES] = dtrace_ustackframes_default;
+	opt[DTRACEOPT_CLEANRATE] = dtrace_cleanrate_default;
+	opt[DTRACEOPT_AGGRATE] = dtrace_aggrate_default;
+	opt[DTRACEOPT_SWITCHRATE] = dtrace_switchrate_default;
+	opt[DTRACEOPT_STATUSRATE] = dtrace_statusrate_default;
+	opt[DTRACEOPT_JSTACKFRAMES] = dtrace_jstackframes_default;
+	opt[DTRACEOPT_JSTACKSTRSIZE] = dtrace_jstackstrsize_default;
+
+	state->dts_activity = DTRACE_ACTIVITY_INACTIVE;
+
+#ifdef FIXME
+	/*
+	 * Set probe visibility and destructiveness based on user credential
+	 * information.  For actual anonymous tracing or if all privileges are
+	 * set, checks are bypassed.
+	 */
+	if (cr == NULL ||
+	    PRIV_POLICY_ONLY(cr, PRIV_ALL, FALSE)) {
+		state->dts_cred.dcr_visible = DTRACE_CRV_ALL;
+		state->dts_cred.dcr_action = DTRACE_CRA_ALL;
+	} else {
+		state->dts_cred.dcr_cred = get_cred(cr);
+
+		/*
+		 * CRA_PROC means "we have *some* privilege for dtrace" and
+		 * it unlocks the use of variables like pid, etc.
+		 */
+		if (PRIV_POLICY_ONLY(cr, PRIV_DTRACE_USER, FALSE) ||
+		    PRIV_POLICY_ONLY(cr, PRIV_DTRACE_PROC, FALSE))
+			state->dts_cred.dcr_action |= DTRACE_CRA_PROC;
+
+		/*
+		 * The DTRACE_USER privilege allows the use of syscall and
+		 * profile providers.  If the user also has PROC_OWNER, we
+		 * extend the scope to include additional visibility and
+		 * destructive power.
+		 */
+		if (PRIV_POLICY_ONLY(cr, PRIV_DTRACE_USER, FALSE)) {
+			if (PRIV_POLICY_ONLY(cr, PRIV_PROC_OWNER, FALSE))
+				state->dts_cred.dcr_visible |=
+					DTRACE_CRV_ALLPROC;
+
+			state->dts_cred.dcr_action |=
+					DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER;
+		}
+
+		/*
+		 * Holding the DTRACE_KERNEL privilege also implies that
+		 * the user has the DTRACE_USER privilege from a visibility
+		 * perspective.  But without further privileges, some
+		 * destructive actions are not available.
+		 */
+		if (PRIV_POLICY_ONLY(cr, PRIV_DTRACE_KERNEL, FALSE)) {
+			/*
+			 * Make all probes in all zones visible.  However,
+			 * this doesn't mean that all actions become available
+			 * to all zones.
+			 */
+			state->dts_cred.dcr_visible |= DTRACE_CRV_KERNEL |
+						       DTRACE_CRV_ALLPROC;
+			state->dts_cred.dcr_action |= DTRACE_CRA_KERNEL |
+						      DTRACE_CRA_PROC;
+
+			/*
+			 * Holding PROC_OWNER means that destructive actions
+			 * are allowed.
+			 */
+			if (PRIV_POLICY_ONLY(cr, PRIV_PROC_OWNER, FALSE))
+				state->dts_cred.dcr_action |=
+					DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER;
+		}
+
+		/*
+		 * Holding the DTRACE_PROC privilege gives control over the
+		 * fasttrap and pid providers.  We need to grant wider
+		 * destructive privileges in the event that the user has
+		 * PROC_OWNER .
+		 */
+		if (PRIV_POLICY_ONLY(cr, PRIV_DTRACE_PROC, FALSE)) {
+			if (PRIV_POLICY_ONLY(cr, PRIV_PROC_OWNER, FALSE))
+				state->dts_cred.dcr_action |=
+					DTRACE_CRA_PROC_DESTRUCTIVE_ALLUSER;
+		}
+	}
+#else
+	state->dts_cred.dcr_visible = DTRACE_CRV_ALLPROC | DTRACE_CRV_KERNEL;
+	state->dts_cred.dcr_action = DTRACE_CRA_ALL;
+#endif
+
+	return state;
+}
+
+static int dtrace_state_buffer(struct dtrace_state *state,
+			       struct dtrace_buffer *buf, int which)
+{
+	dtrace_optval_t	*opt = state->dts_options, size;
+	processorid_t	cpu = DTRACE_CPUALL;
+	int		flags = 0, rval;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(MUTEX_HELD(&cpu_lock));
+	ASSERT(which < DTRACEOPT_MAX);
+	ASSERT(state->dts_activity == DTRACE_ACTIVITY_INACTIVE ||
+	       (state == dtrace_anon.dta_state &&
+	       state->dts_activity == DTRACE_ACTIVITY_ACTIVE));
+
+	if (opt[which] == DTRACEOPT_UNSET || opt[which] == 0)
+		return 0;
+
+	if (opt[DTRACEOPT_CPU] != DTRACEOPT_UNSET)
+		cpu = opt[DTRACEOPT_CPU];
+
+	if (which == DTRACEOPT_SPECSIZE)
+		flags |= DTRACEBUF_NOSWITCH;
+
+	if (which == DTRACEOPT_BUFSIZE) {
+		if (opt[DTRACEOPT_BUFPOLICY] == DTRACEOPT_BUFPOLICY_RING)
+			flags |= DTRACEBUF_RING;
+
+		if (opt[DTRACEOPT_BUFPOLICY] == DTRACEOPT_BUFPOLICY_FILL)
+			flags |= DTRACEBUF_FILL;
+
+		if (state != dtrace_anon.dta_state ||
+		    state->dts_activity != DTRACE_ACTIVITY_ACTIVE)
+			flags |= DTRACEBUF_INACTIVE;
+	}
+
+	for (size = opt[which]; size >= sizeof(uint64_t); size >>= 1) {
+		/*
+		 * The size must be 8-byte aligned.  If the size is not 8-byte
+		 * aligned, drop it down by the difference.
+		 */
+		if (size & (sizeof(uint64_t) - 1))
+			size -= size & (sizeof(uint64_t) - 1);
+
+		if (size < state->dts_reserve) {
+			/*
+			 * Buffers always must be large enough to accommodate
+			 * their prereserved space.  We return -E2BIG instead
+			 * of ENOMEM in this case to allow for user-level
+			 * software to differentiate the cases.
+			 */
+			return -E2BIG;
+		}
+
+		rval = dtrace_buffer_alloc(buf, size, flags, cpu);
+		if (rval != -ENOMEM) {
+			opt[which] = size;
+			return rval;
+		}
+
+		if (opt[DTRACEOPT_BUFRESIZE] == DTRACEOPT_BUFRESIZE_MANUAL)
+			return rval;
+	}
+
+	return -ENOMEM;
+}
+
+static int dtrace_state_buffers(struct dtrace_state *state)
+{
+	struct dtrace_speculation	*spec = state->dts_speculations;
+	int				rval, i;
+
+	rval = dtrace_state_buffer(state, state->dts_buffer, DTRACEOPT_BUFSIZE);
+	if (rval != 0)
+		return rval;
+
+	rval = dtrace_state_buffer(state, state->dts_aggbuffer,
+				   DTRACEOPT_AGGSIZE);
+	if (rval != 0)
+		return rval;
+
+	for (i = 0; i < state->dts_nspeculations; i++) {
+		rval = dtrace_state_buffer(state, spec[i].dtsp_buffer,
+					   DTRACEOPT_SPECSIZE);
+		if (rval != 0)
+			return rval;
+	}
+
+	return 0;
+}
+
+static void dtrace_begin_probe(struct dtrace_state *state)
+{
+	processorid_t		cpuid = smp_processor_id();
+
+	ASSERT(state->dts_buffer[cpuid].dtb_flags & DTRACEBUF_INACTIVE);
+	state->dts_buffer[cpuid].dtb_flags &= ~DTRACEBUF_INACTIVE;
+
+	dtrace_probe(dtrace_probeid_begin, (uint64_t)(uintptr_t)state, 0, 0, 0,
+		     0, 0, 0);
+
+	/*
+	 * We may have had an exit action from a BEGIN probe; only change our
+	 * state to ACTIVE if we're still in WARMUP.
+	 */
+	ASSERT(state->dts_activity == DTRACE_ACTIVITY_WARMUP ||
+	       state->dts_activity == DTRACE_ACTIVITY_DRAINING);
+
+	if (state->dts_activity == DTRACE_ACTIVITY_WARMUP)
+		state->dts_activity = DTRACE_ACTIVITY_ACTIVE;
+
+	dtrace_membar_enter();
+}
+
+static void dtrace_state_prereserve(struct dtrace_state *state)
+{
+	struct dtrace_ecb	*ecb;
+	struct dtrace_probe	*probe;
+
+	state->dts_reserve = 0;
+
+	if (state->dts_options[DTRACEOPT_BUFPOLICY] != DTRACEOPT_BUFPOLICY_FILL)
+		return;
+
+	/*
+	 * If our buffer policy is a "fill" buffer policy, we need to set the
+	 * prereserved space to be the space required by the END probes.
+	 */
+	probe = dtrace_probe_lookup_id(dtrace_probeid_end);
+	ASSERT(probe != NULL);
+
+	for (ecb = probe->dtpr_ecb; ecb != NULL; ecb = ecb->dte_next) {
+		if (ecb->dte_state != state)
+			continue;
+
+		state->dts_reserve += ecb->dte_needed + ecb->dte_alignment;
+	}
+}
+
+int dtrace_state_go(struct dtrace_state *state, processorid_t *cpu)
+{
+	dtrace_optval_t           *opt = state->dts_options, sz, nspec;
+	struct dtrace_speculation *spec;
+	struct dtrace_buffer	  *buf;
+	struct cyc_handler	  hdlr;
+	struct cyc_time		  when;
+	processorid_t		  cpuid;
+	int rval = 0, i, bufsize = NR_CPUS * sizeof(struct dtrace_buffer);
+
+	mutex_lock(&cpu_lock);
+	mutex_lock(&dtrace_lock);
+
+	if (state->dts_activity != DTRACE_ACTIVITY_INACTIVE) {
+		rval = -EBUSY;
+		goto out;
+	}
+
+	/*
+	 * Before we can perform any checks, we must prime all of the
+	 * retained enablings that correspond to this state.
+	 */
+	dtrace_enabling_prime(state);
+
+	if (state->dts_destructive && !state->dts_cred.dcr_destructive) {
+		rval = -EACCES;
+		goto out;
+	}
+
+	dtrace_state_prereserve(state);
+
+	/*
+	 * If a cpu has been selected check if its value is valid and
+	 * the cpu is online.
+	 */
+	cpuid = opt[DTRACEOPT_CPU];
+	if (cpuid != DTRACE_CPUALL &&
+	   (cpuid < 0 || cpuid >= NR_CPUS || !cpu_online(cpuid))) {
+		rval = -ENXIO;
+		goto out;
+	}
+
+	/*
+	 * Now we want to do is try to allocate our speculations.
+	 * We do not automatically resize the number of speculations; if
+	 * this fails, we will fail the operation.
+	 */
+	nspec = opt[DTRACEOPT_NSPEC];
+	ASSERT(nspec != DTRACEOPT_UNSET);
+
+	if (nspec > INT_MAX) {
+		rval = -ENOMEM;
+		goto out;
+	}
+
+	spec = vzalloc(nspec * sizeof(struct dtrace_speculation));
+	if (spec == NULL) {
+		rval = -ENOMEM;
+		goto out;
+	}
+
+	state->dts_speculations = spec;
+	state->dts_nspeculations = (int)nspec;
+
+	for (i = 0; i < nspec; i++) {
+		buf = vzalloc(bufsize);
+		if (buf == NULL) {
+			rval = -ENOMEM;
+			goto err;
+		}
+
+		spec[i].dtsp_buffer = buf;
+	}
+
+	if (opt[DTRACEOPT_GRABANON] != DTRACEOPT_UNSET) {
+		if (dtrace_anon.dta_state == NULL) {
+			rval = -ENOENT;
+			goto out;
+		}
+
+		if (state->dts_necbs != 0) {
+			rval = -EALREADY;
+			goto out;
+		}
+
+		state->dts_anon = dtrace_anon_grab();
+		ASSERT(state->dts_anon != NULL);
+		state = state->dts_anon;
+
+		/*
+		 * We want "grabanon" to be set in the grabbed state, so we'll
+		 * copy that option value from the grabbing state into the
+		 * grabbed state.
+		 */
+		state->dts_options[DTRACEOPT_GRABANON] =
+						opt[DTRACEOPT_GRABANON];
+
+		*cpu = dtrace_anon.dta_beganon;
+
+		/*
+		 * If the anonymous state is active (as it almost certainly
+		 * is if the anonymous enabling ultimately matched anything),
+		 * we don't allow any further option processing -- but we
+		 * don't return failure.
+		 */
+		if (state->dts_activity != DTRACE_ACTIVITY_INACTIVE)
+			goto out;
+	}
+
+	if (opt[DTRACEOPT_AGGSIZE] != DTRACEOPT_UNSET &&
+	    opt[DTRACEOPT_AGGSIZE] != 0) {
+		if (state->dts_naggs == 0) {
+			/*
+			 * We're not going to create an aggregation buffer
+			 * because we don't have any ECBs that contain
+			 * aggregations -- set this option to 0.
+			 */
+			opt[DTRACEOPT_AGGSIZE] = 0;
+		} else {
+			/*
+			 * If we have an aggregation buffer, we must also have
+			 * a buffer to use as scratch.
+			 */
+			if (opt[DTRACEOPT_BUFSIZE] == DTRACEOPT_UNSET ||
+			    opt[DTRACEOPT_BUFSIZE] < state->dts_needed)
+				opt[DTRACEOPT_BUFSIZE] = state->dts_needed;
+		}
+	}
+
+	if (opt[DTRACEOPT_SPECSIZE] != DTRACEOPT_UNSET &&
+	    opt[DTRACEOPT_SPECSIZE] != 0) {
+		/*
+		 * We are not going to create speculation buffers if we do not
+		 * have any ECBs that actually speculate.
+		 */
+		if (!state->dts_speculates)
+			opt[DTRACEOPT_SPECSIZE] = 0;
+	}
+
+	/*
+	 * The bare minimum size for any buffer that we're actually going to
+	 * do anything to is sizeof (uint64_t).
+	 */
+	sz = sizeof(uint64_t);
+
+	if ((state->dts_needed != 0 && opt[DTRACEOPT_BUFSIZE] < sz) ||
+	    (state->dts_speculates && opt[DTRACEOPT_SPECSIZE] < sz) ||
+	    (state->dts_naggs != 0 && opt[DTRACEOPT_AGGSIZE] < sz)) {
+		/*
+		 * A buffer size has been explicitly set to 0 (or to a size
+		 * that will be adjusted to 0) and we need the space -- we
+		 * need to return failure.  We return -ENOSPC to differentiate
+		 * it from failing to allocate a buffer due to failure to meet
+		 * the reserve (for which we return -E2BIG).
+		 */
+		rval = -ENOSPC;
+		goto out;
+	}
+
+	rval = dtrace_state_buffers(state);
+	if (rval != 0)
+		goto err;
+
+	sz = opt[DTRACEOPT_DYNVARSIZE];
+	if (sz == DTRACEOPT_UNSET)
+		sz = dtrace_dstate_defsize;
+
+	do {
+		rval = dtrace_dstate_init(&state->dts_vstate.dtvs_dynvars, sz);
+
+		if (rval == 0)
+			break;
+
+		if (opt[DTRACEOPT_BUFRESIZE] == DTRACEOPT_BUFRESIZE_MANUAL)
+			goto err;
+	} while (sz >>= 1);
+
+	opt[DTRACEOPT_DYNVARSIZE] = sz;
+
+	if (rval != 0)
+		goto err;
+
+	if (opt[DTRACEOPT_STATUSRATE] > dtrace_statusrate_max)
+		opt[DTRACEOPT_STATUSRATE] = dtrace_statusrate_max;
+
+	if (opt[DTRACEOPT_CLEANRATE] == 0)
+		opt[DTRACEOPT_CLEANRATE] = dtrace_cleanrate_max;
+
+	if (opt[DTRACEOPT_CLEANRATE] < dtrace_cleanrate_min)
+		opt[DTRACEOPT_CLEANRATE] = dtrace_cleanrate_min;
+
+	if (opt[DTRACEOPT_CLEANRATE] > dtrace_cleanrate_max)
+		opt[DTRACEOPT_CLEANRATE] = dtrace_cleanrate_max;
+
+	hdlr.cyh_func = (cyc_func_t)dtrace_state_clean;
+	hdlr.cyh_arg = (uintptr_t)state;
+	hdlr.cyh_level = CY_LOW_LEVEL;
+
+	when.cyt_when = ktime_set(0, 0);
+	when.cyt_interval = CY_INTERVAL_INF;
+
+	state->dts_cleaner = cyclic_add(&hdlr, &when);
+	cyclic_reprogram(state->dts_cleaner, ns_to_ktime(
+						opt[DTRACEOPT_CLEANRATE]));
+
+	hdlr.cyh_func = (cyc_func_t)dtrace_state_deadman;
+	hdlr.cyh_arg = (uintptr_t)state;
+	hdlr.cyh_level = CY_LOW_LEVEL;
+
+	when.cyt_when = ktime_set(0, 0);
+	when.cyt_interval = dtrace_deadman_interval;
+
+	state->dts_alive = state->dts_laststatus = dtrace_gethrtime();
+	state->dts_deadman = cyclic_add(&hdlr, &when);
+
+	state->dts_activity = DTRACE_ACTIVITY_WARMUP;
+
+	/*
+	 * Issue xcall even when the BEGIN probe fires on current CPU.  The
+	 * underlying implementation of SMP will turn it into direct function
+	 * call.  It is not allowed to turn off interrupts so we need to pick 
+	 * a cpu first and then xcall it.  This way a begin probe will always
+	 * fire on the expected cpu.
+	 */
+	*cpu = (cpuid == DTRACE_CPUALL) ? smp_processor_id() : cpuid;
+	dtrace_xcall(*cpu, (dtrace_xcall_t)dtrace_begin_probe, state);
+
+	/*
+	 * Regardless of whether or not now we're in ACTIVE or DRAINING, we
+	 * want each CPU to transition its principal buffer out of the
+	 * INACTIVE state.  Doing this assures that no CPU will suddenly begin
+	 * processing an ECB halfway down a probe's ECB chain; all CPUs will
+	 * atomically transition from processing none of a state's ECBs to
+	 * processing all of them.
+	 */
+	dtrace_xcall(DTRACE_CPUALL, (dtrace_xcall_t)dtrace_buffer_activate,
+		     state);
+	goto out;
+
+err:
+	dtrace_buffer_free(state->dts_buffer);
+	dtrace_buffer_free(state->dts_aggbuffer);
+
+	nspec = state->dts_nspeculations;
+	if (nspec == 0) {
+		ASSERT(state->dts_speculations == NULL);
+		goto out;
+	}
+
+	spec = state->dts_speculations;
+	ASSERT(spec != NULL);
+
+	for (i = 0; i < state->dts_nspeculations; i++) {
+		buf = spec[i].dtsp_buffer;
+		if (buf == NULL)
+			break;
+
+		dtrace_buffer_free(buf);
+		vfree(buf);
+	}
+
+	vfree(spec);
+	state->dts_nspeculations = 0;
+	state->dts_speculations = NULL;
+
+out:
+	mutex_unlock(&dtrace_lock);
+	mutex_unlock(&cpu_lock);
+
+	return rval;
+}
+
+static void dtrace_end_probe(struct dtrace_state *state)
+{
+	dtrace_probe(dtrace_probeid_end, (uint64_t)(uintptr_t)state, 0, 0, 0,
+		     0, 0, 0);
+
+	state->dts_activity = DTRACE_ACTIVITY_STOPPED;
+
+	dtrace_membar_enter();
+}
+
+int dtrace_state_stop(struct dtrace_state *state, processorid_t *cpu)
+{
+	processorid_t cpuid = state->dts_options[DTRACEOPT_CPU];
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	if (state->dts_activity != DTRACE_ACTIVITY_ACTIVE &&
+	    state->dts_activity != DTRACE_ACTIVITY_DRAINING)
+		return -EINVAL;
+
+	/*
+	 * We'll set the activity to DTRACE_ACTIVITY_DRAINING, and issue a sync
+	 * to be sure that every CPU has seen it.  See below for the details
+	 * on why this is done.
+	 */
+	state->dts_activity = DTRACE_ACTIVITY_DRAINING;
+	dtrace_sync();
+
+	/*
+	 * By this point, it is impossible for any CPU to be still processing
+	 * with DTRACE_ACTIVITY_ACTIVE.  We can thus set our activity to
+	 * DTRACE_ACTIVITY_COOLDOWN and know that we're not racing with any
+	 * other CPU in dtrace_buffer_reserve().  This allows dtrace_probe()
+	 * and callees to know that the activity is DTRACE_ACTIVITY_COOLDOWN
+	 * iff we're in the END probe.
+	 */
+	state->dts_activity = DTRACE_ACTIVITY_COOLDOWN;
+	dtrace_sync();
+	ASSERT(state->dts_activity == DTRACE_ACTIVITY_COOLDOWN);
+
+	/*
+	 * Finally, we can release the reserve and call the END probe.  We
+	 * disable interrupts across calling the END probe to allow us to
+	 * return the CPU on which we actually called the END probe.  This
+	 * allows user-land to be sure that this CPU's principal buffer is
+	 * processed last.
+	 */
+	state->dts_reserve = 0;
+
+	/*
+	 * Same as for BEGIN probe in dtrace_state_go().  The END probe must
+	 * also fire on the enabled cpu.
+	 */
+	*cpu = (cpuid == DTRACE_CPUALL) ? smp_processor_id() : cpuid;
+	dtrace_xcall(*cpu, (dtrace_xcall_t)dtrace_end_probe, state);
+
+	dtrace_sync();
+	return 0;
+}
+
+int dtrace_state_option(struct dtrace_state *state, dtrace_optid_t option,
+			dtrace_optval_t val)
+{
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+
+	if (state->dts_activity != DTRACE_ACTIVITY_INACTIVE)
+		return -EBUSY;
+
+	if (option >= DTRACEOPT_MAX)
+		return -EINVAL;
+
+	if (option != DTRACEOPT_CPU && val < 0)
+		return -EINVAL;
+
+	switch (option) {
+	case DTRACEOPT_DESTRUCTIVE:
+		if (dtrace_destructive_disallow)
+			return -EACCES;
+
+		state->dts_cred.dcr_destructive = 1;
+		break;
+
+	case DTRACEOPT_BUFSIZE:
+	case DTRACEOPT_DYNVARSIZE:
+	case DTRACEOPT_AGGSIZE:
+	case DTRACEOPT_SPECSIZE:
+	case DTRACEOPT_STRSIZE:
+		if (val < 0)
+			return -EINVAL;
+
+		/*
+		 * If this is an otherwise negative value, set it to the
+		 * highest multiple of 128m less than LONG_MAX.  Technically,
+		 * we're adjusting the size without regard to the buffer
+		 * resizing policy, but in fact, this has no effect -- if we
+		 * set the buffer size to ~LONG_MAX and the buffer policy is
+		 * ultimately set to be "manual", the buffer allocation is
+		 * guaranteed to fail, if only because the allocation requires
+		 * two buffers.  (We set the the size to the highest multiple
+		 * of 128m because it ensures that the size will remain a
+		 * multiple of a megabyte when repeatedly halved -- all the
+		 * way down to 15m.)
+		 */
+		if (val >= LONG_MAX)
+			val = LONG_MAX - (1 << 27) + 1;
+	}
+
+	state->dts_options[option] = val;
+
+	return 0;
+}
+
+void dtrace_state_destroy(struct dtrace_state *state)
+{
+	struct dtrace_ecb	*ecb;
+	struct dtrace_vstate	*vstate = &state->dts_vstate;
+	int			i;
+	struct dtrace_speculation *spec = state->dts_speculations;
+	int			nspec = state->dts_nspeculations;
+	uint32_t		match;
+
+	ASSERT(MUTEX_HELD(&dtrace_lock));
+	ASSERT(MUTEX_HELD(&cpu_lock));
+
+	/*
+	 * First, retract any retained enablings for this state.
+	 */
+	dtrace_enabling_retract(state);
+	ASSERT(state->dts_nretained == 0);
+
+	if (state->dts_activity == DTRACE_ACTIVITY_ACTIVE ||
+	    state->dts_activity == DTRACE_ACTIVITY_DRAINING) {
+		/*
+		 * We have managed to come into dtrace_state_destroy() on a
+		 * hot enabling -- almost certainly because of a disorderly
+		 * shutdown of a consumer.  (That is, a consumer that is
+		 * exiting without having called dtrace_stop().) In this case,
+		 * we're going to set our activity to be KILLED, and then
+		 * issue a sync to be sure that everyone is out of probe
+		 * context before we start blowing away ECBs.
+		 */
+		state->dts_activity = DTRACE_ACTIVITY_KILLED;
+		dtrace_sync();
+	}
+
+	/*
+	 * Release the credential hold we took in dtrace_state_create().
+	 */
+	if (state->dts_cred.dcr_cred != NULL)
+		put_cred(state->dts_cred.dcr_cred);
+
+	/*
+	 * Now we can safely disable and destroy any enabled probes.  Because
+	 * any DTRACE_PRIV_KERNEL probes may actually be slowing our progress
+	 * (especially if they're all enabled), we take two passes through the
+	 * ECBs: in the first, we disable just DTRACE_PRIV_KERNEL probes, and
+	 * in the second we disable whatever is left over.
+	 */
+	for (match = DTRACE_PRIV_KERNEL; ; match = 0) {
+		for (i = 0; i < state->dts_necbs; i++) {
+			ecb = state->dts_ecbs[i];
+			if (ecb == NULL)
+				continue;
+
+			if (match && ecb->dte_probe != NULL) {
+				struct dtrace_probe	*probe =
+							ecb->dte_probe;
+				struct dtrace_provider	*prov =
+							probe->dtpr_provider;
+
+				if (!(prov->dtpv_priv.dtpp_flags & match))
+					continue;
+			}
+
+			dtrace_ecb_disable(ecb);
+			dtrace_ecb_destroy(ecb);
+		}
+
+		if (!match)
+			break;
+	}
+
+	/*
+	 * Before we free the buffers, perform one more sync to assure that
+	 * every CPU is out of probe context.
+	 */
+	dtrace_sync();
+
+	dtrace_buffer_free(state->dts_buffer);
+	dtrace_buffer_free(state->dts_aggbuffer);
+
+	for (i = 0; i < nspec; i++)
+		dtrace_buffer_free(spec[i].dtsp_buffer);
+
+	if (state->dts_cleaner != CYCLIC_NONE)
+		cyclic_remove(state->dts_cleaner);
+
+	if (state->dts_deadman != CYCLIC_NONE)
+		cyclic_remove(state->dts_deadman);
+
+	dtrace_dstate_fini(&vstate->dtvs_dynvars);
+	dtrace_vstate_fini(vstate);
+	vfree(state->dts_ecbs);
+
+	/*
+	 * If there were aggregations allocated, they should have been cleaned
+	 * up by now, so we can get rid of the idr.
+	 */
+	idr_destroy(&state->dts_agg_idr);
+
+	vfree(state->dts_buffer);
+	vfree(state->dts_aggbuffer);
+
+	for (i = 0; i < nspec; i++)
+		vfree(spec[i].dtsp_buffer);
+
+	vfree(spec);
+
+	dtrace_format_destroy(state);
+
+	kfree(state);
+}
diff --git a/dtrace/dtrace_util.c b/dtrace/dtrace_util.c
new file mode 100644
index 000000000000..b7fdaaadcb6b
--- /dev/null
+++ b/dtrace/dtrace_util.c
@@ -0,0 +1,283 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * FILE:	dtrace_util.c
+ * DESCRIPTION:	DTrace - utility functions
+ *
+ * Copyright (c) 2010, 2018, Oracle and/or its affiliates. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/dtrace_cpu.h>
+#include <linux/module.h>
+#include <linux/vmalloc.h>
+#include <asm/pgtable.h>
+
+#include "dtrace.h"
+
+int dtrace_isglob(const char *s)
+{
+	char	c;
+
+	while ((c = *s++) != '\0') {
+		if (c == '[' || c == '?' || c == '*' || c == '\\')
+			return 1;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(dtrace_isglob);
+
+int dtrace_gmatch(const char *s, const char *p)
+{
+	const char	*olds = s;
+	char		sc;
+	char		pc;
+
+	sc = *s++;
+	pc = *p++;
+
+	if (!pc)
+		return !sc;
+
+	switch (pc) {
+	case '[': {
+		int	ok = 0;
+		char	lc = '\0';
+		int	inv = 0;
+
+		if (!sc)
+			return 0;
+
+		if (*p == '!') {
+			inv = 1;
+			p++;
+		}
+
+		pc = *p++;
+		do {
+			if (pc == '-' && lc && *p != ']') {
+				pc = *p++;
+				if (pc == '\\')
+					pc = *p++;
+
+				if (inv) {
+					if (sc < lc || sc > pc)
+						ok++;
+					else
+						return 0;
+				} else {
+					if (lc <= sc && sc <= pc)
+						ok++;
+				}
+			} else if (pc == '\\') {
+				pc = *p++;
+			}
+
+			lc = sc;
+
+			if (inv) {
+				if (sc != lc)
+					ok++;
+				else
+					return 0;
+			} else {
+				if (sc == lc)
+					ok++;
+			}
+
+			pc = *p++;
+		} while (pc != ']');
+
+		return ok ? dtrace_gmatch(s, p) : 0;
+	}
+	case '\\':
+		pc = *p++;
+		if (!pc)
+			return 0;
+
+		/* fall-through */
+	default:
+		if (pc != sc)
+			return 0;
+
+		/* fall-through */
+	case '?':
+		return sc ? dtrace_gmatch(s, p) : 0;
+	case '*':
+		while (*p == '*')
+			p++;
+
+		if (!*p)
+			return 1;
+
+		s = olds;
+		while (*s) {
+			if (dtrace_gmatch(s, p))
+				return 1;
+
+			s++;
+		}
+
+		return 0;
+	}
+}
+EXPORT_SYMBOL(dtrace_gmatch);
+
+int dtrace_badattr(const struct dtrace_attribute *a)
+{
+	return a->dtat_name > DTRACE_STABILITY_MAX ||
+	       a->dtat_data > DTRACE_STABILITY_MAX ||
+	       a->dtat_class > DTRACE_CLASS_MAX;
+}
+
+/*
+ * Allocate a chunk of virtual memory in kernel space, and zero it out.  This
+ * allocation might fail (which will report a backtrace in the kernel log, yet
+ * it is harmless).
+ */
+void *dtrace_vzalloc_try(unsigned long size)
+{
+	return __vmalloc(size,
+			 GFP_NOWAIT | __GFP_FS | __GFP_IO | __GFP_NOMEMALLOC |
+			 __GFP_NORETRY | __GFP_NOWARN | __GFP_ZERO,
+			 PAGE_KERNEL);
+}
+EXPORT_SYMBOL(dtrace_vzalloc_try);
+
+/*
+ * Return a duplicate copy of a string.  If the specified string is NULL, this
+ * function returs a zero-length string.
+ */
+char *dtrace_strdup(const char *str)
+{
+	return kstrdup(str ? str : "", GFP_KERNEL);
+}
+
+/*
+ * Compare two strings using safe loads.
+ */
+int dtrace_strncmp(char *s1, char *s2, size_t limit)
+{
+	uint8_t			c1, c2;
+	volatile uint16_t	*flags;
+
+	if (s1 == s2 || limit == 0)
+		return 0;
+
+	flags = (volatile uint16_t *)&this_cpu_core->cpuc_dtrace_flags;
+
+	do {
+		if (s1 == NULL)
+			c1 = '\0';
+		else
+			c1 = dtrace_load8((uintptr_t)s1++);
+
+		if (s2 == NULL)
+			c2 = '\0';
+		else
+			c2 = dtrace_load8((uintptr_t)s2++);
+
+		if (c1 != c2)
+			return (c1 - c2);
+	} while (--limit && c1 != '\0' && !(*flags & CPU_DTRACE_FAULT));
+
+	return 0;
+}
+
+/*
+ * Compute strlen(s) for a string using safe memory accesses.  The additional
+ * len parameter is used to specify a maximum length to ensure completion.
+ */
+size_t dtrace_strlen(const char *s, size_t lim)
+{
+	uint_t	len;
+
+	for (len = 0; len != lim; len++) {
+		if (dtrace_load8((uintptr_t)s++) == '\0')
+			break;
+	}
+
+	return len;
+}
+
+#define DTRACE_ISALPHA(c)	(((c) >= 'a' && (c) <= 'z') || \
+				 ((c) >= 'A' && (c) <= 'Z'))
+int dtrace_badname(const char *s)
+{
+	char	c;
+
+	if (s == NULL)
+		return 0;
+
+	c = *s++;
+	if (c == '\0')
+		return 0;
+
+	if (!DTRACE_ISALPHA(c) && c != '-' && c != '_' && c != '.')
+		return 1;
+
+	while ((c = *s++) != '\0') {
+		if (!DTRACE_ISALPHA(c) && (c < '0' || c > '9') &&
+		    c != '-' && c != '_' && c != '.' && c != '`')
+			return 1;
+	}
+
+	return 0;
+}
+
+void dtrace_cred2priv(const struct cred *cr, uint32_t *privp, kuid_t *uidp)
+{
+#ifdef FIXME
+/*
+ * This should probably be rewritten based on capabilities in the struct cred.
+ */
+	uint32_t	priv;
+
+	if (cr == NULL)
+		priv = DTRACE_PRIV_ALL;
+	else {
+		const struct cred *lcr = get_cred(cr);
+
+		if (PRIV_POLICY_ONLY(lcr, PRIV_ALL, FALSE))
+			priv = DTRACE_PRIV_ALL;
+		else {
+			*uidp = lcr->uid;
+			priv = 0;
+
+			if (PRIV_POLICY_ONLY(lcr, PRIV_DTRACE_KERNEL, FALSE))
+				priv |= DTRACE_PRIV_KERNEL | DTRACE_PRIV_USER;
+			else if (PRIV_POLICY_ONLY(lcr, PRIV_DTRACE_USER,
+						  FALSE))
+				priv |= DTRACE_PRIV_USER;
+
+			if (PRIV_POLICY_ONLY(lcr, PRIV_DTRACE_PROC, FALSE))
+				priv |= DTRACE_PRIV_PROC;
+			if (PRIV_POLICY_ONLY(lcr, PRIV_PROC_OWNER, FALSE))
+				priv |= DTRACE_PRIV_OWNER;
+		}
+
+		put_cred(cr);
+	}
+
+	*privp = priv;
+#else
+	*privp = DTRACE_PRIV_ALL;
+
+	if (cr != NULL) {
+		const struct cred *lcr = get_cred(cr);
+
+		*uidp = lcr->uid;
+		put_cred(cr);
+	}
+#endif
+}
+
-- 
2.27.0

